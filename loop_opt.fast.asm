
./zig-cache/test:     file format elf64-x86-64


Disassembly of section .text:

0000000000203000 <assert>:
/// In Debug and ReleaseSafe modes, calls to this function are always
/// generated, and the `unreachable` statement triggers a panic.
/// In ReleaseFast and ReleaseSmall modes, calls to this function can be
/// optimized away.
pub fn assert(ok: bool) void {
    if (!ok) {
  203000:	40 f6 c7 01          	test   dil,0x1
  203004:	74 01                	je     203007 <assert+0x7>
pub fn assert(ok: bool) void {
  203006:	c3                   	ret    
        // In ReleaseFast test mode, we still want assert(false) to crash, so
        // we insert an explicit call to @panic instead of unreachable.
        // TODO we should use `assertOrPanic` in tests and remove this logic.
        if (builtin.is_test) {
            @panic("assertion failure");
  203007:	50                   	push   rax
  203008:	e8 c3 01 00 00       	call   2031d0 <panic>
  20300d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000203010 <loop_opt>:
}

var gValue: u32 = undefined;

pub fn setValue(v: u32) void {
    gValue = v;
  203010:	55                   	push   rbp
  203011:	41 57                	push   r15
  203013:	41 56                	push   r14
  203015:	53                   	push   rbx
  203016:	48 83 ec 58          	sub    rsp,0x58
  20301a:	c7 05 f4 ff 00 00 33 	mov    DWORD PTR [rip+0xfff4],0x6a0d7333        # 213018 <gValue>
  203021:	73 0d 6a 

pub fn waitWhileExpectedValue(expectedValue: u32, stallCount: u64) u32 {
    var count = stallCount;
    var val: u32 = undefined;

    val = @atomicLoad(u32, &gValue, AtomicOrder.SeqCst);
  203024:	8b 2d ee ff 00 00    	mov    ebp,DWORD PTR [rip+0xffee]        # 213018 <gValue>
    while ((val == expectedValue) and (count > 0)) {
  20302a:	83 fd 01             	cmp    ebp,0x1
  20302d:	75 50                	jne    20307f <loop_opt+0x6f>
  20302f:	48 c7 c0 19 fc ff ff 	mov    rax,0xfffffffffffffc19
  203036:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20303d:	00 00 00 
        val = @atomicLoad(u32, &gValue, AtomicOrder.SeqCst);
  203040:	8b 2d d2 ff 00 00    	mov    ebp,DWORD PTR [rip+0xffd2]        # 213018 <gValue>
    while ((val == expectedValue) and (count > 0)) {
  203046:	48 85 c0             	test   rax,rax
  203049:	74 09                	je     203054 <loop_opt+0x44>
  20304b:	48 83 c0 01          	add    rax,0x1
  20304f:	83 fd 01             	cmp    ebp,0x1
  203052:	74 ec                	je     203040 <loop_opt+0x30>
  203054:	83 fd 01             	cmp    ebp,0x1
        count -= 1;
    }
    while (val == expectedValue) {
  203057:	75 26                	jne    20307f <loop_opt+0x6f>
  203059:	48 8d 3d b8 ff 00 00 	lea    rdi,[rip+0xffb8]        # 213018 <gValue>
        : "rcx", "r11"
    );
}

pub fn syscall4(number: usize, arg1: usize, arg2: usize, arg3: usize, arg4: usize) usize {
    return asm volatile ("syscall"
  203060:	b8 ca 00 00 00       	mov    eax,0xca
  203065:	be 00 00 00 00       	mov    esi,0x0
  20306a:	ba 01 00 00 00       	mov    edx,0x1
  20306f:	45 31 d2             	xor    r10d,r10d
  203072:	0f 05                	syscall 
        futex_wait(&gValue, expectedValue);
        val = @atomicLoad(u32, &gValue, AtomicOrder.SeqCst);
  203074:	8b 2d 9e ff 00 00    	mov    ebp,DWORD PTR [rip+0xff9e]        # 213018 <gValue>
    while (val == expectedValue) {
  20307a:	83 fd 01             	cmp    ebp,0x1
  20307d:	74 e1                	je     203060 <loop_opt+0x50>
    if (stderr_stream) |st| {
  20307f:	4c 8b 3d 82 1f 01 00 	mov    r15,QWORD PTR [rip+0x11f82]        # 215008 <stderr_stream>
  203086:	4d 85 ff             	test   r15,r15
  203089:	74 09                	je     203094 <loop_opt+0x84>
        pub const Error = WriteError;

        writeFn: fn (self: *Self, bytes: []const u8) Error!void,

        pub fn print(self: *Self, comptime format: []const u8, args: ...) !void {
            return std.fmt.format(self, Error, self.writeFn, format, args);
  20308b:	4c 8b 35 7e ff 00 00 	mov    r14,QWORD PTR [rip+0xff7e]        # 213010 <stderr_file_out_stream+0x8>
  203092:	eb 34                	jmp    2030c8 <loop_opt+0xb8>
        stderr_file = try io.getStdErr();
  203094:	48 8d 05 65 ff 00 00 	lea    rax,[rip+0xff65]        # 213000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20309b:	48 89 05 66 ff 00 00 	mov    QWORD PTR [rip+0xff66],rax        # 213008 <stderr_file_out_stream>
  2030a2:	4c 8d 35 f7 19 00 00 	lea    r14,[rip+0x19f7]        # 204aa0 <FileOutStream_writeFn>
  2030a9:	4c 89 35 60 ff 00 00 	mov    QWORD PTR [rip+0xff60],r14        # 213010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2030b0:	c7 05 46 ff 00 00 02 	mov    DWORD PTR [rip+0xff46],0x2        # 213000 <stderr_file>
  2030b7:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2030ba:	4c 8d 3d 4f ff 00 00 	lea    r15,[rip+0xff4f]        # 213010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2030c1:	4c 89 3d 40 1f 01 00 	mov    QWORD PTR [rip+0x11f40],r15        # 215008 <stderr_stream>
    inline for (fmt) |c, i| {
        switch (state) {
            State.Start => switch (c) {
                '{' => {
                    if (start_index < i) {
                        try output(context, fmt[start_index..i]);
  2030c8:	48 8d 35 d9 11 01 00 	lea    rsi,[rip+0x111d9]        # 2142a8 <__unnamed_1>
  2030cf:	4c 89 ff             	mov    rdi,r15
  2030d2:	41 ff d6             	call   r14
  2030d5:	66 85 c0             	test   ax,ax
  2030d8:	0f 85 d8 00 00 00    	jne    2031b6 <loop_opt+0x1a6>
    comptime Errors: type,
    output: fn (@typeOf(context), []const u8) Errors!void,
) Errors!void {
    // max_int_digits accounts for the minus sign. when printing an unsigned
    // number we don't need to do that.
    var buf: [max_int_digits - 1]u8 = undefined;
  2030de:	c5 fc 10 05 39 f4 ff 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffff439]        # 20251f <__unnamed_2+0x1f>
  2030e5:	ff 
  2030e6:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  2030ec:	c5 fc 10 05 0c f4 ff 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffff40c]        # 202500 <__unnamed_2>
  2030f3:	ff 
  2030f4:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
    var a = if (@sizeOf(@typeOf(value)) == 1) u8(value) else value;
    var index: usize = buf.len;

    while (true) {
        const digit = a % base;
  2030fa:	89 e8                	mov    eax,ebp
  2030fc:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  203101:	48 0f af c8          	imul   rcx,rax
  203105:	48 c1 e9 23          	shr    rcx,0x23
  203109:	01 c9                	add    ecx,ecx
  20310b:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20310e:	89 e8                	mov    eax,ebp
  203110:	29 c8                	sub    eax,ecx
    return value;
}

fn digitToChar(digit: u8, uppercase: bool) u8 {
    return switch (digit) {
        0...9 => digit + '0',
  203112:	b1 30                	mov    cl,0x30
  203114:	3c 0a                	cmp    al,0xa
  203116:	72 02                	jb     20311a <loop_opt+0x10a>
  203118:	b1 57                	mov    cl,0x57
  20311a:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20311c:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
        if (a == 0) break;
  203120:	83 fd 0a             	cmp    ebp,0xa
  203123:	73 0c                	jae    203131 <loop_opt+0x121>
  203125:	48 8d 4c 24 4f       	lea    rcx,[rsp+0x4f]
  20312a:	b8 40 00 00 00       	mov    eax,0x40
  20312f:	eb 51                	jmp    203182 <loop_opt+0x172>
  203131:	b8 40 00 00 00       	mov    eax,0x40
  203136:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  20313b:	89 ea                	mov    edx,ebp
  20313d:	0f 1f 00             	nop    DWORD PTR [rax]
        a /= base;
  203140:	89 d6                	mov    esi,edx
  203142:	48 0f af f1          	imul   rsi,rcx
  203146:	48 c1 ee 23          	shr    rsi,0x23
        const digit = a % base;
  20314a:	48 89 f7             	mov    rdi,rsi
  20314d:	48 0f af f9          	imul   rdi,rcx
  203151:	48 c1 ef 23          	shr    rdi,0x23
  203155:	01 ff                	add    edi,edi
  203157:	8d 1c bf             	lea    ebx,[rdi+rdi*4]
  20315a:	89 f7                	mov    edi,esi
  20315c:	29 df                	sub    edi,ebx
        0...9 => digit + '0',
  20315e:	b3 30                	mov    bl,0x30
  203160:	40 80 ff 0a          	cmp    dil,0xa
  203164:	72 02                	jb     203168 <loop_opt+0x158>
  203166:	b3 57                	mov    bl,0x57
  203168:	40 00 fb             	add    bl,dil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20316b:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  20316f:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  203173:	83 fa 63             	cmp    edx,0x63
  203176:	89 f2                	mov    edx,esi
  203178:	77 c6                	ja     203140 <loop_opt+0x130>
        const padded_buf = buf[index - padding ..];
  20317a:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20317e:	48 83 c1 0f          	add    rcx,0xf
  203182:	ba 41 00 00 00       	mov    edx,0x41
  203187:	48 29 c2             	sub    rdx,rax
  20318a:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  20318e:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  203193:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  203196:	4c 89 ff             	mov    rdi,r15
  203199:	c5 f8 77             	vzeroupper 
  20319c:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20319f:	66 85 c0             	test   ax,ax
  2031a2:	75 0d                	jne    2031b1 <loop_opt+0x1a1>
        try output(context, fmt[start_index..]);
  2031a4:	48 8d 35 0d 11 01 00 	lea    rsi,[rip+0x1110d]        # 2142b8 <__unnamed_3>
  2031ab:	4c 89 ff             	mov    rdi,r15
  2031ae:	41 ff d6             	call   r14
    var prng = std.rand.DefaultPrng.init(12345678);
    setValue(prng.random.scalar(u32));

    var new_value = waitWhileExpectedValue(1, 1000);
    warn("new_value={}\n", new_value);
    assert(new_value != 1);
  2031b1:	83 fd 01             	cmp    ebp,0x1
    if (!ok) {
  2031b4:	74 0d                	je     2031c3 <loop_opt+0x1b3>
test "loop_opt" {
  2031b6:	31 c0                	xor    eax,eax
  2031b8:	48 83 c4 58          	add    rsp,0x58
  2031bc:	5b                   	pop    rbx
  2031bd:	41 5e                	pop    r14
  2031bf:	41 5f                	pop    r15
  2031c1:	5d                   	pop    rbp
  2031c2:	c3                   	ret    
            @panic("assertion failure");
  2031c3:	e8 08 00 00 00       	call   2031d0 <panic>
  2031c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2031cf:	00 

00000000002031d0 <panic>:
        // TODO: fix panic in zen.
        builtin.Os.freestanding, builtin.Os.zen => {
            while (true) {}
        },
        else => {
            const first_trace_addr = @ptrToInt(@returnAddress());
  2031d0:	48 83 ec 18          	sub    rsp,0x18
  2031d4:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
            std.debug.panicExtra(error_return_trace, first_trace_addr, "{}", msg);
  2031d9:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2031de:	c6 44 24 10 01       	mov    BYTE PTR [rsp+0x10],0x1
  2031e3:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
  2031e8:	e8 03 00 00 00       	call   2031f0 <panicExtra>
  2031ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000002031f0 <panicExtra>:
    panicExtra(null, first_trace_addr, format, args);
}

var panicking: u8 = 0; // TODO make this a bool

pub fn panicExtra(trace: ?*const builtin.StackTrace, first_trace_addr: ?usize, comptime format: []const u8, args: ...) noreturn {
  2031f0:	41 57                	push   r15
  2031f2:	41 56                	push   r14
  2031f4:	53                   	push   rbx
  2031f5:	48 83 ec 10          	sub    rsp,0x10
  2031f9:	b0 01                	mov    al,0x1
    @setCold(true);

    if (@atomicRmw(u8, &panicking, builtin.AtomicRmwOp.Xchg, 1, builtin.AtomicOrder.SeqCst) == 1) {
  2031fb:	86 05 ff 1d 01 00    	xchg   BYTE PTR [rip+0x11dff],al        # 215000 <panicking>
  203201:	49 89 fe             	mov    r14,rdi
  203204:	3c 01                	cmp    al,0x1
  203206:	74 7e                	je     203286 <panicExtra+0x96>
    if (stderr_stream) |st| {
  203208:	48 8b 1d f9 1d 01 00 	mov    rbx,QWORD PTR [rip+0x11df9]        # 215008 <stderr_stream>
  20320f:	48 85 db             	test   rbx,rbx
  203212:	75 36                	jne    20324a <panicExtra+0x5a>
        stderr_file = try io.getStdErr();
  203214:	48 8d 05 e5 fd 00 00 	lea    rax,[rip+0xfde5]        # 213000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20321b:	48 89 05 e6 fd 00 00 	mov    QWORD PTR [rip+0xfde6],rax        # 213008 <stderr_file_out_stream>
  203222:	4c 8d 3d 77 18 00 00 	lea    r15,[rip+0x1877]        # 204aa0 <FileOutStream_writeFn>
  203229:	4c 89 3d e0 fd 00 00 	mov    QWORD PTR [rip+0xfde0],r15        # 213010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  203230:	c7 05 c6 fd 00 00 02 	mov    DWORD PTR [rip+0xfdc6],0x2        # 213000 <stderr_file>
  203237:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20323a:	48 8d 1d cf fd 00 00 	lea    rbx,[rip+0xfdcf]        # 213010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  203241:	48 89 1d c0 1d 01 00 	mov    QWORD PTR [rip+0x11dc0],rbx        # 215008 <stderr_stream>
  203248:	eb 07                	jmp    203251 <panicExtra+0x61>
  20324a:	4c 8b 3d bf fd 00 00 	mov    r15,QWORD PTR [rip+0xfdbf]        # 213010 <stderr_file_out_stream+0x8>
                const casted_value = ([]const u8)(value);
  203251:	c5 f8 10 05 2f 10 01 	vmovups xmm0,XMMWORD PTR [rip+0x1102f]        # 214288 <__unnamed_4>
  203258:	00 
  203259:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  20325e:	48 89 e6             	mov    rsi,rsp
                return output(context, casted_value);
  203261:	48 89 df             	mov    rdi,rbx
  203264:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  203267:	66 85 c0             	test   ax,ax
  20326a:	75 1a                	jne    203286 <panicExtra+0x96>
        try output(context, fmt[start_index..]);
  20326c:	48 8d 35 25 10 01 00 	lea    rsi,[rip+0x11025]        # 214298 <__unnamed_5>
  203273:	48 89 df             	mov    rdi,rbx
  203276:	41 ff d7             	call   r15
        // we would want to return here instead of calling abort, so that the thread
        // which first called panic can finish printing a stack trace.
        os.abort();
    }
    const stderr = getStderrStream() catch os.abort();
    stderr.print(format ++ "\n", args) catch os.abort();
  203279:	66 85 c0             	test   ax,ax
  20327c:	75 08                	jne    203286 <panicExtra+0x96>
    if (trace) |t| {
        dumpStackTrace(t);
    }
    dumpCurrentStackTrace(first_trace_addr);
  20327e:	4c 89 f7             	mov    rdi,r14
  203281:	e8 0a 01 00 00       	call   203390 <dumpCurrentStackTrace>
  203286:	e8 05 00 00 00       	call   203290 <abort>
  20328b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000203290 <abort>:
pub const SIG_DFL = @intToPtr(extern fn (i32) void, 0);
pub const SIG_IGN = @intToPtr(extern fn (i32) void, 1);
pub const empty_sigset = []usize{0} ** sigset_t.len;

pub fn raise(sig: i32) usize {
    var set: sigset_t = undefined;
  203290:	50                   	push   rax
  203291:	c5 fc 10 05 7f dc ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffdc7f]        # 200f18 <__unnamed_6+0x60>
  203298:	ff 
  203299:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  20329f:	c5 fc 10 0d 51 dc ff 	vmovups ymm1,YMMWORD PTR [rip+0xffffffffffffdc51]        # 200ef8 <__unnamed_6+0x40>
  2032a6:	ff 
  2032a7:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  2032ad:	c5 fc 10 15 23 dc ff 	vmovups ymm2,YMMWORD PTR [rip+0xffffffffffffdc23]        # 200ed8 <__unnamed_6+0x20>
  2032b4:	ff 
  2032b5:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  2032bb:	c5 fc 10 1d f5 db ff 	vmovups ymm3,YMMWORD PTR [rip+0xffffffffffffdbf5]        # 200eb8 <__unnamed_6>
  2032c2:	ff 
  2032c3:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
        : "rcx", "r11"
    );
}

pub fn syscall4(number: usize, arg1: usize, arg2: usize, arg3: usize, arg4: usize) usize {
    return asm volatile ("syscall"
  2032c9:	4c 8d 0d 50 cf ff ff 	lea    r9,[rip+0xffffffffffffcf50]        # 200220 <app_mask>
  2032d0:	4c 8d 44 24 80       	lea    r8,[rsp-0x80]
  2032d5:	b8 0e 00 00 00       	mov    eax,0xe
  2032da:	bf 00 00 00 00       	mov    edi,0x0
  2032df:	41 ba 08 00 00 00    	mov    r10d,0x8
  2032e5:	4c 89 ce             	mov    rsi,r9
  2032e8:	4c 89 c2             	mov    rdx,r8
  2032eb:	0f 05                	syscall 
    return asm volatile ("syscall"
  2032ed:	b8 ba 00 00 00       	mov    eax,0xba
  2032f2:	0f 05                	syscall 
    blockAppSignals(&set);
    const tid = @intCast(i32, syscall0(SYS_gettid));
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  2032f4:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  2032f7:	b8 c8 00 00 00       	mov    eax,0xc8
  2032fc:	be 06 00 00 00       	mov    esi,0x6
  203301:	0f 05                	syscall 
    return asm volatile ("syscall"
  203303:	b8 0e 00 00 00       	mov    eax,0xe
  203308:	bf 02 00 00 00       	mov    edi,0x2
  20330d:	ba 00 00 00 00       	mov    edx,0x0
  203312:	41 ba 08 00 00 00    	mov    r10d,0x8
  203318:	4c 89 c6             	mov    rsi,r8
  20331b:	0f 05                	syscall 
    var set: sigset_t = undefined;
  20331d:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  203323:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  203329:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  20332f:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
  203335:	b8 0e 00 00 00       	mov    eax,0xe
  20333a:	bf 00 00 00 00       	mov    edi,0x0
  20333f:	41 ba 08 00 00 00    	mov    r10d,0x8
  203345:	4c 89 ce             	mov    rsi,r9
  203348:	4c 89 c2             	mov    rdx,r8
  20334b:	0f 05                	syscall 
    return asm volatile ("syscall"
  20334d:	b8 ba 00 00 00       	mov    eax,0xba
  203352:	0f 05                	syscall 
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  203354:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  203357:	b8 c8 00 00 00       	mov    eax,0xc8
  20335c:	be 09 00 00 00       	mov    esi,0x9
  203361:	0f 05                	syscall 
    return asm volatile ("syscall"
  203363:	b8 0e 00 00 00       	mov    eax,0xe
  203368:	bf 02 00 00 00       	mov    edi,0x2
  20336d:	31 d2                	xor    edx,edx
  20336f:	41 ba 08 00 00 00    	mov    r10d,0x8
  203375:	4c 89 c6             	mov    rsi,r8
  203378:	0f 05                	syscall 
  20337a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    }
    switch (builtin.os) {
        Os.linux, Os.macosx, Os.ios => {
            _ = posix.raise(posix.SIGABRT);
            _ = posix.raise(posix.SIGKILL);
            while (true) {}
  203380:	eb fe                	jmp    203380 <abort+0xf0>
  203382:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  203389:	1f 84 00 00 00 00 00 

0000000000203390 <dumpCurrentStackTrace>:
pub fn dumpCurrentStackTrace(start_addr: ?usize) void {
  203390:	55                   	push   rbp
  203391:	48 89 e5             	mov    rbp,rsp
  203394:	41 57                	push   r15
  203396:	41 56                	push   r14
  203398:	41 55                	push   r13
  20339a:	41 54                	push   r12
  20339c:	53                   	push   rbx
  20339d:	48 83 e4 e0          	and    rsp,0xffffffffffffffe0
  2033a1:	48 81 ec a0 01 00 00 	sub    rsp,0x1a0
  2033a8:	49 89 fe             	mov    r14,rdi
    if (stderr_stream) |st| {
  2033ab:	48 8b 1d 56 1c 01 00 	mov    rbx,QWORD PTR [rip+0x11c56]        # 215008 <stderr_stream>
  2033b2:	48 85 db             	test   rbx,rbx
  2033b5:	74 39                	je     2033f0 <dumpCurrentStackTrace+0x60>
    if (self_debug_info) |info| {
  2033b7:	48 8b 05 52 1c 01 00 	mov    rax,QWORD PTR [rip+0x11c52]        # 215010 <self_debug_info>
  2033be:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  2033c3:	48 85 c0             	test   rax,rax
  2033c6:	74 6d                	je     203435 <dumpCurrentStackTrace+0xa5>
// TODO make thread safe
var debug_info_allocator: ?*mem.Allocator = null;
var debug_info_direct_allocator: std.heap.DirectAllocator = undefined;
var debug_info_arena_allocator: std.heap.ArenaAllocator = undefined;
fn getDebugInfoAllocator() *mem.Allocator {
    if (debug_info_allocator) |a| return a;
  2033c8:	48 83 3d 48 1c 01 00 	cmp    QWORD PTR [rip+0x11c48],0x0        # 215018 <debug_info_allocator>
  2033cf:	00 
  2033d0:	0f 84 4e 01 00 00    	je     203524 <dumpCurrentStackTrace+0x194>
    }
}

/// TODO make this go through libc when we have it
pub fn getEnvPosix(key: []const u8) ?[]const u8 {
    for (posix_environ_raw) |ptr| {
  2033d6:	48 8b 05 ab fc 00 00 	mov    rax,QWORD PTR [rip+0xfcab]        # 213088 <posix_environ_raw+0x8>
  2033dd:	48 85 c0             	test   rax,rax
  2033e0:	48 89 5c 24 70       	mov    QWORD PTR [rsp+0x70],rbx
  2033e5:	0f 85 a4 01 00 00    	jne    20358f <dumpCurrentStackTrace+0x1ff>
  2033eb:	e9 5d 02 00 00       	jmp    20364d <dumpCurrentStackTrace+0x2bd>
        stderr_file = try io.getStdErr();
  2033f0:	48 8d 05 09 fc 00 00 	lea    rax,[rip+0xfc09]        # 213000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2033f7:	48 89 05 0a fc 00 00 	mov    QWORD PTR [rip+0xfc0a],rax        # 213008 <stderr_file_out_stream>
  2033fe:	48 8d 05 9b 16 00 00 	lea    rax,[rip+0x169b]        # 204aa0 <FileOutStream_writeFn>
  203405:	48 89 05 04 fc 00 00 	mov    QWORD PTR [rip+0xfc04],rax        # 213010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20340c:	c7 05 ea fb 00 00 02 	mov    DWORD PTR [rip+0xfbea],0x2        # 213000 <stderr_file>
  203413:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  203416:	48 8d 1d f3 fb 00 00 	lea    rbx,[rip+0xfbf3]        # 213010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20341d:	48 89 1d e4 1b 01 00 	mov    QWORD PTR [rip+0x11be4],rbx        # 215008 <stderr_stream>
    if (self_debug_info) |info| {
  203424:	48 8b 05 e5 1b 01 00 	mov    rax,QWORD PTR [rip+0x11be5]        # 215010 <self_debug_info>
  20342b:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  203430:	48 85 c0             	test   rax,rax
  203433:	75 93                	jne    2033c8 <dumpCurrentStackTrace+0x38>
    if (debug_info_allocator) |a| return a;
  203435:	48 8b 35 dc 1b 01 00 	mov    rsi,QWORD PTR [rip+0x11bdc]        # 215018 <debug_info_allocator>
  20343c:	48 85 f6             	test   rsi,rsi
  20343f:	75 56                	jne    203497 <dumpCurrentStackTrace+0x107>

    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  203441:	c5 fc 10 05 77 10 01 	vmovups ymm0,YMMWORD PTR [rip+0x11077]        # 2144c0 <__unnamed_7>
  203448:	00 
  203449:	c5 fc 11 05 cf fb 00 	vmovups YMMWORD PTR [rip+0xfbcf],ymm0        # 213020 <debug_info_direct_allocator>
  203450:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  203451:	c5 fa 6f 05 87 10 01 	vmovdqu xmm0,XMMWORD PTR [rip+0x11087]        # 2144e0 <__unnamed_8>
  203458:	00 
  203459:	c5 fa 7f 05 df fb 00 	vmovdqu XMMWORD PTR [rip+0xfbdf],xmm0        # 213040 <debug_info_arena_allocator>
  203460:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  203461:	48 8d 05 b8 fb 00 00 	lea    rax,[rip+0xfbb8]        # 213020 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  203468:	48 8b 0d 81 10 01 00 	mov    rcx,QWORD PTR [rip+0x11081]        # 2144f0 <__unnamed_8+0x10>
  20346f:	48 89 0d da fb 00 00 	mov    QWORD PTR [rip+0xfbda],rcx        # 213050 <debug_info_arena_allocator+0x10>
  203476:	48 8d 35 c3 fb 00 00 	lea    rsi,[rip+0xfbc3]        # 213040 <debug_info_arena_allocator>
  20347d:	48 89 05 d4 fb 00 00 	mov    QWORD PTR [rip+0xfbd4],rax        # 213058 <debug_info_arena_allocator+0x18>
  203484:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  203488:	c5 fe 7f 05 d0 fb 00 	vmovdqu YMMWORD PTR [rip+0xfbd0],ymm0        # 213060 <debug_info_arena_allocator+0x20>
  20348f:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  203490:	48 89 35 81 1b 01 00 	mov    QWORD PTR [rip+0x11b81],rsi        # 215018 <debug_info_allocator>
  203497:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
        const info = try openSelfDebugInfo(getDebugInfoAllocator());
  20349c:	c5 f8 77             	vzeroupper 
  20349f:	e8 ec 16 00 00       	call   204b90 <openSelfDebugInfo>
  2034a4:	4c 0f bf 7c 24 30    	movsx  r15,WORD PTR [rsp+0x30]
  2034aa:	4d 85 ff             	test   r15,r15
  2034ad:	74 56                	je     203505 <dumpCurrentStackTrace+0x175>
  2034af:	4c 8b 33             	mov    r14,QWORD PTR [rbx]
                        try output(context, fmt[start_index..i]);
  2034b2:	48 8d 35 87 0e 01 00 	lea    rsi,[rip+0x10e87]        # 214340 <__unnamed_9>
  2034b9:	48 89 df             	mov    rdi,rbx
  2034bc:	41 ff d6             	call   r14
  2034bf:	66 85 c0             	test   ax,ax
  2034c2:	0f 85 f9 14 00 00    	jne    2049c1 <dumpCurrentStackTrace+0x1631>
        stderr.print("Unable to dump stack trace: Unable to open debug info: {}\n", @errorName(err)) catch return;
  2034c8:	49 c1 e7 04          	shl    r15,0x4
  2034cc:	48 8d 05 2d 0b 01 00 	lea    rax,[rip+0x10b2d]        # 214000 <raw+0xf68>
                const casted_value = ([]const u8)(value);
  2034d3:	c4 c1 7a 6f 04 07    	vmovdqu xmm0,XMMWORD PTR [r15+rax*1]
  2034d9:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
  2034df:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
                return output(context, casted_value);
  2034e4:	48 89 df             	mov    rdi,rbx
  2034e7:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2034ea:	66 85 c0             	test   ax,ax
  2034ed:	0f 85 ce 14 00 00    	jne    2049c1 <dumpCurrentStackTrace+0x1631>
        try output(context, fmt[start_index..]);
  2034f3:	48 8d 35 56 0e 01 00 	lea    rsi,[rip+0x10e56]        # 214350 <__unnamed_10>
  2034fa:	48 89 df             	mov    rdi,rbx
  2034fd:	41 ff d6             	call   r14
  203500:	e9 bc 14 00 00       	jmp    2049c1 <dumpCurrentStackTrace+0x1631>
        const info = try openSelfDebugInfo(getDebugInfoAllocator());
  203505:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  20350a:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
        self_debug_info = info;
  20350f:	48 89 05 fa 1a 01 00 	mov    QWORD PTR [rip+0x11afa],rax        # 215010 <self_debug_info>
    if (debug_info_allocator) |a| return a;
  203516:	48 83 3d fa 1a 01 00 	cmp    QWORD PTR [rip+0x11afa],0x0        # 215018 <debug_info_allocator>
  20351d:	00 
  20351e:	0f 85 b2 fe ff ff    	jne    2033d6 <dumpCurrentStackTrace+0x46>
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  203524:	c5 fc 10 05 94 0f 01 	vmovups ymm0,YMMWORD PTR [rip+0x10f94]        # 2144c0 <__unnamed_7>
  20352b:	00 
  20352c:	c5 fc 11 05 ec fa 00 	vmovups YMMWORD PTR [rip+0xfaec],ymm0        # 213020 <debug_info_direct_allocator>
  203533:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  203534:	c5 fa 6f 05 a4 0f 01 	vmovdqu xmm0,XMMWORD PTR [rip+0x10fa4]        # 2144e0 <__unnamed_8>
  20353b:	00 
  20353c:	c5 fa 7f 05 fc fa 00 	vmovdqu XMMWORD PTR [rip+0xfafc],xmm0        # 213040 <debug_info_arena_allocator>
  203543:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  203544:	48 8d 05 d5 fa 00 00 	lea    rax,[rip+0xfad5]        # 213020 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  20354b:	48 8b 0d 9e 0f 01 00 	mov    rcx,QWORD PTR [rip+0x10f9e]        # 2144f0 <__unnamed_8+0x10>
  203552:	48 89 0d f7 fa 00 00 	mov    QWORD PTR [rip+0xfaf7],rcx        # 213050 <debug_info_arena_allocator+0x10>
  203559:	48 8d 0d e0 fa 00 00 	lea    rcx,[rip+0xfae0]        # 213040 <debug_info_arena_allocator>
  203560:	48 89 05 f1 fa 00 00 	mov    QWORD PTR [rip+0xfaf1],rax        # 213058 <debug_info_arena_allocator+0x18>
  203567:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20356b:	c5 fe 7f 05 ed fa 00 	vmovdqu YMMWORD PTR [rip+0xfaed],ymm0        # 213060 <debug_info_arena_allocator+0x20>
  203572:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  203573:	48 89 0d 9e 1a 01 00 	mov    QWORD PTR [rip+0x11a9e],rcx        # 215018 <debug_info_allocator>
  20357a:	48 8b 05 07 fb 00 00 	mov    rax,QWORD PTR [rip+0xfb07]        # 213088 <posix_environ_raw+0x8>
  203581:	48 85 c0             	test   rax,rax
  203584:	48 89 5c 24 70       	mov    QWORD PTR [rsp+0x70],rbx
  203589:	0f 84 be 00 00 00    	je     20364d <dumpCurrentStackTrace+0x2bd>
  20358f:	48 8b 0d ea fa 00 00 	mov    rcx,QWORD PTR [rip+0xfaea]        # 213080 <posix_environ_raw>
  203596:	31 d2                	xor    edx,edx
  203598:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20359f:	00 
  2035a0:	48 8b 34 d1          	mov    rsi,QWORD PTR [rcx+rdx*8]
  2035a4:	48 c7 c7 f1 ff ff ff 	mov    rdi,0xfffffffffffffff1
        var line_i: usize = 0;
        while (ptr[line_i] != 0 and ptr[line_i] != '=') : (line_i += 1) {}
  2035ab:	8a 5c 3e 0f          	mov    bl,BYTE PTR [rsi+rdi*1+0xf]
  2035af:	84 db                	test   bl,bl
  2035b1:	74 1f                	je     2035d2 <dumpCurrentStackTrace+0x242>
  2035b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2035ba:	84 00 00 00 00 00 
  2035c0:	80 fb 3d             	cmp    bl,0x3d
  2035c3:	74 0d                	je     2035d2 <dumpCurrentStackTrace+0x242>
  2035c5:	48 83 c7 01          	add    rdi,0x1
  2035c9:	0f b6 5c 3e 0f       	movzx  ebx,BYTE PTR [rsi+rdi*1+0xf]
  2035ce:	84 db                	test   bl,bl
  2035d0:	75 ee                	jne    2035c0 <dumpCurrentStackTrace+0x230>
    assert(lessThan(u8, "", "a"));
}

/// Compares two slices and returns whether they are equal.
pub fn eql(comptime T: type, a: []const T, b: []const T) bool {
    if (a.len != b.len) return false;
  2035d2:	48 85 ff             	test   rdi,rdi
  2035d5:	75 69                	jne    203640 <dumpCurrentStackTrace+0x2b0>
    for (a) |item, index| {
        if (b[index] != item) return false;
  2035d7:	80 3e 5a             	cmp    BYTE PTR [rsi],0x5a
  2035da:	75 64                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  2035dc:	80 7e 01 49          	cmp    BYTE PTR [rsi+0x1],0x49
  2035e0:	75 5e                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  2035e2:	80 7e 02 47          	cmp    BYTE PTR [rsi+0x2],0x47
  2035e6:	75 58                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  2035e8:	80 7e 03 5f          	cmp    BYTE PTR [rsi+0x3],0x5f
  2035ec:	75 52                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  2035ee:	80 7e 04 44          	cmp    BYTE PTR [rsi+0x4],0x44
  2035f2:	75 4c                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  2035f4:	80 7e 05 45          	cmp    BYTE PTR [rsi+0x5],0x45
  2035f8:	75 46                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  2035fa:	80 7e 06 42          	cmp    BYTE PTR [rsi+0x6],0x42
  2035fe:	75 40                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  203600:	80 7e 07 55          	cmp    BYTE PTR [rsi+0x7],0x55
  203604:	75 3a                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  203606:	80 7e 08 47          	cmp    BYTE PTR [rsi+0x8],0x47
  20360a:	75 34                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  20360c:	80 7e 09 5f          	cmp    BYTE PTR [rsi+0x9],0x5f
  203610:	75 2e                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  203612:	80 7e 0a 43          	cmp    BYTE PTR [rsi+0xa],0x43
  203616:	75 28                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  203618:	80 7e 0b 4f          	cmp    BYTE PTR [rsi+0xb],0x4f
  20361c:	75 22                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  20361e:	80 7e 0c 4c          	cmp    BYTE PTR [rsi+0xc],0x4c
  203622:	75 1c                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  203624:	80 7e 0d 4f          	cmp    BYTE PTR [rsi+0xd],0x4f
  203628:	75 16                	jne    203640 <dumpCurrentStackTrace+0x2b0>
  20362a:	80 7e 0e 52          	cmp    BYTE PTR [rsi+0xe],0x52
  20362e:	0f 84 44 14 00 00    	je     204a78 <dumpCurrentStackTrace+0x16e8>
  203634:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20363b:	00 00 00 00 00 
    for (posix_environ_raw) |ptr| {
  203640:	48 83 c2 01          	add    rdx,0x1
  203644:	48 39 c2             	cmp    rdx,rax
  203647:	0f 82 53 ff ff ff    	jb     2035a0 <dumpCurrentStackTrace+0x210>
    return syscall3(SYS_ioctl, @intCast(usize, fd), TIOCGWINSZ, @ptrToInt(&wsz)) == 0;
  20364d:	48 63 3d ac f9 00 00 	movsxd rdi,DWORD PTR [rip+0xf9ac]        # 213000 <stderr_file>
  203654:	48 8d 54 24 30       	lea    rdx,[rsp+0x30]
    return asm volatile ("syscall"
  203659:	b8 10 00 00 00       	mov    eax,0x10
  20365e:	be 13 54 00 00       	mov    esi,0x5413
  203663:	0f 05                	syscall 
  203665:	48 85 c0             	test   rax,rax
  203668:	0f 94 44 24 0f       	sete   BYTE PTR [rsp+0xf]
    if (start_addr) |addr| {
  20366d:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  203672:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  203677:	75 0f                	jne    203688 <dumpCurrentStackTrace+0x2f8>
  203679:	49 8b 0e             	mov    rcx,QWORD PTR [r14]
  20367c:	b0 01                	mov    al,0x1
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  20367e:	48 85 ed             	test   rbp,rbp
  203681:	75 10                	jne    203693 <dumpCurrentStackTrace+0x303>
  203683:	e9 39 13 00 00       	jmp    2049c1 <dumpCurrentStackTrace+0x1631>
  203688:	31 c0                	xor    eax,eax
  20368a:	48 85 ed             	test   rbp,rbp
  20368d:	0f 84 2e 13 00 00    	je     2049c1 <dumpCurrentStackTrace+0x1631>
  203693:	48 89 ea             	mov    rdx,rbp
  203696:	c4 62 7d 59 25 69 cb 	vpbroadcastq ymm12,QWORD PTR [rip+0xffffffffffffcb69]        # 200208 <app_mask-0x18>
  20369d:	ff ff 
  20369f:	c4 62 7d 59 2d 98 cb 	vpbroadcastq ymm13,QWORD PTR [rip+0xffffffffffffcb98]        # 200240 <app_mask+0x20>
  2036a6:	ff ff 
  2036a8:	c5 7d 7f a4 24 00 01 	vmovdqa YMMWORD PTR [rsp+0x100],ymm12
  2036af:	00 00 
  2036b1:	c5 7d 7f ac 24 e0 00 	vmovdqa YMMWORD PTR [rsp+0xe0],ymm13
  2036b8:	00 00 
  2036ba:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  2036c1:	00 
  2036c2:	48 89 74 24 28       	mov    QWORD PTR [rsp+0x28],rsi
  2036c7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2036ce:	00 00 
        const return_address = @intToPtr(*const usize, fp + @sizeOf(usize)).*;
  2036d0:	4c 8b 6a 08          	mov    r13,QWORD PTR [rdx+0x8]
                if (return_address == addr) {
  2036d4:	49 39 cd             	cmp    r13,rcx
        switch (addr_state) {
  2036d7:	74 17                	je     2036f0 <dumpCurrentStackTrace+0x360>
  2036d9:	f6 d0                	not    al
  2036db:	a8 01                	test   al,0x1
  2036dd:	b0 01                	mov    al,0x1
  2036df:	75 0f                	jne    2036f0 <dumpCurrentStackTrace+0x360>
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  2036e1:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  2036e4:	48 85 d2             	test   rdx,rdx
  2036e7:	75 e7                	jne    2036d0 <dumpCurrentStackTrace+0x340>
  2036e9:	e9 d3 12 00 00       	jmp    2049c1 <dumpCurrentStackTrace+0x1631>
  2036ee:	66 90                	xchg   ax,ax
  2036f0:	48 89 94 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rdx
  2036f7:	00 
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  2036f8:	48 89 b4 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rsi
  2036ff:	00 
  203700:	48 8d 05 b9 5f 00 00 	lea    rax,[rip+0x5fb9]        # 2096c0 <FileInStream_readFn>
  203707:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20370e:	00 
        pub fn deinit(self: Self) void {
            self.allocator.free(self.items);
        }

        pub fn toSlice(self: Self) []align(A) T {
            return self.items[0..self.len];
  20370f:	48 8b 86 b8 00 00 00 	mov    rax,QWORD PTR [rsi+0xb8]
  203716:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  20371b:	48 85 c0             	test   rax,rax
  20371e:	0f 84 6c 04 00 00    	je     203b90 <dumpCurrentStackTrace+0x800>
  203724:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  203729:	4c 8b 88 a8 00 00 00 	mov    r9,QWORD PTR [rax+0xa8]
  203730:	45 31 e4             	xor    r12d,r12d
  203733:	e9 08 02 00 00       	jmp    203940 <dumpCurrentStackTrace+0x5b0>
                result = (result << 8) | b;
            }
        },
        builtin.Endian.Little => {
            const ShiftType = math.Log2Int(T);
            for (bytes) |b, index| {
  203738:	48 89 c3             	mov    rbx,rax
  20373b:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  20373f:	48 8d 73 f0          	lea    rsi,[rbx-0x10]
  203743:	48 89 f7             	mov    rdi,rsi
  203746:	48 c1 ef 04          	shr    rdi,0x4
  20374a:	44 8d 47 01          	lea    r8d,[rdi+0x1]
  20374e:	41 83 e0 01          	and    r8d,0x1
  203752:	48 85 f6             	test   rsi,rsi
  203755:	0f 84 bd 01 00 00    	je     203918 <dumpCurrentStackTrace+0x588>
  20375b:	49 8d 70 ff          	lea    rsi,[r8-0x1]
  20375f:	48 29 fe             	sub    rsi,rdi
  203762:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  203766:	31 ff                	xor    edi,edi
  203768:	c5 fd 6f 25 30 ca ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffffca30]        # 2001a0 <app_mask-0x80>
  20376f:	ff 
  203770:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  203774:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  203778:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  20377c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  203780:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  203786:	c4 e2 7d 32 74 39 04 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x4]
  20378d:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  203794:	c4 62 7d 32 44 39 0c 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0xc]
  20379b:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  2037a0:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  2037a5:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  2037aa:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  2037af:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  2037b4:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  2037b8:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  2037bd:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  2037c1:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  2037c6:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  2037ca:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  2037cf:	c4 e2 7d 32 74 39 10 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x10]
  2037d6:	c4 e2 7d 32 7c 39 14 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x14]
  2037dd:	c4 62 7d 32 44 39 18 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0x18]
  2037e4:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  2037e8:	c4 e2 7d 32 6c 39 1c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x1c]
  2037ef:	c4 62 7d 59 15 40 ca 	vpbroadcastq ymm10,QWORD PTR [rip+0xffffffffffffca40]        # 200238 <app_mask+0x18>
  2037f6:	ff ff 
  2037f8:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  2037fd:	c4 62 7d 59 1d e2 c9 	vpbroadcastq ymm11,QWORD PTR [rip+0xffffffffffffc9e2]        # 2001e8 <app_mask-0x38>
  203804:	ff ff 
  203806:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  20380b:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  203810:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  203815:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  20381a:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  20381e:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  203823:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  203827:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  20382c:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  203830:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  203835:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  203839:	48 83 c7 20          	add    rdi,0x20
  20383d:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  203842:	48 83 c6 02          	add    rsi,0x2
  203846:	0f 85 34 ff ff ff    	jne    203780 <dumpCurrentStackTrace+0x3f0>
  20384c:	4d 85 c0             	test   r8,r8
  20384f:	74 53                	je     2038a4 <dumpCurrentStackTrace+0x514>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  203851:	c4 e2 7d 32 6c 39 0c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0xc]
  203858:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  20385d:	c4 c1 5d d4 f4       	vpaddq ymm6,ymm4,ymm12
  203862:	c4 c1 4d db f5       	vpand  ymm6,ymm6,ymm13
  203867:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20386c:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  203873:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  203877:	c4 c1 5d db e5       	vpand  ymm4,ymm4,ymm13
  20387c:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  203881:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  203885:	c4 e2 7d 32 6c 39 04 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x4]
  20388c:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  203891:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  203895:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  20389b:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  2038a0:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  2038a4:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  2038a8:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  2038ac:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2038b0:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  2038b6:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2038ba:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  2038bf:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  2038c3:	c4 e1 f9 7e c6       	vmovq  rsi,xmm0
  2038c8:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  2038cb:	74 31                	je     2038fe <dumpCurrentStackTrace+0x56e>
  2038cd:	48 29 d8             	sub    rax,rbx
  2038d0:	48 01 d9             	add    rcx,rbx
  2038d3:	48 c1 e3 03          	shl    rbx,0x3
  2038d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2038de:	00 00 
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2038e0:	0f b6 39             	movzx  edi,BYTE PTR [rcx]
  2038e3:	89 da                	mov    edx,ebx
  2038e5:	80 e2 38             	and    dl,0x38
  2038e8:	c4 e2 e9 f7 d7       	shlx   rdx,rdi,rdx
  2038ed:	48 09 d6             	or     rsi,rdx
            for (bytes) |b, index| {
  2038f0:	48 83 c3 08          	add    rbx,0x8
  2038f4:	48 83 c1 01          	add    rcx,0x1
  2038f8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2038fc:	75 e2                	jne    2038e0 <dumpCurrentStackTrace+0x550>
            if (st.debug_ranges) |debug_ranges| {
  2038fe:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  203903:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  20390a:	48 85 c0             	test   rax,rax
  20390d:	0f 85 fd 00 00 00    	jne    203a10 <dumpCurrentStackTrace+0x680>
  203913:	e9 68 02 00 00       	jmp    203b80 <dumpCurrentStackTrace+0x7f0>
  203918:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20391c:	31 ff                	xor    edi,edi
  20391e:	c5 fd 6f 25 7a c8 ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffffc87a]        # 2001a0 <app_mask-0x80>
  203925:	ff 
  203926:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  20392a:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20392e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  203932:	4d 85 c0             	test   r8,r8
  203935:	0f 85 16 ff ff ff    	jne    203851 <dumpCurrentStackTrace+0x4c1>
  20393b:	e9 64 ff ff ff       	jmp    2038a4 <dumpCurrentStackTrace+0x514>
        if (compile_unit.pc_range) |range| {
  203940:	4f 8d 34 64          	lea    r14,[r12+r12*2]
  203944:	49 c1 e6 04          	shl    r14,0x4
  203948:	43 80 7c 31 28 01    	cmp    BYTE PTR [r9+r14*1+0x28],0x1
  20394e:	75 12                	jne    203962 <dumpCurrentStackTrace+0x5d2>
            if (target_address >= range.start and target_address < range.end) return compile_unit;
  203950:	4f 39 6c 31 18       	cmp    QWORD PTR [r9+r14*1+0x18],r13
  203955:	77 0b                	ja     203962 <dumpCurrentStackTrace+0x5d2>
  203957:	4f 39 6c 31 20       	cmp    QWORD PTR [r9+r14*1+0x20],r13
  20395c:	0f 87 4c 04 00 00    	ja     203dae <dumpCurrentStackTrace+0xa1e>
        if (compile_unit.die.getAttrSecOffset(DW.AT_ranges)) |ranges_offset| {
  203962:	4b 8b 4c 31 08       	mov    rcx,QWORD PTR [r9+r14*1+0x8]
  203967:	48 8b 41 20          	mov    rax,QWORD PTR [rcx+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  20396b:	48 85 c0             	test   rax,rax
  20396e:	0f 84 0c 02 00 00    	je     203b80 <dumpCurrentStackTrace+0x7f0>
  203974:	4b 8d 14 31          	lea    rdx,[r9+r14*1]
  203978:	48 83 c2 08          	add    rdx,0x8
  20397c:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  203983:	00 
  203984:	48 8b 49 10          	mov    rcx,QWORD PTR [rcx+0x10]
            if (attr.id == id) return &attr.value;
  203988:	48 83 c1 20          	add    rcx,0x20
  20398c:	31 d2                	xor    edx,edx
  20398e:	66 90                	xchg   ax,ax
  203990:	48 83 79 e0 55       	cmp    QWORD PTR [rcx-0x20],0x55
  203995:	74 19                	je     2039b0 <dumpCurrentStackTrace+0x620>
        for (self.attrs.toSliceConst()) |*attr| {
  203997:	48 83 c2 01          	add    rdx,0x1
  20399b:	48 83 c1 28          	add    rcx,0x28
  20399f:	48 39 c2             	cmp    rdx,rax
  2039a2:	72 ec                	jb     203990 <dumpCurrentStackTrace+0x600>
  2039a4:	e9 d7 01 00 00       	jmp    203b80 <dumpCurrentStackTrace+0x7f0>
  2039a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  2039b0:	8a 01                	mov    al,BYTE PTR [rcx]
  2039b2:	3c 05                	cmp    al,0x5
        return switch (form_value.*) {
  2039b4:	74 41                	je     2039f7 <dumpCurrentStackTrace+0x667>
  2039b6:	3c 02                	cmp    al,0x2
  2039b8:	0f 85 d2 01 00 00    	jne    203b90 <dumpCurrentStackTrace+0x800>
            FormValue.Const => |value| value.asUnsignedLe(),
  2039be:	48 8b 41 f0          	mov    rax,QWORD PTR [rcx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  2039c2:	48 83 f8 08          	cmp    rax,0x8
  2039c6:	0f 87 c4 01 00 00    	ja     203b90 <dumpCurrentStackTrace+0x800>
            FormValue.Const => |value| value.asUnsignedLe(),
  2039cc:	8a 51 f8             	mov    dl,BYTE PTR [rcx-0x8]
        if (self.signed) return error.InvalidDebugInfo;
  2039cf:	84 d2                	test   dl,dl
  2039d1:	0f 85 b9 01 00 00    	jne    203b90 <dumpCurrentStackTrace+0x800>
  2039d7:	48 85 c0             	test   rax,rax
  2039da:	0f 84 7c 01 00 00    	je     203b5c <dumpCurrentStackTrace+0x7cc>
  2039e0:	48 8b 49 e8          	mov    rcx,QWORD PTR [rcx-0x18]
  2039e4:	48 83 f8 10          	cmp    rax,0x10
  2039e8:	0f 83 4a fd ff ff    	jae    203738 <dumpCurrentStackTrace+0x3a8>
  2039ee:	31 db                	xor    ebx,ebx
  2039f0:	31 f6                	xor    esi,esi
  2039f2:	e9 d6 fe ff ff       	jmp    2038cd <dumpCurrentStackTrace+0x53d>
            FormValue.SecOffset => |value| value,
  2039f7:	48 8b 71 e8          	mov    rsi,QWORD PTR [rcx-0x18]
            if (st.debug_ranges) |debug_ranges| {
  2039fb:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  203a00:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  203a07:	48 85 c0             	test   rax,rax
  203a0a:	0f 84 70 01 00 00    	je     203b80 <dumpCurrentStackTrace+0x7f0>
/// Cast an integer to a different integer type. If the value doesn't fit,
/// return an error.
pub fn cast(comptime T: type, x: var) (error{Overflow}!T) {
    comptime assert(@typeId(T) == builtin.TypeId.Int); // must pass an integer
    comptime assert(@typeId(@typeOf(x)) == builtin.TypeId.Int); // must pass an integer
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  203a10:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  203a14:	0f 88 76 01 00 00    	js     203b90 <dumpCurrentStackTrace+0x800>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  203a1a:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  203a1f:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  203a22:	b8 08 00 00 00       	mov    eax,0x8
  203a27:	31 d2                	xor    edx,edx
  203a29:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  203a2b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const ipos = try math.cast(isize, pos);
                const result = posix.lseek(self.handle, ipos, posix.SEEK_SET);
                const err = posix.getErrno(result);
                if (err > 0) {
  203a31:	0f 83 59 01 00 00    	jae    203b90 <dumpCurrentStackTrace+0x800>
  203a37:	4c 89 cb             	mov    rbx,r9
            try self.readNoEof(bytes[0..]);
  203a3a:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  203a41:	00 
  203a42:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  203a47:	48 c7 44 24 18 08 00 	mov    QWORD PTR [rsp+0x18],0x8
  203a4e:	00 00 
            return self.readFn(self, buffer);
  203a50:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
  203a55:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  203a5c:	00 
  203a5d:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  203a62:	c5 f8 77             	vzeroupper 
  203a65:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
            const amt_read = try self.read(buf);
  203a6c:	66 83 7c 24 30 00    	cmp    WORD PTR [rsp+0x30],0x0
  203a72:	0f 85 18 01 00 00    	jne    203b90 <dumpCurrentStackTrace+0x800>
  203a78:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  203a7d:	0f 1f 00             	nop    DWORD PTR [rax]
            if (amt_read < buf.len) return error.EndOfStream;
  203a80:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  203a85:	0f 82 05 01 00 00    	jb     203b90 <dumpCurrentStackTrace+0x800>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  203a8b:	4c 8b bc 24 b8 00 00 	mov    r15,QWORD PTR [rsp+0xb8]
  203a92:	00 
            try self.readNoEof(bytes[0..]);
  203a93:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  203a9a:	00 
  203a9b:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  203aa0:	48 c7 44 24 18 08 00 	mov    QWORD PTR [rsp+0x18],0x8
  203aa7:	00 00 
            return self.readFn(self, buffer);
  203aa9:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
  203aae:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  203ab5:	00 
  203ab6:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  203abb:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
            const amt_read = try self.read(buf);
  203ac2:	66 83 7c 24 30 00    	cmp    WORD PTR [rsp+0x30],0x0
  203ac8:	0f 85 c2 00 00 00    	jne    203b90 <dumpCurrentStackTrace+0x800>
  203ace:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  203ad3:	48 39 44 24 38       	cmp    QWORD PTR [rsp+0x38],rax
  203ad8:	0f 82 b2 00 00 00    	jb     203b90 <dumpCurrentStackTrace+0x800>
  203ade:	48 8b 84 24 b8 00 00 	mov    rax,QWORD PTR [rsp+0xb8]
  203ae5:	00 
                    if (begin_addr == 0 and end_addr == 0) {
  203ae6:	48 89 c1             	mov    rcx,rax
  203ae9:	4c 09 f9             	or     rcx,r15
  203aec:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  203af3:	00 00 
  203af5:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  203afc:	00 00 
  203afe:	49 89 d9             	mov    r9,rbx
  203b01:	74 7d                	je     203b80 <dumpCurrentStackTrace+0x7f0>
                    if (begin_addr == @maxValue(usize)) {
  203b03:	49 83 ff ff          	cmp    r15,0xffffffffffffffff
  203b07:	74 0e                	je     203b17 <dumpCurrentStackTrace+0x787>
                    if (target_address >= begin_addr and target_address < end_addr) {
  203b09:	4d 39 ef             	cmp    r15,r13
  203b0c:	77 09                	ja     203b17 <dumpCurrentStackTrace+0x787>
  203b0e:	4c 39 e8             	cmp    rax,r13
  203b11:	0f 87 8d 02 00 00    	ja     203da4 <dumpCurrentStackTrace+0xa14>
            try self.readNoEof(bytes[0..]);
  203b17:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  203b1e:	00 
  203b1f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  203b24:	48 c7 44 24 18 08 00 	mov    QWORD PTR [rsp+0x18],0x8
  203b2b:	00 00 
            return self.readFn(self, buffer);
  203b2d:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
  203b32:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  203b39:	00 
  203b3a:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  203b3f:	c5 f8 77             	vzeroupper 
  203b42:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
  203b49:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  203b4e:	66 83 7c 24 30 00    	cmp    WORD PTR [rsp+0x30],0x0
  203b54:	0f 84 26 ff ff ff    	je     203a80 <dumpCurrentStackTrace+0x6f0>
  203b5a:	eb 34                	jmp    203b90 <dumpCurrentStackTrace+0x800>
        return switch (form_value.*) {
  203b5c:	31 f6                	xor    esi,esi
            if (st.debug_ranges) |debug_ranges| {
  203b5e:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  203b63:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  203b6a:	48 85 c0             	test   rax,rax
  203b6d:	0f 85 9d fe ff ff    	jne    203a10 <dumpCurrentStackTrace+0x680>
  203b73:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  203b7a:	84 00 00 00 00 00 
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  203b80:	49 83 c4 01          	add    r12,0x1
  203b84:	4c 3b 64 24 78       	cmp    r12,QWORD PTR [rsp+0x78]
  203b89:	0f 82 b1 fd ff ff    	jb     203940 <dumpCurrentStackTrace+0x5b0>
  203b8f:	90                   	nop
  203b90:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
            return std.fmt.format(self, Error, self.writeFn, format, args);
  203b95:	4d 8b 34 24          	mov    r14,QWORD PTR [r12]
                if (tty_color) {
  203b99:	80 7c 24 0f 00       	cmp    BYTE PTR [rsp+0xf],0x0
  203b9e:	74 70                	je     203c10 <dumpCurrentStackTrace+0x880>
                        try output(context, fmt[start_index..i]);
  203ba0:	4c 89 e7             	mov    rdi,r12
  203ba3:	48 8d 35 d6 07 01 00 	lea    rsi,[rip+0x107d6]        # 214380 <__unnamed_11>
  203baa:	c5 f8 77             	vzeroupper 
  203bad:	41 ff d6             	call   r14
  203bb0:	41 89 c7             	mov    r15d,eax
  203bb3:	66 45 85 ff          	test   r15w,r15w
  203bb7:	0f 85 a3 01 00 00    	jne    203d60 <dumpCurrentStackTrace+0x9d0>
    var buf: [max_int_digits - 1]u8 = undefined;
  203bbd:	c5 fc 10 05 5a e9 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe95a]        # 20251f <__unnamed_2+0x1f>
  203bc4:	ff 
  203bc5:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  203bcb:	c5 fe 6f 05 2d e9 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe92d]        # 202500 <__unnamed_2>
  203bd2:	ff 
  203bd3:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  203bd9:	44 89 e8             	mov    eax,r13d
  203bdc:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  203bde:	b1 30                	mov    cl,0x30
  203be0:	3c 0a                	cmp    al,0xa
  203be2:	72 02                	jb     203be6 <dumpCurrentStackTrace+0x856>
  203be4:	b1 57                	mov    cl,0x57
  203be6:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  203be8:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  203bec:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  203bf1:	49 83 fd 10          	cmp    r13,0x10
  203bf5:	73 7e                	jae    203c75 <dumpCurrentStackTrace+0x8e5>
  203bf7:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  203bfc:	e9 af 00 00 00       	jmp    203cb0 <dumpCurrentStackTrace+0x920>
  203c01:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  203c08:	0f 1f 84 00 00 00 00 
  203c0f:	00 
                        try output(context, fmt[start_index..i]);
  203c10:	4c 89 e7             	mov    rdi,r12
  203c13:	48 8d 35 86 07 01 00 	lea    rsi,[rip+0x10786]        # 2143a0 <__unnamed_12>
  203c1a:	c5 f8 77             	vzeroupper 
  203c1d:	41 ff d6             	call   r14
  203c20:	41 89 c7             	mov    r15d,eax
  203c23:	66 45 85 ff          	test   r15w,r15w
  203c27:	0f 85 33 01 00 00    	jne    203d60 <dumpCurrentStackTrace+0x9d0>
    var buf: [max_int_digits - 1]u8 = undefined;
  203c2d:	c5 fc 10 05 ea e8 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe8ea]        # 20251f <__unnamed_2+0x1f>
  203c34:	ff 
  203c35:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  203c3b:	c5 fe 6f 05 bd e8 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe8bd]        # 202500 <__unnamed_2>
  203c42:	ff 
  203c43:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  203c49:	44 89 e8             	mov    eax,r13d
  203c4c:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  203c4e:	b1 30                	mov    cl,0x30
  203c50:	3c 0a                	cmp    al,0xa
  203c52:	72 02                	jb     203c56 <dumpCurrentStackTrace+0x8c6>
  203c54:	b1 57                	mov    cl,0x57
  203c56:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  203c58:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  203c5c:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  203c61:	49 83 fd 10          	cmp    r13,0x10
  203c65:	0f 83 7e 00 00 00    	jae    203ce9 <dumpCurrentStackTrace+0x959>
  203c6b:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  203c70:	e9 ab 00 00 00       	jmp    203d20 <dumpCurrentStackTrace+0x990>
        a /= base;
  203c75:	4c 89 e9             	mov    rcx,r13
  203c78:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  203c7f:	00 
  203c80:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  203c84:	89 ca                	mov    edx,ecx
  203c86:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  203c89:	b3 30                	mov    bl,0x30
  203c8b:	80 fa 0a             	cmp    dl,0xa
  203c8e:	72 02                	jb     203c92 <dumpCurrentStackTrace+0x902>
  203c90:	b3 57                	mov    bl,0x57
  203c92:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  203c94:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  203c98:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  203c9c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  203ca3:	49 89 cd             	mov    r13,rcx
  203ca6:	77 d8                	ja     203c80 <dumpCurrentStackTrace+0x8f0>
        const padded_buf = buf[index - padding ..];
  203ca8:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  203cac:	48 83 c1 2f          	add    rcx,0x2f
  203cb0:	ba 41 00 00 00       	mov    edx,0x41
  203cb5:	48 29 c2             	sub    rdx,rax
  203cb8:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  203cbd:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  203cc2:	4c 89 e7             	mov    rdi,r12
  203cc5:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  203cca:	c5 f8 77             	vzeroupper 
  203ccd:	41 ff d6             	call   r14
  203cd0:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  203cd3:	66 45 85 ff          	test   r15w,r15w
  203cd7:	0f 85 83 00 00 00    	jne    203d60 <dumpCurrentStackTrace+0x9d0>
        try output(context, fmt[start_index..]);
  203cdd:	4c 89 e7             	mov    rdi,r12
  203ce0:	48 8d 35 a9 06 01 00 	lea    rsi,[rip+0x106a9]        # 214390 <__unnamed_13>
  203ce7:	eb 6a                	jmp    203d53 <dumpCurrentStackTrace+0x9c3>
        a /= base;
  203ce9:	4c 89 e9             	mov    rcx,r13
  203cec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  203cf0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  203cf4:	89 ca                	mov    edx,ecx
  203cf6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  203cf9:	b3 30                	mov    bl,0x30
  203cfb:	80 fa 0a             	cmp    dl,0xa
  203cfe:	72 02                	jb     203d02 <dumpCurrentStackTrace+0x972>
  203d00:	b3 57                	mov    bl,0x57
  203d02:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  203d04:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  203d08:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  203d0c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  203d13:	49 89 cd             	mov    r13,rcx
  203d16:	77 d8                	ja     203cf0 <dumpCurrentStackTrace+0x960>
        const padded_buf = buf[index - padding ..];
  203d18:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  203d1c:	48 83 c1 2f          	add    rcx,0x2f
  203d20:	ba 41 00 00 00       	mov    edx,0x41
  203d25:	48 29 c2             	sub    rdx,rax
  203d28:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  203d2d:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  203d32:	4c 89 e7             	mov    rdi,r12
  203d35:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  203d3a:	c5 f8 77             	vzeroupper 
  203d3d:	41 ff d6             	call   r14
  203d40:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  203d43:	66 45 85 ff          	test   r15w,r15w
  203d47:	75 17                	jne    203d60 <dumpCurrentStackTrace+0x9d0>
        try output(context, fmt[start_index..]);
  203d49:	4c 89 e7             	mov    rdi,r12
  203d4c:	48 8d 35 5d 06 01 00 	lea    rsi,[rip+0x1065d]        # 2143b0 <__unnamed_14>
  203d53:	41 ff d6             	call   r14
  203d56:	41 89 c7             	mov    r15d,eax
  203d59:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  203d60:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  203d67:	00 00 
  203d69:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  203d70:	00 00 
        try printSourceAtAddress(debug_info, out_stream, return_address, tty_color);
  203d72:	66 45 85 ff          	test   r15w,r15w
  203d76:	0f 85 f8 0b 00 00    	jne    204974 <dumpCurrentStackTrace+0x15e4>
  203d7c:	31 c0                	xor    eax,eax
  203d7e:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  203d85:	00 
  203d86:	48 8b 94 24 b0 00 00 	mov    rdx,QWORD PTR [rsp+0xb0]
  203d8d:	00 
  203d8e:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  203d93:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  203d96:	48 85 d2             	test   rdx,rdx
  203d99:	0f 85 31 f9 ff ff    	jne    2036d0 <dumpCurrentStackTrace+0x340>
  203d9f:	e9 1d 0c 00 00       	jmp    2049c1 <dumpCurrentStackTrace+0x1631>
  203da4:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  203dab:	00 
  203dac:	eb 08                	jmp    203db6 <dumpCurrentStackTrace+0xa26>
            const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  203dae:	4b 8d 04 31          	lea    rax,[r9+r14*1]
  203db2:	48 83 c0 08          	add    rax,0x8
  203db6:	48 8b 00             	mov    rax,QWORD PTR [rax]
        }

        pub fn toSliceConst(self: Self) []align(A) const T {
            return self.items[0..self.len];
  203db9:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  203dbd:	48 85 c9             	test   rcx,rcx
  203dc0:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
  203dc5:	0f 84 84 0b 00 00    	je     20494f <dumpCurrentStackTrace+0x15bf>
  203dcb:	4d 01 f1             	add    r9,r14
  203dce:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  203dd2:	31 d2                	xor    edx,edx
  203dd4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  203ddb:	00 00 00 00 00 
            if (attr.id == id) return &attr.value;
  203de0:	48 83 38 03          	cmp    QWORD PTR [rax],0x3
  203de4:	74 12                	je     203df8 <dumpCurrentStackTrace+0xa68>
        for (self.attrs.toSliceConst()) |*attr| {
  203de6:	48 83 c2 01          	add    rdx,0x1
  203dea:	48 83 c0 28          	add    rax,0x28
  203dee:	48 39 ca             	cmp    rdx,rcx
  203df1:	72 ed                	jb     203de0 <dumpCurrentStackTrace+0xa50>
  203df3:	e9 57 0b 00 00       	jmp    20494f <dumpCurrentStackTrace+0x15bf>
  203df8:	8a 50 20             	mov    dl,BYTE PTR [rax+0x20]
  203dfb:	80 fa 0a             	cmp    dl,0xa
        return switch (form_value.*) {
  203dfe:	74 2f                	je     203e2f <dumpCurrentStackTrace+0xa9f>
  203e00:	48 8d 0d b1 d4 ff ff 	lea    rcx,[rip+0xffffffffffffd4b1]        # 2012b8 <__unnamed_15>
  203e07:	80 fa 09             	cmp    dl,0x9
  203e0a:	0f 85 a4 00 00 00    	jne    203eb4 <dumpCurrentStackTrace+0xb24>
            FormValue.String => |value| value,
  203e10:	66 c7 44 24 10 00 00 	mov    WORD PTR [rsp+0x10],0x0
  203e17:	c5 fa 6f 40 08       	vmovdqu xmm0,XMMWORD PTR [rax+0x8]
  203e1c:	48 8d 44 24 18       	lea    rax,[rsp+0x18]
  203e21:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
        return switch (form_value.*) {
  203e25:	48 8d 4c 24 10       	lea    rcx,[rsp+0x10]
  203e2a:	e9 85 00 00 00       	jmp    203eb4 <dumpCurrentStackTrace+0xb24>
            FormValue.StrPtr => |offset| getString(st, offset),
  203e2f:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
  203e33:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
    const pos = st.debug_str.offset + offset;
  203e38:	48 8b 41 70          	mov    rax,QWORD PTR [rcx+0x70]
  203e3c:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  203e40:	78 45                	js     203e87 <dumpCurrentStackTrace+0xaf7>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  203e42:	48 63 39             	movsxd rdi,DWORD PTR [rcx]
  203e45:	b8 08 00 00 00       	mov    eax,0x8
  203e4a:	31 d2                	xor    edx,edx
  203e4c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  203e4e:	48 89 c1             	mov    rcx,rax
  203e51:	48 f7 d9             	neg    rcx
  203e54:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  203e5a:	b8 00 00 00 00       	mov    eax,0x0
  203e5f:	48 0f 46 c8          	cmovbe rcx,rax
  203e63:	66 b8 05 00          	mov    ax,0x5
  203e67:	48 83 f9 1d          	cmp    rcx,0x1d
  203e6b:	0f 87 a2 09 00 00    	ja     204813 <dumpCurrentStackTrace+0x1483>
  203e71:	48 8d 15 d8 c3 ff ff 	lea    rdx,[rip+0xffffffffffffc3d8]        # 200250 <__unnamed_128+0x8>
  203e78:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  203e7c:	48 01 d1             	add    rcx,rdx
  203e7f:	ff e1                	jmp    rcx
  203e81:	66 b8 20 00          	mov    ax,0x20
  203e85:	eb 04                	jmp    203e8b <dumpCurrentStackTrace+0xafb>
  203e87:	66 b8 21 00          	mov    ax,0x21
    try st.self_exe_file.seekTo(pos);
  203e8b:	66 89 44 24 30       	mov    WORD PTR [rsp+0x30],ax
  203e90:	48 8b 84 24 d6 00 00 	mov    rax,QWORD PTR [rsp+0xd6]
  203e97:	00 
  203e98:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  203e9d:	48 89 41 d1          	mov    QWORD PTR [rcx-0x2f],rax
  203ea1:	c5 fa 6f 84 24 c8 00 	vmovdqu xmm0,XMMWORD PTR [rsp+0xc8]
  203ea8:	00 00 
  203eaa:	c5 fa 7f 41 c3       	vmovdqu XMMWORD PTR [rcx-0x3d],xmm0
        return switch (form_value.*) {
  203eaf:	48 8d 4c 24 30       	lea    rcx,[rsp+0x30]
  203eb4:	44 0f b7 39          	movzx  r15d,WORD PTR [rcx]
  203eb8:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
  203ebc:	48 89 84 24 4e 01 00 	mov    QWORD PTR [rsp+0x14e],rax
  203ec3:	00 
  203ec4:	c5 fa 6f 41 02       	vmovdqu xmm0,XMMWORD PTR [rcx+0x2]
  203ec9:	c5 f9 7f 84 24 40 01 	vmovdqa XMMWORD PTR [rsp+0x140],xmm0
  203ed0:	00 00 
            const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  203ed2:	66 45 85 ff          	test   r15w,r15w
  203ed6:	0f 85 98 0a 00 00    	jne    204974 <dumpCurrentStackTrace+0x15e4>
  203edc:	48 8d 84 24 46 01 00 	lea    rax,[rsp+0x146]
  203ee3:	00 
  203ee4:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  203ee8:	c5 f9 7f 84 24 20 01 	vmovdqa XMMWORD PTR [rsp+0x120],xmm0
  203eef:	00 00 
            if (getLineNumberInfo(debug_info, compile_unit, address - 1)) |line_info| {
  203ef1:	49 8d 4d ff          	lea    rcx,[r13-0x1]
  203ef5:	48 8d bc 24 58 01 00 	lea    rdi,[rsp+0x158]
  203efc:	00 
  203efd:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  203f02:	4c 89 ca             	mov    rdx,r9
  203f05:	c5 f8 77             	vzeroupper 
  203f08:	e8 c3 99 00 00       	call   20d8d0 <getLineNumberInfo>
  203f0d:	44 0f b7 bc 24 58 01 	movzx  r15d,WORD PTR [rsp+0x158]
  203f14:	00 00 
  203f16:	66 45 85 ff          	test   r15w,r15w
  203f1a:	74 77                	je     203f93 <dumpCurrentStackTrace+0xc03>
            } else |err| switch (err) {
  203f1c:	44 89 f8             	mov    eax,r15d
  203f1f:	25 fe ff 00 00       	and    eax,0xfffe
  203f24:	83 f8 22             	cmp    eax,0x22
  203f27:	0f 85 47 0a 00 00    	jne    204974 <dumpCurrentStackTrace+0x15e4>
  203f2d:	4d 8b 34 24          	mov    r14,QWORD PTR [r12]
                        try output(context, fmt[start_index..i]);
  203f31:	4c 89 e7             	mov    rdi,r12
  203f34:	48 8d 35 35 05 01 00 	lea    rsi,[rip+0x10535]        # 214470 <__unnamed_16>
  203f3b:	41 ff d6             	call   r14
  203f3e:	41 89 c7             	mov    r15d,eax
  203f41:	66 45 85 ff          	test   r15w,r15w
  203f45:	0f 85 15 fe ff ff    	jne    203d60 <dumpCurrentStackTrace+0x9d0>
    var buf: [max_int_digits - 1]u8 = undefined;
  203f4b:	c5 fc 10 05 cc e5 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe5cc]        # 20251f <__unnamed_2+0x1f>
  203f52:	ff 
  203f53:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  203f59:	c5 fe 6f 05 9f e5 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe59f]        # 202500 <__unnamed_2>
  203f60:	ff 
  203f61:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  203f67:	44 89 e8             	mov    eax,r13d
  203f6a:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  203f6c:	b1 30                	mov    cl,0x30
  203f6e:	3c 0a                	cmp    al,0xa
  203f70:	72 02                	jb     203f74 <dumpCurrentStackTrace+0xbe4>
  203f72:	b1 57                	mov    cl,0x57
  203f74:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  203f76:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  203f7a:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  203f7f:	49 83 fd 10          	cmp    r13,0x10
  203f83:	0f 83 b8 04 00 00    	jae    204441 <dumpCurrentStackTrace+0x10b1>
  203f89:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  203f8e:	e9 ed 04 00 00       	jmp    204480 <dumpCurrentStackTrace+0x10f0>
  203f93:	48 8d 84 24 60 01 00 	lea    rax,[rsp+0x160]
  203f9a:	00 
            if (getLineNumberInfo(debug_info, compile_unit, address - 1)) |line_info| {
  203f9b:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  203f9f:	c5 fe 7f 84 24 80 00 	vmovdqu YMMWORD PTR [rsp+0x80],ymm0
  203fa6:	00 00 
  203fa8:	48 8b 40 20          	mov    rax,QWORD PTR [rax+0x20]
  203fac:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  203fb3:	00 
  203fb4:	4c 89 e3             	mov    rbx,r12
  203fb7:	4c 8b a4 24 80 00 00 	mov    r12,QWORD PTR [rsp+0x80]
  203fbe:	00 
  203fbf:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  203fc6:	00 
  203fc7:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  203fcc:	4c 8b 33             	mov    r14,QWORD PTR [rbx]
                if (tty_color) {
  203fcf:	80 7c 24 0f 00       	cmp    BYTE PTR [rsp+0xf],0x0
  203fd4:	0f 84 cb 01 00 00    	je     2041a5 <dumpCurrentStackTrace+0xe15>
                        try output(context, fmt[start_index..i]);
  203fda:	48 89 df             	mov    rdi,rbx
  203fdd:	48 8d 35 dc 03 01 00 	lea    rsi,[rip+0x103dc]        # 2143c0 <__unnamed_17>
  203fe4:	c5 f8 77             	vzeroupper 
  203fe7:	41 ff d6             	call   r14
  203fea:	41 89 c7             	mov    r15d,eax
  203fed:	66 45 85 ff          	test   r15w,r15w
  203ff1:	0f 85 dc 09 00 00    	jne    2049d3 <dumpCurrentStackTrace+0x1643>
                const casted_value = ([]const u8)(value);
  203ff7:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  203ffe:	00 
  203fff:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  204003:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  204009:	48 89 df             	mov    rdi,rbx
  20400c:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  204011:	41 ff d6             	call   r14
  204014:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  204017:	66 45 85 ff          	test   r15w,r15w
  20401b:	0f 85 b2 09 00 00    	jne    2049d3 <dumpCurrentStackTrace+0x1643>
                        try output(context, fmt[start_index..i]);
  204021:	48 89 df             	mov    rdi,rbx
  204024:	48 8d 35 a5 03 01 00 	lea    rsi,[rip+0x103a5]        # 2143d0 <__unnamed_18>
  20402b:	41 ff d6             	call   r14
  20402e:	41 89 c7             	mov    r15d,eax
  204031:	66 45 85 ff          	test   r15w,r15w
  204035:	0f 85 c1 09 00 00    	jne    2049fc <dumpCurrentStackTrace+0x166c>
    var buf: [max_int_digits - 1]u8 = undefined;
  20403b:	c5 fc 10 05 dc e4 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe4dc]        # 20251f <__unnamed_2+0x1f>
  204042:	ff 
  204043:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  204049:	c5 fe 6f 05 af e4 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe4af]        # 202500 <__unnamed_2>
  204050:	ff 
  204051:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        const digit = a % base;
  204057:	4c 89 e2             	mov    rdx,r12
  20405a:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  204061:	cc cc cc 
  204064:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  204069:	c1 e9 02             	shr    ecx,0x2
  20406c:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  204072:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  204075:	44 89 e0             	mov    eax,r12d
  204078:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20407a:	b1 30                	mov    cl,0x30
  20407c:	3c 0a                	cmp    al,0xa
  20407e:	72 02                	jb     204082 <dumpCurrentStackTrace+0xcf2>
  204080:	b1 57                	mov    cl,0x57
  204082:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  204084:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  204088:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20408d:	49 83 fc 0a          	cmp    r12,0xa
  204091:	73 0d                	jae    2040a0 <dumpCurrentStackTrace+0xd10>
  204093:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  204098:	eb 58                	jmp    2040f2 <dumpCurrentStackTrace+0xd62>
  20409a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        a /= base;
  2040a0:	4c 89 e2             	mov    rdx,r12
  2040a3:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  2040aa:	cc cc cc 
  2040ad:	48 89 ce             	mov    rsi,rcx
  2040b0:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  2040b5:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  2040b9:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  2040be:	c1 ee 02             	shr    esi,0x2
  2040c1:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  2040c7:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  2040ca:	89 d1                	mov    ecx,edx
  2040cc:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  2040ce:	b3 30                	mov    bl,0x30
  2040d0:	80 f9 0a             	cmp    cl,0xa
  2040d3:	72 02                	jb     2040d7 <dumpCurrentStackTrace+0xd47>
  2040d5:	b3 57                	mov    bl,0x57
  2040d7:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2040d9:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  2040dd:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2040e1:	49 83 fc 63          	cmp    r12,0x63
  2040e5:	49 89 d4             	mov    r12,rdx
  2040e8:	77 b6                	ja     2040a0 <dumpCurrentStackTrace+0xd10>
        const padded_buf = buf[index - padding ..];
  2040ea:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  2040ee:	48 83 c1 2f          	add    rcx,0x2f
  2040f2:	ba 41 00 00 00       	mov    edx,0x41
  2040f7:	48 29 c2             	sub    rdx,rax
  2040fa:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  2040ff:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  204104:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        return output(context, padded_buf);
  204109:	4c 89 e7             	mov    rdi,r12
  20410c:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  204111:	c5 f8 77             	vzeroupper 
  204114:	41 ff d6             	call   r14
  204117:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20411a:	66 45 85 ff          	test   r15w,r15w
  20411e:	0f 85 dd 08 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  204124:	4c 89 e7             	mov    rdi,r12
  204127:	48 8d 35 b2 02 01 00 	lea    rsi,[rip+0x102b2]        # 2143e0 <__unnamed_19>
  20412e:	41 ff d6             	call   r14
  204131:	41 89 c7             	mov    r15d,eax
  204134:	66 45 85 ff          	test   r15w,r15w
  204138:	0f 85 c3 08 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
    var buf: [max_int_digits - 1]u8 = undefined;
  20413e:	c5 fc 10 05 d9 e3 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe3d9]        # 20251f <__unnamed_2+0x1f>
  204145:	ff 
  204146:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20414c:	c5 fe 6f 05 ac e3 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe3ac]        # 202500 <__unnamed_2>
  204153:	ff 
  204154:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
  20415a:	48 8b 54 24 78       	mov    rdx,QWORD PTR [rsp+0x78]
        const digit = a % base;
  20415f:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  204166:	cc cc cc 
  204169:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  20416e:	c1 e9 02             	shr    ecx,0x2
  204171:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  204177:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20417a:	89 d0                	mov    eax,edx
  20417c:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20417e:	b1 30                	mov    cl,0x30
  204180:	3c 0a                	cmp    al,0xa
  204182:	72 02                	jb     204186 <dumpCurrentStackTrace+0xdf6>
  204184:	b1 57                	mov    cl,0x57
  204186:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  204188:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20418c:	b9 40 00 00 00       	mov    ecx,0x40
        if (a == 0) break;
  204191:	48 83 fa 0a          	cmp    rdx,0xa
  204195:	0f 83 62 03 00 00    	jae    2044fd <dumpCurrentStackTrace+0x116d>
  20419b:	48 8d 44 24 6f       	lea    rax,[rsp+0x6f]
  2041a0:	e9 af 03 00 00       	jmp    204554 <dumpCurrentStackTrace+0x11c4>
                const casted_value = ([]const u8)(value);
  2041a5:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  2041ac:	00 
  2041ad:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2041b1:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  2041b7:	48 89 df             	mov    rdi,rbx
  2041ba:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2041bf:	c5 f8 77             	vzeroupper 
  2041c2:	41 ff d6             	call   r14
  2041c5:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2041c8:	66 45 85 ff          	test   r15w,r15w
  2041cc:	0f 85 01 08 00 00    	jne    2049d3 <dumpCurrentStackTrace+0x1643>
                        try output(context, fmt[start_index..i]);
  2041d2:	48 89 df             	mov    rdi,rbx
  2041d5:	48 8d 35 44 02 01 00 	lea    rsi,[rip+0x10244]        # 214420 <__unnamed_20>
  2041dc:	41 ff d6             	call   r14
  2041df:	41 89 c7             	mov    r15d,eax
  2041e2:	66 45 85 ff          	test   r15w,r15w
  2041e6:	0f 85 f9 07 00 00    	jne    2049e5 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  2041ec:	c5 fc 10 05 2b e3 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe32b]        # 20251f <__unnamed_2+0x1f>
  2041f3:	ff 
  2041f4:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  2041fa:	c5 fe 6f 05 fe e2 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe2fe]        # 202500 <__unnamed_2>
  204201:	ff 
  204202:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        const digit = a % base;
  204208:	4c 89 e2             	mov    rdx,r12
  20420b:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  204212:	cc cc cc 
  204215:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  20421a:	c1 e9 02             	shr    ecx,0x2
  20421d:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  204223:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  204226:	44 89 e0             	mov    eax,r12d
  204229:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20422b:	b1 30                	mov    cl,0x30
  20422d:	3c 0a                	cmp    al,0xa
  20422f:	72 02                	jb     204233 <dumpCurrentStackTrace+0xea3>
  204231:	b1 57                	mov    cl,0x57
  204233:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  204235:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  204239:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20423e:	49 83 fc 0a          	cmp    r12,0xa
  204242:	73 0c                	jae    204250 <dumpCurrentStackTrace+0xec0>
  204244:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  204249:	eb 57                	jmp    2042a2 <dumpCurrentStackTrace+0xf12>
  20424b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        a /= base;
  204250:	4c 89 e2             	mov    rdx,r12
  204253:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  20425a:	cc cc cc 
  20425d:	48 89 ce             	mov    rsi,rcx
  204260:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  204265:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  204269:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  20426e:	c1 ee 02             	shr    esi,0x2
  204271:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  204277:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  20427a:	89 d1                	mov    ecx,edx
  20427c:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  20427e:	b3 30                	mov    bl,0x30
  204280:	80 f9 0a             	cmp    cl,0xa
  204283:	72 02                	jb     204287 <dumpCurrentStackTrace+0xef7>
  204285:	b3 57                	mov    bl,0x57
  204287:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  204289:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20428d:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  204291:	49 83 fc 63          	cmp    r12,0x63
  204295:	49 89 d4             	mov    r12,rdx
  204298:	77 b6                	ja     204250 <dumpCurrentStackTrace+0xec0>
        const padded_buf = buf[index - padding ..];
  20429a:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20429e:	48 83 c1 2f          	add    rcx,0x2f
  2042a2:	ba 41 00 00 00       	mov    edx,0x41
  2042a7:	48 29 c2             	sub    rdx,rax
  2042aa:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  2042af:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  2042b4:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        return output(context, padded_buf);
  2042b9:	4c 89 e7             	mov    rdi,r12
  2042bc:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  2042c1:	c5 f8 77             	vzeroupper 
  2042c4:	41 ff d6             	call   r14
  2042c7:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2042ca:	66 45 85 ff          	test   r15w,r15w
  2042ce:	0f 85 2d 07 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  2042d4:	4c 89 e7             	mov    rdi,r12
  2042d7:	48 8d 35 52 01 01 00 	lea    rsi,[rip+0x10152]        # 214430 <__unnamed_21>
  2042de:	41 ff d6             	call   r14
  2042e1:	41 89 c7             	mov    r15d,eax
  2042e4:	66 45 85 ff          	test   r15w,r15w
  2042e8:	0f 85 13 07 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
    var buf: [max_int_digits - 1]u8 = undefined;
  2042ee:	c5 fc 10 05 29 e2 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe229]        # 20251f <__unnamed_2+0x1f>
  2042f5:	ff 
  2042f6:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  2042fc:	c5 fe 6f 05 fc e1 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe1fc]        # 202500 <__unnamed_2>
  204303:	ff 
  204304:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
  20430a:	48 8b 7c 24 78       	mov    rdi,QWORD PTR [rsp+0x78]
        const digit = a % base;
  20430f:	48 89 fa             	mov    rdx,rdi
  204312:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  204319:	cc cc cc 
  20431c:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  204321:	c1 e9 02             	shr    ecx,0x2
  204324:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20432a:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20432d:	89 f8                	mov    eax,edi
  20432f:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  204331:	b1 30                	mov    cl,0x30
  204333:	3c 0a                	cmp    al,0xa
  204335:	72 02                	jb     204339 <dumpCurrentStackTrace+0xfa9>
  204337:	b1 57                	mov    cl,0x57
  204339:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20433b:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20433f:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  204344:	48 83 ff 0a          	cmp    rdi,0xa
  204348:	73 16                	jae    204360 <dumpCurrentStackTrace+0xfd0>
  20434a:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20434f:	eb 61                	jmp    2043b2 <dumpCurrentStackTrace+0x1022>
  204351:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  204358:	0f 1f 84 00 00 00 00 
  20435f:	00 
        a /= base;
  204360:	48 89 fa             	mov    rdx,rdi
  204363:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  20436a:	cc cc cc 
  20436d:	48 89 ce             	mov    rsi,rcx
  204370:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  204375:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  204379:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  20437e:	c1 ee 02             	shr    esi,0x2
  204381:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  204387:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  20438a:	89 d1                	mov    ecx,edx
  20438c:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  20438e:	b3 30                	mov    bl,0x30
  204390:	80 f9 0a             	cmp    cl,0xa
  204393:	72 02                	jb     204397 <dumpCurrentStackTrace+0x1007>
  204395:	b3 57                	mov    bl,0x57
  204397:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  204399:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20439d:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2043a1:	48 83 ff 63          	cmp    rdi,0x63
  2043a5:	48 89 d7             	mov    rdi,rdx
  2043a8:	77 b6                	ja     204360 <dumpCurrentStackTrace+0xfd0>
        const padded_buf = buf[index - padding ..];
  2043aa:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  2043ae:	48 83 c1 2f          	add    rcx,0x2f
  2043b2:	ba 41 00 00 00       	mov    edx,0x41
  2043b7:	48 29 c2             	sub    rdx,rax
  2043ba:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  2043bf:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  2043c4:	4c 89 e7             	mov    rdi,r12
  2043c7:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  2043cc:	c5 f8 77             	vzeroupper 
  2043cf:	41 ff d6             	call   r14
  2043d2:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2043d5:	66 45 85 ff          	test   r15w,r15w
  2043d9:	0f 85 22 06 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  2043df:	4c 89 e7             	mov    rdi,r12
  2043e2:	48 8d 35 57 00 01 00 	lea    rsi,[rip+0x10057]        # 214440 <__unnamed_22>
  2043e9:	41 ff d6             	call   r14
  2043ec:	41 89 c7             	mov    r15d,eax
  2043ef:	66 45 85 ff          	test   r15w,r15w
  2043f3:	0f 85 08 06 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
    var buf: [max_int_digits - 1]u8 = undefined;
  2043f9:	c5 fc 10 05 1e e1 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffe11e]        # 20251f <__unnamed_2+0x1f>
  204400:	ff 
  204401:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  204407:	c5 fe 6f 05 f1 e0 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffe0f1]        # 202500 <__unnamed_2>
  20440e:	ff 
  20440f:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  204415:	44 89 e8             	mov    eax,r13d
  204418:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  20441a:	b1 30                	mov    cl,0x30
  20441c:	3c 0a                	cmp    al,0xa
  20441e:	72 02                	jb     204422 <dumpCurrentStackTrace+0x1092>
  204420:	b1 57                	mov    cl,0x57
  204422:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  204424:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  204428:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20442d:	49 83 fd 10          	cmp    r13,0x10
  204431:	0f 83 ac 01 00 00    	jae    2045e3 <dumpCurrentStackTrace+0x1253>
  204437:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20443c:	e9 df 01 00 00       	jmp    204620 <dumpCurrentStackTrace+0x1290>
        a /= base;
  204441:	4c 89 e9             	mov    rcx,r13
  204444:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20444b:	00 00 00 00 00 
  204450:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  204454:	89 ca                	mov    edx,ecx
  204456:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  204459:	b3 30                	mov    bl,0x30
  20445b:	80 fa 0a             	cmp    dl,0xa
  20445e:	72 02                	jb     204462 <dumpCurrentStackTrace+0x10d2>
  204460:	b3 57                	mov    bl,0x57
  204462:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  204464:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  204468:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20446c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  204473:	49 89 cd             	mov    r13,rcx
  204476:	77 d8                	ja     204450 <dumpCurrentStackTrace+0x10c0>
        const padded_buf = buf[index - padding ..];
  204478:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20447c:	48 83 c1 2f          	add    rcx,0x2f
  204480:	ba 41 00 00 00       	mov    edx,0x41
  204485:	48 29 c2             	sub    rdx,rax
  204488:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20448d:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  204492:	4c 89 e7             	mov    rdi,r12
  204495:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20449a:	c5 f8 77             	vzeroupper 
  20449d:	41 ff d6             	call   r14
  2044a0:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2044a3:	66 45 85 ff          	test   r15w,r15w
  2044a7:	0f 85 b3 f8 ff ff    	jne    203d60 <dumpCurrentStackTrace+0x9d0>
                        try output(context, fmt[start_index..i]);
  2044ad:	4c 89 e7             	mov    rdi,r12
  2044b0:	48 8d 35 c9 ff 00 00 	lea    rsi,[rip+0xffc9]        # 214480 <__unnamed_23>
  2044b7:	41 ff d6             	call   r14
  2044ba:	41 89 c7             	mov    r15d,eax
  2044bd:	66 45 85 ff          	test   r15w,r15w
  2044c1:	0f 85 99 f8 ff ff    	jne    203d60 <dumpCurrentStackTrace+0x9d0>
                const casted_value = ([]const u8)(value);
  2044c7:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  2044ce:	00 00 
  2044d0:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  2044d6:	4c 89 e7             	mov    rdi,r12
  2044d9:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2044de:	41 ff d6             	call   r14
  2044e1:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2044e4:	66 45 85 ff          	test   r15w,r15w
  2044e8:	0f 85 72 f8 ff ff    	jne    203d60 <dumpCurrentStackTrace+0x9d0>
        try output(context, fmt[start_index..]);
  2044ee:	4c 89 e7             	mov    rdi,r12
  2044f1:	48 8d 35 98 ff 00 00 	lea    rsi,[rip+0xff98]        # 214490 <__unnamed_24>
  2044f8:	e9 56 f8 ff ff       	jmp    203d53 <dumpCurrentStackTrace+0x9c3>
  2044fd:	48 89 d0             	mov    rax,rdx
        a /= base;
  204500:	48 89 c2             	mov    rdx,rax
  204503:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  20450a:	cc cc cc 
  20450d:	48 89 f7             	mov    rdi,rsi
  204510:	c4 e2 cb f6 d7       	mulx   rdx,rsi,rdi
  204515:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  204519:	c4 e2 cb f6 ff       	mulx   rdi,rsi,rdi
  20451e:	c1 ef 02             	shr    edi,0x2
  204521:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  204527:	8d 3c bf             	lea    edi,[rdi+rdi*4]
  20452a:	89 d6                	mov    esi,edx
  20452c:	29 fe                	sub    esi,edi
        0...9 => digit + '0',
  20452e:	b3 30                	mov    bl,0x30
  204530:	40 80 fe 0a          	cmp    sil,0xa
  204534:	72 02                	jb     204538 <dumpCurrentStackTrace+0x11a8>
  204536:	b3 57                	mov    bl,0x57
  204538:	40 00 f3             	add    bl,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20453b:	88 5c 0c 2e          	mov    BYTE PTR [rsp+rcx*1+0x2e],bl
        if (a == 0) break;
  20453f:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  204543:	48 83 f8 63          	cmp    rax,0x63
  204547:	48 89 d0             	mov    rax,rdx
  20454a:	77 b4                	ja     204500 <dumpCurrentStackTrace+0x1170>
        const padded_buf = buf[index - padding ..];
  20454c:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  204550:	48 83 c0 2f          	add    rax,0x2f
  204554:	ba 41 00 00 00       	mov    edx,0x41
  204559:	48 29 ca             	sub    rdx,rcx
  20455c:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  204561:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  204566:	4c 89 e7             	mov    rdi,r12
  204569:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20456e:	c5 f8 77             	vzeroupper 
  204571:	41 ff d6             	call   r14
  204574:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  204577:	66 45 85 ff          	test   r15w,r15w
  20457b:	0f 85 80 04 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  204581:	4c 89 e7             	mov    rdi,r12
  204584:	48 8d 35 65 fe 00 00 	lea    rsi,[rip+0xfe65]        # 2143f0 <__unnamed_25>
  20458b:	41 ff d6             	call   r14
  20458e:	41 89 c7             	mov    r15d,eax
  204591:	66 45 85 ff          	test   r15w,r15w
  204595:	0f 85 66 04 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
    var buf: [max_int_digits - 1]u8 = undefined;
  20459b:	c5 fc 10 05 7c df ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffdf7c]        # 20251f <__unnamed_2+0x1f>
  2045a2:	ff 
  2045a3:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  2045a9:	c5 fe 6f 05 4f df ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffdf4f]        # 202500 <__unnamed_2>
  2045b0:	ff 
  2045b1:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2045b7:	44 89 e8             	mov    eax,r13d
  2045ba:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  2045bc:	b1 30                	mov    cl,0x30
  2045be:	3c 0a                	cmp    al,0xa
  2045c0:	72 02                	jb     2045c4 <dumpCurrentStackTrace+0x1234>
  2045c2:	b1 57                	mov    cl,0x57
  2045c4:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2045c6:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  2045ca:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  2045cf:	49 83 fd 10          	cmp    r13,0x10
  2045d3:	0f 83 d4 00 00 00    	jae    2046ad <dumpCurrentStackTrace+0x131d>
  2045d9:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  2045de:	e9 fd 00 00 00       	jmp    2046e0 <dumpCurrentStackTrace+0x1350>
        a /= base;
  2045e3:	4c 89 e9             	mov    rcx,r13
  2045e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2045ed:	00 00 00 
  2045f0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2045f4:	89 ca                	mov    edx,ecx
  2045f6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  2045f9:	b3 30                	mov    bl,0x30
  2045fb:	80 fa 0a             	cmp    dl,0xa
  2045fe:	72 02                	jb     204602 <dumpCurrentStackTrace+0x1272>
  204600:	b3 57                	mov    bl,0x57
  204602:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  204604:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  204608:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20460c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  204613:	49 89 cd             	mov    r13,rcx
  204616:	77 d8                	ja     2045f0 <dumpCurrentStackTrace+0x1260>
        const padded_buf = buf[index - padding ..];
  204618:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20461c:	48 83 c1 2f          	add    rcx,0x2f
  204620:	ba 41 00 00 00       	mov    edx,0x41
  204625:	48 29 c2             	sub    rdx,rax
  204628:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20462d:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  204632:	4c 89 e7             	mov    rdi,r12
  204635:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20463a:	c5 f8 77             	vzeroupper 
  20463d:	41 ff d6             	call   r14
  204640:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  204643:	66 45 85 ff          	test   r15w,r15w
  204647:	0f 85 b4 03 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20464d:	4c 89 e7             	mov    rdi,r12
  204650:	48 8d 35 f9 fd 00 00 	lea    rsi,[rip+0xfdf9]        # 214450 <__unnamed_26>
  204657:	41 ff d6             	call   r14
  20465a:	41 89 c7             	mov    r15d,eax
  20465d:	66 45 85 ff          	test   r15w,r15w
  204661:	0f 85 9a 03 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
                const casted_value = ([]const u8)(value);
  204667:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  20466e:	00 00 
  204670:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  204676:	4c 89 e7             	mov    rdi,r12
  204679:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20467e:	41 ff d6             	call   r14
  204681:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  204684:	66 45 85 ff          	test   r15w,r15w
  204688:	0f 85 73 03 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
        try output(context, fmt[start_index..]);
  20468e:	4c 89 e7             	mov    rdi,r12
  204691:	48 8d 35 c8 fd 00 00 	lea    rsi,[rip+0xfdc8]        # 214460 <__unnamed_27>
  204698:	41 ff d6             	call   r14
  20469b:	41 89 c7             	mov    r15d,eax
                    try out_stream.print(
  20469e:	66 45 85 ff          	test   r15w,r15w
  2046a2:	0f 84 3e 02 00 00    	je     2048e6 <dumpCurrentStackTrace+0x1556>
  2046a8:	e9 54 03 00 00       	jmp    204a01 <dumpCurrentStackTrace+0x1671>
        a /= base;
  2046ad:	4c 89 e9             	mov    rcx,r13
  2046b0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2046b4:	89 ca                	mov    edx,ecx
  2046b6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  2046b9:	b3 30                	mov    bl,0x30
  2046bb:	80 fa 0a             	cmp    dl,0xa
  2046be:	72 02                	jb     2046c2 <dumpCurrentStackTrace+0x1332>
  2046c0:	b3 57                	mov    bl,0x57
  2046c2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2046c4:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  2046c8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2046cc:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  2046d3:	49 89 cd             	mov    r13,rcx
  2046d6:	77 d8                	ja     2046b0 <dumpCurrentStackTrace+0x1320>
        const padded_buf = buf[index - padding ..];
  2046d8:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  2046dc:	48 83 c1 2f          	add    rcx,0x2f
  2046e0:	ba 41 00 00 00       	mov    edx,0x41
  2046e5:	48 29 c2             	sub    rdx,rax
  2046e8:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  2046ed:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  2046f2:	4c 89 e7             	mov    rdi,r12
  2046f5:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  2046fa:	c5 f8 77             	vzeroupper 
  2046fd:	41 ff d6             	call   r14
  204700:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  204703:	66 45 85 ff          	test   r15w,r15w
  204707:	0f 85 f4 02 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20470d:	4c 89 e7             	mov    rdi,r12
  204710:	48 8d 35 e9 fc 00 00 	lea    rsi,[rip+0xfce9]        # 214400 <__unnamed_28>
  204717:	41 ff d6             	call   r14
  20471a:	41 89 c7             	mov    r15d,eax
  20471d:	66 45 85 ff          	test   r15w,r15w
  204721:	0f 85 da 02 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
                const casted_value = ([]const u8)(value);
  204727:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  20472e:	00 00 
  204730:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  204736:	4c 89 e7             	mov    rdi,r12
  204739:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20473e:	41 ff d6             	call   r14
  204741:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  204744:	66 45 85 ff          	test   r15w,r15w
  204748:	0f 85 b3 02 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
        try output(context, fmt[start_index..]);
  20474e:	4c 89 e7             	mov    rdi,r12
  204751:	48 8d 35 b8 fc 00 00 	lea    rsi,[rip+0xfcb8]        # 214410 <__unnamed_29>
  204758:	41 ff d6             	call   r14
  20475b:	41 89 c7             	mov    r15d,eax
                    try out_stream.print(
  20475e:	66 45 85 ff          	test   r15w,r15w
  204762:	0f 85 99 02 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
  204768:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20476d:	48 8b b8 a0 00 00 00 	mov    rdi,QWORD PTR [rax+0xa0]
                    if (printLineFromFile(debug_info.allocator(), out_stream, line_info)) {
  204774:	4c 89 e6             	mov    rsi,r12
  204777:	48 8d 94 24 80 00 00 	lea    rdx,[rsp+0x80]
  20477e:	00 
  20477f:	e8 7c b1 00 00       	call   20f900 <printLineFromFile>
  204784:	41 89 c7             	mov    r15d,eax
  204787:	41 0f b7 c7          	movzx  eax,r15w
  20478b:	83 f8 24             	cmp    eax,0x24
  20478e:	0f 84 52 01 00 00    	je     2048e6 <dumpCurrentStackTrace+0x1556>
  204794:	66 45 85 ff          	test   r15w,r15w
  204798:	0f 85 84 00 00 00    	jne    204822 <dumpCurrentStackTrace+0x1492>
  20479e:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
                        if (line_info.column == 0) {
  2047a3:	48 85 c0             	test   rax,rax
  2047a6:	0f 84 1f 01 00 00    	je     2048cb <dumpCurrentStackTrace+0x153b>
  2047ac:	48 83 f8 01          	cmp    rax,0x1
  2047b0:	74 41                	je     2047f3 <dumpCurrentStackTrace+0x1463>
  2047b2:	bb 01 00 00 00       	mov    ebx,0x1
  2047b7:	c6 44 24 10 20       	mov    BYTE PTR [rsp+0x10],0x20
        pub fn write(self: *Self, bytes: []const u8) !void {
            return self.writeFn(self, bytes);
        }

        pub fn writeByte(self: *Self, byte: u8) !void {
            const slice = (*[1]u8)(&byte)[0..];
  2047bc:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  2047c1:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  2047c6:	48 c7 44 24 38 01 00 	mov    QWORD PTR [rsp+0x38],0x1
  2047cd:	00 00 
            return self.writeFn(self, slice);
  2047cf:	4c 89 e7             	mov    rdi,r12
  2047d2:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2047d7:	41 ff 14 24          	call   QWORD PTR [r12]
  2047db:	41 89 c7             	mov    r15d,eax
                                    try out_stream.writeByte(' ');
  2047de:	66 45 85 ff          	test   r15w,r15w
  2047e2:	0f 85 19 02 00 00    	jne    204a01 <dumpCurrentStackTrace+0x1671>
  2047e8:	48 83 c3 01          	add    rbx,0x1
                                while (col_i < line_info.column) : (col_i += 1) {
  2047ec:	48 3b 5c 24 78       	cmp    rbx,QWORD PTR [rsp+0x78]
  2047f1:	72 c4                	jb     2047b7 <dumpCurrentStackTrace+0x1427>
            return self.writeFn(self, bytes);
  2047f3:	4c 89 e7             	mov    rdi,r12
  2047f6:	48 8d 35 73 fb 00 00 	lea    rsi,[rip+0xfb73]        # 214370 <__unnamed_30>
  2047fd:	41 ff 14 24          	call   QWORD PTR [r12]
  204801:	41 89 c7             	mov    r15d,eax
  204804:	66 45 85 ff          	test   r15w,r15w
  204808:	0f 84 d8 00 00 00    	je     2048e6 <dumpCurrentStackTrace+0x1556>
  20480e:	e9 29 02 00 00       	jmp    204a3c <dumpCurrentStackTrace+0x16ac>
  204813:	48 83 f9 4b          	cmp    rcx,0x4b
  204817:	0f 85 6e f6 ff ff    	jne    203e8b <dumpCurrentStackTrace+0xafb>
  20481d:	e9 5f f6 ff ff       	jmp    203e81 <dumpCurrentStackTrace+0xaf1>
        const bytes = @sliceToBytes(memory);
  204822:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  204829:	00 
        if (bytes.len == 0) return;
  20482a:	48 85 c0             	test   rax,rax
  20482d:	0f 84 2d f5 ff ff    	je     203d60 <dumpCurrentStackTrace+0x9d0>
  204833:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  20483a:	00 
        const bytes = @sliceToBytes(memory);
  20483b:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  204842:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  204843:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  204847:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  20484c:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  204851:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  204856:	ff d2                	call   rdx
  204858:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  20485f:	00 00 
  204861:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  204868:	00 00 
        try printSourceAtAddress(debug_info, out_stream, return_address, tty_color);
  20486a:	66 45 85 ff          	test   r15w,r15w
  20486e:	0f 84 08 f5 ff ff    	je     203d7c <dumpCurrentStackTrace+0x9ec>
  204874:	e9 fb 00 00 00       	jmp    204974 <dumpCurrentStackTrace+0x15e4>
  204879:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  20487e:	48 89 8c 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rcx
  204885:	00 
  204886:	48 8d 05 33 4e 00 00 	lea    rax,[rip+0x4e33]        # 2096c0 <FileInStream_readFn>
  20488d:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  204894:	00 
  204895:	48 8b b1 a0 00 00 00 	mov    rsi,QWORD PTR [rcx+0xa0]
  20489c:	4c 8d 74 24 30       	lea    r14,[rsp+0x30]
            return readStringRaw(self.allocator(), in_stream);
  2048a1:	4c 89 f7             	mov    rdi,r14
  2048a4:	48 8d 94 24 c0 00 00 	lea    rdx,[rsp+0xc0]
  2048ab:	00 
  2048ac:	4c 89 cb             	mov    rbx,r9
  2048af:	c5 f8 77             	vzeroupper 
  2048b2:	e8 c9 8b 00 00       	call   20d480 <readStringRaw>
  2048b7:	49 89 d9             	mov    r9,rbx
        return switch (form_value.*) {
  2048ba:	4c 89 f1             	mov    rcx,r14
  2048bd:	e9 f2 f5 ff ff       	jmp    203eb4 <dumpCurrentStackTrace+0xb24>
  2048c2:	66 b8 1c 00          	mov    ax,0x1c
  2048c6:	e9 c0 f5 ff ff       	jmp    203e8b <dumpCurrentStackTrace+0xafb>
  2048cb:	4c 89 e7             	mov    rdi,r12
  2048ce:	48 8d 35 8b fa 00 00 	lea    rsi,[rip+0xfa8b]        # 214360 <__unnamed_31>
  2048d5:	41 ff 14 24          	call   QWORD PTR [r12]
  2048d9:	41 89 c7             	mov    r15d,eax
  2048dc:	66 45 85 ff          	test   r15w,r15w
  2048e0:	0f 85 56 01 00 00    	jne    204a3c <dumpCurrentStackTrace+0x16ac>
        const bytes = @sliceToBytes(memory);
  2048e6:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  2048ed:	00 
        if (bytes.len == 0) return;
  2048ee:	48 85 c0             	test   rax,rax
  2048f1:	74 25                	je     204918 <dumpCurrentStackTrace+0x1588>
  2048f3:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  2048fa:	00 
        const bytes = @sliceToBytes(memory);
  2048fb:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  204902:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  204903:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  204907:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  20490c:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  204911:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  204916:	ff d2                	call   rdx
  204918:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  20491f:	00 
  204920:	48 8b 94 24 b0 00 00 	mov    rdx,QWORD PTR [rsp+0xb0]
  204927:	00 
  204928:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  20492f:	00 00 
  204931:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  204938:	00 00 
  20493a:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  20493f:	31 c0                	xor    eax,eax
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  204941:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  204944:	48 85 d2             	test   rdx,rdx
  204947:	0f 85 83 ed ff ff    	jne    2036d0 <dumpCurrentStackTrace+0x340>
  20494d:	eb 72                	jmp    2049c1 <dumpCurrentStackTrace+0x1631>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  20494f:	48 8b 05 5a c9 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffc95a]        # 2012b0 <__unnamed_32+0x10>
  204956:	48 89 84 24 4e 01 00 	mov    QWORD PTR [rsp+0x14e],rax
  20495d:	00 
  20495e:	c5 fa 6f 05 3c c9 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffc93c]        # 2012a2 <__unnamed_32+0x2>
  204965:	ff 
  204966:	c5 f9 7f 84 24 40 01 	vmovdqa XMMWORD PTR [rsp+0x140],xmm0
  20496d:	00 00 
  20496f:	66 41 bf 22 00       	mov    r15w,0x22
            return std.fmt.format(self, Error, self.writeFn, format, args);
  204974:	49 8b 1c 24          	mov    rbx,QWORD PTR [r12]
                        try output(context, fmt[start_index..i]);
  204978:	48 8d 35 21 fb 00 00 	lea    rsi,[rip+0xfb21]        # 2144a0 <__unnamed_33>
  20497f:	4c 89 e7             	mov    rdi,r12
  204982:	c5 f8 77             	vzeroupper 
  204985:	ff d3                	call   rbx
  204987:	66 85 c0             	test   ax,ax
  20498a:	75 35                	jne    2049c1 <dumpCurrentStackTrace+0x1631>
        stderr.print("Unable to dump stack trace: {}\n", @errorName(err)) catch return;
  20498c:	49 0f bf c7          	movsx  rax,r15w
  204990:	48 c1 e0 04          	shl    rax,0x4
  204994:	48 8d 0d 65 f6 00 00 	lea    rcx,[rip+0xf665]        # 214000 <raw+0xf68>
                const casted_value = ([]const u8)(value);
  20499b:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  2049a0:	c5 f8 29 44 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm0
  2049a6:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
                return output(context, casted_value);
  2049ab:	4c 89 e7             	mov    rdi,r12
  2049ae:	ff d3                	call   rbx
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2049b0:	66 85 c0             	test   ax,ax
  2049b3:	75 0c                	jne    2049c1 <dumpCurrentStackTrace+0x1631>
        try output(context, fmt[start_index..]);
  2049b5:	48 8d 35 f4 fa 00 00 	lea    rsi,[rip+0xfaf4]        # 2144b0 <__unnamed_34>
  2049bc:	4c 89 e7             	mov    rdi,r12
  2049bf:	ff d3                	call   rbx
    const stderr = getStderrStream() catch return;
  2049c1:	48 8d 65 d8          	lea    rsp,[rbp-0x28]
  2049c5:	5b                   	pop    rbx
  2049c6:	41 5c                	pop    r12
  2049c8:	41 5d                	pop    r13
  2049ca:	41 5e                	pop    r14
  2049cc:	41 5f                	pop    r15
  2049ce:	5d                   	pop    rbp
  2049cf:	c5 f8 77             	vzeroupper 
  2049d2:	c3                   	ret    
  2049d3:	49 89 dc             	mov    r12,rbx
        const bytes = @sliceToBytes(memory);
  2049d6:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  2049dd:	00 
        if (bytes.len == 0) return;
  2049de:	48 85 c0             	test   rax,rax
  2049e1:	75 2f                	jne    204a12 <dumpCurrentStackTrace+0x1682>
  2049e3:	eb 8f                	jmp    204974 <dumpCurrentStackTrace+0x15e4>
  2049e5:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        const bytes = @sliceToBytes(memory);
  2049ea:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  2049f1:	00 
        if (bytes.len == 0) return;
  2049f2:	48 85 c0             	test   rax,rax
  2049f5:	75 1b                	jne    204a12 <dumpCurrentStackTrace+0x1682>
  2049f7:	e9 78 ff ff ff       	jmp    204974 <dumpCurrentStackTrace+0x15e4>
  2049fc:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        const bytes = @sliceToBytes(memory);
  204a01:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  204a08:	00 
        if (bytes.len == 0) return;
  204a09:	48 85 c0             	test   rax,rax
  204a0c:	0f 84 62 ff ff ff    	je     204974 <dumpCurrentStackTrace+0x15e4>
  204a12:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  204a19:	00 
        const bytes = @sliceToBytes(memory);
  204a1a:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  204a21:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  204a22:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  204a26:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  204a2b:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  204a30:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  204a35:	ff d2                	call   rdx
  204a37:	e9 38 ff ff ff       	jmp    204974 <dumpCurrentStackTrace+0x15e4>
        const bytes = @sliceToBytes(memory);
  204a3c:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  204a43:	00 
        if (bytes.len == 0) return;
  204a44:	48 85 c0             	test   rax,rax
  204a47:	74 25                	je     204a6e <dumpCurrentStackTrace+0x16de>
  204a49:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  204a50:	00 
        const bytes = @sliceToBytes(memory);
  204a51:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  204a58:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  204a59:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  204a5d:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  204a62:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  204a67:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  204a6c:	ff d2                	call   rdx
  204a6e:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
  204a73:	e9 fc fe ff ff       	jmp    204974 <dumpCurrentStackTrace+0x15e4>
  204a78:	48 c7 c0 fe ff ff ff 	mov    rax,0xfffffffffffffffe
        const this_key = ptr[0..line_i];
        if (!mem.eql(u8, key, this_key)) continue;

        var end_i: usize = line_i;
        while (ptr[end_i] != 0) : (end_i += 1) {}
  204a7f:	80 7c 06 11 00       	cmp    BYTE PTR [rsi+rax*1+0x11],0x0
  204a84:	48 8d 40 01          	lea    rax,[rax+0x1]
  204a88:	75 f5                	jne    204a7f <dumpCurrentStackTrace+0x16ef>
  204a8a:	c6 44 24 0f 01       	mov    BYTE PTR [rsp+0xf],0x1
        const addr = @ptrToInt(self.buffer.ptr) + self.end_index;
        const rem = @rem(addr, alignment);
        const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
        const adjusted_index = self.end_index + march_forward_bytes;
        const new_end_index = adjusted_index + n;
        if (new_end_index > self.buffer.len) {
  204a8f:	48 3d 81 00 00 00    	cmp    rax,0x81
        if (n == 0) {
  204a95:	0f 83 b2 eb ff ff    	jae    20364d <dumpCurrentStackTrace+0x2bd>
  204a9b:	e9 cd eb ff ff       	jmp    20366d <dumpCurrentStackTrace+0x2dd>

0000000000204aa0 <FileOutStream_writeFn>:
    fn writeFn(out_stream: *Stream, bytes: []const u8) !void {
  204aa0:	53                   	push   rbx
  204aa1:	49 89 f0             	mov    r8,rsi
    while (index < bytes.len) {
  204aa4:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  204aa8:	48 85 d2             	test   rdx,rdx
  204aab:	0f 84 98 00 00 00    	je     204b49 <FileOutStream_writeFn+0xa9>
        return self.file.write(bytes);
  204ab1:	48 8b 47 f8          	mov    rax,QWORD PTR [rdi-0x8]
  204ab5:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  204ab8:	45 31 c9             	xor    r9d,r9d
  204abb:	41 ba 00 f0 ff 7f    	mov    r10d,0x7ffff000
  204ac1:	48 8d 1d 00 b8 ff ff 	lea    rbx,[rip+0xffffffffffffb800]        # 2002c8 <__unnamed_128+0x80>
  204ac8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  204acf:	00 
        const amt_to_write = math.min(bytes.len - index, usize(max_bytes_len));
  204ad0:	4c 29 ca             	sub    rdx,r9
    return if (x < y) x else y;
  204ad3:	48 81 fa 00 f0 ff 7f 	cmp    rdx,0x7ffff000
  204ada:	49 0f 43 d2          	cmovae rdx,r10
  204ade:	49 8b 30             	mov    rsi,QWORD PTR [r8]
        const rc = posix.write(fd, bytes.ptr + index, amt_to_write);
  204ae1:	4c 01 ce             	add    rsi,r9
  204ae4:	b8 01 00 00 00       	mov    eax,0x1
  204ae9:	0f 05                	syscall 
  204aeb:	48 89 c1             	mov    rcx,rax
  204aee:	48 81 f9 00 f0 ff ff 	cmp    rcx,0xfffffffffffff000
  204af5:	77 39                	ja     204b30 <FileOutStream_writeFn+0x90>
  204af7:	31 d2                	xor    edx,edx
        if (write_err > 0) {
  204af9:	48 83 fa 04          	cmp    rdx,0x4
  204afd:	74 3d                	je     204b3c <FileOutStream_writeFn+0x9c>
  204aff:	48 83 fa 59          	cmp    rdx,0x59
  204b03:	77 48                	ja     204b4d <FileOutStream_writeFn+0xad>
  204b05:	66 b8 06 00          	mov    ax,0x6
  204b09:	48 63 14 93          	movsxd rdx,DWORD PTR [rbx+rdx*4]
  204b0d:	48 01 da             	add    rdx,rbx
  204b10:	ff e2                	jmp    rdx
        index += rc;
  204b12:	49 01 c9             	add    r9,rcx
    while (index < bytes.len) {
  204b15:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  204b19:	31 c0                	xor    eax,eax
  204b1b:	4c 39 ca             	cmp    rdx,r9
  204b1e:	77 b0                	ja     204ad0 <FileOutStream_writeFn+0x30>
  204b20:	eb 25                	jmp    204b47 <FileOutStream_writeFn+0xa7>
  204b22:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  204b29:	1f 84 00 00 00 00 00 
  204b30:	48 89 ca             	mov    rdx,rcx
  204b33:	48 f7 da             	neg    rdx
        if (write_err > 0) {
  204b36:	48 83 fa 04          	cmp    rdx,0x4
  204b3a:	75 c3                	jne    204aff <FileOutStream_writeFn+0x5f>
    while (index < bytes.len) {
  204b3c:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  204b40:	4c 39 ca             	cmp    rdx,r9
  204b43:	77 8b                	ja     204ad0 <FileOutStream_writeFn+0x30>
  204b45:	31 c0                	xor    eax,eax
  204b47:	5b                   	pop    rbx
  204b48:	c3                   	ret    
  204b49:	31 c0                	xor    eax,eax
  204b4b:	5b                   	pop    rbx
  204b4c:	c3                   	ret    
        if (write_err > 0) {
  204b4d:	48 83 fa 7a          	cmp    rdx,0x7a
  204b51:	75 06                	jne    204b59 <FileOutStream_writeFn+0xb9>
  204b53:	66 b8 09 00          	mov    ax,0x9
  204b57:	5b                   	pop    rbx
  204b58:	c3                   	ret    
  204b59:	66 b8 05 00          	mov    ax,0x5
  204b5d:	5b                   	pop    rbx
  204b5e:	c3                   	ret    
  204b5f:	66 b8 0d 00          	mov    ax,0xd
  204b63:	5b                   	pop    rbx
  204b64:	c3                   	ret    
  204b65:	66 b8 0b 00          	mov    ax,0xb
  204b69:	5b                   	pop    rbx
  204b6a:	c3                   	ret    
  204b6b:	66 b8 07 00          	mov    ax,0x7
  204b6f:	5b                   	pop    rbx
  204b70:	c3                   	ret    
  204b71:	66 b8 0a 00          	mov    ax,0xa
  204b75:	5b                   	pop    rbx
  204b76:	c3                   	ret    
  204b77:	66 b8 0c 00          	mov    ax,0xc
  204b7b:	5b                   	pop    rbx
  204b7c:	c3                   	ret    
  204b7d:	66 b8 04 00          	mov    ax,0x4
  204b81:	5b                   	pop    rbx
  204b82:	c3                   	ret    
  204b83:	66 b8 08 00          	mov    ax,0x8
  204b87:	5b                   	pop    rbx
  204b88:	c3                   	ret    
  204b89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000204b90 <openSelfDebugInfo>:
            return Self{
  204b90:	55                   	push   rbp
  204b91:	41 57                	push   r15
  204b93:	41 56                	push   r14
  204b95:	41 55                	push   r13
  204b97:	41 54                	push   r12
  204b99:	53                   	push   rbx
  204b9a:	48 81 ec 28 05 00 00 	sub    rsp,0x528
  204ba1:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  204ba5:	c5 f8 29 84 24 90 03 	vmovaps XMMWORD PTR [rsp+0x390],xmm0
  204bac:	00 00 
  204bae:	c5 f8 29 84 24 70 03 	vmovaps XMMWORD PTR [rsp+0x370],xmm0
  204bb5:	00 00 
  204bb7:	49 89 f7             	mov    r15,rsi
  204bba:	49 89 fe             	mov    r14,rdi
            const st = try allocator.create(ElfStackTrace{
  204bbd:	c5 fc 10 05 73 c3 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc373]        # 200f38 <__unnamed_35>
  204bc4:	ff 
  204bc5:	c5 fc 11 84 24 b0 04 	vmovups YMMWORD PTR [rsp+0x4b0],ymm0
  204bcc:	00 00 
  204bce:	48 c7 84 24 a0 03 00 	mov    QWORD PTR [rsp+0x3a0],0x0
  204bd5:	00 00 00 00 00 
  204bda:	c5 fc 10 05 76 c3 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc376]        # 200f58 <__unnamed_35+0x20>
  204be1:	ff 
  204be2:	c5 fc 11 84 24 d0 04 	vmovups YMMWORD PTR [rsp+0x4d0],ymm0
  204be9:	00 00 
  204beb:	48 c7 84 24 80 03 00 	mov    QWORD PTR [rsp+0x380],0x0
  204bf2:	00 00 00 00 00 
  204bf7:	c5 fe 6f 05 71 c3 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc371]        # 200f70 <__unnamed_35+0x38>
  204bfe:	ff 
  204bff:	c5 fe 7f 84 24 e8 04 	vmovdqu YMMWORD PTR [rsp+0x4e8],ymm0
  204c06:	00 00 
  204c08:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  204c0f:	00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  204c10:	ba c8 00 00 00       	mov    edx,0xc8
  204c15:	b9 04 00 00 00       	mov    ecx,0x4
  204c1a:	c5 f8 77             	vzeroupper 
  204c1d:	41 ff 17             	call   QWORD PTR [r15]
  204c20:	0f b7 84 24 a0 00 00 	movzx  eax,WORD PTR [rsp+0xa0]
  204c27:	00 
  204c28:	66 85 c0             	test   ax,ax
  204c2b:	74 19                	je     204c46 <openSelfDebugInfo+0xb6>
  204c2d:	66 41 89 06          	mov    WORD PTR [r14],ax
  204c31:	48 8b 84 24 1a 04 00 	mov    rax,QWORD PTR [rsp+0x41a]
  204c38:	00 
  204c39:	48 8b 8c 24 20 04 00 	mov    rcx,QWORD PTR [rsp+0x420]
  204c40:	00 
  204c41:	e9 40 0c 00 00       	jmp    205886 <openSelfDebugInfo+0xcf6>
        assert(byte_slice.len == byte_count);
  204c46:	48 81 bc 24 b0 00 00 	cmp    QWORD PTR [rsp+0xb0],0xc8
  204c4d:	00 c8 00 00 00 
    if (!ok) {
  204c52:	0f 85 0a 36 00 00    	jne    208262 <openSelfDebugInfo+0x36d2>
  204c58:	48 8b 9c 24 a8 00 00 	mov    rbx,QWORD PTR [rsp+0xa8]
  204c5f:	00 
        ptr.* = init;
  204c60:	c5 fc 10 84 24 a8 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4a8]
  204c67:	00 00 
  204c69:	c5 fe 6f 8c 24 c8 04 	vmovdqu ymm1,YMMWORD PTR [rsp+0x4c8]
  204c70:	00 00 
  204c72:	c5 fe 6f 94 24 e8 04 	vmovdqu ymm2,YMMWORD PTR [rsp+0x4e8]
  204c79:	00 00 
  204c7b:	c5 fe 6f 9c 24 08 05 	vmovdqu ymm3,YMMWORD PTR [rsp+0x508]
  204c82:	00 00 
  204c84:	c5 fe 7f 5b 60       	vmovdqu YMMWORD PTR [rbx+0x60],ymm3
  204c89:	c5 fe 7f 53 40       	vmovdqu YMMWORD PTR [rbx+0x40],ymm2
  204c8e:	c5 fe 7f 4b 20       	vmovdqu YMMWORD PTR [rbx+0x20],ymm1
  204c93:	c5 fc 11 03          	vmovups YMMWORD PTR [rbx],ymm0
  204c97:	48 c7 83 80 00 00 00 	mov    QWORD PTR [rbx+0x80],0x0
  204c9e:	00 00 00 00 
  204ca2:	48 8b 84 24 a0 03 00 	mov    rax,QWORD PTR [rsp+0x3a0]
  204ca9:	00 
  204caa:	48 89 83 98 00 00 00 	mov    QWORD PTR [rbx+0x98],rax
  204cb1:	c5 f8 28 84 24 90 03 	vmovaps xmm0,XMMWORD PTR [rsp+0x390]
  204cb8:	00 00 
  204cba:	c5 f8 11 83 88 00 00 	vmovups XMMWORD PTR [rbx+0x88],xmm0
  204cc1:	00 
  204cc2:	4c 89 bb a0 00 00 00 	mov    QWORD PTR [rbx+0xa0],r15
  204cc9:	48 8b 84 24 80 03 00 	mov    rax,QWORD PTR [rsp+0x380]
  204cd0:	00 
  204cd1:	48 89 83 b8 00 00 00 	mov    QWORD PTR [rbx+0xb8],rax
  204cd8:	c5 f8 28 84 24 70 03 	vmovaps xmm0,XMMWORD PTR [rsp+0x370]
  204cdf:	00 00 
  204ce1:	c5 f8 11 83 a8 00 00 	vmovups XMMWORD PTR [rbx+0xa8],xmm0
  204ce8:	00 
  204ce9:	4c 89 bb c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],r15

pub fn openSelfExe() !os.File {
    switch (builtin.os) {
        Os.linux => {
            const proc_file_path = "/proc/self/exe";
            var fixed_buffer_mem: [proc_file_path.len + 1]u8 = undefined;
  204cf0:	48 8b 05 da c2 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffc2da]        # 200fd1 <__unnamed_36+0x7>
  204cf7:	48 89 44 24 67       	mov    QWORD PTR [rsp+0x67],rax
  204cfc:	48 8b 05 c7 c2 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffc2c7]        # 200fca <__unnamed_36>
  204d03:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
            var fixed_allocator = std.heap.FixedBufferAllocator.init(fixed_buffer_mem[0..]);
  204d08:	c5 fa 6f 05 18 f6 00 	vmovdqu xmm0,XMMWORD PTR [rip+0xf618]        # 214328 <__unnamed_37>
  204d0f:	00 
  204d10:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  204d17:	00 00 
  204d19:	48 8b 05 18 f6 00 00 	mov    rax,QWORD PTR [rip+0xf618]        # 214338 <__unnamed_37+0x10>
  204d20:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  204d27:	00 
  204d28:	48 c7 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],0x0
  204d2f:	00 00 00 00 00 
  204d34:	48 8d 44 24 60       	lea    rax,[rsp+0x60]
  204d39:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  204d40:	00 
  204d41:	48 c7 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],0xf
  204d48:	00 0f 00 00 00 
            return os.File.openRead(&fixed_allocator.allocator, proc_file_path);
  204d4d:	48 8d 15 c4 f5 00 00 	lea    rdx,[rip+0xf5c4]        # 214318 <__unnamed_38>
  204d54:	48 8d bc 24 b8 02 00 	lea    rdi,[rsp+0x2b8]
  204d5b:	00 
  204d5c:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  204d63:	00 
  204d64:	c5 f8 77             	vzeroupper 
  204d67:	e8 64 42 00 00       	call   208fd0 <File_openRead>
  204d6c:	48 8b ac 24 b8 02 00 	mov    rbp,QWORD PTR [rsp+0x2b8]
  204d73:	00 
            st.self_exe_file = try os.openSelfExe();
  204d74:	66 85 ed             	test   bp,bp
  204d77:	74 3e                	je     204db7 <openSelfDebugInfo+0x227>
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  204d79:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  204d7d:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  204d84:	00 
  204d85:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  204d8c:	00 c8 00 00 00 
  204d91:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  204d98:	00 
  204d99:	4c 89 ff             	mov    rdi,r15
  204d9c:	ff d0                	call   rax
  204d9e:	66 41 89 2e          	mov    WORD PTR [r14],bp
  204da2:	48 8b 84 24 0c 04 00 	mov    rax,QWORD PTR [rsp+0x40c]
  204da9:	00 
  204daa:	48 8b 8c 24 12 04 00 	mov    rcx,QWORD PTR [rsp+0x412]
  204db1:	00 
  204db2:	e9 cf 0a 00 00       	jmp    205886 <openSelfDebugInfo+0xcf6>
  204db7:	48 c1 ed 20          	shr    rbp,0x20
  204dbb:	89 2b                	mov    DWORD PTR [rbx],ebp
            try st.elf.openFile(allocator, &st.self_exe_file);
  204dbd:	4c 8d 63 08          	lea    r12,[rbx+0x8]
        elf.auto_close_stream = true;
    }

    /// Call close when done.
    pub fn openFile(elf: *Elf, allocator: *mem.Allocator, file: *os.File) !void {
        elf.allocator = allocator;
  204dc1:	4c 89 7b 50          	mov    QWORD PTR [rbx+0x50],r15
        elf.in_file = file;
  204dc5:	48 89 5b 08          	mov    QWORD PTR [rbx+0x8],rbx
        elf.auto_close_stream = false;
  204dc9:	c6 43 10 00          	mov    BYTE PTR [rbx+0x10],0x0

        var file_stream = io.FileInStream.init(elf.in_file);
  204dcd:	48 89 5c 24 20       	mov    QWORD PTR [rsp+0x20],rbx
  204dd2:	48 8d 05 e7 48 00 00 	lea    rax,[rip+0x48e7]        # 2096c0 <FileInStream_readFn>
  204dd9:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  204dde:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  204de5:	00 
        const in = &file_stream.stream;

        var magic: [4]u8 = undefined;
        try in.readNoEof(magic[0..]);
  204de6:	48 89 84 24 b8 02 00 	mov    QWORD PTR [rsp+0x2b8],rax
  204ded:	00 
  204dee:	48 c7 84 24 c0 02 00 	mov    QWORD PTR [rsp+0x2c0],0x4
  204df5:	00 04 00 00 00 
        return self.file.read(buffer);
  204dfa:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  204dff:	4c 8d ac 24 a0 00 00 	lea    r13,[rsp+0xa0]
  204e06:	00 
  204e07:	48 8d 94 24 b8 02 00 	lea    rdx,[rsp+0x2b8]
  204e0e:	00 
  204e0f:	4c 89 ef             	mov    rdi,r13
  204e12:	e8 99 47 00 00       	call   2095b0 <File_read>
  204e17:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  204e1e:	00 
            const amt_read = try self.read(buf);
  204e1f:	66 85 ed             	test   bp,bp
  204e22:	75 16                	jne    204e3a <openSelfDebugInfo+0x2aa>
  204e24:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  204e2b:	00 
  204e2c:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  204e30:	48 3b 84 24 c0 02 00 	cmp    rax,QWORD PTR [rsp+0x2c0]
  204e37:	00 
  204e38:	73 50                	jae    204e8a <openSelfDebugInfo+0x2fa>
  204e3a:	66 85 ed             	test   bp,bp
  204e3d:	0f 84 77 06 00 00    	je     2054ba <openSelfDebugInfo+0x92a>
  204e43:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  204e46:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  204e4d:	00 00 00 
    return asm volatile ("syscall"
  204e50:	b8 03 00 00 00       	mov    eax,0x3
  204e55:	0f 05                	syscall 
            switch (err) {
  204e57:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  204e5b:	74 f3                	je     204e50 <openSelfDebugInfo+0x2c0>
        /// Remove and return the first node in the list.
        ///
        /// Returns:
        ///     A pointer to the first node in the list.
        pub fn popFirst(list: *Self) ?*Node {
            const first = list.first orelse return null;
  204e5d:	48 8b 05 bc 01 01 00 	mov    rax,QWORD PTR [rip+0x101bc]        # 215020 <emfile_promise_queue>
  204e64:	48 85 c0             	test   rax,rax
  204e67:	0f 84 2b 01 00 00    	je     204f98 <openSelfDebugInfo+0x408>
            if (node.prev) |prev_node| {
  204e6d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  204e70:	48 85 c9             	test   rcx,rcx
  204e73:	0f 84 b5 00 00 00    	je     204f2e <openSelfDebugInfo+0x39e>
                prev_node.next = node.next;
  204e79:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  204e7d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  204e81:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  204e85:	e9 af 00 00 00       	jmp    204f39 <openSelfDebugInfo+0x3a9>
        if (b[index] != item) return false;
  204e8a:	80 bc 24 50 01 00 00 	cmp    BYTE PTR [rsp+0x150],0x7f
  204e91:	7f 
  204e92:	0f 85 15 06 00 00    	jne    2054ad <openSelfDebugInfo+0x91d>
  204e98:	80 bc 24 51 01 00 00 	cmp    BYTE PTR [rsp+0x151],0x45
  204e9f:	45 
  204ea0:	0f 85 07 06 00 00    	jne    2054ad <openSelfDebugInfo+0x91d>
  204ea6:	80 bc 24 52 01 00 00 	cmp    BYTE PTR [rsp+0x152],0x4c
  204ead:	4c 
  204eae:	0f 85 f9 05 00 00    	jne    2054ad <openSelfDebugInfo+0x91d>
  204eb4:	80 bc 24 53 01 00 00 	cmp    BYTE PTR [rsp+0x153],0x46
  204ebb:	46 
  204ebc:	0f 85 17 01 00 00    	jne    204fd9 <openSelfDebugInfo+0x449>
  204ec2:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  204ec7:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
            try self.readNoEof(result[0..]);
  204ecc:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  204ed1:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  204ed8:	00 00 
  204eda:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  204ee1:	00 
  204ee2:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  204ee7:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  204eeb:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  204ef2:	00 
            const amt_read = try self.read(buf);
  204ef3:	66 85 ed             	test   bp,bp
  204ef6:	0f 85 3e ff ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  204efc:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  204f03:	00 
  204f04:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  204f08:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  204f0d:	0f 82 27 ff ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
            return result[0];
  204f13:	8a 44 24 07          	mov    al,BYTE PTR [rsp+0x7]
        if (!mem.eql(u8, magic, "\x7fELF")) return error.InvalidFormat;

        elf.is_64 = switch (try in.readByte()) {
  204f17:	3c 01                	cmp    al,0x1
  204f19:	0f 84 cc 00 00 00    	je     204feb <openSelfDebugInfo+0x45b>
  204f1f:	3c 02                	cmp    al,0x2
  204f21:	0f 85 86 05 00 00    	jne    2054ad <openSelfDebugInfo+0x91d>
  204f27:	b0 01                	mov    al,0x1
  204f29:	e9 bf 00 00 00       	jmp    204fed <openSelfDebugInfo+0x45d>
                list.first = node.next;
  204f2e:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  204f32:	48 89 0d e7 00 01 00 	mov    QWORD PTR [rip+0x100e7],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  204f39:	48 85 c9             	test   rcx,rcx
  204f3c:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  204f3f:	48 8d 35 e2 00 01 00 	lea    rsi,[rip+0x100e2]        # 215028 <emfile_promise_queue+0x8>
  204f46:	48 0f 45 f1          	cmovne rsi,rcx
  204f4a:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  204f4d:	48 83 05 db 00 01 00 	add    QWORD PTR [rip+0x100db],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  204f54:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  204f55:	74 1e                	je     204f75 <openSelfDebugInfo+0x3e5>
  204f57:	48 83 3d c1 00 01 00 	cmp    QWORD PTR [rip+0x100c1],0x0        # 215020 <emfile_promise_queue>
  204f5e:	00 
  204f5f:	0f 84 fd 32 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  204f65:	48 8b 0d bc 00 01 00 	mov    rcx,QWORD PTR [rip+0x100bc]        # 215028 <emfile_promise_queue+0x8>
  204f6c:	48 85 c9             	test   rcx,rcx
  204f6f:	0f 84 ed 32 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  204f75:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  204f79:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  204f7d:	0f 1f 00             	nop    DWORD PTR [rax]
  204f80:	48 89 c1             	mov    rcx,rax
  204f83:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  204f87:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  204f8d:	75 f1                	jne    204f80 <openSelfDebugInfo+0x3f0>
  204f8f:	a8 01                	test   al,0x1
  204f91:	75 05                	jne    204f98 <openSelfDebugInfo+0x408>
  204f93:	c5 f8 77             	vzeroupper 
  204f96:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  204f98:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  204f9c:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  204fa3:	00 
  204fa4:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  204fab:	00 c8 00 00 00 
  204fb0:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  204fb7:	00 
  204fb8:	4c 89 ff             	mov    rdi,r15
  204fbb:	c5 f8 77             	vzeroupper 
  204fbe:	ff d0                	call   rax
  204fc0:	66 41 89 2e          	mov    WORD PTR [r14],bp
  204fc4:	48 8b 84 24 fe 03 00 	mov    rax,QWORD PTR [rsp+0x3fe]
  204fcb:	00 
  204fcc:	48 8b 8c 24 04 04 00 	mov    rcx,QWORD PTR [rsp+0x404]
  204fd3:	00 
  204fd4:	e9 ad 08 00 00       	jmp    205886 <openSelfDebugInfo+0xcf6>
  204fd9:	66 bd 1f 00          	mov    bp,0x1f
  204fdd:	66 85 ed             	test   bp,bp
  204fe0:	0f 85 5d fe ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
  204fe6:	e9 cf 04 00 00       	jmp    2054ba <openSelfDebugInfo+0x92a>
  204feb:	31 c0                	xor    eax,eax
  204fed:	88 43 11             	mov    BYTE PTR [rbx+0x11],al
            try self.readNoEof(result[0..]);
  204ff0:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  204ff5:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  204ffa:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  205001:	00 00 
  205003:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20500a:	00 
  20500b:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  205010:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  205015:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  205019:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  205020:	00 
            const amt_read = try self.read(buf);
  205021:	66 85 ed             	test   bp,bp
  205024:	0f 85 10 fe ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  20502a:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  205031:	00 
  205032:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  205036:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20503b:	0f 82 f9 fd ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
            return result[0];
  205041:	8a 44 24 07          	mov    al,BYTE PTR [rsp+0x7]
            1 => false,
            2 => true,
            else => return error.InvalidFormat,
        };

        elf.endian = switch (try in.readByte()) {
  205045:	3c 01                	cmp    al,0x1
  205047:	74 0c                	je     205055 <openSelfDebugInfo+0x4c5>
  205049:	3c 02                	cmp    al,0x2
  20504b:	0f 85 5c 04 00 00    	jne    2054ad <openSelfDebugInfo+0x91d>
  205051:	31 c0                	xor    eax,eax
  205053:	eb 02                	jmp    205057 <openSelfDebugInfo+0x4c7>
  205055:	b0 01                	mov    al,0x1
  205057:	48 8d 4b 12          	lea    rcx,[rbx+0x12]
  20505b:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  205060:	88 01                	mov    BYTE PTR [rcx],al
            try self.readNoEof(result[0..]);
  205062:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  205067:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20506c:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  205073:	00 00 
  205075:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20507c:	00 
  20507d:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  205082:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  205087:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20508b:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  205092:	00 
            const amt_read = try self.read(buf);
  205093:	66 85 ed             	test   bp,bp
  205096:	0f 85 9e fd ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  20509c:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2050a3:	00 
  2050a4:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  2050a8:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  2050ad:	0f 82 87 fd ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
            2 => builtin.Endian.Big,
            else => return error.InvalidFormat,
        };

        const version_byte = try in.readByte();
        if (version_byte != 1) return error.InvalidFormat;
  2050b3:	80 7c 24 07 01       	cmp    BYTE PTR [rsp+0x7],0x1
  2050b8:	0f 85 ef 03 00 00    	jne    2054ad <openSelfDebugInfo+0x91d>

        // skip over padding
        try elf.in_file.seekForward(9);
  2050be:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2050c2:	48 63 38             	movsxd rdi,DWORD PTR [rax]
    return asm volatile ("syscall"
  2050c5:	b8 08 00 00 00       	mov    eax,0x8
  2050ca:	be 09 00 00 00       	mov    esi,0x9
  2050cf:	ba 01 00 00 00       	mov    edx,0x1
  2050d4:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2050d6:	48 89 c2             	mov    rdx,rax
  2050d9:	48 f7 da             	neg    rdx
  2050dc:	31 c9                	xor    ecx,ecx
  2050de:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2050e4:	48 0f 47 ca          	cmova  rcx,rdx
                if (err > 0) {
  2050e8:	48 83 f9 1d          	cmp    rcx,0x1d
  2050ec:	0f 87 4b 31 00 00    	ja     20823d <openSelfDebugInfo+0x36ad>
  2050f2:	48 8d 05 37 b3 ff ff 	lea    rax,[rip+0xffffffffffffb337]        # 200430 <__unnamed_128+0x1e8>
  2050f9:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  2050fd:	48 01 c1             	add    rcx,rax
  205100:	66 bd 05 00          	mov    bp,0x5
  205104:	ff e1                	jmp    rcx
  205106:	66 bd 20 00          	mov    bp,0x20
  20510a:	66 85 ed             	test   bp,bp
  20510d:	0f 85 30 fd ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
  205113:	e9 a2 03 00 00       	jmp    2054ba <openSelfDebugInfo+0x92a>

        elf.file_type = switch (try in.readInt(elf.endian, u16)) {
  205118:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
  20511b:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20511f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            try self.readNoEof(bytes[0..]);
  205124:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  205129:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  205130:	00 00 
  205132:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  205139:	00 
  20513a:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20513f:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  205144:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  205148:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20514f:	00 
            const amt_read = try self.read(buf);
  205150:	66 85 ed             	test   bp,bp
  205153:	0f 85 e1 fc ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  205159:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  205160:	00 
  205161:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  205165:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20516a:	0f 82 ca fc ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
  205170:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  205175:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20517a:	89 ca                	mov    edx,ecx
  20517c:	c1 e2 08             	shl    edx,0x8
  20517f:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  205181:	c1 e0 08             	shl    eax,0x8
  205184:	09 c8                	or     eax,ecx
    switch (endian) {
  205186:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20518b:	66 0f 45 c2          	cmovne ax,dx
  20518f:	83 c0 ff             	add    eax,0xffffffff
  205192:	0f b7 c8             	movzx  ecx,ax
  205195:	83 f9 03             	cmp    ecx,0x3
  205198:	0f 87 0f 03 00 00    	ja     2054ad <openSelfDebugInfo+0x91d>
  20519e:	24 03                	and    al,0x3
  2051a0:	88 43 13             	mov    BYTE PTR [rbx+0x13],al
            3 => FileType.Shared,
            4 => FileType.Core,
            else => return error.InvalidFormat,
        };

        elf.arch = switch (try in.readInt(elf.endian, u16)) {
  2051a3:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  2051a6:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  2051aa:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2051af:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  2051b4:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  2051bb:	00 00 
  2051bd:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  2051c4:	00 
  2051c5:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  2051ca:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  2051cf:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  2051d3:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  2051da:	00 
            const amt_read = try self.read(buf);
  2051db:	66 85 ed             	test   bp,bp
  2051de:	0f 85 56 fc ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  2051e4:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2051eb:	00 
  2051ec:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  2051f0:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  2051f5:	0f 82 3f fc ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
  2051fb:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  205200:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  205205:	89 ca                	mov    edx,ecx
  205207:	c1 e2 08             	shl    edx,0x8
  20520a:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20520c:	c1 e0 08             	shl    eax,0x8
  20520f:	09 c8                	or     eax,ecx
    switch (endian) {
  205211:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  205216:	66 0f 45 c2          	cmovne ax,dx
  20521a:	8d 48 fe             	lea    ecx,[rax-0x2]
  20521d:	0f b7 c9             	movzx  ecx,cx
  205220:	83 f9 3c             	cmp    ecx,0x3c
  205223:	77 1a                	ja     20523f <openSelfDebugInfo+0x6af>
  205225:	31 c0                	xor    eax,eax
  205227:	48 8d 15 7a b2 ff ff 	lea    rdx,[rip+0xffffffffffffb27a]        # 2004a8 <__unnamed_128+0x260>
  20522e:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  205232:	48 01 d1             	add    rcx,rdx
  205235:	66 bd 1f 00          	mov    bp,0x1f
  205239:	ff e1                	jmp    rcx
  20523b:	b0 01                	mov    al,0x1
  20523d:	eb 28                	jmp    205267 <openSelfDebugInfo+0x6d7>
  20523f:	0f b7 c0             	movzx  eax,ax
  205242:	3d b7 00 00 00       	cmp    eax,0xb7
  205247:	0f 85 60 02 00 00    	jne    2054ad <openSelfDebugInfo+0x91d>
  20524d:	b0 08                	mov    al,0x8
  20524f:	eb 16                	jmp    205267 <openSelfDebugInfo+0x6d7>
  205251:	b0 06                	mov    al,0x6
  205253:	eb 12                	jmp    205267 <openSelfDebugInfo+0x6d7>
  205255:	b0 07                	mov    al,0x7
  205257:	eb 0e                	jmp    205267 <openSelfDebugInfo+0x6d7>
  205259:	b0 02                	mov    al,0x2
  20525b:	eb 0a                	jmp    205267 <openSelfDebugInfo+0x6d7>
  20525d:	b0 04                	mov    al,0x4
  20525f:	eb 06                	jmp    205267 <openSelfDebugInfo+0x6d7>
  205261:	b0 03                	mov    al,0x3
  205263:	eb 02                	jmp    205267 <openSelfDebugInfo+0x6d7>
  205265:	b0 05                	mov    al,0x5
  205267:	24 0f                	and    al,0xf
  205269:	88 43 14             	mov    BYTE PTR [rbx+0x14],al
            0x3E => Arch.x86_64,
            0xb7 => Arch.AArch64,
            else => return error.InvalidFormat,
        };

        const elf_version = try in.readInt(elf.endian, u32);
  20526c:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  20526f:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  205273:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  205278:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20527d:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  205284:	00 00 
  205286:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20528d:	00 
  20528e:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  205293:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  205298:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20529c:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  2052a3:	00 
            const amt_read = try self.read(buf);
  2052a4:	66 85 ed             	test   bp,bp
  2052a7:	0f 85 8d fb ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  2052ad:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2052b4:	00 
  2052b5:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  2052b9:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  2052be:	0f 82 76 fb ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
  2052c4:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  2052c9:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  2052ce:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  2052d3:	74 23                	je     2052f8 <openSelfDebugInfo+0x768>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2052d5:	c1 e1 08             	shl    ecx,0x8
  2052d8:	09 c1                	or     ecx,eax
  2052da:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  2052df:	c1 e2 10             	shl    edx,0x10
  2052e2:	09 ca                	or     edx,ecx
  2052e4:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  2052e9:	c1 e0 18             	shl    eax,0x18
  2052ec:	09 d0                	or     eax,edx
        if (elf_version != 1) return error.InvalidFormat;
  2052ee:	83 f8 01             	cmp    eax,0x1
  2052f1:	74 27                	je     20531a <openSelfDebugInfo+0x78a>
  2052f3:	e9 b5 01 00 00       	jmp    2054ad <openSelfDebugInfo+0x91d>
                result = (result << 8) | b;
  2052f8:	c1 e0 08             	shl    eax,0x8
  2052fb:	09 c8                	or     eax,ecx
  2052fd:	c1 e0 08             	shl    eax,0x8
  205300:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  205305:	09 c1                	or     ecx,eax
  205307:	c1 e1 08             	shl    ecx,0x8
  20530a:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20530f:	09 c8                	or     eax,ecx
  205311:	83 f8 01             	cmp    eax,0x1
  205314:	0f 85 93 01 00 00    	jne    2054ad <openSelfDebugInfo+0x91d>
  20531a:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]

        if (elf.is_64) {
  20531d:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  205321:	80 7b 11 01          	cmp    BYTE PTR [rbx+0x11],0x1
  205325:	0f 85 58 23 00 00    	jne    207683 <openSelfDebugInfo+0x2af3>
            elf.entry_addr = try in.readInt(elf.endian, u64);
  20532b:	0f b6 54 24 38       	movzx  edx,BYTE PTR [rsp+0x38]
  205330:	48 8d bc 24 28 04 00 	lea    rdi,[rsp+0x428]
  205337:	00 
  205338:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20533d:	e8 3e 41 00 00       	call   209480 <InStream(ReadError)_readInt.16>
  205342:	0f b7 ac 24 28 04 00 	movzx  ebp,WORD PTR [rsp+0x428]
  205349:	00 
  20534a:	66 85 ed             	test   bp,bp
  20534d:	0f 85 e7 fa ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  205353:	48 8b 84 24 30 04 00 	mov    rax,QWORD PTR [rsp+0x430]
  20535a:	00 
  20535b:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
            elf.program_header_offset = try in.readInt(elf.endian, u64);
  20535f:	0f b6 53 12          	movzx  edx,BYTE PTR [rbx+0x12]
  205363:	48 8d bc 24 10 02 00 	lea    rdi,[rsp+0x210]
  20536a:	00 
  20536b:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  205370:	e8 0b 41 00 00       	call   209480 <InStream(ReadError)_readInt.16>
  205375:	0f b7 ac 24 10 02 00 	movzx  ebp,WORD PTR [rsp+0x210]
  20537c:	00 
  20537d:	66 85 ed             	test   bp,bp
  205380:	0f 85 b4 fa ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  205386:	48 8b 84 24 18 02 00 	mov    rax,QWORD PTR [rsp+0x218]
  20538d:	00 
  20538e:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
            elf.section_header_offset = try in.readInt(elf.endian, u64);
  205392:	0f b6 53 12          	movzx  edx,BYTE PTR [rbx+0x12]
  205396:	48 8d bc 24 e0 01 00 	lea    rdi,[rsp+0x1e0]
  20539d:	00 
  20539e:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  2053a3:	e8 d8 40 00 00       	call   209480 <InStream(ReadError)_readInt.16>
  2053a8:	0f b7 ac 24 e0 01 00 	movzx  ebp,WORD PTR [rsp+0x1e0]
  2053af:	00 
  2053b0:	66 85 ed             	test   bp,bp
  2053b3:	0f 85 81 fa ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  2053b9:	48 8b 84 24 e8 01 00 	mov    rax,QWORD PTR [rsp+0x1e8]
  2053c0:	00 
  2053c1:	48 89 43 28          	mov    QWORD PTR [rbx+0x28],rax
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
        }

        // skip over flags
        try elf.in_file.seekForward(4);
  2053c5:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2053c9:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  2053cc:	b8 08 00 00 00       	mov    eax,0x8
  2053d1:	be 04 00 00 00       	mov    esi,0x4
  2053d6:	ba 01 00 00 00       	mov    edx,0x1
  2053db:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2053dd:	48 89 c2             	mov    rdx,rax
  2053e0:	48 f7 da             	neg    rdx
  2053e3:	31 c9                	xor    ecx,ecx
  2053e5:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2053eb:	48 0f 47 ca          	cmova  rcx,rdx
  2053ef:	48 83 f9 1d          	cmp    rcx,0x1d
  2053f3:	0f 87 44 2e 00 00    	ja     20823d <openSelfDebugInfo+0x36ad>
  2053f9:	48 8d 05 9c b1 ff ff 	lea    rax,[rip+0xffffffffffffb19c]        # 20059c <__unnamed_128+0x354>
  205400:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  205404:	48 01 c1             	add    rcx,rax
  205407:	66 bd 05 00          	mov    bp,0x5
  20540b:	ff e1                	jmp    rcx

        const header_size = try in.readInt(elf.endian, u16);
  20540d:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  205412:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  205414:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  205418:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20541d:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  205422:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  205429:	00 00 
  20542b:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  205432:	00 
  205433:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  205438:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20543d:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  205441:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  205448:	00 
            const amt_read = try self.read(buf);
  205449:	66 85 ed             	test   bp,bp
  20544c:	0f 85 e8 f9 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  205452:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  205459:	00 
  20545a:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20545e:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  205463:	0f 82 d1 f9 ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
  205469:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20546e:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  205473:	89 ca                	mov    edx,ecx
  205475:	c1 e2 08             	shl    edx,0x8
  205478:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20547a:	c1 e0 08             	shl    eax,0x8
  20547d:	09 c8                	or     eax,ecx
    switch (endian) {
  20547f:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  205484:	66 0f 45 c2          	cmovne ax,dx
        if ((elf.is_64 and header_size != 64) or (!elf.is_64 and header_size != 52)) {
  205488:	8a 4b 11             	mov    cl,BYTE PTR [rbx+0x11]
  20548b:	80 f9 01             	cmp    cl,0x1
  20548e:	75 08                	jne    205498 <openSelfDebugInfo+0x908>
  205490:	0f b7 d0             	movzx  edx,ax
  205493:	83 fa 40             	cmp    edx,0x40
  205496:	75 15                	jne    2054ad <openSelfDebugInfo+0x91d>
  205498:	0f b7 c0             	movzx  eax,ax
  20549b:	83 f8 34             	cmp    eax,0x34
  20549e:	0f 84 c2 23 00 00    	je     207866 <openSelfDebugInfo+0x2cd6>
  2054a4:	80 f1 01             	xor    cl,0x1
  2054a7:	0f 84 b9 23 00 00    	je     207866 <openSelfDebugInfo+0x2cd6>
  2054ad:	66 bd 1f 00          	mov    bp,0x1f
  2054b1:	66 85 ed             	test   bp,bp
  2054b4:	0f 85 89 f9 ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
            st.debug_info = (try st.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  2054ba:	48 8d 15 07 ee 00 00 	lea    rdx,[rip+0xee07]        # 2142c8 <__unnamed_39>
  2054c1:	48 8d bc 24 a8 02 00 	lea    rdi,[rsp+0x2a8]
  2054c8:	00 
  2054c9:	4c 89 e6             	mov    rsi,r12
  2054cc:	c5 f8 77             	vzeroupper 
  2054cf:	e8 ac 38 00 00       	call   208d80 <Elf_findSection>
  2054d4:	66 83 bc 24 a8 02 00 	cmp    WORD PTR [rsp+0x2a8],0x0
  2054db:	00 00 
  2054dd:	74 7b                	je     20555a <openSelfDebugInfo+0x9ca>
        const bytes = @sliceToBytes(memory);
  2054df:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  2054e3:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2054e7:	74 26                	je     20550f <openSelfDebugInfo+0x97f>
  2054e9:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  2054ed:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2054f1:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2054f5:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  2054fc:	00 
  2054fd:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  205504:	00 
  205505:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20550c:	00 
  20550d:	ff d2                	call   rdx
    }

    pub fn close(elf: *Elf) void {
        elf.allocator.free(elf.section_headers);

        if (elf.auto_close_stream) elf.in_file.close();
  20550f:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  205513:	0f 85 8c 02 00 00    	jne    2057a5 <openSelfDebugInfo+0xc15>
  205519:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20551d:	48 63 38             	movsxd rdi,DWORD PTR [rax]
    return asm volatile ("syscall"
  205520:	b8 03 00 00 00       	mov    eax,0x3
  205525:	0f 05                	syscall 
            switch (err) {
  205527:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20552b:	74 f3                	je     205520 <openSelfDebugInfo+0x990>
            const first = list.first orelse return null;
  20552d:	48 8b 05 ec fa 00 00 	mov    rax,QWORD PTR [rip+0xfaec]        # 215020 <emfile_promise_queue>
  205534:	48 85 c0             	test   rax,rax
  205537:	0f 84 68 02 00 00    	je     2057a5 <openSelfDebugInfo+0xc15>
            if (node.prev) |prev_node| {
  20553d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  205540:	48 85 c9             	test   rcx,rcx
  205543:	0f 84 f8 01 00 00    	je     205741 <openSelfDebugInfo+0xbb1>
                prev_node.next = node.next;
  205549:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20554d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  205551:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205555:	e9 f2 01 00 00       	jmp    20574c <openSelfDebugInfo+0xbbc>
  20555a:	48 8b 84 24 b0 02 00 	mov    rax,QWORD PTR [rsp+0x2b0]
  205561:	00 
  205562:	48 85 c0             	test   rax,rax
  205565:	0f 84 a5 00 00 00    	je     205610 <openSelfDebugInfo+0xa80>
  20556b:	48 89 43 60          	mov    QWORD PTR [rbx+0x60],rax
            st.debug_abbrev = (try st.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  20556f:	48 8d 15 62 ed 00 00 	lea    rdx,[rip+0xed62]        # 2142d8 <__unnamed_40>
  205576:	48 8d bc 24 98 02 00 	lea    rdi,[rsp+0x298]
  20557d:	00 
  20557e:	4c 89 e6             	mov    rsi,r12
  205581:	e8 fa 37 00 00       	call   208d80 <Elf_findSection>
  205586:	66 83 bc 24 98 02 00 	cmp    WORD PTR [rsp+0x298],0x0
  20558d:	00 00 
  20558f:	0f 84 f6 00 00 00    	je     20568b <openSelfDebugInfo+0xafb>
        const bytes = @sliceToBytes(memory);
  205595:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  205599:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20559d:	74 26                	je     2055c5 <openSelfDebugInfo+0xa35>
  20559f:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  2055a3:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2055a7:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2055ab:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  2055b2:	00 
  2055b3:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  2055ba:	00 
  2055bb:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  2055c2:	00 
  2055c3:	ff d2                	call   rdx
  2055c5:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  2055c9:	0f 85 69 04 00 00    	jne    205a38 <openSelfDebugInfo+0xea8>
  2055cf:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  2055d3:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  2055d6:	b8 03 00 00 00       	mov    eax,0x3
  2055db:	0f 05                	syscall 
  2055dd:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2055e1:	74 f3                	je     2055d6 <openSelfDebugInfo+0xa46>
            const first = list.first orelse return null;
  2055e3:	48 8b 05 36 fa 00 00 	mov    rax,QWORD PTR [rip+0xfa36]        # 215020 <emfile_promise_queue>
  2055ea:	48 85 c0             	test   rax,rax
  2055ed:	0f 84 45 04 00 00    	je     205a38 <openSelfDebugInfo+0xea8>
            if (node.prev) |prev_node| {
  2055f3:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2055f6:	48 85 c9             	test   rcx,rcx
  2055f9:	0f 84 d5 03 00 00    	je     2059d4 <openSelfDebugInfo+0xe44>
                prev_node.next = node.next;
  2055ff:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  205603:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  205607:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20560b:	e9 cf 03 00 00       	jmp    2059df <openSelfDebugInfo+0xe4f>
        const bytes = @sliceToBytes(memory);
  205610:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  205614:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  205618:	74 26                	je     205640 <openSelfDebugInfo+0xab0>
  20561a:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20561e:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  205622:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  205626:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20562d:	00 
  20562e:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  205635:	00 
  205636:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20563d:	00 
  20563e:	ff d2                	call   rdx
  205640:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  205644:	0f 85 33 05 00 00    	jne    205b7d <openSelfDebugInfo+0xfed>
  20564a:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20564e:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  205651:	b8 03 00 00 00       	mov    eax,0x3
  205656:	0f 05                	syscall 
  205658:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20565c:	74 f3                	je     205651 <openSelfDebugInfo+0xac1>
            const first = list.first orelse return null;
  20565e:	48 8b 05 bb f9 00 00 	mov    rax,QWORD PTR [rip+0xf9bb]        # 215020 <emfile_promise_queue>
  205665:	48 85 c0             	test   rax,rax
  205668:	0f 84 0f 05 00 00    	je     205b7d <openSelfDebugInfo+0xfed>
            if (node.prev) |prev_node| {
  20566e:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  205671:	48 85 c9             	test   rcx,rcx
  205674:	0f 84 9f 04 00 00    	je     205b19 <openSelfDebugInfo+0xf89>
                prev_node.next = node.next;
  20567a:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20567e:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  205682:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205686:	e9 99 04 00 00       	jmp    205b24 <openSelfDebugInfo+0xf94>
  20568b:	48 8b 84 24 a0 02 00 	mov    rax,QWORD PTR [rsp+0x2a0]
  205692:	00 
  205693:	48 85 c0             	test   rax,rax
  205696:	0f 84 07 02 00 00    	je     2058a3 <openSelfDebugInfo+0xd13>
  20569c:	48 89 43 68          	mov    QWORD PTR [rbx+0x68],rax
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  2056a0:	48 8d 15 41 ec 00 00 	lea    rdx,[rip+0xec41]        # 2142e8 <__unnamed_41>
  2056a7:	48 8d bc 24 88 02 00 	lea    rdi,[rsp+0x288]
  2056ae:	00 
  2056af:	4c 89 e6             	mov    rsi,r12
  2056b2:	e8 c9 36 00 00       	call   208d80 <Elf_findSection>
  2056b7:	66 83 bc 24 88 02 00 	cmp    WORD PTR [rsp+0x288],0x0
  2056be:	00 00 
  2056c0:	0f 84 58 02 00 00    	je     20591e <openSelfDebugInfo+0xd8e>
        const bytes = @sliceToBytes(memory);
  2056c6:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  2056ca:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2056ce:	74 26                	je     2056f6 <openSelfDebugInfo+0xb66>
  2056d0:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  2056d4:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2056d8:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2056dc:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  2056e3:	00 
  2056e4:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  2056eb:	00 
  2056ec:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  2056f3:	00 
  2056f4:	ff d2                	call   rdx
  2056f6:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  2056fa:	0f 85 df 06 00 00    	jne    205ddf <openSelfDebugInfo+0x124f>
  205700:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  205704:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  205707:	b8 03 00 00 00       	mov    eax,0x3
  20570c:	0f 05                	syscall 
  20570e:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  205712:	74 f3                	je     205707 <openSelfDebugInfo+0xb77>
            const first = list.first orelse return null;
  205714:	48 8b 05 05 f9 00 00 	mov    rax,QWORD PTR [rip+0xf905]        # 215020 <emfile_promise_queue>
  20571b:	48 85 c0             	test   rax,rax
  20571e:	0f 84 bb 06 00 00    	je     205ddf <openSelfDebugInfo+0x124f>
            if (node.prev) |prev_node| {
  205724:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  205727:	48 85 c9             	test   rcx,rcx
  20572a:	0f 84 4b 06 00 00    	je     205d7b <openSelfDebugInfo+0x11eb>
                prev_node.next = node.next;
  205730:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  205734:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  205738:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20573c:	e9 45 06 00 00       	jmp    205d86 <openSelfDebugInfo+0x11f6>
                list.first = node.next;
  205741:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205745:	48 89 0d d4 f8 00 00 	mov    QWORD PTR [rip+0xf8d4],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  20574c:	48 85 c9             	test   rcx,rcx
  20574f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  205752:	48 8d 35 cf f8 00 00 	lea    rsi,[rip+0xf8cf]        # 215028 <emfile_promise_queue+0x8>
  205759:	48 0f 45 f1          	cmovne rsi,rcx
  20575d:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  205760:	48 83 05 c8 f8 00 00 	add    QWORD PTR [rip+0xf8c8],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  205767:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  205768:	74 1e                	je     205788 <openSelfDebugInfo+0xbf8>
  20576a:	48 83 3d ae f8 00 00 	cmp    QWORD PTR [rip+0xf8ae],0x0        # 215020 <emfile_promise_queue>
  205771:	00 
  205772:	0f 84 ea 2a 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  205778:	48 8b 0d a9 f8 00 00 	mov    rcx,QWORD PTR [rip+0xf8a9]        # 215028 <emfile_promise_queue+0x8>
  20577f:	48 85 c9             	test   rcx,rcx
  205782:	0f 84 da 2a 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  205788:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20578c:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  205790:	48 89 c1             	mov    rcx,rax
  205793:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  205797:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20579d:	75 f1                	jne    205790 <openSelfDebugInfo+0xc00>
  20579f:	a8 01                	test   al,0x1
  2057a1:	75 02                	jne    2057a5 <openSelfDebugInfo+0xc15>
  2057a3:	ff 17                	call   QWORD PTR [rdi]
  2057a5:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  2057a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2057af:	00 
  2057b0:	b8 03 00 00 00       	mov    eax,0x3
  2057b5:	0f 05                	syscall 
            switch (err) {
  2057b7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2057bb:	74 f3                	je     2057b0 <openSelfDebugInfo+0xc20>
            const first = list.first orelse return null;
  2057bd:	48 8b 05 5c f8 00 00 	mov    rax,QWORD PTR [rip+0xf85c]        # 215020 <emfile_promise_queue>
  2057c4:	48 85 c0             	test   rax,rax
  2057c7:	74 7c                	je     205845 <openSelfDebugInfo+0xcb5>
            if (node.prev) |prev_node| {
  2057c9:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2057cc:	48 85 c9             	test   rcx,rcx
  2057cf:	74 0e                	je     2057df <openSelfDebugInfo+0xc4f>
                prev_node.next = node.next;
  2057d1:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2057d5:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2057d9:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2057dd:	eb 0b                	jmp    2057ea <openSelfDebugInfo+0xc5a>
                list.first = node.next;
  2057df:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2057e3:	48 89 0d 36 f8 00 00 	mov    QWORD PTR [rip+0xf836],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  2057ea:	48 85 c9             	test   rcx,rcx
  2057ed:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2057f0:	48 8d 35 31 f8 00 00 	lea    rsi,[rip+0xf831]        # 215028 <emfile_promise_queue+0x8>
  2057f7:	48 0f 45 f1          	cmovne rsi,rcx
  2057fb:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2057fe:	48 83 05 2a f8 00 00 	add    QWORD PTR [rip+0xf82a],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  205805:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  205806:	74 1e                	je     205826 <openSelfDebugInfo+0xc96>
  205808:	48 83 3d 10 f8 00 00 	cmp    QWORD PTR [rip+0xf810],0x0        # 215020 <emfile_promise_queue>
  20580f:	00 
  205810:	0f 84 4c 2a 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  205816:	48 8b 0d 0b f8 00 00 	mov    rcx,QWORD PTR [rip+0xf80b]        # 215028 <emfile_promise_queue+0x8>
  20581d:	48 85 c9             	test   rcx,rcx
  205820:	0f 84 3c 2a 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  205826:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20582a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20582e:	66 90                	xchg   ax,ax
  205830:	48 89 c1             	mov    rcx,rax
  205833:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  205837:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20583d:	75 f1                	jne    205830 <openSelfDebugInfo+0xca0>
  20583f:	a8 01                	test   al,0x1
  205841:	75 02                	jne    205845 <openSelfDebugInfo+0xcb5>
  205843:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  205845:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  205849:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  205850:	00 
  205851:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  205858:	00 c8 00 00 00 
  20585d:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  205864:	00 
  205865:	4c 89 ff             	mov    rdi,r15
  205868:	ff d0                	call   rax
            st.debug_info = (try st.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  20586a:	0f b7 84 24 a8 02 00 	movzx  eax,WORD PTR [rsp+0x2a8]
  205871:	00 
  205872:	66 41 89 06          	mov    WORD PTR [r14],ax
  205876:	48 8b 84 24 f0 03 00 	mov    rax,QWORD PTR [rsp+0x3f0]
  20587d:	00 
  20587e:	48 8b 8c 24 f6 03 00 	mov    rcx,QWORD PTR [rsp+0x3f6]
  205885:	00 
  205886:	49 89 4e 08          	mov    QWORD PTR [r14+0x8],rcx
  20588a:	49 89 46 02          	mov    QWORD PTR [r14+0x2],rax
  20588e:	48 81 c4 28 05 00 00 	add    rsp,0x528
  205895:	5b                   	pop    rbx
  205896:	41 5c                	pop    r12
  205898:	41 5d                	pop    r13
  20589a:	41 5e                	pop    r14
  20589c:	41 5f                	pop    r15
  20589e:	5d                   	pop    rbp
  20589f:	c5 f8 77             	vzeroupper 
  2058a2:	c3                   	ret    
        const bytes = @sliceToBytes(memory);
  2058a3:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  2058a7:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2058ab:	74 26                	je     2058d3 <openSelfDebugInfo+0xd43>
  2058ad:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  2058b1:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2058b5:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  2058b9:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  2058c0:	00 
  2058c1:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  2058c8:	00 
  2058c9:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  2058d0:	00 
  2058d1:	ff d2                	call   rdx
  2058d3:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  2058d7:	0f 85 42 06 00 00    	jne    205f1f <openSelfDebugInfo+0x138f>
  2058dd:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  2058e1:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  2058e4:	b8 03 00 00 00       	mov    eax,0x3
  2058e9:	0f 05                	syscall 
            switch (err) {
  2058eb:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2058ef:	74 f3                	je     2058e4 <openSelfDebugInfo+0xd54>
            const first = list.first orelse return null;
  2058f1:	48 8b 05 28 f7 00 00 	mov    rax,QWORD PTR [rip+0xf728]        # 215020 <emfile_promise_queue>
  2058f8:	48 85 c0             	test   rax,rax
  2058fb:	0f 84 1e 06 00 00    	je     205f1f <openSelfDebugInfo+0x138f>
            if (node.prev) |prev_node| {
  205901:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  205904:	48 85 c9             	test   rcx,rcx
  205907:	0f 84 ae 05 00 00    	je     205ebb <openSelfDebugInfo+0x132b>
                prev_node.next = node.next;
  20590d:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  205911:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  205915:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205919:	e9 a8 05 00 00       	jmp    205ec6 <openSelfDebugInfo+0x1336>
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  20591e:	48 8b 84 24 90 02 00 	mov    rax,QWORD PTR [rsp+0x290]
  205925:	00 
  205926:	48 85 c0             	test   rax,rax
  205929:	0f 84 1b 03 00 00    	je     205c4a <openSelfDebugInfo+0x10ba>
  20592f:	48 89 43 70          	mov    QWORD PTR [rbx+0x70],rax
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  205933:	48 8d 15 be e9 00 00 	lea    rdx,[rip+0xe9be]        # 2142f8 <__unnamed_42>
  20593a:	48 8d bc 24 78 02 00 	lea    rdi,[rsp+0x278]
  205941:	00 
  205942:	4c 89 e6             	mov    rsi,r12
  205945:	e8 36 34 00 00       	call   208d80 <Elf_findSection>
  20594a:	66 83 bc 24 78 02 00 	cmp    WORD PTR [rsp+0x278],0x0
  205951:	00 00 
  205953:	0f 84 6c 03 00 00    	je     205cc5 <openSelfDebugInfo+0x1135>
        const bytes = @sliceToBytes(memory);
  205959:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20595d:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  205961:	74 26                	je     205989 <openSelfDebugInfo+0xdf9>
  205963:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  205967:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20596b:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20596f:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  205976:	00 
  205977:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20597e:	00 
  20597f:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  205986:	00 
  205987:	ff d2                	call   rdx
  205989:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20598d:	0f 85 d8 14 00 00    	jne    206e6b <openSelfDebugInfo+0x22db>
  205993:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  205997:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20599a:	b8 03 00 00 00       	mov    eax,0x3
  20599f:	0f 05                	syscall 
  2059a1:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2059a5:	74 f3                	je     20599a <openSelfDebugInfo+0xe0a>
            const first = list.first orelse return null;
  2059a7:	48 8b 05 72 f6 00 00 	mov    rax,QWORD PTR [rip+0xf672]        # 215020 <emfile_promise_queue>
  2059ae:	48 85 c0             	test   rax,rax
  2059b1:	0f 84 b4 14 00 00    	je     206e6b <openSelfDebugInfo+0x22db>
            if (node.prev) |prev_node| {
  2059b7:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2059ba:	48 85 c9             	test   rcx,rcx
  2059bd:	0f 84 44 14 00 00    	je     206e07 <openSelfDebugInfo+0x2277>
                prev_node.next = node.next;
  2059c3:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2059c7:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2059cb:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2059cf:	e9 3e 14 00 00       	jmp    206e12 <openSelfDebugInfo+0x2282>
                list.first = node.next;
  2059d4:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2059d8:	48 89 0d 41 f6 00 00 	mov    QWORD PTR [rip+0xf641],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  2059df:	48 85 c9             	test   rcx,rcx
  2059e2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2059e5:	48 8d 35 3c f6 00 00 	lea    rsi,[rip+0xf63c]        # 215028 <emfile_promise_queue+0x8>
  2059ec:	48 0f 45 f1          	cmovne rsi,rcx
  2059f0:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2059f3:	48 83 05 35 f6 00 00 	add    QWORD PTR [rip+0xf635],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  2059fa:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2059fb:	74 1e                	je     205a1b <openSelfDebugInfo+0xe8b>
  2059fd:	48 83 3d 1b f6 00 00 	cmp    QWORD PTR [rip+0xf61b],0x0        # 215020 <emfile_promise_queue>
  205a04:	00 
  205a05:	0f 84 57 28 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  205a0b:	48 8b 0d 16 f6 00 00 	mov    rcx,QWORD PTR [rip+0xf616]        # 215028 <emfile_promise_queue+0x8>
  205a12:	48 85 c9             	test   rcx,rcx
  205a15:	0f 84 47 28 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  205a1b:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  205a1f:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  205a23:	48 89 c1             	mov    rcx,rax
  205a26:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  205a2a:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  205a30:	75 f1                	jne    205a23 <openSelfDebugInfo+0xe93>
  205a32:	a8 01                	test   al,0x1
  205a34:	75 02                	jne    205a38 <openSelfDebugInfo+0xea8>
  205a36:	ff 17                	call   QWORD PTR [rdi]
  205a38:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  205a3b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  205a40:	b8 03 00 00 00       	mov    eax,0x3
  205a45:	0f 05                	syscall 
            switch (err) {
  205a47:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  205a4b:	74 f3                	je     205a40 <openSelfDebugInfo+0xeb0>
            const first = list.first orelse return null;
  205a4d:	48 8b 05 cc f5 00 00 	mov    rax,QWORD PTR [rip+0xf5cc]        # 215020 <emfile_promise_queue>
  205a54:	48 85 c0             	test   rax,rax
  205a57:	74 7a                	je     205ad3 <openSelfDebugInfo+0xf43>
            if (node.prev) |prev_node| {
  205a59:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  205a5c:	48 85 c9             	test   rcx,rcx
  205a5f:	74 0e                	je     205a6f <openSelfDebugInfo+0xedf>
                prev_node.next = node.next;
  205a61:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  205a65:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  205a69:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205a6d:	eb 0b                	jmp    205a7a <openSelfDebugInfo+0xeea>
                list.first = node.next;
  205a6f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205a73:	48 89 0d a6 f5 00 00 	mov    QWORD PTR [rip+0xf5a6],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  205a7a:	48 85 c9             	test   rcx,rcx
  205a7d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  205a80:	48 8d 35 a1 f5 00 00 	lea    rsi,[rip+0xf5a1]        # 215028 <emfile_promise_queue+0x8>
  205a87:	48 0f 45 f1          	cmovne rsi,rcx
  205a8b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  205a8e:	48 83 05 9a f5 00 00 	add    QWORD PTR [rip+0xf59a],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  205a95:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  205a96:	74 1e                	je     205ab6 <openSelfDebugInfo+0xf26>
  205a98:	48 83 3d 80 f5 00 00 	cmp    QWORD PTR [rip+0xf580],0x0        # 215020 <emfile_promise_queue>
  205a9f:	00 
  205aa0:	0f 84 bc 27 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  205aa6:	48 8b 0d 7b f5 00 00 	mov    rcx,QWORD PTR [rip+0xf57b]        # 215028 <emfile_promise_queue+0x8>
  205aad:	48 85 c9             	test   rcx,rcx
  205ab0:	0f 84 ac 27 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  205ab6:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  205aba:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  205abe:	48 89 c1             	mov    rcx,rax
  205ac1:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  205ac5:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  205acb:	75 f1                	jne    205abe <openSelfDebugInfo+0xf2e>
  205acd:	a8 01                	test   al,0x1
  205acf:	75 02                	jne    205ad3 <openSelfDebugInfo+0xf43>
  205ad1:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  205ad3:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  205ad7:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  205ade:	00 
  205adf:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  205ae6:	00 c8 00 00 00 
  205aeb:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  205af2:	00 
  205af3:	4c 89 ff             	mov    rdi,r15
  205af6:	ff d0                	call   rax
            st.debug_abbrev = (try st.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  205af8:	0f b7 84 24 98 02 00 	movzx  eax,WORD PTR [rsp+0x298]
  205aff:	00 
  205b00:	66 41 89 06          	mov    WORD PTR [r14],ax
  205b04:	48 8b 84 24 e2 03 00 	mov    rax,QWORD PTR [rsp+0x3e2]
  205b0b:	00 
  205b0c:	48 8b 8c 24 e8 03 00 	mov    rcx,QWORD PTR [rsp+0x3e8]
  205b13:	00 
  205b14:	e9 6d fd ff ff       	jmp    205886 <openSelfDebugInfo+0xcf6>
                list.first = node.next;
  205b19:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205b1d:	48 89 0d fc f4 00 00 	mov    QWORD PTR [rip+0xf4fc],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  205b24:	48 85 c9             	test   rcx,rcx
  205b27:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  205b2a:	48 8d 35 f7 f4 00 00 	lea    rsi,[rip+0xf4f7]        # 215028 <emfile_promise_queue+0x8>
  205b31:	48 0f 45 f1          	cmovne rsi,rcx
  205b35:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  205b38:	48 83 05 f0 f4 00 00 	add    QWORD PTR [rip+0xf4f0],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  205b3f:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  205b40:	74 1e                	je     205b60 <openSelfDebugInfo+0xfd0>
  205b42:	48 83 3d d6 f4 00 00 	cmp    QWORD PTR [rip+0xf4d6],0x0        # 215020 <emfile_promise_queue>
  205b49:	00 
  205b4a:	0f 84 12 27 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  205b50:	48 8b 0d d1 f4 00 00 	mov    rcx,QWORD PTR [rip+0xf4d1]        # 215028 <emfile_promise_queue+0x8>
  205b57:	48 85 c9             	test   rcx,rcx
  205b5a:	0f 84 02 27 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  205b60:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  205b64:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  205b68:	48 89 c1             	mov    rcx,rax
  205b6b:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  205b6f:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  205b75:	75 f1                	jne    205b68 <openSelfDebugInfo+0xfd8>
  205b77:	a8 01                	test   al,0x1
  205b79:	75 02                	jne    205b7d <openSelfDebugInfo+0xfed>
  205b7b:	ff 17                	call   QWORD PTR [rdi]
  205b7d:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  205b80:	b8 03 00 00 00       	mov    eax,0x3
  205b85:	0f 05                	syscall 
            switch (err) {
  205b87:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  205b8b:	74 f3                	je     205b80 <openSelfDebugInfo+0xff0>
            const first = list.first orelse return null;
  205b8d:	48 8b 05 8c f4 00 00 	mov    rax,QWORD PTR [rip+0xf48c]        # 215020 <emfile_promise_queue>
  205b94:	48 85 c0             	test   rax,rax
  205b97:	74 7a                	je     205c13 <openSelfDebugInfo+0x1083>
            if (node.prev) |prev_node| {
  205b99:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  205b9c:	48 85 c9             	test   rcx,rcx
  205b9f:	74 0e                	je     205baf <openSelfDebugInfo+0x101f>
                prev_node.next = node.next;
  205ba1:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  205ba5:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  205ba9:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205bad:	eb 0b                	jmp    205bba <openSelfDebugInfo+0x102a>
                list.first = node.next;
  205baf:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205bb3:	48 89 0d 66 f4 00 00 	mov    QWORD PTR [rip+0xf466],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  205bba:	48 85 c9             	test   rcx,rcx
  205bbd:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  205bc0:	48 8d 35 61 f4 00 00 	lea    rsi,[rip+0xf461]        # 215028 <emfile_promise_queue+0x8>
  205bc7:	48 0f 45 f1          	cmovne rsi,rcx
  205bcb:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  205bce:	48 83 05 5a f4 00 00 	add    QWORD PTR [rip+0xf45a],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  205bd5:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  205bd6:	74 1e                	je     205bf6 <openSelfDebugInfo+0x1066>
  205bd8:	48 83 3d 40 f4 00 00 	cmp    QWORD PTR [rip+0xf440],0x0        # 215020 <emfile_promise_queue>
  205bdf:	00 
  205be0:	0f 84 7c 26 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  205be6:	48 8b 0d 3b f4 00 00 	mov    rcx,QWORD PTR [rip+0xf43b]        # 215028 <emfile_promise_queue+0x8>
  205bed:	48 85 c9             	test   rcx,rcx
  205bf0:	0f 84 6c 26 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  205bf6:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  205bfa:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  205bfe:	48 89 c1             	mov    rcx,rax
  205c01:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  205c05:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  205c0b:	75 f1                	jne    205bfe <openSelfDebugInfo+0x106e>
  205c0d:	a8 01                	test   al,0x1
  205c0f:	75 02                	jne    205c13 <openSelfDebugInfo+0x1083>
  205c11:	ff 17                	call   QWORD PTR [rdi]
  205c13:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  205c17:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  205c1e:	00 
  205c1f:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  205c26:	00 c8 00 00 00 
  205c2b:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  205c32:	00 
  205c33:	4c 89 ff             	mov    rdi,r15
  205c36:	ff d0                	call   rax
  205c38:	c5 fa 6f 05 70 c9 ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffc970]        # 2025b0 <__unnamed_43>
  205c3f:	ff 
  205c40:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  205c45:	e9 44 fc ff ff       	jmp    20588e <openSelfDebugInfo+0xcfe>
        const bytes = @sliceToBytes(memory);
  205c4a:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  205c4e:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  205c52:	74 26                	je     205c7a <openSelfDebugInfo+0x10ea>
  205c54:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  205c58:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  205c5c:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  205c60:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  205c67:	00 
  205c68:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  205c6f:	00 
  205c70:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  205c77:	00 
  205c78:	ff d2                	call   rdx
  205c7a:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  205c7e:	0f 85 27 13 00 00    	jne    206fab <openSelfDebugInfo+0x241b>
  205c84:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  205c88:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  205c8b:	b8 03 00 00 00       	mov    eax,0x3
  205c90:	0f 05                	syscall 
            switch (err) {
  205c92:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  205c96:	74 f3                	je     205c8b <openSelfDebugInfo+0x10fb>
            const first = list.first orelse return null;
  205c98:	48 8b 05 81 f3 00 00 	mov    rax,QWORD PTR [rip+0xf381]        # 215020 <emfile_promise_queue>
  205c9f:	48 85 c0             	test   rax,rax
  205ca2:	0f 84 03 13 00 00    	je     206fab <openSelfDebugInfo+0x241b>
            if (node.prev) |prev_node| {
  205ca8:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  205cab:	48 85 c9             	test   rcx,rcx
  205cae:	0f 84 93 12 00 00    	je     206f47 <openSelfDebugInfo+0x23b7>
                prev_node.next = node.next;
  205cb4:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  205cb8:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  205cbc:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205cc0:	e9 8d 12 00 00       	jmp    206f52 <openSelfDebugInfo+0x23c2>
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  205cc5:	48 8b 84 24 80 02 00 	mov    rax,QWORD PTR [rsp+0x280]
  205ccc:	00 
  205ccd:	48 85 c0             	test   rax,rax
  205cd0:	0f 84 e2 02 00 00    	je     205fb8 <openSelfDebugInfo+0x1428>
  205cd6:	48 89 43 78          	mov    QWORD PTR [rbx+0x78],rax
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  205cda:	48 8d 15 27 e6 00 00 	lea    rdx,[rip+0xe627]        # 214308 <__unnamed_44>
  205ce1:	48 8d bc 24 68 02 00 	lea    rdi,[rsp+0x268]
  205ce8:	00 
  205ce9:	4c 89 e6             	mov    rsi,r12
  205cec:	e8 8f 30 00 00       	call   208d80 <Elf_findSection>
  205cf1:	66 83 bc 24 68 02 00 	cmp    WORD PTR [rsp+0x268],0x0
  205cf8:	00 00 
  205cfa:	0f 84 33 03 00 00    	je     206033 <openSelfDebugInfo+0x14a3>
        const bytes = @sliceToBytes(memory);
  205d00:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  205d04:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  205d08:	74 26                	je     205d30 <openSelfDebugInfo+0x11a0>
  205d0a:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  205d0e:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  205d12:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  205d16:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  205d1d:	00 
  205d1e:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  205d25:	00 
  205d26:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  205d2d:	00 
  205d2e:	ff d2                	call   rdx
  205d30:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  205d34:	0f 85 a2 13 00 00    	jne    2070dc <openSelfDebugInfo+0x254c>
  205d3a:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  205d3e:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  205d41:	b8 03 00 00 00       	mov    eax,0x3
  205d46:	0f 05                	syscall 
  205d48:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  205d4c:	74 f3                	je     205d41 <openSelfDebugInfo+0x11b1>
            const first = list.first orelse return null;
  205d4e:	48 8b 05 cb f2 00 00 	mov    rax,QWORD PTR [rip+0xf2cb]        # 215020 <emfile_promise_queue>
  205d55:	48 85 c0             	test   rax,rax
  205d58:	0f 84 7e 13 00 00    	je     2070dc <openSelfDebugInfo+0x254c>
            if (node.prev) |prev_node| {
  205d5e:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  205d61:	48 85 c9             	test   rcx,rcx
  205d64:	0f 84 0e 13 00 00    	je     207078 <openSelfDebugInfo+0x24e8>
                prev_node.next = node.next;
  205d6a:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  205d6e:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  205d72:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205d76:	e9 08 13 00 00       	jmp    207083 <openSelfDebugInfo+0x24f3>
                list.first = node.next;
  205d7b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205d7f:	48 89 0d 9a f2 00 00 	mov    QWORD PTR [rip+0xf29a],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  205d86:	48 85 c9             	test   rcx,rcx
  205d89:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  205d8c:	48 8d 35 95 f2 00 00 	lea    rsi,[rip+0xf295]        # 215028 <emfile_promise_queue+0x8>
  205d93:	48 0f 45 f1          	cmovne rsi,rcx
  205d97:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  205d9a:	48 83 05 8e f2 00 00 	add    QWORD PTR [rip+0xf28e],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  205da1:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  205da2:	74 1e                	je     205dc2 <openSelfDebugInfo+0x1232>
  205da4:	48 83 3d 74 f2 00 00 	cmp    QWORD PTR [rip+0xf274],0x0        # 215020 <emfile_promise_queue>
  205dab:	00 
  205dac:	0f 84 b0 24 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  205db2:	48 8b 0d 6f f2 00 00 	mov    rcx,QWORD PTR [rip+0xf26f]        # 215028 <emfile_promise_queue+0x8>
  205db9:	48 85 c9             	test   rcx,rcx
  205dbc:	0f 84 a0 24 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  205dc2:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  205dc6:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  205dca:	48 89 c1             	mov    rcx,rax
  205dcd:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  205dd1:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  205dd7:	75 f1                	jne    205dca <openSelfDebugInfo+0x123a>
  205dd9:	a8 01                	test   al,0x1
  205ddb:	75 02                	jne    205ddf <openSelfDebugInfo+0x124f>
  205ddd:	ff 17                	call   QWORD PTR [rdi]
  205ddf:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  205de2:	b8 03 00 00 00       	mov    eax,0x3
  205de7:	0f 05                	syscall 
            switch (err) {
  205de9:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  205ded:	74 f3                	je     205de2 <openSelfDebugInfo+0x1252>
            const first = list.first orelse return null;
  205def:	48 8b 05 2a f2 00 00 	mov    rax,QWORD PTR [rip+0xf22a]        # 215020 <emfile_promise_queue>
  205df6:	48 85 c0             	test   rax,rax
  205df9:	74 7a                	je     205e75 <openSelfDebugInfo+0x12e5>
            if (node.prev) |prev_node| {
  205dfb:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  205dfe:	48 85 c9             	test   rcx,rcx
  205e01:	74 0e                	je     205e11 <openSelfDebugInfo+0x1281>
                prev_node.next = node.next;
  205e03:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  205e07:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  205e0b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205e0f:	eb 0b                	jmp    205e1c <openSelfDebugInfo+0x128c>
                list.first = node.next;
  205e11:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205e15:	48 89 0d 04 f2 00 00 	mov    QWORD PTR [rip+0xf204],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  205e1c:	48 85 c9             	test   rcx,rcx
  205e1f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  205e22:	48 8d 35 ff f1 00 00 	lea    rsi,[rip+0xf1ff]        # 215028 <emfile_promise_queue+0x8>
  205e29:	48 0f 45 f1          	cmovne rsi,rcx
  205e2d:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  205e30:	48 83 05 f8 f1 00 00 	add    QWORD PTR [rip+0xf1f8],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  205e37:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  205e38:	74 1e                	je     205e58 <openSelfDebugInfo+0x12c8>
  205e3a:	48 83 3d de f1 00 00 	cmp    QWORD PTR [rip+0xf1de],0x0        # 215020 <emfile_promise_queue>
  205e41:	00 
  205e42:	0f 84 1a 24 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  205e48:	48 8b 0d d9 f1 00 00 	mov    rcx,QWORD PTR [rip+0xf1d9]        # 215028 <emfile_promise_queue+0x8>
  205e4f:	48 85 c9             	test   rcx,rcx
  205e52:	0f 84 0a 24 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  205e58:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  205e5c:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  205e60:	48 89 c1             	mov    rcx,rax
  205e63:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  205e67:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  205e6d:	75 f1                	jne    205e60 <openSelfDebugInfo+0x12d0>
  205e6f:	a8 01                	test   al,0x1
  205e71:	75 02                	jne    205e75 <openSelfDebugInfo+0x12e5>
  205e73:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  205e75:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  205e79:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  205e80:	00 
  205e81:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  205e88:	00 c8 00 00 00 
  205e8d:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  205e94:	00 
  205e95:	4c 89 ff             	mov    rdi,r15
  205e98:	ff d0                	call   rax
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  205e9a:	0f b7 84 24 88 02 00 	movzx  eax,WORD PTR [rsp+0x288]
  205ea1:	00 
  205ea2:	66 41 89 06          	mov    WORD PTR [r14],ax
  205ea6:	48 8b 84 24 d4 03 00 	mov    rax,QWORD PTR [rsp+0x3d4]
  205ead:	00 
  205eae:	48 8b 8c 24 da 03 00 	mov    rcx,QWORD PTR [rsp+0x3da]
  205eb5:	00 
  205eb6:	e9 cb f9 ff ff       	jmp    205886 <openSelfDebugInfo+0xcf6>
                list.first = node.next;
  205ebb:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205ebf:	48 89 0d 5a f1 00 00 	mov    QWORD PTR [rip+0xf15a],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  205ec6:	48 85 c9             	test   rcx,rcx
  205ec9:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  205ecc:	48 8d 35 55 f1 00 00 	lea    rsi,[rip+0xf155]        # 215028 <emfile_promise_queue+0x8>
  205ed3:	48 0f 45 f1          	cmovne rsi,rcx
  205ed7:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  205eda:	48 83 05 4e f1 00 00 	add    QWORD PTR [rip+0xf14e],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  205ee1:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  205ee2:	74 1e                	je     205f02 <openSelfDebugInfo+0x1372>
  205ee4:	48 83 3d 34 f1 00 00 	cmp    QWORD PTR [rip+0xf134],0x0        # 215020 <emfile_promise_queue>
  205eeb:	00 
  205eec:	0f 84 70 23 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  205ef2:	48 8b 0d 2f f1 00 00 	mov    rcx,QWORD PTR [rip+0xf12f]        # 215028 <emfile_promise_queue+0x8>
  205ef9:	48 85 c9             	test   rcx,rcx
  205efc:	0f 84 60 23 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  205f02:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  205f06:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  205f0a:	48 89 c1             	mov    rcx,rax
  205f0d:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  205f11:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  205f17:	75 f1                	jne    205f0a <openSelfDebugInfo+0x137a>
  205f19:	a8 01                	test   al,0x1
  205f1b:	75 02                	jne    205f1f <openSelfDebugInfo+0x138f>
  205f1d:	ff 17                	call   QWORD PTR [rdi]
  205f1f:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  205f22:	b8 03 00 00 00       	mov    eax,0x3
  205f27:	0f 05                	syscall 
            switch (err) {
  205f29:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  205f2d:	74 f3                	je     205f22 <openSelfDebugInfo+0x1392>
            const first = list.first orelse return null;
  205f2f:	48 8b 05 ea f0 00 00 	mov    rax,QWORD PTR [rip+0xf0ea]        # 215020 <emfile_promise_queue>
  205f36:	48 85 c0             	test   rax,rax
  205f39:	0f 84 d4 fc ff ff    	je     205c13 <openSelfDebugInfo+0x1083>
            if (node.prev) |prev_node| {
  205f3f:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  205f42:	48 85 c9             	test   rcx,rcx
  205f45:	74 0e                	je     205f55 <openSelfDebugInfo+0x13c5>
                prev_node.next = node.next;
  205f47:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  205f4b:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  205f4f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205f53:	eb 0b                	jmp    205f60 <openSelfDebugInfo+0x13d0>
                list.first = node.next;
  205f55:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  205f59:	48 89 0d c0 f0 00 00 	mov    QWORD PTR [rip+0xf0c0],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  205f60:	48 85 c9             	test   rcx,rcx
  205f63:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  205f66:	48 8d 35 bb f0 00 00 	lea    rsi,[rip+0xf0bb]        # 215028 <emfile_promise_queue+0x8>
  205f6d:	48 0f 45 f1          	cmovne rsi,rcx
  205f71:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  205f74:	48 83 05 b4 f0 00 00 	add    QWORD PTR [rip+0xf0b4],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  205f7b:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  205f7c:	74 1e                	je     205f9c <openSelfDebugInfo+0x140c>
  205f7e:	48 83 3d 9a f0 00 00 	cmp    QWORD PTR [rip+0xf09a],0x0        # 215020 <emfile_promise_queue>
  205f85:	00 
  205f86:	0f 84 d6 22 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  205f8c:	48 8b 0d 95 f0 00 00 	mov    rcx,QWORD PTR [rip+0xf095]        # 215028 <emfile_promise_queue+0x8>
  205f93:	48 85 c9             	test   rcx,rcx
  205f96:	0f 84 c6 22 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  205f9c:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  205fa0:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  205fa4:	48 89 c1             	mov    rcx,rax
  205fa7:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  205fab:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  205fb1:	75 f1                	jne    205fa4 <openSelfDebugInfo+0x1414>
  205fb3:	e9 55 fc ff ff       	jmp    205c0d <openSelfDebugInfo+0x107d>
        const bytes = @sliceToBytes(memory);
  205fb8:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  205fbc:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  205fc0:	74 26                	je     205fe8 <openSelfDebugInfo+0x1458>
  205fc2:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  205fc6:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  205fca:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  205fce:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  205fd5:	00 
  205fd6:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  205fdd:	00 
  205fde:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  205fe5:	00 
  205fe6:	ff d2                	call   rdx
  205fe8:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  205fec:	0f 85 2a 12 00 00    	jne    20721c <openSelfDebugInfo+0x268c>
  205ff2:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  205ff6:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  205ff9:	b8 03 00 00 00       	mov    eax,0x3
  205ffe:	0f 05                	syscall 
            switch (err) {
  206000:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  206004:	74 f3                	je     205ff9 <openSelfDebugInfo+0x1469>
            const first = list.first orelse return null;
  206006:	48 8b 05 13 f0 00 00 	mov    rax,QWORD PTR [rip+0xf013]        # 215020 <emfile_promise_queue>
  20600d:	48 85 c0             	test   rax,rax
  206010:	0f 84 06 12 00 00    	je     20721c <openSelfDebugInfo+0x268c>
            if (node.prev) |prev_node| {
  206016:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  206019:	48 85 c9             	test   rcx,rcx
  20601c:	0f 84 96 11 00 00    	je     2071b8 <openSelfDebugInfo+0x2628>
                prev_node.next = node.next;
  206022:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  206026:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20602a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20602e:	e9 90 11 00 00       	jmp    2071c3 <openSelfDebugInfo+0x2633>
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  206033:	48 8b 84 24 70 02 00 	mov    rax,QWORD PTR [rsp+0x270]
  20603a:	00 
  20603b:	48 89 83 80 00 00 00 	mov    QWORD PTR [rbx+0x80],rax
    const debug_info_end = st.debug_info.offset + st.debug_info.size;
  206042:	48 8b 43 60          	mov    rax,QWORD PTR [rbx+0x60]
  206046:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  20604a:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  20604f:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  206053:	48 89 9c 24 40 01 00 	mov    QWORD PTR [rsp+0x140],rbx
  20605a:	00 
  20605b:	48 8d 05 5e 36 00 00 	lea    rax,[rip+0x365e]        # 2096c0 <FileInStream_readFn>
  206062:	48 89 84 24 48 01 00 	mov    QWORD PTR [rsp+0x148],rax
  206069:	00 
  20606a:	48 89 4c 24 50       	mov    QWORD PTR [rsp+0x50],rcx
    while (this_unit_offset < debug_info_end) {
  20606f:	48 85 c9             	test   rcx,rcx
  206072:	0f 84 cc 0f 00 00    	je     207044 <openSelfDebugInfo+0x24b4>
  206078:	48 8d 83 88 00 00 00 	lea    rax,[rbx+0x88]
  20607f:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  206084:	48 8d 83 a8 00 00 00 	lea    rax,[rbx+0xa8]
  20608b:	48 89 84 24 78 01 00 	mov    QWORD PTR [rsp+0x178],rax
  206092:	00 
  206093:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  206098:	48 01 44 24 50       	add    QWORD PTR [rsp+0x50],rax
  20609d:	66 c7 84 24 9e 00 00 	mov    WORD PTR [rsp+0x9e],0x1c
  2060a4:	00 1c 00 
  2060a7:	c4 e2 7d 19 05 58 a1 	vbroadcastsd ymm0,QWORD PTR [rip+0xffffffffffffa158]        # 200208 <app_mask-0x18>
  2060ae:	ff ff 
  2060b0:	c5 fc 11 84 24 80 04 	vmovups YMMWORD PTR [rsp+0x480],ymm0
  2060b7:	00 00 
  2060b9:	c4 e2 7d 59 05 7e a1 	vpbroadcastq ymm0,QWORD PTR [rip+0xffffffffffffa17e]        # 200240 <app_mask+0x20>
  2060c0:	ff ff 
  2060c2:	c5 fe 7f 84 24 60 04 	vmovdqu YMMWORD PTR [rsp+0x460],ymm0
  2060c9:	00 00 
  2060cb:	66 c7 44 24 04 05 00 	mov    WORD PTR [rsp+0x4],0x5
  2060d2:	31 c0                	xor    eax,eax
  2060d4:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  2060db:	00 
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  2060dc:	48 83 7c 24 38 00    	cmp    QWORD PTR [rsp+0x38],0x0
  2060e2:	0f 88 08 14 00 00    	js     2074f0 <openSelfDebugInfo+0x2960>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2060e8:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
    return asm volatile ("syscall"
  2060eb:	b8 08 00 00 00       	mov    eax,0x8
  2060f0:	31 d2                	xor    edx,edx
  2060f2:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  2060f7:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2060f9:	48 89 c1             	mov    rcx,rax
  2060fc:	48 f7 d9             	neg    rcx
  2060ff:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  206105:	b8 00 00 00 00       	mov    eax,0x0
  20610a:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  20610e:	48 85 c9             	test   rcx,rcx
  206111:	0f 85 01 14 00 00    	jne    207518 <openSelfDebugInfo+0x2988>
            try self.readNoEof(bytes[0..]);
  206117:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20611c:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  206121:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  206128:	00 00 
            return self.readFn(self, buffer);
  20612a:	4c 89 ef             	mov    rdi,r13
  20612d:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  206134:	00 
  206135:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20613a:	c5 f8 77             	vzeroupper 
  20613d:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  206144:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20614b:	00 
  20614c:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20614e:	66 85 c9             	test   cx,cx
  206151:	0f 85 51 13 00 00    	jne    2074a8 <openSelfDebugInfo+0x2918>
  206157:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20615e:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20615f:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  206164:	0f 82 3a 13 00 00    	jb     2074a4 <openSelfDebugInfo+0x2914>
  20616a:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20616f:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  206174:	48 c1 e1 08          	shl    rcx,0x8
  206178:	48 09 c1             	or     rcx,rax
  20617b:	0f b6 44 24 0a       	movzx  eax,BYTE PTR [rsp+0xa]
  206180:	48 c1 e0 10          	shl    rax,0x10
  206184:	48 09 c8             	or     rax,rcx
  206187:	0f b6 4c 24 0b       	movzx  ecx,BYTE PTR [rsp+0xb]
  20618c:	48 c1 e1 18          	shl    rcx,0x18
  206190:	48 09 c1             	or     rcx,rax
  206193:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
    is_64.* = (first_32_bits == 0xffffffff);
  206198:	83 f9 ff             	cmp    ecx,0xffffffff
    if (is_64.*) {
  20619b:	74 20                	je     2061bd <openSelfDebugInfo+0x162d>
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  20619d:	83 7c 24 48 ef       	cmp    DWORD PTR [rsp+0x48],0xffffffef
  2061a2:	0f 87 5c 13 00 00    	ja     207504 <openSelfDebugInfo+0x2974>
  2061a8:	c7 44 24 40 00 00 00 	mov    DWORD PTR [rsp+0x40],0x0
  2061af:	00 
        if (unit_length == 0) return;
  2061b0:	48 83 7c 24 48 00    	cmp    QWORD PTR [rsp+0x48],0x0
  2061b6:	75 77                	jne    20622f <openSelfDebugInfo+0x169f>
  2061b8:	e9 87 0e 00 00       	jmp    207044 <openSelfDebugInfo+0x24b4>
            try self.readNoEof(bytes[0..]);
  2061bd:	48 8d 84 24 b8 02 00 	lea    rax,[rsp+0x2b8]
  2061c4:	00 
  2061c5:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  2061ca:	48 c7 44 24 68 08 00 	mov    QWORD PTR [rsp+0x68],0x8
  2061d1:	00 00 
            return self.readFn(self, buffer);
  2061d3:	4c 89 ef             	mov    rdi,r13
  2061d6:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  2061dd:	00 
  2061de:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  2061e3:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  2061ea:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  2061f1:	00 
  2061f2:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  2061f4:	66 85 c9             	test   cx,cx
  2061f7:	0f 85 ab 12 00 00    	jne    2074a8 <openSelfDebugInfo+0x2918>
  2061fd:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  206204:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  206205:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20620a:	0f 82 94 12 00 00    	jb     2074a4 <openSelfDebugInfo+0x2914>
  206210:	48 8b 84 24 b8 02 00 	mov    rax,QWORD PTR [rsp+0x2b8]
  206217:	00 
  206218:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  20621d:	b0 01                	mov    al,0x1
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  20621f:	89 44 24 40          	mov    DWORD PTR [rsp+0x40],eax
        if (unit_length == 0) return;
  206223:	48 83 7c 24 48 00    	cmp    QWORD PTR [rsp+0x48],0x0
  206229:	0f 84 15 0e 00 00    	je     207044 <openSelfDebugInfo+0x24b4>
        const version = try in_stream.readInt(st.elf.endian, u16);
  20622f:	40 8a 6b 12          	mov    bpl,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  206233:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  206238:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20623d:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  206244:	00 00 
            return self.readFn(self, buffer);
  206246:	4c 89 ef             	mov    rdi,r13
  206249:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  206250:	00 
  206251:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  206256:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  20625d:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  206264:	00 
  206265:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  206267:	66 85 c9             	test   cx,cx
  20626a:	0f 85 38 12 00 00    	jne    2074a8 <openSelfDebugInfo+0x2918>
  206270:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  206277:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  206278:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20627d:	0f 82 21 12 00 00    	jb     2074a4 <openSelfDebugInfo+0x2914>
  206283:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
  206288:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  20628d:	89 c1                	mov    ecx,eax
  20628f:	c1 e1 08             	shl    ecx,0x8
  206292:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  206294:	c1 e2 08             	shl    edx,0x8
  206297:	09 c2                	or     edx,eax
    switch (endian) {
  206299:	40 f6 c5 01          	test   bpl,0x1
  20629d:	66 0f 45 d1          	cmovne dx,cx
  2062a1:	48 89 94 24 60 02 00 	mov    QWORD PTR [rsp+0x260],rdx
  2062a8:	00 
        if (version < 2 or version > 5) return error.InvalidDebugInfo;
  2062a9:	8d 42 fe             	lea    eax,[rdx-0x2]
  2062ac:	0f b7 c0             	movzx  eax,ax
  2062af:	83 f8 03             	cmp    eax,0x3
  2062b2:	0f 87 4c 12 00 00    	ja     207504 <openSelfDebugInfo+0x2974>
  2062b8:	40 8a 6b 12          	mov    bpl,BYTE PTR [rbx+0x12]
        const debug_abbrev_offset = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  2062bc:	80 7c 24 40 00       	cmp    BYTE PTR [rsp+0x40],0x0
  2062c1:	74 37                	je     2062fa <openSelfDebugInfo+0x176a>
  2062c3:	40 0f b6 d5          	movzx  edx,bpl
  2062c7:	48 8d bc 24 38 03 00 	lea    rdi,[rsp+0x338]
  2062ce:	00 
  2062cf:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  2062d6:	00 
  2062d7:	e8 a4 31 00 00       	call   209480 <InStream(ReadError)_readInt.16>
  2062dc:	0f b7 bc 24 38 03 00 	movzx  edi,WORD PTR [rsp+0x338]
  2062e3:	00 
  2062e4:	66 85 ff             	test   di,di
  2062e7:	0f 85 f8 0f 00 00    	jne    2072e5 <openSelfDebugInfo+0x2755>
  2062ed:	48 8b 84 24 40 03 00 	mov    rax,QWORD PTR [rsp+0x340]
  2062f4:	00 
  2062f5:	e9 96 00 00 00       	jmp    206390 <openSelfDebugInfo+0x1800>
            try self.readNoEof(bytes[0..]);
  2062fa:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2062ff:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  206304:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20630b:	00 00 
            return self.readFn(self, buffer);
  20630d:	4c 89 ef             	mov    rdi,r13
  206310:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  206317:	00 
  206318:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20631d:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  206324:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20632b:	00 
  20632c:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20632e:	66 85 c9             	test   cx,cx
  206331:	0f 85 71 11 00 00    	jne    2074a8 <openSelfDebugInfo+0x2918>
  206337:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20633e:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20633f:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  206344:	0f 82 5a 11 00 00    	jb     2074a4 <openSelfDebugInfo+0x2914>
  20634a:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20634f:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  206354:	40 f6 c5 01          	test   bpl,0x1
  206358:	74 1b                	je     206375 <openSelfDebugInfo+0x17e5>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20635a:	c1 e1 08             	shl    ecx,0x8
  20635d:	09 c1                	or     ecx,eax
  20635f:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  206364:	c1 e2 10             	shl    edx,0x10
  206367:	09 ca                	or     edx,ecx
  206369:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20636e:	c1 e0 18             	shl    eax,0x18
  206371:	09 d0                	or     eax,edx
  206373:	eb 19                	jmp    20638e <openSelfDebugInfo+0x17fe>
                result = (result << 8) | b;
  206375:	c1 e0 08             	shl    eax,0x8
  206378:	09 c8                	or     eax,ecx
  20637a:	c1 e0 08             	shl    eax,0x8
  20637d:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  206382:	09 c1                	or     ecx,eax
  206384:	c1 e1 08             	shl    ecx,0x8
  206387:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20638c:	09 c8                	or     eax,ecx
  20638e:	89 c0                	mov    eax,eax
  206390:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
            try self.readNoEof(result[0..]);
  206395:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20639a:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20639f:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  2063a6:	00 00 
            return self.readFn(self, buffer);
  2063a8:	4c 89 ef             	mov    rdi,r13
  2063ab:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  2063b2:	00 
  2063b3:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  2063b8:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  2063bf:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  2063c6:	00 
  2063c7:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  2063c9:	66 85 c9             	test   cx,cx
  2063cc:	0f 85 d6 10 00 00    	jne    2074a8 <openSelfDebugInfo+0x2918>
  2063d2:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2063d9:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2063da:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  2063df:	0f 82 bf 10 00 00    	jb     2074a4 <openSelfDebugInfo+0x2914>
        if (address_size != @sizeOf(usize)) return error.InvalidDebugInfo;
  2063e5:	80 7c 24 07 08       	cmp    BYTE PTR [rsp+0x7],0x8
  2063ea:	66 bf 23 00          	mov    di,0x23
  2063ee:	0f 85 f1 0e 00 00    	jne    2072e5 <openSelfDebugInfo+0x2755>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2063f4:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  2063f7:	b8 08 00 00 00       	mov    eax,0x8
  2063fc:	be 00 00 00 00       	mov    esi,0x0
  206401:	ba 01 00 00 00       	mov    edx,0x1
  206406:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  206408:	48 89 c2             	mov    rdx,rax
  20640b:	48 f7 da             	neg    rdx
  20640e:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  206413:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  206419:	b9 00 00 00 00       	mov    ecx,0x0
  20641e:	48 0f 46 d1          	cmovbe rdx,rcx
    pub fn getPos(self: *File) !usize {
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const result = posix.lseek(self.handle, 0, posix.SEEK_CUR);
                const err = posix.getErrno(result);
                if (err > 0) {
  206422:	48 85 d2             	test   rdx,rdx
  206425:	0f 85 16 11 00 00    	jne    207541 <openSelfDebugInfo+0x29b1>
            return self.items[0..self.len];
  20642b:	48 8b 83 98 00 00 00 	mov    rax,QWORD PTR [rbx+0x98]
    for (st.abbrev_table_list.toSlice()) |*header| {
  206432:	48 85 c0             	test   rax,rax
  206435:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  20643a:	74 24                	je     206460 <openSelfDebugInfo+0x18d0>
  20643c:	48 8b b3 88 00 00 00 	mov    rsi,QWORD PTR [rbx+0x88]
        if (header.offset == abbrev_offset) {
  206443:	48 83 c6 08          	add    rsi,0x8
  206447:	31 c9                	xor    ecx,ecx
  206449:	48 39 56 f8          	cmp    QWORD PTR [rsi-0x8],rdx
  20644d:	0f 84 48 01 00 00    	je     20659b <openSelfDebugInfo+0x1a0b>
    for (st.abbrev_table_list.toSlice()) |*header| {
  206453:	48 83 c1 01          	add    rcx,0x1
  206457:	48 83 c6 28          	add    rsi,0x28
  20645b:	48 39 c1             	cmp    rcx,rax
  20645e:	72 e9                	jb     206449 <openSelfDebugInfo+0x18b9>
    try st.self_exe_file.seekTo(st.debug_abbrev.offset + abbrev_offset);
  206460:	48 8b 43 68          	mov    rax,QWORD PTR [rbx+0x68]
  206464:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  206468:	48 01 d6             	add    rsi,rdx
  20646b:	0f 88 7f 10 00 00    	js     2074f0 <openSelfDebugInfo+0x2960>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  206471:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  206474:	b8 08 00 00 00       	mov    eax,0x8
  206479:	31 d2                	xor    edx,edx
  20647b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20647d:	48 89 c1             	mov    rcx,rax
  206480:	48 f7 d9             	neg    rcx
  206483:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  206489:	b8 00 00 00 00       	mov    eax,0x0
  20648e:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  206492:	48 85 c9             	test   rcx,rcx
  206495:	0f 85 2d 11 00 00    	jne    2075c8 <openSelfDebugInfo+0x2a38>
        .table = try parseAbbrevTable(st),
  20649b:	4c 89 ef             	mov    rdi,r13
  20649e:	48 89 de             	mov    rsi,rbx
  2064a1:	e8 4a 32 00 00       	call   2096f0 <parseAbbrevTable>
  2064a6:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  2064ad:	00 
  2064ae:	89 c8                	mov    eax,ecx
  2064b0:	66 85 c9             	test   cx,cx
  2064b3:	0f 85 ef 0f 00 00    	jne    2074a8 <openSelfDebugInfo+0x2918>
    try st.abbrev_table_list.append(AbbrevTableHeader{
  2064b9:	48 8d 84 24 a8 00 00 	lea    rax,[rsp+0xa8]
  2064c0:	00 
  2064c1:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  2064c5:	c5 fe 7f 44 24 60    	vmovdqu YMMWORD PTR [rsp+0x60],ymm0
            }
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
        }

        pub fn addOne(self: *Self) !*T {
            const new_length = self.len + 1;
  2064cb:	48 8b ab 98 00 00 00 	mov    rbp,QWORD PTR [rbx+0x98]
            var better_capacity = self.items.len;
  2064d2:	48 8b 8b 90 00 00 00 	mov    rcx,QWORD PTR [rbx+0x90]
            if (better_capacity >= new_capacity) return;
  2064d9:	48 39 e9             	cmp    rcx,rbp
  2064dc:	76 05                	jbe    2064e3 <openSelfDebugInfo+0x1953>
            try self.ensureCapacity(new_length);
            const result = &self.items[self.len];
  2064de:	48 89 e8             	mov    rax,rbp
  2064e1:	eb 5d                	jmp    206540 <openSelfDebugInfo+0x19b0>
                better_capacity += better_capacity / 2 + 8;
  2064e3:	48 89 c8             	mov    rax,rcx
  2064e6:	48 d1 e8             	shr    rax,1
  2064e9:	48 01 c1             	add    rcx,rax
  2064ec:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2064f0:	48 39 e9             	cmp    rcx,rbp
  2064f3:	76 ee                	jbe    2064e3 <openSelfDebugInfo+0x1953>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2064f5:	48 8b b3 a0 00 00 00 	mov    rsi,QWORD PTR [rbx+0xa0]
  2064fc:	48 8d bc 24 b8 02 00 	lea    rdi,[rsp+0x2b8]
  206503:	00 
  206504:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
  206509:	c5 f8 77             	vzeroupper 
  20650c:	e8 0f 3e 00 00       	call   20a320 <Allocator_alignedRealloc.27>
  206511:	0f b7 8c 24 b8 02 00 	movzx  ecx,WORD PTR [rsp+0x2b8]
  206518:	00 
  206519:	89 c8                	mov    eax,ecx
  20651b:	66 85 c9             	test   cx,cx
  20651e:	0f 85 84 0f 00 00    	jne    2074a8 <openSelfDebugInfo+0x2918>
  206524:	48 8d 84 24 c0 02 00 	lea    rax,[rsp+0x2c0]
  20652b:	00 
  20652c:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  206530:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  206535:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  206539:	48 8b 83 98 00 00 00 	mov    rax,QWORD PTR [rbx+0x98]
  206540:	48 83 c5 01          	add    rbp,0x1
  206544:	48 8b 8b 88 00 00 00 	mov    rcx,QWORD PTR [rbx+0x88]
            self.len = new_length;
  20654b:	48 89 ab 98 00 00 00 	mov    QWORD PTR [rbx+0x98],rbp
            new_item_ptr.* = item;
  206552:	48 8d 04 80          	lea    rax,[rax+rax*4]
  206556:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  20655b:	48 89 14 c1          	mov    QWORD PTR [rcx+rax*8],rdx
  20655f:	c5 fe 6f 44 24 60    	vmovdqu ymm0,YMMWORD PTR [rsp+0x60]
  206565:	c5 fe 7f 44 c1 08    	vmovdqu YMMWORD PTR [rcx+rax*8+0x8],ymm0
    return &st.abbrev_table_list.items[st.abbrev_table_list.len - 1].table;
  20656b:	48 8b 83 88 00 00 00 	mov    rax,QWORD PTR [rbx+0x88]
  206572:	48 8b 8b 98 00 00 00 	mov    rcx,QWORD PTR [rbx+0x98]
  206579:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  20657d:	48 8d 04 c8          	lea    rax,[rax+rcx*8]
  206581:	48 83 c0 e0          	add    rax,0xffffffffffffffe0
  206585:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20658a:	66 bf 21 00          	mov    di,0x21
  20658e:	48 83 7c 24 18 00    	cmp    QWORD PTR [rsp+0x18],0x0
  206594:	79 1a                	jns    2065b0 <openSelfDebugInfo+0x1a20>
  206596:	e9 4a 0d 00 00       	jmp    2072e5 <openSelfDebugInfo+0x2755>
  20659b:	48 89 74 24 30       	mov    QWORD PTR [rsp+0x30],rsi
  2065a0:	66 bf 21 00          	mov    di,0x21
  2065a4:	48 83 7c 24 18 00    	cmp    QWORD PTR [rsp+0x18],0x0
  2065aa:	0f 88 35 0d 00 00    	js     2072e5 <openSelfDebugInfo+0x2755>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2065b0:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  2065b3:	b8 08 00 00 00       	mov    eax,0x8
  2065b8:	31 d2                	xor    edx,edx
  2065ba:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
  2065bf:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2065c1:	48 89 c1             	mov    rcx,rax
  2065c4:	48 f7 d9             	neg    rcx
  2065c7:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2065cd:	b8 00 00 00 00       	mov    eax,0x0
  2065d2:	48 0f 46 c8          	cmovbe rcx,rax
  2065d6:	48 85 c9             	test   rcx,rcx
  2065d9:	0f 85 c4 0f 00 00    	jne    2075a3 <openSelfDebugInfo+0x2a13>
  2065df:	48 8b 83 a0 00 00 00 	mov    rax,QWORD PTR [rbx+0xa0]
    var in_file_stream = io.FileInStream.init(in_file);
  2065e6:	48 89 84 24 58 02 00 	mov    QWORD PTR [rsp+0x258],rax
  2065ed:	00 
  2065ee:	48 89 9c 24 50 01 00 	mov    QWORD PTR [rsp+0x150],rbx
  2065f5:	00 
  2065f6:	48 8d 05 c3 30 00 00 	lea    rax,[rip+0x30c3]        # 2096c0 <FileInStream_readFn>
  2065fd:	48 89 84 24 58 01 00 	mov    QWORD PTR [rsp+0x158],rax
  206604:	00 
            try self.readNoEof(result[0..]);
  206605:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20660a:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20660f:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  206616:	00 00 
        return self.file.read(buffer);
  206618:	48 8b b4 24 50 01 00 	mov    rsi,QWORD PTR [rsp+0x150]
  20661f:	00 
  206620:	48 8d bc 24 88 01 00 	lea    rdi,[rsp+0x188]
  206627:	00 
  206628:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20662d:	c5 f8 77             	vzeroupper 
  206630:	e8 7b 2f 00 00       	call   2095b0 <File_read>
  206635:	c5 fa 6f 84 24 88 01 	vmovdqu xmm0,XMMWORD PTR [rsp+0x188]
  20663c:	00 00 
  20663e:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
            return self.readFn(self, buffer);
  206644:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  206649:	66 85 c9             	test   cx,cx
  20664c:	0f 85 67 0c 00 00    	jne    2072b9 <openSelfDebugInfo+0x2729>
  206652:	0f b6 44 24 40       	movzx  eax,BYTE PTR [rsp+0x40]
  206657:	48 89 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rax
  20665e:	00 
  20665f:	48 8d 04 c5 04 00 00 	lea    rax,[rax*8+0x4]
  206666:	00 
  206667:	48 89 84 24 50 02 00 	mov    QWORD PTR [rsp+0x250],rax
  20666e:	00 
  20666f:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  206674:	31 c9                	xor    ecx,ecx
  206676:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  20667b:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  20667d:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  206682:	0f 82 2d 0c 00 00    	jb     2072b5 <openSelfDebugInfo+0x2725>
            return result[0];
  206688:	0f b6 44 24 07       	movzx  eax,BYTE PTR [rsp+0x7]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20668d:	89 c2                	mov    edx,eax
  20668f:	83 e2 7f             	and    edx,0x7f
  206692:	89 ee                	mov    esi,ebp
  206694:	83 e6 3f             	and    esi,0x3f
  206697:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20669c:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2066a1:	48 39 d6             	cmp    rsi,rdx
  2066a4:	0f 85 13 0c 00 00    	jne    2072bd <openSelfDebugInfo+0x272d>
        result |= operand;
  2066aa:	48 09 4c 24 18       	or     QWORD PTR [rsp+0x18],rcx
        if ((byte & 0b10000000) == 0) return result;
  2066af:	84 c0                	test   al,al
  2066b1:	79 44                	jns    2066f7 <openSelfDebugInfo+0x1b67>
        shift += 7;
  2066b3:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2066b7:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  2066bc:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2066c1:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2066c8:	00 00 
            return self.readFn(self, buffer);
  2066ca:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2066cf:	48 8d b4 24 58 01 00 	lea    rsi,[rsp+0x158]
  2066d6:	00 
  2066d7:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2066dc:	ff 94 24 58 01 00 00 	call   QWORD PTR [rsp+0x158]
  2066e3:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  2066e8:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2066ed:	66 85 c9             	test   cx,cx
  2066f0:	74 8b                	je     20667d <openSelfDebugInfo+0x1aed>
  2066f2:	e9 c2 0b 00 00       	jmp    2072b9 <openSelfDebugInfo+0x2729>
            return self.items[0..self.len];
  2066f7:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  2066fc:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
    for (abbrev_table.toSliceConst()) |*table_entry| {
  206700:	48 85 c0             	test   rax,rax
  206703:	0f 84 b1 0d 00 00    	je     2074ba <openSelfDebugInfo+0x292a>
  206709:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20670e:	48 8b 29             	mov    rbp,QWORD PTR [rcx]
  206711:	31 c9                	xor    ecx,ecx
        if (table_entry.abbrev_code == abbrev_code) return table_entry;
  206713:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  206718:	48 39 55 08          	cmp    QWORD PTR [rbp+0x8],rdx
  20671c:	74 12                	je     206730 <openSelfDebugInfo+0x1ba0>
    for (abbrev_table.toSliceConst()) |*table_entry| {
  20671e:	48 83 c1 01          	add    rcx,0x1
  206722:	48 83 c5 38          	add    rbp,0x38
  206726:	48 39 c1             	cmp    rcx,rax
  206729:	72 e8                	jb     206713 <openSelfDebugInfo+0x1b83>
  20672b:	e9 8a 0d 00 00       	jmp    2074ba <openSelfDebugInfo+0x292a>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  206730:	48 85 ed             	test   rbp,rbp
  206733:	0f 84 81 0d 00 00    	je     2074ba <openSelfDebugInfo+0x292a>
        .tag_id = table_entry.tag_id,
  206739:	48 8b 45 10          	mov    rax,QWORD PTR [rbp+0x10]
        .has_children = table_entry.has_children,
  20673d:	8a 4d 00             	mov    cl,BYTE PTR [rbp+0x0]
  206740:	48 8b b3 a0 00 00 00 	mov    rsi,QWORD PTR [rbx+0xa0]
  206747:	48 8d 94 24 f7 02 00 	lea    rdx,[rsp+0x2f7]
  20674e:	00 
    var result = Die{
  20674f:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  206753:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
  206757:	48 c7 42 10 00 00 00 	mov    QWORD PTR [rdx+0x10],0x0
  20675e:	00 
  20675f:	48 89 84 24 e0 01 00 	mov    QWORD PTR [rsp+0x1e0],rax
  206766:	00 
  206767:	88 8c 24 e8 01 00 00 	mov    BYTE PTR [rsp+0x1e8],cl
  20676e:	c5 fa 6f 84 24 f0 02 	vmovdqu xmm0,XMMWORD PTR [rsp+0x2f0]
  206775:	00 00 
  206777:	c5 fa 6f 8c 24 ff 02 	vmovdqu xmm1,XMMWORD PTR [rsp+0x2ff]
  20677e:	00 00 
  206780:	48 8d 84 24 e9 01 00 	lea    rax,[rsp+0x1e9]
  206787:	00 
  206788:	c5 fa 7f 48 0f       	vmovdqu XMMWORD PTR [rax+0xf],xmm1
  20678d:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  206791:	48 89 b4 24 08 02 00 	mov    QWORD PTR [rsp+0x208],rsi
  206798:	00 
    try result.attrs.resize(table_entry.attrs.len);
  206799:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
            var better_capacity = self.items.len;
  20679d:	48 8b 8c 24 f8 01 00 	mov    rcx,QWORD PTR [rsp+0x1f8]
  2067a4:	00 
  2067a5:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
            if (better_capacity >= new_capacity) return;
  2067aa:	48 39 c1             	cmp    rcx,rax
  2067ad:	73 5a                	jae    206809 <openSelfDebugInfo+0x1c79>
                better_capacity += better_capacity / 2 + 8;
  2067af:	48 89 c8             	mov    rax,rcx
  2067b2:	48 d1 e8             	shr    rax,1
  2067b5:	48 01 c1             	add    rcx,rax
  2067b8:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2067bc:	48 3b 4c 24 18       	cmp    rcx,QWORD PTR [rsp+0x18]
  2067c1:	72 ec                	jb     2067af <openSelfDebugInfo+0x1c1f>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2067c3:	48 8d bc 24 88 01 00 	lea    rdi,[rsp+0x188]
  2067ca:	00 
  2067cb:	48 8d 94 24 f0 01 00 	lea    rdx,[rsp+0x1f0]
  2067d2:	00 
  2067d3:	e8 d8 68 00 00       	call   20d0b0 <Allocator_alignedRealloc.30>
  2067d8:	0f b7 8c 24 88 01 00 	movzx  ecx,WORD PTR [rsp+0x188]
  2067df:	00 
  2067e0:	89 c8                	mov    eax,ecx
  2067e2:	66 85 c9             	test   cx,cx
  2067e5:	0f 85 87 0e 00 00    	jne    207672 <openSelfDebugInfo+0x2ae2>
  2067eb:	48 8d 84 24 90 01 00 	lea    rax,[rsp+0x190]
  2067f2:	00 
  2067f3:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2067f7:	48 8d 84 24 f0 01 00 	lea    rax,[rsp+0x1f0]
  2067fe:	00 
  2067ff:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            return self.items[0..self.len];
  206803:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  206807:	eb 05                	jmp    20680e <openSelfDebugInfo+0x1c7e>
  206809:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20680e:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  206815:	00 
            self.len = new_len;
  206816:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20681b:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  206822:	00 
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  206823:	48 83 bc 24 68 01 00 	cmp    QWORD PTR [rsp+0x168],0x0
  20682a:	00 00 
  20682c:	0f 84 c9 00 00 00    	je     2068fb <openSelfDebugInfo+0x1d6b>
  206832:	48 8b 45 18          	mov    rax,QWORD PTR [rbp+0x18]
  206836:	48 8b ac 24 f0 01 00 	mov    rbp,QWORD PTR [rsp+0x1f0]
  20683d:	00 
  20683e:	48 83 c0 08          	add    rax,0x8
  206842:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  206847:	48 83 c5 08          	add    rbp,0x8
  20684b:	31 c0                	xor    eax,eax
  20684d:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  206852:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  206857:	48 8b 48 f8          	mov    rcx,QWORD PTR [rax-0x8]
  20685b:	48 89 8c 24 60 01 00 	mov    QWORD PTR [rsp+0x160],rcx
  206862:	00 
  206863:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  206866:	48 8b b3 a0 00 00 00 	mov    rsi,QWORD PTR [rbx+0xa0]
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  20686d:	48 8d bc 24 48 03 00 	lea    rdi,[rsp+0x348]
  206874:	00 
  206875:	48 8d 94 24 58 01 00 	lea    rdx,[rsp+0x158]
  20687c:	00 
  20687d:	4c 8b 84 24 38 01 00 	mov    r8,QWORD PTR [rsp+0x138]
  206884:	00 
  206885:	c5 f8 77             	vzeroupper 
  206888:	e8 23 3d 00 00       	call   20a5b0 <parseFormValue>
  20688d:	0f b7 8c 24 48 03 00 	movzx  ecx,WORD PTR [rsp+0x348]
  206894:	00 
  206895:	89 c8                	mov    eax,ecx
  206897:	66 85 c9             	test   cx,cx
  20689a:	0f 85 cd 0c 00 00    	jne    20756d <openSelfDebugInfo+0x29dd>
        result.attrs.items[i] = Die.Attr{
  2068a0:	48 8d 84 24 50 03 00 	lea    rax,[rsp+0x350]
  2068a7:	00 
  2068a8:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  2068ac:	c5 fc 11 84 24 10 03 	vmovups YMMWORD PTR [rsp+0x310],ymm0
  2068b3:	00 00 
  2068b5:	48 8b 84 24 60 01 00 	mov    rax,QWORD PTR [rsp+0x160]
  2068bc:	00 
  2068bd:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  2068c1:	c5 fe 6f 84 24 10 03 	vmovdqu ymm0,YMMWORD PTR [rsp+0x310]
  2068c8:	00 00 
  2068ca:	c5 fe 7f 45 00       	vmovdqu YMMWORD PTR [rbp+0x0],ymm0
  2068cf:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  2068d4:	48 89 c1             	mov    rcx,rax
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  2068d7:	48 83 c1 01          	add    rcx,0x1
  2068db:	48 83 44 24 18 10    	add    QWORD PTR [rsp+0x18],0x10
  2068e1:	48 83 c5 28          	add    rbp,0x28
  2068e5:	48 89 c8             	mov    rax,rcx
  2068e8:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  2068ed:	48 3b 8c 24 68 01 00 	cmp    rcx,QWORD PTR [rsp+0x168]
  2068f4:	00 
  2068f5:	0f 82 57 ff ff ff    	jb     206852 <openSelfDebugInfo+0x1cc2>
    return result;
  2068fb:	c5 fc 10 84 24 e0 01 	vmovups ymm0,YMMWORD PTR [rsp+0x1e0]
  206902:	00 00 
  206904:	c5 fc 10 8c 24 f0 01 	vmovups ymm1,YMMWORD PTR [rsp+0x1f0]
  20690b:	00 00 
  20690d:	48 8d 84 24 2e 04 00 	lea    rax,[rsp+0x42e]
  206914:	00 
  206915:	c5 fc 11 48 10       	vmovups YMMWORD PTR [rax+0x10],ymm1
  20691a:	c5 fc 11 00          	vmovups YMMWORD PTR [rax],ymm0
  20691e:	c5 fc 10 84 24 28 04 	vmovups ymm0,YMMWORD PTR [rsp+0x428]
  206925:	00 00 
  206927:	c5 fc 10 8c 24 3e 04 	vmovups ymm1,YMMWORD PTR [rsp+0x43e]
  20692e:	00 00 
  206930:	c5 fc 11 84 24 10 02 	vmovups YMMWORD PTR [rsp+0x210],ymm0
  206937:	00 00 
  206939:	c5 fc 11 8c 24 26 02 	vmovups YMMWORD PTR [rsp+0x226],ymm1
  206940:	00 00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  206942:	ba 30 00 00 00       	mov    edx,0x30
  206947:	b9 08 00 00 00       	mov    ecx,0x8
  20694c:	4c 89 ef             	mov    rdi,r13
  20694f:	48 8b b4 24 58 02 00 	mov    rsi,QWORD PTR [rsp+0x258]
  206956:	00 
  206957:	c5 f8 77             	vzeroupper 
  20695a:	ff 16                	call   QWORD PTR [rsi]
  20695c:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  206963:	00 
  206964:	89 c8                	mov    eax,ecx
  206966:	66 85 c9             	test   cx,cx
  206969:	0f 85 39 0b 00 00    	jne    2074a8 <openSelfDebugInfo+0x2918>
        assert(byte_slice.len == byte_count);
  20696f:	48 83 bc 24 b0 00 00 	cmp    QWORD PTR [rsp+0xb0],0x30
  206976:	00 30 
    if (!ok) {
  206978:	0f 85 e4 18 00 00    	jne    208262 <openSelfDebugInfo+0x36d2>
  20697e:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  206985:	00 
  206986:	48 8d 84 24 16 02 00 	lea    rax,[rsp+0x216]
  20698d:	00 
        ptr.* = init;
  20698e:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  206992:	c5 fe 6f 48 10       	vmovdqu ymm1,YMMWORD PTR [rax+0x10]
  206997:	c5 fe 7f 01          	vmovdqu YMMWORD PTR [rcx],ymm0
  20699b:	c5 fe 7f 49 10       	vmovdqu YMMWORD PTR [rcx+0x10],ymm1
  2069a0:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
        if (compile_unit_die.tag_id != DW.TAG_compile_unit) return error.InvalidDebugInfo;
  2069a5:	48 83 39 11          	cmp    QWORD PTR [rcx],0x11
  2069a9:	0f 85 55 0b 00 00    	jne    207504 <openSelfDebugInfo+0x2974>
  2069af:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  2069b4:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  2069b8:	48 85 c9             	test   rcx,rcx
  2069bb:	74 25                	je     2069e2 <openSelfDebugInfo+0x1e52>
  2069bd:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  2069c2:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  2069c6:	48 89 d0             	mov    rax,rdx
  2069c9:	31 f6                	xor    esi,esi
            if (attr.id == id) return &attr.value;
  2069cb:	48 83 38 11          	cmp    QWORD PTR [rax],0x11
  2069cf:	0f 84 52 01 00 00    	je     206b27 <openSelfDebugInfo+0x1f97>
        for (self.attrs.toSliceConst()) |*attr| {
  2069d5:	48 83 c6 01          	add    rsi,0x1
  2069d9:	48 83 c0 28          	add    rax,0x28
  2069dd:	48 39 ce             	cmp    rsi,rcx
  2069e0:	72 e9                	jb     2069cb <openSelfDebugInfo+0x1e3b>
        const pc_range = x: {
  2069e2:	48 8d 05 8f a6 ff ff 	lea    rax,[rip+0xffffffffffffa68f]        # 201078 <__unnamed_45>
  2069e9:	48 8b 48 10          	mov    rcx,QWORD PTR [rax+0x10]
  2069ed:	48 89 8c 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],rcx
  2069f4:	00 
  2069f5:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2069f9:	c5 f9 7f 84 24 a0 01 	vmovdqa XMMWORD PTR [rsp+0x1a0],xmm0
  206a00:	00 00 
            const new_length = self.len + 1;
  206a02:	48 8b ab b8 00 00 00 	mov    rbp,QWORD PTR [rbx+0xb8]
            var better_capacity = self.items.len;
  206a09:	48 8b 8b b0 00 00 00 	mov    rcx,QWORD PTR [rbx+0xb0]
            if (better_capacity >= new_capacity) return;
  206a10:	48 39 e9             	cmp    rcx,rbp
  206a13:	76 05                	jbe    206a1a <openSelfDebugInfo+0x1e8a>
            const result = &self.items[self.len];
  206a15:	48 89 e8             	mov    rax,rbp
  206a18:	eb 5e                	jmp    206a78 <openSelfDebugInfo+0x1ee8>
                better_capacity += better_capacity / 2 + 8;
  206a1a:	48 89 c8             	mov    rax,rcx
  206a1d:	48 d1 e8             	shr    rax,1
  206a20:	48 01 c1             	add    rcx,rax
  206a23:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  206a27:	48 39 e9             	cmp    rcx,rbp
  206a2a:	76 ee                	jbe    206a1a <openSelfDebugInfo+0x1e8a>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  206a2c:	48 8b b3 c0 00 00 00 	mov    rsi,QWORD PTR [rbx+0xc0]
  206a33:	4c 89 ef             	mov    rdi,r13
  206a36:	48 8b 94 24 78 01 00 	mov    rdx,QWORD PTR [rsp+0x178]
  206a3d:	00 
  206a3e:	c5 f8 77             	vzeroupper 
  206a41:	e8 fa 6b 00 00       	call   20d640 <Allocator_alignedRealloc.37>
  206a46:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  206a4d:	00 
  206a4e:	89 c8                	mov    eax,ecx
  206a50:	66 85 c9             	test   cx,cx
  206a53:	0f 85 4f 0a 00 00    	jne    2074a8 <openSelfDebugInfo+0x2918>
  206a59:	48 8d 84 24 a8 00 00 	lea    rax,[rsp+0xa8]
  206a60:	00 
  206a61:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  206a65:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  206a6c:	00 
  206a6d:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  206a71:	48 8b 83 b8 00 00 00 	mov    rax,QWORD PTR [rbx+0xb8]
  206a78:	48 83 c5 01          	add    rbp,0x1
  206a7c:	48 8b 8b a8 00 00 00 	mov    rcx,QWORD PTR [rbx+0xa8]
  206a83:	48 8d 04 40          	lea    rax,[rax+rax*2]
  206a87:	48 c1 e0 04          	shl    rax,0x4
            self.len = new_length;
  206a8b:	48 89 ab b8 00 00 00 	mov    QWORD PTR [rbx+0xb8],rbp
            new_item_ptr.* = item;
  206a92:	48 8b 94 24 60 02 00 	mov    rdx,QWORD PTR [rsp+0x260]
  206a99:	00 
  206a9a:	66 89 14 01          	mov    WORD PTR [rcx+rax*1],dx
  206a9e:	8b 54 24 40          	mov    edx,DWORD PTR [rsp+0x40]
  206aa2:	88 54 01 02          	mov    BYTE PTR [rcx+rax*1+0x2],dl
  206aa6:	8a 94 24 77 01 00 00 	mov    dl,BYTE PTR [rsp+0x177]
  206aad:	88 54 01 07          	mov    BYTE PTR [rcx+rax*1+0x7],dl
  206ab1:	8b 94 24 73 01 00 00 	mov    edx,DWORD PTR [rsp+0x173]
  206ab8:	89 54 01 03          	mov    DWORD PTR [rcx+rax*1+0x3],edx
  206abc:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  206ac1:	48 89 54 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],rdx
  206ac6:	48 8b 94 24 80 01 00 	mov    rdx,QWORD PTR [rsp+0x180]
  206acd:	00 
  206ace:	48 89 d6             	mov    rsi,rdx
  206ad1:	48 89 74 01 10       	mov    QWORD PTR [rcx+rax*1+0x10],rsi
  206ad6:	48 8b 94 24 b0 01 00 	mov    rdx,QWORD PTR [rsp+0x1b0]
  206add:	00 
  206ade:	48 89 54 01 28       	mov    QWORD PTR [rcx+rax*1+0x28],rdx
  206ae3:	c5 f9 6f 84 24 a0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1a0]
  206aea:	00 00 
  206aec:	c5 fa 7f 44 01 18    	vmovdqu XMMWORD PTR [rcx+rax*1+0x18],xmm0
  206af2:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  206af7:	48 03 44 24 38       	add    rax,QWORD PTR [rsp+0x38]
        this_unit_offset += next_offset;
  206afc:	48 03 84 24 50 02 00 	add    rax,QWORD PTR [rsp+0x250]
  206b03:	00 
        cu_index += 1;
  206b04:	48 83 c6 01          	add    rsi,0x1
  206b08:	48 89 b4 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rsi
  206b0f:	00 
  206b10:	31 ff                	xor    edi,edi
  206b12:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
    while (this_unit_offset < debug_info_end) {
  206b17:	48 3b 44 24 50       	cmp    rax,QWORD PTR [rsp+0x50]
  206b1c:	0f 82 ba f5 ff ff    	jb     2060dc <openSelfDebugInfo+0x154c>
  206b22:	e9 be 07 00 00       	jmp    2072e5 <openSelfDebugInfo+0x2755>
        return switch (form_value.*) {
  206b27:	40 8a 78 20          	mov    dil,BYTE PTR [rax+0x20]
  206b2b:	48 8d 35 9e ba ff ff 	lea    rsi,[rip+0xffffffffffffba9e]        # 2025d0 <__unnamed_46>
  206b32:	40 84 ff             	test   dil,dil
  206b35:	75 19                	jne    206b50 <openSelfDebugInfo+0x1fc0>
            FormValue.Address => |value| value,
  206b37:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  206b3b:	66 c7 84 24 a0 00 00 	mov    WORD PTR [rsp+0xa0],0x0
  206b42:	00 00 00 
  206b45:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  206b4c:	00 
  206b4d:	4c 89 ee             	mov    rsi,r13
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  206b50:	0f b7 3e             	movzx  edi,WORD PTR [rsi]
        const pc_range = x: {
  206b53:	48 8d 05 1e a5 ff ff 	lea    rax,[rip+0xffffffffffffa51e]        # 201078 <__unnamed_45>
  206b5a:	89 fd                	mov    ebp,edi
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  206b5c:	83 ff 22             	cmp    edi,0x22
  206b5f:	0f 84 84 fe ff ff    	je     2069e9 <openSelfDebugInfo+0x1e59>
  206b65:	89 ef                	mov    edi,ebp
  206b67:	66 85 ff             	test   di,di
  206b6a:	0f 85 75 07 00 00    	jne    2072e5 <openSelfDebugInfo+0x2755>
  206b70:	4c 8b 4e 08          	mov    r9,QWORD PTR [rsi+0x8]
            if (attr.id == id) return &attr.value;
  206b74:	48 83 c2 20          	add    rdx,0x20
  206b78:	31 f6                	xor    esi,esi
  206b7a:	48 83 7a e0 12       	cmp    QWORD PTR [rdx-0x20],0x12
  206b7f:	74 12                	je     206b93 <openSelfDebugInfo+0x2003>
        for (self.attrs.toSliceConst()) |*attr| {
  206b81:	48 83 c6 01          	add    rsi,0x1
  206b85:	48 83 c2 28          	add    rdx,0x28
  206b89:	48 39 ce             	cmp    rsi,rcx
  206b8c:	72 ec                	jb     206b7a <openSelfDebugInfo+0x1fea>
  206b8e:	e9 4f fe ff ff       	jmp    2069e2 <openSelfDebugInfo+0x1e52>
  206b93:	8a 0a                	mov    cl,BYTE PTR [rdx]
  206b95:	80 f9 02             	cmp    cl,0x2
                    const pc_end = switch (high_pc_value.*) {
  206b98:	74 15                	je     206baf <openSelfDebugInfo+0x201f>
  206b9a:	66 bf 23 00          	mov    di,0x23
  206b9e:	84 c9                	test   cl,cl
  206ba0:	0f 85 3f 07 00 00    	jne    2072e5 <openSelfDebugInfo+0x2755>
                        FormValue.Address => |value| value,
  206ba6:	48 8b 7a e8          	mov    rdi,QWORD PTR [rdx-0x18]
  206baa:	e9 33 02 00 00       	jmp    206de2 <openSelfDebugInfo+0x2252>
                        FormValue.Const => |value| b: {
  206baf:	48 8b 4a f0          	mov    rcx,QWORD PTR [rdx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  206bb3:	48 83 f9 08          	cmp    rcx,0x8
  206bb7:	0f 87 47 09 00 00    	ja     207504 <openSelfDebugInfo+0x2974>
  206bbd:	f6 42 f8 01          	test   BYTE PTR [rdx-0x8],0x1
  206bc1:	66 bf 23 00          	mov    di,0x23
  206bc5:	0f 85 1a 07 00 00    	jne    2072e5 <openSelfDebugInfo+0x2755>
  206bcb:	48 85 c9             	test   rcx,rcx
            for (bytes) |b, index| {
  206bce:	74 13                	je     206be3 <openSelfDebugInfo+0x2053>
  206bd0:	48 8b 52 e8          	mov    rdx,QWORD PTR [rdx-0x18]
  206bd4:	48 83 f9 10          	cmp    rcx,0x10
  206bd8:	73 10                	jae    206bea <openSelfDebugInfo+0x205a>
  206bda:	31 c0                	xor    eax,eax
  206bdc:	31 ff                	xor    edi,edi
  206bde:	e9 d3 01 00 00       	jmp    206db6 <openSelfDebugInfo+0x2226>
  206be3:	31 ff                	xor    edi,edi
  206be5:	e9 f5 01 00 00       	jmp    206ddf <openSelfDebugInfo+0x224f>
  206bea:	48 89 c8             	mov    rax,rcx
  206bed:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  206bf1:	48 8d 78 f0          	lea    rdi,[rax-0x10]
  206bf5:	48 89 fd             	mov    rbp,rdi
  206bf8:	48 c1 ed 04          	shr    rbp,0x4
  206bfc:	44 8d 45 01          	lea    r8d,[rbp+0x1]
  206c00:	41 83 e0 01          	and    r8d,0x1
  206c04:	48 85 ff             	test   rdi,rdi
  206c07:	0f 84 01 01 00 00    	je     206d0e <openSelfDebugInfo+0x217e>
  206c0d:	49 8d 78 ff          	lea    rdi,[r8-0x1]
  206c11:	48 29 ef             	sub    rdi,rbp
  206c14:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  206c18:	31 ed                	xor    ebp,ebp
  206c1a:	c5 fd 6f 25 7e 95 ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff957e]        # 2001a0 <app_mask-0x80>
  206c21:	ff 
  206c22:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  206c26:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  206c2a:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  206c2e:	c4 e2 7d 32 2c 2a    	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1]
  206c34:	c4 e2 7d 32 74 2a 04 	vpmovzxbq ymm6,DWORD PTR [rdx+rbp*1+0x4]
  206c3b:	c4 e2 7d 32 7c 2a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rbp*1+0x8]
  206c42:	c4 62 7d 32 44 2a 0c 	vpmovzxbq ymm8,DWORD PTR [rdx+rbp*1+0xc]
  206c49:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  206c4e:	c5 7e 6f a4 24 80 04 	vmovdqu ymm12,YMMWORD PTR [rsp+0x480]
  206c55:	00 00 
  206c57:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  206c5c:	c5 7e 6f ac 24 60 04 	vmovdqu ymm13,YMMWORD PTR [rsp+0x460]
  206c63:	00 00 
  206c65:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  206c6a:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  206c6f:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  206c74:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  206c78:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  206c7d:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  206c81:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  206c86:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  206c8a:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  206c8f:	c4 e2 7d 32 74 2a 10 	vpmovzxbq ymm6,DWORD PTR [rdx+rbp*1+0x10]
  206c96:	c4 e2 7d 32 7c 2a 14 	vpmovzxbq ymm7,DWORD PTR [rdx+rbp*1+0x14]
  206c9d:	c4 62 7d 32 44 2a 18 	vpmovzxbq ymm8,DWORD PTR [rdx+rbp*1+0x18]
  206ca4:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  206ca8:	c4 e2 7d 32 6c 2a 1c 	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1+0x1c]
  206caf:	c4 62 7d 59 15 80 95 	vpbroadcastq ymm10,QWORD PTR [rip+0xffffffffffff9580]        # 200238 <app_mask+0x18>
  206cb6:	ff ff 
  206cb8:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  206cbd:	c4 62 7d 59 1d 22 95 	vpbroadcastq ymm11,QWORD PTR [rip+0xffffffffffff9522]        # 2001e8 <app_mask-0x38>
  206cc4:	ff ff 
  206cc6:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  206ccb:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  206cd0:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  206cd5:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  206cda:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  206cde:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  206ce3:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  206ce7:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  206cec:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  206cf0:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  206cf5:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  206cf9:	48 83 c5 20          	add    rbp,0x20
  206cfd:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  206d02:	48 83 c7 02          	add    rdi,0x2
  206d06:	0f 85 22 ff ff ff    	jne    206c2e <openSelfDebugInfo+0x209e>
  206d0c:	eb 1a                	jmp    206d28 <openSelfDebugInfo+0x2198>
  206d0e:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  206d12:	31 ed                	xor    ebp,ebp
  206d14:	c5 fd 6f 25 84 94 ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff9484]        # 2001a0 <app_mask-0x80>
  206d1b:	ff 
  206d1c:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  206d20:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  206d24:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  206d28:	4d 85 c0             	test   r8,r8
  206d2b:	74 60                	je     206d8d <openSelfDebugInfo+0x21fd>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  206d2d:	c4 e2 7d 32 6c 2a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1+0xc]
  206d34:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  206d39:	c5 dd d4 b4 24 80 04 	vpaddq ymm6,ymm4,YMMWORD PTR [rsp+0x480]
  206d40:	00 00 
  206d42:	c5 7e 6f 84 24 60 04 	vmovdqu ymm8,YMMWORD PTR [rsp+0x460]
  206d49:	00 00 
  206d4b:	c4 c1 4d db f0       	vpand  ymm6,ymm6,ymm8
  206d50:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  206d55:	c4 e2 7d 32 7c 2a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rbp*1+0x8]
  206d5c:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  206d60:	c4 c1 5d db e0       	vpand  ymm4,ymm4,ymm8
  206d65:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  206d6a:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  206d6e:	c4 e2 7d 32 6c 2a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1+0x4]
  206d75:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  206d7a:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  206d7e:	c4 e2 7d 32 2c 2a    	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1]
  206d84:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  206d89:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  206d8d:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  206d91:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  206d95:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  206d99:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  206d9f:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  206da3:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  206da8:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  206dac:	c4 e1 f9 7e c7       	vmovq  rdi,xmm0
  206db1:	48 39 c1             	cmp    rcx,rax
            for (bytes) |b, index| {
  206db4:	74 29                	je     206ddf <openSelfDebugInfo+0x224f>
  206db6:	48 29 c1             	sub    rcx,rax
  206db9:	48 01 c2             	add    rdx,rax
  206dbc:	48 c1 e0 03          	shl    rax,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  206dc0:	0f b6 2a             	movzx  ebp,BYTE PTR [rdx]
  206dc3:	89 c6                	mov    esi,eax
  206dc5:	40 80 e6 38          	and    sil,0x38
  206dc9:	c4 e2 c9 f7 f5       	shlx   rsi,rbp,rsi
  206dce:	48 09 f7             	or     rdi,rsi
            for (bytes) |b, index| {
  206dd1:	48 83 c0 08          	add    rax,0x8
  206dd5:	48 83 c2 01          	add    rdx,0x1
  206dd9:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  206ddd:	75 e1                	jne    206dc0 <openSelfDebugInfo+0x2230>
                            break :b (low_pc + offset);
  206ddf:	4c 01 cf             	add    rdi,r9
                    break :x PcRange{
  206de2:	4c 89 8c 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],r9
  206de9:	00 
  206dea:	48 89 bc 24 c8 01 00 	mov    QWORD PTR [rsp+0x1c8],rdi
  206df1:	00 
  206df2:	c6 84 24 d0 01 00 00 	mov    BYTE PTR [rsp+0x1d0],0x1
  206df9:	01 
        const pc_range = x: {
  206dfa:	48 8d 84 24 c0 01 00 	lea    rax,[rsp+0x1c0]
  206e01:	00 
  206e02:	e9 e2 fb ff ff       	jmp    2069e9 <openSelfDebugInfo+0x1e59>
                list.first = node.next;
  206e07:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  206e0b:	48 89 0d 0e e2 00 00 	mov    QWORD PTR [rip+0xe20e],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  206e12:	48 85 c9             	test   rcx,rcx
  206e15:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  206e18:	48 8d 35 09 e2 00 00 	lea    rsi,[rip+0xe209]        # 215028 <emfile_promise_queue+0x8>
  206e1f:	48 0f 45 f1          	cmovne rsi,rcx
  206e23:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  206e26:	48 83 05 02 e2 00 00 	add    QWORD PTR [rip+0xe202],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  206e2d:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  206e2e:	74 1e                	je     206e4e <openSelfDebugInfo+0x22be>
  206e30:	48 83 3d e8 e1 00 00 	cmp    QWORD PTR [rip+0xe1e8],0x0        # 215020 <emfile_promise_queue>
  206e37:	00 
  206e38:	0f 84 24 14 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  206e3e:	48 8b 0d e3 e1 00 00 	mov    rcx,QWORD PTR [rip+0xe1e3]        # 215028 <emfile_promise_queue+0x8>
  206e45:	48 85 c9             	test   rcx,rcx
  206e48:	0f 84 14 14 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  206e4e:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  206e52:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  206e56:	48 89 c1             	mov    rcx,rax
  206e59:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  206e5d:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  206e63:	75 f1                	jne    206e56 <openSelfDebugInfo+0x22c6>
  206e65:	a8 01                	test   al,0x1
  206e67:	75 02                	jne    206e6b <openSelfDebugInfo+0x22db>
  206e69:	ff 17                	call   QWORD PTR [rdi]
  206e6b:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
    return asm volatile ("syscall"
  206e6e:	b8 03 00 00 00       	mov    eax,0x3
  206e73:	0f 05                	syscall 
            switch (err) {
  206e75:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  206e79:	74 f3                	je     206e6e <openSelfDebugInfo+0x22de>
            const first = list.first orelse return null;
  206e7b:	48 8b 05 9e e1 00 00 	mov    rax,QWORD PTR [rip+0xe19e]        # 215020 <emfile_promise_queue>
  206e82:	48 85 c0             	test   rax,rax
  206e85:	74 7a                	je     206f01 <openSelfDebugInfo+0x2371>
            if (node.prev) |prev_node| {
  206e87:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  206e8a:	48 85 c9             	test   rcx,rcx
  206e8d:	74 0e                	je     206e9d <openSelfDebugInfo+0x230d>
                prev_node.next = node.next;
  206e8f:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  206e93:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  206e97:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  206e9b:	eb 0b                	jmp    206ea8 <openSelfDebugInfo+0x2318>
                list.first = node.next;
  206e9d:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  206ea1:	48 89 0d 78 e1 00 00 	mov    QWORD PTR [rip+0xe178],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  206ea8:	48 85 c9             	test   rcx,rcx
  206eab:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  206eae:	48 8d 35 73 e1 00 00 	lea    rsi,[rip+0xe173]        # 215028 <emfile_promise_queue+0x8>
  206eb5:	48 0f 45 f1          	cmovne rsi,rcx
  206eb9:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  206ebc:	48 83 05 6c e1 00 00 	add    QWORD PTR [rip+0xe16c],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  206ec3:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  206ec4:	74 1e                	je     206ee4 <openSelfDebugInfo+0x2354>
  206ec6:	48 83 3d 52 e1 00 00 	cmp    QWORD PTR [rip+0xe152],0x0        # 215020 <emfile_promise_queue>
  206ecd:	00 
  206ece:	0f 84 8e 13 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  206ed4:	48 8b 0d 4d e1 00 00 	mov    rcx,QWORD PTR [rip+0xe14d]        # 215028 <emfile_promise_queue+0x8>
  206edb:	48 85 c9             	test   rcx,rcx
  206ede:	0f 84 7e 13 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  206ee4:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  206ee8:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  206eec:	48 89 c1             	mov    rcx,rax
  206eef:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  206ef3:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  206ef9:	75 f1                	jne    206eec <openSelfDebugInfo+0x235c>
  206efb:	a8 01                	test   al,0x1
  206efd:	75 02                	jne    206f01 <openSelfDebugInfo+0x2371>
  206eff:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  206f01:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  206f05:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  206f0c:	00 
  206f0d:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  206f14:	00 c8 00 00 00 
  206f19:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  206f20:	00 
  206f21:	4c 89 ff             	mov    rdi,r15
  206f24:	ff d0                	call   rax
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  206f26:	0f b7 84 24 78 02 00 	movzx  eax,WORD PTR [rsp+0x278]
  206f2d:	00 
  206f2e:	66 41 89 06          	mov    WORD PTR [r14],ax
  206f32:	48 8b 84 24 c6 03 00 	mov    rax,QWORD PTR [rsp+0x3c6]
  206f39:	00 
  206f3a:	48 8b 8c 24 cc 03 00 	mov    rcx,QWORD PTR [rsp+0x3cc]
  206f41:	00 
  206f42:	e9 3f e9 ff ff       	jmp    205886 <openSelfDebugInfo+0xcf6>
                list.first = node.next;
  206f47:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  206f4b:	48 89 0d ce e0 00 00 	mov    QWORD PTR [rip+0xe0ce],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  206f52:	48 85 c9             	test   rcx,rcx
  206f55:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  206f58:	48 8d 35 c9 e0 00 00 	lea    rsi,[rip+0xe0c9]        # 215028 <emfile_promise_queue+0x8>
  206f5f:	48 0f 45 f1          	cmovne rsi,rcx
  206f63:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  206f66:	48 83 05 c2 e0 00 00 	add    QWORD PTR [rip+0xe0c2],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  206f6d:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  206f6e:	74 1e                	je     206f8e <openSelfDebugInfo+0x23fe>
  206f70:	48 83 3d a8 e0 00 00 	cmp    QWORD PTR [rip+0xe0a8],0x0        # 215020 <emfile_promise_queue>
  206f77:	00 
  206f78:	0f 84 e4 12 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  206f7e:	48 8b 0d a3 e0 00 00 	mov    rcx,QWORD PTR [rip+0xe0a3]        # 215028 <emfile_promise_queue+0x8>
  206f85:	48 85 c9             	test   rcx,rcx
  206f88:	0f 84 d4 12 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  206f8e:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  206f92:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  206f96:	48 89 c1             	mov    rcx,rax
  206f99:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  206f9d:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  206fa3:	75 f1                	jne    206f96 <openSelfDebugInfo+0x2406>
  206fa5:	a8 01                	test   al,0x1
  206fa7:	75 02                	jne    206fab <openSelfDebugInfo+0x241b>
  206fa9:	ff 17                	call   QWORD PTR [rdi]
  206fab:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  206fae:	b8 03 00 00 00       	mov    eax,0x3
  206fb3:	0f 05                	syscall 
            switch (err) {
  206fb5:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  206fb9:	74 f3                	je     206fae <openSelfDebugInfo+0x241e>
            const first = list.first orelse return null;
  206fbb:	48 8b 05 5e e0 00 00 	mov    rax,QWORD PTR [rip+0xe05e]        # 215020 <emfile_promise_queue>
  206fc2:	48 85 c0             	test   rax,rax
  206fc5:	0f 84 48 ec ff ff    	je     205c13 <openSelfDebugInfo+0x1083>
            if (node.prev) |prev_node| {
  206fcb:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  206fce:	48 85 c9             	test   rcx,rcx
  206fd1:	74 0e                	je     206fe1 <openSelfDebugInfo+0x2451>
                prev_node.next = node.next;
  206fd3:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  206fd7:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  206fdb:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  206fdf:	eb 0b                	jmp    206fec <openSelfDebugInfo+0x245c>
                list.first = node.next;
  206fe1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  206fe5:	48 89 0d 34 e0 00 00 	mov    QWORD PTR [rip+0xe034],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  206fec:	48 85 c9             	test   rcx,rcx
  206fef:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  206ff2:	48 8d 35 2f e0 00 00 	lea    rsi,[rip+0xe02f]        # 215028 <emfile_promise_queue+0x8>
  206ff9:	48 0f 45 f1          	cmovne rsi,rcx
  206ffd:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  207000:	48 83 05 28 e0 00 00 	add    QWORD PTR [rip+0xe028],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  207007:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  207008:	74 1e                	je     207028 <openSelfDebugInfo+0x2498>
  20700a:	48 83 3d 0e e0 00 00 	cmp    QWORD PTR [rip+0xe00e],0x0        # 215020 <emfile_promise_queue>
  207011:	00 
  207012:	0f 84 4a 12 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  207018:	48 8b 0d 09 e0 00 00 	mov    rcx,QWORD PTR [rip+0xe009]        # 215028 <emfile_promise_queue+0x8>
  20701f:	48 85 c9             	test   rcx,rcx
  207022:	0f 84 3a 12 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  207028:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20702c:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  207030:	48 89 c1             	mov    rcx,rax
  207033:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  207037:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20703d:	75 f1                	jne    207030 <openSelfDebugInfo+0x24a0>
  20703f:	e9 c9 eb ff ff       	jmp    205c0d <openSelfDebugInfo+0x107d>
  207044:	31 ff                	xor    edi,edi
  207046:	89 fd                	mov    ebp,edi
            try scanAllCompileUnits(st);
  207048:	66 85 ff             	test   di,di
  20704b:	0f 85 9f 02 00 00    	jne    2072f0 <openSelfDebugInfo+0x2760>
            return st;
  207051:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  207057:	0f b7 84 24 de 01 00 	movzx  eax,WORD PTR [rsp+0x1de]
  20705e:	00 
  20705f:	66 41 89 46 06       	mov    WORD PTR [r14+0x6],ax
  207064:	8b 84 24 da 01 00 00 	mov    eax,DWORD PTR [rsp+0x1da]
  20706b:	41 89 46 02          	mov    DWORD PTR [r14+0x2],eax
  20706f:	49 89 5e 08          	mov    QWORD PTR [r14+0x8],rbx
  207073:	e9 16 e8 ff ff       	jmp    20588e <openSelfDebugInfo+0xcfe>
                list.first = node.next;
  207078:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20707c:	48 89 0d 9d df 00 00 	mov    QWORD PTR [rip+0xdf9d],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  207083:	48 85 c9             	test   rcx,rcx
  207086:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  207089:	48 8d 35 98 df 00 00 	lea    rsi,[rip+0xdf98]        # 215028 <emfile_promise_queue+0x8>
  207090:	48 0f 45 f1          	cmovne rsi,rcx
  207094:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  207097:	48 83 05 91 df 00 00 	add    QWORD PTR [rip+0xdf91],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  20709e:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20709f:	74 1e                	je     2070bf <openSelfDebugInfo+0x252f>
  2070a1:	48 83 3d 77 df 00 00 	cmp    QWORD PTR [rip+0xdf77],0x0        # 215020 <emfile_promise_queue>
  2070a8:	00 
  2070a9:	0f 84 b3 11 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  2070af:	48 8b 0d 72 df 00 00 	mov    rcx,QWORD PTR [rip+0xdf72]        # 215028 <emfile_promise_queue+0x8>
  2070b6:	48 85 c9             	test   rcx,rcx
  2070b9:	0f 84 a3 11 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  2070bf:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2070c3:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2070c7:	48 89 c1             	mov    rcx,rax
  2070ca:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2070ce:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2070d4:	75 f1                	jne    2070c7 <openSelfDebugInfo+0x2537>
  2070d6:	a8 01                	test   al,0x1
  2070d8:	75 02                	jne    2070dc <openSelfDebugInfo+0x254c>
  2070da:	ff 17                	call   QWORD PTR [rdi]
  2070dc:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  2070df:	b8 03 00 00 00       	mov    eax,0x3
  2070e4:	0f 05                	syscall 
            switch (err) {
  2070e6:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2070ea:	74 f3                	je     2070df <openSelfDebugInfo+0x254f>
            const first = list.first orelse return null;
  2070ec:	48 8b 05 2d df 00 00 	mov    rax,QWORD PTR [rip+0xdf2d]        # 215020 <emfile_promise_queue>
  2070f3:	48 85 c0             	test   rax,rax
  2070f6:	74 7a                	je     207172 <openSelfDebugInfo+0x25e2>
            if (node.prev) |prev_node| {
  2070f8:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2070fb:	48 85 c9             	test   rcx,rcx
  2070fe:	74 0e                	je     20710e <openSelfDebugInfo+0x257e>
                prev_node.next = node.next;
  207100:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  207104:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  207108:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20710c:	eb 0b                	jmp    207119 <openSelfDebugInfo+0x2589>
                list.first = node.next;
  20710e:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  207112:	48 89 0d 07 df 00 00 	mov    QWORD PTR [rip+0xdf07],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  207119:	48 85 c9             	test   rcx,rcx
  20711c:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20711f:	48 8d 35 02 df 00 00 	lea    rsi,[rip+0xdf02]        # 215028 <emfile_promise_queue+0x8>
  207126:	48 0f 45 f1          	cmovne rsi,rcx
  20712a:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20712d:	48 83 05 fb de 00 00 	add    QWORD PTR [rip+0xdefb],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  207134:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  207135:	74 1e                	je     207155 <openSelfDebugInfo+0x25c5>
  207137:	48 83 3d e1 de 00 00 	cmp    QWORD PTR [rip+0xdee1],0x0        # 215020 <emfile_promise_queue>
  20713e:	00 
  20713f:	0f 84 1d 11 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  207145:	48 8b 0d dc de 00 00 	mov    rcx,QWORD PTR [rip+0xdedc]        # 215028 <emfile_promise_queue+0x8>
  20714c:	48 85 c9             	test   rcx,rcx
  20714f:	0f 84 0d 11 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  207155:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  207159:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20715d:	48 89 c1             	mov    rcx,rax
  207160:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  207164:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20716a:	75 f1                	jne    20715d <openSelfDebugInfo+0x25cd>
  20716c:	a8 01                	test   al,0x1
  20716e:	75 02                	jne    207172 <openSelfDebugInfo+0x25e2>
  207170:	ff 17                	call   QWORD PTR [rdi]
  207172:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  207176:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20717d:	00 
  20717e:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  207185:	00 c8 00 00 00 
  20718a:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  207191:	00 
  207192:	4c 89 ff             	mov    rdi,r15
  207195:	ff d0                	call   rax
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  207197:	0f b7 84 24 68 02 00 	movzx  eax,WORD PTR [rsp+0x268]
  20719e:	00 
  20719f:	66 41 89 06          	mov    WORD PTR [r14],ax
  2071a3:	48 8b 84 24 b8 03 00 	mov    rax,QWORD PTR [rsp+0x3b8]
  2071aa:	00 
  2071ab:	48 8b 8c 24 be 03 00 	mov    rcx,QWORD PTR [rsp+0x3be]
  2071b2:	00 
  2071b3:	e9 ce e6 ff ff       	jmp    205886 <openSelfDebugInfo+0xcf6>
                list.first = node.next;
  2071b8:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2071bc:	48 89 0d 5d de 00 00 	mov    QWORD PTR [rip+0xde5d],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  2071c3:	48 85 c9             	test   rcx,rcx
  2071c6:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  2071c9:	48 8d 35 58 de 00 00 	lea    rsi,[rip+0xde58]        # 215028 <emfile_promise_queue+0x8>
  2071d0:	48 0f 45 f1          	cmovne rsi,rcx
  2071d4:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  2071d7:	48 83 05 51 de 00 00 	add    QWORD PTR [rip+0xde51],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  2071de:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  2071df:	74 1e                	je     2071ff <openSelfDebugInfo+0x266f>
  2071e1:	48 83 3d 37 de 00 00 	cmp    QWORD PTR [rip+0xde37],0x0        # 215020 <emfile_promise_queue>
  2071e8:	00 
  2071e9:	0f 84 73 10 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  2071ef:	48 8b 0d 32 de 00 00 	mov    rcx,QWORD PTR [rip+0xde32]        # 215028 <emfile_promise_queue+0x8>
  2071f6:	48 85 c9             	test   rcx,rcx
  2071f9:	0f 84 63 10 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  2071ff:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  207203:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  207207:	48 89 c1             	mov    rcx,rax
  20720a:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20720e:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  207214:	75 f1                	jne    207207 <openSelfDebugInfo+0x2677>
  207216:	a8 01                	test   al,0x1
  207218:	75 02                	jne    20721c <openSelfDebugInfo+0x268c>
  20721a:	ff 17                	call   QWORD PTR [rdi]
  20721c:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20721f:	b8 03 00 00 00       	mov    eax,0x3
  207224:	0f 05                	syscall 
            switch (err) {
  207226:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20722a:	74 f3                	je     20721f <openSelfDebugInfo+0x268f>
            const first = list.first orelse return null;
  20722c:	48 8b 05 ed dd 00 00 	mov    rax,QWORD PTR [rip+0xdded]        # 215020 <emfile_promise_queue>
  207233:	48 85 c0             	test   rax,rax
  207236:	0f 84 d7 e9 ff ff    	je     205c13 <openSelfDebugInfo+0x1083>
            if (node.prev) |prev_node| {
  20723c:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20723f:	48 85 c9             	test   rcx,rcx
  207242:	74 0e                	je     207252 <openSelfDebugInfo+0x26c2>
                prev_node.next = node.next;
  207244:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  207248:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20724c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  207250:	eb 0b                	jmp    20725d <openSelfDebugInfo+0x26cd>
                list.first = node.next;
  207252:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  207256:	48 89 0d c3 dd 00 00 	mov    QWORD PTR [rip+0xddc3],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  20725d:	48 85 c9             	test   rcx,rcx
  207260:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  207263:	48 8d 35 be dd 00 00 	lea    rsi,[rip+0xddbe]        # 215028 <emfile_promise_queue+0x8>
  20726a:	48 0f 45 f1          	cmovne rsi,rcx
  20726e:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  207271:	48 83 05 b7 dd 00 00 	add    QWORD PTR [rip+0xddb7],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  207278:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  207279:	74 1e                	je     207299 <openSelfDebugInfo+0x2709>
  20727b:	48 83 3d 9d dd 00 00 	cmp    QWORD PTR [rip+0xdd9d],0x0        # 215020 <emfile_promise_queue>
  207282:	00 
  207283:	0f 84 d9 0f 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  207289:	48 8b 0d 98 dd 00 00 	mov    rcx,QWORD PTR [rip+0xdd98]        # 215028 <emfile_promise_queue+0x8>
  207290:	48 85 c9             	test   rcx,rcx
  207293:	0f 84 c9 0f 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  207299:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20729d:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2072a1:	48 89 c1             	mov    rcx,rax
  2072a4:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2072a8:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2072ae:	75 f1                	jne    2072a1 <openSelfDebugInfo+0x2711>
  2072b0:	e9 58 e9 ff ff       	jmp    205c0d <openSelfDebugInfo+0x107d>
  2072b5:	66 b9 1e 00          	mov    cx,0x1e
  2072b9:	89 cf                	mov    edi,ecx
  2072bb:	eb 04                	jmp    2072c1 <openSelfDebugInfo+0x2731>
  2072bd:	66 bf 23 00          	mov    di,0x23
    const abbrev_code = try readULeb128(in_stream);
  2072c1:	c5 fe 6f 84 24 a0 00 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa0]
  2072c8:	00 00 
  2072ca:	c5 fe 6f 8c 24 b6 00 	vmovdqu ymm1,YMMWORD PTR [rsp+0xb6]
  2072d1:	00 00 
  2072d3:	c5 fe 7f 8c 24 26 02 	vmovdqu YMMWORD PTR [rsp+0x226],ymm1
  2072da:	00 00 
  2072dc:	c5 fe 7f 84 24 10 02 	vmovdqu YMMWORD PTR [rsp+0x210],ymm0
  2072e3:	00 00 
  2072e5:	89 fd                	mov    ebp,edi
            try scanAllCompileUnits(st);
  2072e7:	66 85 ff             	test   di,di
  2072ea:	0f 84 61 fd ff ff    	je     207051 <openSelfDebugInfo+0x24c1>
        const bytes = @sliceToBytes(memory);
  2072f0:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  2072f4:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  2072f8:	74 29                	je     207323 <openSelfDebugInfo+0x2793>
  2072fa:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  2072fe:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  207302:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  207306:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20730d:	00 
  20730e:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  207315:	00 
  207316:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20731d:	00 
  20731e:	c5 f8 77             	vzeroupper 
  207321:	ff d2                	call   rdx
  207323:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  207327:	0f 85 9d 00 00 00    	jne    2073ca <openSelfDebugInfo+0x283a>
  20732d:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  207331:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  207334:	b8 03 00 00 00       	mov    eax,0x3
  207339:	0f 05                	syscall 
            switch (err) {
  20733b:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20733f:	74 f3                	je     207334 <openSelfDebugInfo+0x27a4>
            const first = list.first orelse return null;
  207341:	48 8b 05 d8 dc 00 00 	mov    rax,QWORD PTR [rip+0xdcd8]        # 215020 <emfile_promise_queue>
  207348:	48 85 c0             	test   rax,rax
  20734b:	74 7d                	je     2073ca <openSelfDebugInfo+0x283a>
            if (node.prev) |prev_node| {
  20734d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  207350:	48 85 c9             	test   rcx,rcx
  207353:	74 0e                	je     207363 <openSelfDebugInfo+0x27d3>
                prev_node.next = node.next;
  207355:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  207359:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20735d:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  207361:	eb 0b                	jmp    20736e <openSelfDebugInfo+0x27de>
                list.first = node.next;
  207363:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  207367:	48 89 0d b2 dc 00 00 	mov    QWORD PTR [rip+0xdcb2],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  20736e:	48 85 c9             	test   rcx,rcx
  207371:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  207374:	48 8d 35 ad dc 00 00 	lea    rsi,[rip+0xdcad]        # 215028 <emfile_promise_queue+0x8>
  20737b:	48 0f 45 f1          	cmovne rsi,rcx
  20737f:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  207382:	48 83 05 a6 dc 00 00 	add    QWORD PTR [rip+0xdca6],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  207389:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20738a:	74 1e                	je     2073aa <openSelfDebugInfo+0x281a>
  20738c:	48 83 3d 8c dc 00 00 	cmp    QWORD PTR [rip+0xdc8c],0x0        # 215020 <emfile_promise_queue>
  207393:	00 
  207394:	0f 84 c8 0e 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  20739a:	48 8b 0d 87 dc 00 00 	mov    rcx,QWORD PTR [rip+0xdc87]        # 215028 <emfile_promise_queue+0x8>
  2073a1:	48 85 c9             	test   rcx,rcx
  2073a4:	0f 84 b8 0e 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  2073aa:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  2073ae:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  2073b2:	48 89 c1             	mov    rcx,rax
  2073b5:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  2073b9:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  2073bf:	75 f1                	jne    2073b2 <openSelfDebugInfo+0x2822>
  2073c1:	a8 01                	test   al,0x1
  2073c3:	75 05                	jne    2073ca <openSelfDebugInfo+0x283a>
  2073c5:	c5 f8 77             	vzeroupper 
  2073c8:	ff 17                	call   QWORD PTR [rdi]
  2073ca:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  2073cd:	b8 03 00 00 00       	mov    eax,0x3
  2073d2:	0f 05                	syscall 
            switch (err) {
  2073d4:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2073d8:	74 f3                	je     2073cd <openSelfDebugInfo+0x283d>
            const first = list.first orelse return null;
  2073da:	48 8b 05 3f dc 00 00 	mov    rax,QWORD PTR [rip+0xdc3f]        # 215020 <emfile_promise_queue>
  2073e1:	48 85 c0             	test   rax,rax
  2073e4:	74 7d                	je     207463 <openSelfDebugInfo+0x28d3>
            if (node.prev) |prev_node| {
  2073e6:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2073e9:	48 85 c9             	test   rcx,rcx
  2073ec:	74 0e                	je     2073fc <openSelfDebugInfo+0x286c>
                prev_node.next = node.next;
  2073ee:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2073f2:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2073f6:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2073fa:	eb 0b                	jmp    207407 <openSelfDebugInfo+0x2877>
                list.first = node.next;
  2073fc:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  207400:	48 89 0d 19 dc 00 00 	mov    QWORD PTR [rip+0xdc19],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  207407:	48 85 c9             	test   rcx,rcx
  20740a:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20740d:	48 8d 35 14 dc 00 00 	lea    rsi,[rip+0xdc14]        # 215028 <emfile_promise_queue+0x8>
  207414:	48 0f 45 f1          	cmovne rsi,rcx
  207418:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20741b:	48 83 05 0d dc 00 00 	add    QWORD PTR [rip+0xdc0d],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  207422:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  207423:	74 1e                	je     207443 <openSelfDebugInfo+0x28b3>
  207425:	48 83 3d f3 db 00 00 	cmp    QWORD PTR [rip+0xdbf3],0x0        # 215020 <emfile_promise_queue>
  20742c:	00 
  20742d:	0f 84 2f 0e 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
  207433:	48 8b 0d ee db 00 00 	mov    rcx,QWORD PTR [rip+0xdbee]        # 215028 <emfile_promise_queue+0x8>
  20743a:	48 85 c9             	test   rcx,rcx
  20743d:	0f 84 1f 0e 00 00    	je     208262 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  207443:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  207447:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20744b:	48 89 c1             	mov    rcx,rax
  20744e:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  207452:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  207458:	75 f1                	jne    20744b <openSelfDebugInfo+0x28bb>
  20745a:	a8 01                	test   al,0x1
  20745c:	75 05                	jne    207463 <openSelfDebugInfo+0x28d3>
  20745e:	c5 f8 77             	vzeroupper 
  207461:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  207463:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  207467:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20746e:	00 
  20746f:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  207476:	00 c8 00 00 00 
  20747b:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  207482:	00 
  207483:	4c 89 ff             	mov    rdi,r15
  207486:	c5 f8 77             	vzeroupper 
  207489:	ff d0                	call   rax
  20748b:	66 41 89 2e          	mov    WORD PTR [r14],bp
  20748f:	48 8b 84 24 aa 03 00 	mov    rax,QWORD PTR [rsp+0x3aa]
  207496:	00 
  207497:	48 8b 8c 24 b0 03 00 	mov    rcx,QWORD PTR [rsp+0x3b0]
  20749e:	00 
  20749f:	e9 e2 e3 ff ff       	jmp    205886 <openSelfDebugInfo+0xcf6>
  2074a4:	66 b8 1e 00          	mov    ax,0x1e
  2074a8:	89 c7                	mov    edi,eax
  2074aa:	89 fd                	mov    ebp,edi
  2074ac:	66 85 ff             	test   di,di
  2074af:	0f 85 3b fe ff ff    	jne    2072f0 <openSelfDebugInfo+0x2760>
  2074b5:	e9 97 fb ff ff       	jmp    207051 <openSelfDebugInfo+0x24c1>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  2074ba:	c5 fc 10 05 76 9c ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff9c76]        # 201138 <__unnamed_47+0x18>
  2074c1:	ff 
  2074c2:	c5 fc 11 84 24 26 02 	vmovups YMMWORD PTR [rsp+0x226],ymm0
  2074c9:	00 00 
  2074cb:	c5 fe 6f 05 4f 9c ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff9c4f]        # 201122 <__unnamed_47+0x2>
  2074d2:	ff 
  2074d3:	c5 fe 7f 84 24 10 02 	vmovdqu YMMWORD PTR [rsp+0x210],ymm0
  2074da:	00 00 
  2074dc:	66 bf 23 00          	mov    di,0x23
  2074e0:	89 fd                	mov    ebp,edi
            try scanAllCompileUnits(st);
  2074e2:	66 85 ff             	test   di,di
  2074e5:	0f 85 05 fe ff ff    	jne    2072f0 <openSelfDebugInfo+0x2760>
  2074eb:	e9 61 fb ff ff       	jmp    207051 <openSelfDebugInfo+0x24c1>
  2074f0:	66 bf 21 00          	mov    di,0x21
  2074f4:	89 fd                	mov    ebp,edi
  2074f6:	66 85 ff             	test   di,di
  2074f9:	0f 85 f1 fd ff ff    	jne    2072f0 <openSelfDebugInfo+0x2760>
  2074ff:	e9 4d fb ff ff       	jmp    207051 <openSelfDebugInfo+0x24c1>
  207504:	66 bf 23 00          	mov    di,0x23
  207508:	89 fd                	mov    ebp,edi
  20750a:	66 85 ff             	test   di,di
  20750d:	0f 85 dd fd ff ff    	jne    2072f0 <openSelfDebugInfo+0x2760>
  207513:	e9 39 fb ff ff       	jmp    207051 <openSelfDebugInfo+0x24c1>
  207518:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  20751c:	48 83 f8 17          	cmp    rax,0x17
  207520:	0f 87 d4 00 00 00    	ja     2075fa <openSelfDebugInfo+0x2a6a>
  207526:	48 8d 0d 5f 91 ff ff 	lea    rcx,[rip+0xffffffffffff915f]        # 20068c <__unnamed_128+0x444>
  20752d:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  207531:	48 01 c8             	add    rax,rcx
  207534:	66 c7 44 24 04 20 00 	mov    WORD PTR [rsp+0x4],0x20
  20753b:	66 bf 05 00          	mov    di,0x5
  20753f:	ff e0                	jmp    rax
  207541:	48 8d 4a fa          	lea    rcx,[rdx-0x6]
  207545:	48 83 f9 17          	cmp    rcx,0x17
  207549:	0f 87 c2 00 00 00    	ja     207611 <openSelfDebugInfo+0x2a81>
  20754f:	66 bf 1c 00          	mov    di,0x1c
  207553:	48 8d 05 92 91 ff ff 	lea    rax,[rip+0xffffffffffff9192]        # 2006ec <__unnamed_128+0x4a4>
  20755a:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  20755e:	48 01 c1             	add    rcx,rax
  207561:	66 c7 84 24 9e 00 00 	mov    WORD PTR [rsp+0x9e],0x20
  207568:	00 20 00 
  20756b:	ff e1                	jmp    rcx
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  20756d:	c5 fc 10 84 24 b8 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2b8]
  207574:	00 00 
  207576:	c5 fc 10 8c 24 ce 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2ce]
  20757d:	00 00 
  20757f:	c5 fc 11 8c 24 26 02 	vmovups YMMWORD PTR [rsp+0x226],ymm1
  207586:	00 00 
  207588:	c5 fc 11 84 24 10 02 	vmovups YMMWORD PTR [rsp+0x210],ymm0
  20758f:	00 00 
  207591:	89 c7                	mov    edi,eax
  207593:	89 fd                	mov    ebp,edi
            try scanAllCompileUnits(st);
  207595:	66 85 ff             	test   di,di
  207598:	0f 85 52 fd ff ff    	jne    2072f0 <openSelfDebugInfo+0x2760>
  20759e:	e9 ae fa ff ff       	jmp    207051 <openSelfDebugInfo+0x24c1>
  2075a3:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  2075a7:	48 83 f8 17          	cmp    rax,0x17
  2075ab:	77 4d                	ja     2075fa <openSelfDebugInfo+0x2a6a>
  2075ad:	48 8d 0d f8 91 ff ff 	lea    rcx,[rip+0xffffffffffff91f8]        # 2007ac <__unnamed_128+0x564>
  2075b4:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  2075b8:	48 01 c8             	add    rax,rcx
  2075bb:	66 c7 44 24 04 20 00 	mov    WORD PTR [rsp+0x4],0x20
  2075c2:	66 bf 05 00          	mov    di,0x5
  2075c6:	ff e0                	jmp    rax
  2075c8:	66 bf 05 00          	mov    di,0x5
  2075cc:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  2075d0:	48 83 f8 17          	cmp    rax,0x17
  2075d4:	77 7c                	ja     207652 <openSelfDebugInfo+0x2ac2>
  2075d6:	48 8d 0d 6f 91 ff ff 	lea    rcx,[rip+0xffffffffffff916f]        # 20074c <__unnamed_128+0x504>
  2075dd:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  2075e1:	48 01 c8             	add    rax,rcx
  2075e4:	ff e0                	jmp    rax
  2075e6:	66 bf 20 00          	mov    di,0x20
  2075ea:	89 fd                	mov    ebp,edi
  2075ec:	66 85 ff             	test   di,di
  2075ef:	0f 85 fb fc ff ff    	jne    2072f0 <openSelfDebugInfo+0x2760>
  2075f5:	e9 57 fa ff ff       	jmp    207051 <openSelfDebugInfo+0x24c1>
  2075fa:	66 c7 44 24 04 20 00 	mov    WORD PTR [rsp+0x4],0x20
  207601:	66 bf 05 00          	mov    di,0x5
  207605:	48 83 f9 4b          	cmp    rcx,0x4b
  207609:	0f 85 d6 fc ff ff    	jne    2072e5 <openSelfDebugInfo+0x2755>
  20760f:	eb 2a                	jmp    20763b <openSelfDebugInfo+0x2aab>
  207611:	66 c7 84 24 9e 00 00 	mov    WORD PTR [rsp+0x9e],0x20
  207618:	00 20 00 
                if (err > 0) {
  20761b:	48 83 fa 4b          	cmp    rdx,0x4b
  20761f:	75 1a                	jne    20763b <openSelfDebugInfo+0x2aab>
  207621:	0f b7 84 24 9e 00 00 	movzx  eax,WORD PTR [rsp+0x9e]
  207628:	00 
  207629:	89 c7                	mov    edi,eax
  20762b:	89 fd                	mov    ebp,edi
  20762d:	66 85 ff             	test   di,di
  207630:	0f 85 ba fc ff ff    	jne    2072f0 <openSelfDebugInfo+0x2760>
  207636:	e9 16 fa ff ff       	jmp    207051 <openSelfDebugInfo+0x24c1>
  20763b:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  207640:	89 c7                	mov    edi,eax
  207642:	89 fd                	mov    ebp,edi
  207644:	66 85 ff             	test   di,di
  207647:	0f 85 a3 fc ff ff    	jne    2072f0 <openSelfDebugInfo+0x2760>
  20764d:	e9 ff f9 ff ff       	jmp    207051 <openSelfDebugInfo+0x24c1>
                if (err > 0) {
  207652:	48 83 f9 4b          	cmp    rcx,0x4b
  207656:	0f 85 89 fc ff ff    	jne    2072e5 <openSelfDebugInfo+0x2755>
  20765c:	eb 88                	jmp    2075e6 <openSelfDebugInfo+0x2a56>
  20765e:	66 bf 1c 00          	mov    di,0x1c
  207662:	89 fd                	mov    ebp,edi
  207664:	66 85 ff             	test   di,di
  207667:	0f 85 83 fc ff ff    	jne    2072f0 <openSelfDebugInfo+0x2760>
  20766d:	e9 df f9 ff ff       	jmp    207051 <openSelfDebugInfo+0x24c1>
    try result.attrs.resize(table_entry.attrs.len);
  207672:	c5 fc 10 44 24 60    	vmovups ymm0,YMMWORD PTR [rsp+0x60]
  207678:	c5 fc 10 4c 24 76    	vmovups ymm1,YMMWORD PTR [rsp+0x76]
  20767e:	e9 fc fe ff ff       	jmp    20757f <openSelfDebugInfo+0x29ef>
            try self.readNoEof(bytes[0..]);
  207683:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  207688:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20768d:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  207694:	00 00 
  207696:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20769d:	00 
  20769e:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  2076a3:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  2076a8:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  2076ac:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  2076b3:	00 
            const amt_read = try self.read(buf);
  2076b4:	66 85 ed             	test   bp,bp
  2076b7:	0f 85 7d d7 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  2076bd:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2076c4:	00 
  2076c5:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  2076c9:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  2076ce:	0f 82 66 d7 ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
  2076d4:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  2076d9:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  2076de:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  2076e3:	74 1b                	je     207700 <openSelfDebugInfo+0x2b70>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2076e5:	c1 e1 08             	shl    ecx,0x8
  2076e8:	09 c1                	or     ecx,eax
  2076ea:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  2076ef:	c1 e2 10             	shl    edx,0x10
  2076f2:	09 ca                	or     edx,ecx
  2076f4:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  2076f9:	c1 e0 18             	shl    eax,0x18
  2076fc:	09 d0                	or     eax,edx
  2076fe:	eb 19                	jmp    207719 <openSelfDebugInfo+0x2b89>
                result = (result << 8) | b;
  207700:	c1 e0 08             	shl    eax,0x8
  207703:	09 c8                	or     eax,ecx
  207705:	c1 e0 08             	shl    eax,0x8
  207708:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20770d:	09 c1                	or     ecx,eax
  20770f:	c1 e1 08             	shl    ecx,0x8
  207712:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  207717:	09 c8                	or     eax,ecx
            elf.entry_addr = u64(try in.readInt(elf.endian, u32));
  207719:	89 c0                	mov    eax,eax
  20771b:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
  20771f:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  207722:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  207726:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20772b:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  207730:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  207737:	00 00 
  207739:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  207740:	00 
  207741:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  207746:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20774b:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20774f:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  207756:	00 
            const amt_read = try self.read(buf);
  207757:	66 85 ed             	test   bp,bp
  20775a:	0f 85 da d6 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  207760:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  207767:	00 
  207768:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20776c:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  207771:	0f 82 c3 d6 ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
  207777:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20777c:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  207781:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  207786:	74 1b                	je     2077a3 <openSelfDebugInfo+0x2c13>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  207788:	c1 e1 08             	shl    ecx,0x8
  20778b:	09 c1                	or     ecx,eax
  20778d:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  207792:	c1 e2 10             	shl    edx,0x10
  207795:	09 ca                	or     edx,ecx
  207797:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20779c:	c1 e0 18             	shl    eax,0x18
  20779f:	09 d0                	or     eax,edx
  2077a1:	eb 19                	jmp    2077bc <openSelfDebugInfo+0x2c2c>
                result = (result << 8) | b;
  2077a3:	c1 e0 08             	shl    eax,0x8
  2077a6:	09 c8                	or     eax,ecx
  2077a8:	c1 e0 08             	shl    eax,0x8
  2077ab:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  2077b0:	09 c1                	or     ecx,eax
  2077b2:	c1 e1 08             	shl    ecx,0x8
  2077b5:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  2077ba:	09 c8                	or     eax,ecx
  2077bc:	89 c0                	mov    eax,eax
  2077be:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
  2077c2:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  2077c5:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  2077c9:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2077ce:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  2077d3:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  2077da:	00 00 
  2077dc:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  2077e3:	00 
  2077e4:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  2077e9:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  2077ee:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  2077f2:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  2077f9:	00 
            const amt_read = try self.read(buf);
  2077fa:	66 85 ed             	test   bp,bp
  2077fd:	0f 85 37 d6 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  207803:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20780a:	00 
  20780b:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20780f:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  207814:	0f 82 20 d6 ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
  20781a:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20781f:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  207824:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  207829:	74 1b                	je     207846 <openSelfDebugInfo+0x2cb6>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20782b:	c1 e1 08             	shl    ecx,0x8
  20782e:	09 c1                	or     ecx,eax
  207830:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  207835:	c1 e2 10             	shl    edx,0x10
  207838:	09 ca                	or     edx,ecx
  20783a:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20783f:	c1 e0 18             	shl    eax,0x18
  207842:	09 d0                	or     eax,edx
  207844:	eb 19                	jmp    20785f <openSelfDebugInfo+0x2ccf>
                result = (result << 8) | b;
  207846:	c1 e0 08             	shl    eax,0x8
  207849:	09 c8                	or     eax,ecx
  20784b:	c1 e0 08             	shl    eax,0x8
  20784e:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  207853:	09 c1                	or     ecx,eax
  207855:	c1 e1 08             	shl    ecx,0x8
  207858:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20785d:	09 c8                	or     eax,ecx
  20785f:	89 c0                	mov    eax,eax
  207861:	e9 5b db ff ff       	jmp    2053c1 <openSelfDebugInfo+0x831>
        const ph_entry_size = try in.readInt(elf.endian, u16);
  207866:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20786b:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20786d:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  207871:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  207876:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20787b:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  207882:	00 00 
  207884:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20788b:	00 
  20788c:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  207891:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  207896:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20789a:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  2078a1:	00 
            const amt_read = try self.read(buf);
  2078a2:	66 85 ed             	test   bp,bp
  2078a5:	0f 85 8f d5 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  2078ab:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2078b2:	00 
  2078b3:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  2078b7:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  2078bc:	0f 82 78 d5 ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
  2078c2:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2078c7:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  2078cc:	89 c1                	mov    ecx,eax
  2078ce:	c1 e1 08             	shl    ecx,0x8
  2078d1:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  2078d3:	c1 e2 08             	shl    edx,0x8
  2078d6:	09 c2                	or     edx,eax
    switch (endian) {
  2078d8:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  2078dd:	66 0f 45 d1          	cmovne dx,cx
  2078e1:	89 54 24 48          	mov    DWORD PTR [rsp+0x48],edx
        const ph_entry_count = try in.readInt(elf.endian, u16);
  2078e5:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  2078ea:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  2078ec:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  2078f0:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2078f5:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  2078fa:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  207901:	00 00 
  207903:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20790a:	00 
  20790b:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  207910:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  207915:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  207919:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  207920:	00 
            const amt_read = try self.read(buf);
  207921:	66 85 ed             	test   bp,bp
  207924:	0f 85 10 d5 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  20792a:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  207931:	00 
  207932:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  207936:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20793b:	0f 82 f9 d4 ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
  207941:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  207946:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  20794b:	89 c1                	mov    ecx,eax
  20794d:	c1 e1 08             	shl    ecx,0x8
  207950:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  207952:	c1 e2 08             	shl    edx,0x8
  207955:	09 c2                	or     edx,eax
    switch (endian) {
  207957:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20795c:	66 0f 45 d1          	cmovne dx,cx
  207960:	89 54 24 50          	mov    DWORD PTR [rsp+0x50],edx
        const sh_entry_size = try in.readInt(elf.endian, u16);
  207964:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  207969:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20796b:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20796f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  207974:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  207979:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  207980:	00 00 
  207982:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  207989:	00 
  20798a:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20798f:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  207994:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  207998:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20799f:	00 
            const amt_read = try self.read(buf);
  2079a0:	66 85 ed             	test   bp,bp
  2079a3:	0f 85 91 d4 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  2079a9:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2079b0:	00 
  2079b1:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  2079b5:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  2079ba:	0f 82 7a d4 ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
  2079c0:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2079c5:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  2079ca:	89 c1                	mov    ecx,eax
  2079cc:	c1 e1 08             	shl    ecx,0x8
  2079cf:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  2079d1:	c1 e2 08             	shl    edx,0x8
  2079d4:	09 c2                	or     edx,eax
    switch (endian) {
  2079d6:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  2079db:	66 0f 45 d1          	cmovne dx,cx
  2079df:	89 54 24 40          	mov    DWORD PTR [rsp+0x40],edx
        const sh_entry_count = try in.readInt(elf.endian, u16);
  2079e3:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  2079e8:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  2079ea:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  2079ee:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2079f3:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  2079f8:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  2079ff:	00 00 
  207a01:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  207a08:	00 
  207a09:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  207a0e:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  207a13:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  207a17:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  207a1e:	00 
            const amt_read = try self.read(buf);
  207a1f:	66 85 ed             	test   bp,bp
  207a22:	0f 85 12 d4 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  207a28:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  207a2f:	00 
  207a30:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  207a34:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  207a39:	0f 82 fb d3 ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
  207a3f:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  207a44:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  207a49:	89 c1                	mov    ecx,eax
  207a4b:	c1 e1 08             	shl    ecx,0x8
  207a4e:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  207a50:	c1 e2 08             	shl    edx,0x8
  207a53:	09 c2                	or     edx,eax
    switch (endian) {
  207a55:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  207a5a:	66 0f 45 d1          	cmovne dx,cx
  207a5e:	89 54 24 38          	mov    DWORD PTR [rsp+0x38],edx
        elf.string_section_index = u64(try in.readInt(elf.endian, u16));
  207a62:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  207a65:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  207a69:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  207a6e:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  207a73:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  207a7a:	00 00 
  207a7c:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  207a83:	00 
  207a84:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  207a89:	48 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],rdi
            return self.readFn(self, buffer);
  207a8e:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  207a93:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  207a97:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  207a9e:	00 
            const amt_read = try self.read(buf);
  207a9f:	66 85 ed             	test   bp,bp
  207aa2:	0f 85 92 d3 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  207aa8:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  207aaf:	00 
  207ab0:	66 bd 1e 00          	mov    bp,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  207ab4:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  207ab9:	0f 82 7b d3 ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
  207abf:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  207ac4:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  207ac9:	89 ca                	mov    edx,ecx
  207acb:	c1 e2 08             	shl    edx,0x8
  207ace:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  207ad0:	c1 e0 08             	shl    eax,0x8
  207ad3:	09 c8                	or     eax,ecx
    switch (endian) {
  207ad5:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  207ada:	66 0f 45 c2          	cmovne ax,dx
  207ade:	0f b7 c0             	movzx  eax,ax
  207ae1:	48 89 43 30          	mov    QWORD PTR [rbx+0x30],rax
        if (elf.string_section_index >= sh_entry_count) return error.InvalidFormat;
  207ae5:	66 3b 44 24 38       	cmp    ax,WORD PTR [rsp+0x38]
  207aea:	0f 83 bd d9 ff ff    	jae    2054ad <openSelfDebugInfo+0x91d>
  207af0:	0f b7 4c 24 38       	movzx  ecx,WORD PTR [rsp+0x38]
        const sh_byte_count = u64(sh_entry_size) * u64(sh_entry_count);
  207af5:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  207afa:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  207aff:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  207b04:	48 0f af c1          	imul   rax,rcx
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  207b08:	48 03 43 28          	add    rax,QWORD PTR [rbx+0x28]
  207b0c:	73 1f                	jae    207b2d <openSelfDebugInfo+0x2f9d>
  207b0e:	48 8d 05 ab aa ff ff 	lea    rax,[rip+0xffffffffffffaaab]        # 2025c0 <__unnamed_48>
  207b15:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  207b1a:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  207b1f:	0f b7 28             	movzx  ebp,WORD PTR [rax]
        const end_sh = try math.add(u64, elf.section_header_offset, sh_byte_count);
  207b22:	66 85 ed             	test   bp,bp
  207b25:	0f 85 0f d3 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  207b2b:	eb 23                	jmp    207b50 <openSelfDebugInfo+0x2fc0>
  207b2d:	66 c7 84 24 a0 00 00 	mov    WORD PTR [rsp+0xa0],0x0
  207b34:	00 00 00 
  207b37:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  207b3e:	00 
  207b3f:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  207b44:	0f b7 28             	movzx  ebp,WORD PTR [rax]
  207b47:	66 85 ed             	test   bp,bp
  207b4a:	0f 85 ea d2 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  207b50:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  207b55:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
        const ph_byte_count = u64(ph_entry_size) * u64(ph_entry_count);
  207b59:	0f b7 44 24 48       	movzx  eax,WORD PTR [rsp+0x48]
  207b5e:	0f b7 4c 24 50       	movzx  ecx,WORD PTR [rsp+0x50]
  207b63:	48 0f af c8          	imul   rcx,rax
  207b67:	48 03 4b 20          	add    rcx,QWORD PTR [rbx+0x20]
  207b6b:	73 15                	jae    207b82 <openSelfDebugInfo+0x2ff2>
  207b6d:	48 8d 05 4c aa ff ff 	lea    rax,[rip+0xffffffffffffaa4c]        # 2025c0 <__unnamed_48>
  207b74:	0f b7 28             	movzx  ebp,WORD PTR [rax]
        const end_ph = try math.add(u64, elf.program_header_offset, ph_byte_count);
  207b77:	66 85 ed             	test   bp,bp
  207b7a:	0f 85 ba d2 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  207b80:	eb 26                	jmp    207ba8 <openSelfDebugInfo+0x3018>
  207b82:	48 8d 84 24 a0 00 00 	lea    rax,[rsp+0xa0]
  207b89:	00 
  207b8a:	66 c7 84 24 a0 00 00 	mov    WORD PTR [rsp+0xa0],0x0
  207b91:	00 00 00 
  207b94:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  207b9b:	00 
  207b9c:	0f b7 28             	movzx  ebp,WORD PTR [rax]
  207b9f:	66 85 ed             	test   bp,bp
  207ba2:	0f 85 92 d2 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  207ba8:	4c 8b 40 08          	mov    r8,QWORD PTR [rax+0x8]
        const stream_end = try elf.in_file.getEndPos();
  207bac:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
pub fn accept4(fd: i32, noalias addr: *sockaddr, noalias len: *socklen_t, flags: u32) usize {
    return syscall4(SYS_accept4, @intCast(usize, fd), @ptrToInt(addr), @ptrToInt(len), flags);
}

pub fn fstat(fd: i32, stat_buf: *Stat) usize {
    return syscall2(SYS_fstat, @intCast(usize, fd), @ptrToInt(stat_buf));
  207bb0:	48 63 38             	movsxd rdi,DWORD PTR [rax]
        }
    }
}

pub fn posixFStat(fd: i32) !posix.Stat {
    var stat: posix.Stat = undefined;
  207bb3:	c5 fc 10 05 9d 94 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff949d]        # 201058 <__unnamed_49+0x70>
  207bba:	ff 
  207bbb:	c5 fc 11 84 24 10 01 	vmovups YMMWORD PTR [rsp+0x110],ymm0
  207bc2:	00 00 
  207bc4:	c5 fc 10 05 7c 94 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff947c]        # 201048 <__unnamed_49+0x60>
  207bcb:	ff 
  207bcc:	c5 fc 11 84 24 00 01 	vmovups YMMWORD PTR [rsp+0x100],ymm0
  207bd3:	00 00 
  207bd5:	c5 fc 10 05 4b 94 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff944b]        # 201028 <__unnamed_49+0x40>
  207bdc:	ff 
  207bdd:	c5 fc 11 84 24 e0 00 	vmovups YMMWORD PTR [rsp+0xe0],ymm0
  207be4:	00 00 
  207be6:	c5 fc 10 05 1a 94 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff941a]        # 201008 <__unnamed_49+0x20>
  207bed:	ff 
  207bee:	c5 fc 11 84 24 c0 00 	vmovups YMMWORD PTR [rsp+0xc0],ymm0
  207bf5:	00 00 
  207bf7:	c5 fe 6f 05 e9 93 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff93e9]        # 200fe8 <__unnamed_49>
  207bfe:	ff 
  207bff:	c5 fe 7f 84 24 a0 00 	vmovdqu YMMWORD PTR [rsp+0xa0],ymm0
  207c06:	00 00 
  207c08:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  207c0f:	00 
    return asm volatile ("syscall"
  207c10:	b8 05 00 00 00       	mov    eax,0x5
  207c15:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  207c17:	48 89 c6             	mov    rsi,rax
  207c1a:	48 f7 de             	neg    rsi
  207c1d:	31 c9                	xor    ecx,ecx
  207c1f:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  207c25:	48 0f 47 ce          	cmova  rcx,rsi
    const err = posix.getErrno(posix.fstat(fd, &stat));
    if (err > 0) {
  207c29:	48 85 c9             	test   rcx,rcx
  207c2c:	74 26                	je     207c54 <openSelfDebugInfo+0x30c4>
  207c2e:	48 83 f9 09          	cmp    rcx,0x9
  207c32:	0f 84 18 06 00 00    	je     208250 <openSelfDebugInfo+0x36c0>
  207c38:	48 83 f9 0c          	cmp    rcx,0xc
  207c3c:	0f 85 28 06 00 00    	jne    20826a <openSelfDebugInfo+0x36da>
  207c42:	66 bd 01 00          	mov    bp,0x1
            try st.elf.openFile(allocator, &st.self_exe_file);
  207c46:	66 85 ed             	test   bp,bp
  207c49:	0f 85 f4 d1 ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
  207c4f:	e9 66 d8 ff ff       	jmp    2054ba <openSelfDebugInfo+0x92a>
            posix.ENOMEM => error.SystemResources,
            else => os.unexpectedErrorPosix(err),
        };
    }

    return stat;
  207c54:	48 8b 84 24 d0 00 00 	mov    rax,QWORD PTR [rsp+0xd0]
  207c5b:	00 
  207c5c:	48 89 84 24 60 01 00 	mov    QWORD PTR [rsp+0x160],rax
  207c63:	00 
  207c64:	66 bd 1f 00          	mov    bp,0x1f
        if (stream_end < end_sh or stream_end < end_ph) {
  207c68:	48 39 d0             	cmp    rax,rdx
  207c6b:	0f 82 c9 d1 ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
  207c71:	4c 39 84 24 60 01 00 	cmp    QWORD PTR [rsp+0x160],r8
  207c78:	00 
  207c79:	0f 82 bb d1 ff ff    	jb     204e3a <openSelfDebugInfo+0x2aa>
        try elf.in_file.seekTo(elf.section_header_offset);
  207c7f:	48 8b 73 28          	mov    rsi,QWORD PTR [rbx+0x28]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  207c83:	48 85 f6             	test   rsi,rsi
  207c86:	0f 88 f0 05 00 00    	js     20827c <openSelfDebugInfo+0x36ec>
  207c8c:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  207c90:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  207c93:	31 ed                	xor    ebp,ebp
    return asm volatile ("syscall"
  207c95:	b8 08 00 00 00       	mov    eax,0x8
  207c9a:	31 d2                	xor    edx,edx
  207c9c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  207c9e:	48 89 c1             	mov    rcx,rax
  207ca1:	48 f7 d9             	neg    rcx
  207ca4:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  207caa:	48 0f 46 cd          	cmovbe rcx,rbp
  207cae:	48 83 f9 1d          	cmp    rcx,0x1d
  207cb2:	0f 87 85 05 00 00    	ja     20823d <openSelfDebugInfo+0x36ad>
  207cb8:	48 8d 05 55 89 ff ff 	lea    rax,[rip+0xffffffffffff8955]        # 200614 <__unnamed_128+0x3cc>
  207cbf:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  207cc3:	48 01 c1             	add    rcx,rax
  207cc6:	66 bd 05 00          	mov    bp,0x5
  207cca:	ff e1                	jmp    rcx
        elf.section_headers = try elf.allocator.alloc(SectionHeader, sh_entry_count);
  207ccc:	48 8b 73 50          	mov    rsi,QWORD PTR [rbx+0x50]
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  207cd0:	48 8b 54 24 38       	mov    rdx,QWORD PTR [rsp+0x38]
  207cd5:	48 c1 e2 06          	shl    rdx,0x6
  207cd9:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  207ce0:	00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  207ce1:	b9 04 00 00 00       	mov    ecx,0x4
  207ce6:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  207ced:	00 
  207cee:	c5 f8 77             	vzeroupper 
  207cf1:	ff 16                	call   QWORD PTR [rsi]
  207cf3:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  207cfa:	00 
  207cfb:	66 85 ed             	test   bp,bp
  207cfe:	0f 85 36 d1 ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
        assert(byte_slice.len == byte_count);
  207d04:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  207d0b:	00 
  207d0c:	48 39 84 24 b0 00 00 	cmp    QWORD PTR [rsp+0xb0],rax
  207d13:	00 
    if (!ok) {
  207d14:	0f 85 48 05 00 00    	jne    208262 <openSelfDebugInfo+0x36d2>
  207d1a:	48 8d 43 50          	lea    rax,[rbx+0x50]
  207d1e:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  207d23:	48 8d 43 40          	lea    rax,[rbx+0x40]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  207d27:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  207d2c:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  207d33:	00 
  207d34:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  207d39:	48 89 43 40          	mov    QWORD PTR [rbx+0x40],rax
  207d3d:	48 8d 43 48          	lea    rax,[rbx+0x48]
  207d41:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  207d46:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  207d4b:	48 89 43 48          	mov    QWORD PTR [rbx+0x48],rax
        if (elf.is_64) {
  207d4f:	80 7b 11 01          	cmp    BYTE PTR [rbx+0x11],0x1
  207d53:	0f 85 35 05 00 00    	jne    20828e <openSelfDebugInfo+0x36fe>
            if (sh_entry_size != 64) return error.InvalidFormat;
  207d59:	83 7c 24 40 40       	cmp    DWORD PTR [rsp+0x40],0x40
  207d5e:	0f 85 a0 0e 00 00    	jne    208c04 <openSelfDebugInfo+0x4074>
                elf_section.name = try in.readInt(elf.endian, u32);
  207d64:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  207d69:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  207d6b:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  207d6f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  207d74:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  207d79:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  207d80:	00 00 
  207d82:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  207d89:	00 
  207d8a:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  207d8f:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  207d94:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  207d98:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  207d9f:	00 
            const amt_read = try self.read(buf);
  207da0:	66 85 ed             	test   bp,bp
  207da3:	0f 85 97 0e 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  207da9:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  207db0:	00 
  207db1:	31 c9                	xor    ecx,ecx
  207db3:	48 89 8c 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rcx
  207dba:	00 
  207dbb:	b9 38 00 00 00       	mov    ecx,0x38
  207dc0:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  207dc5:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  207dca:	0f 82 6c 0e 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  207dd0:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  207dd5:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  207dda:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  207ddf:	74 1b                	je     207dfc <openSelfDebugInfo+0x326c>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  207de1:	c1 e1 08             	shl    ecx,0x8
  207de4:	09 c1                	or     ecx,eax
  207de6:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  207deb:	c1 e2 10             	shl    edx,0x10
  207dee:	09 ca                	or     edx,ecx
  207df0:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  207df5:	c1 e0 18             	shl    eax,0x18
  207df8:	09 d0                	or     eax,edx
  207dfa:	eb 19                	jmp    207e15 <openSelfDebugInfo+0x3285>
                result = (result << 8) | b;
  207dfc:	c1 e0 08             	shl    eax,0x8
  207dff:	09 c8                	or     eax,ecx
  207e01:	c1 e0 08             	shl    eax,0x8
  207e04:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  207e09:	09 c1                	or     ecx,eax
  207e0b:	c1 e1 08             	shl    ecx,0x8
  207e0e:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  207e13:	09 c8                	or     eax,ecx
  207e15:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  207e1a:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  207e1f:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  207e23:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  207e28:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  207e2b:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  207e2f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  207e34:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  207e39:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  207e40:	00 00 
            return self.readFn(self, buffer);
  207e42:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  207e49:	00 
  207e4a:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  207e4f:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  207e54:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  207e58:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  207e5f:	00 
            const amt_read = try self.read(buf);
  207e60:	66 85 ed             	test   bp,bp
  207e63:	0f 85 d7 0d 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  207e69:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  207e70:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  207e71:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  207e76:	0f 82 c0 0d 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  207e7c:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  207e81:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  207e86:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  207e8b:	74 1b                	je     207ea8 <openSelfDebugInfo+0x3318>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  207e8d:	c1 e1 08             	shl    ecx,0x8
  207e90:	09 c1                	or     ecx,eax
  207e92:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  207e97:	c1 e2 10             	shl    edx,0x10
  207e9a:	09 ca                	or     edx,ecx
  207e9c:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  207ea1:	c1 e0 18             	shl    eax,0x18
  207ea4:	09 d0                	or     eax,edx
  207ea6:	eb 19                	jmp    207ec1 <openSelfDebugInfo+0x3331>
                result = (result << 8) | b;
  207ea8:	c1 e0 08             	shl    eax,0x8
  207eab:	09 c8                	or     eax,ecx
  207ead:	c1 e0 08             	shl    eax,0x8
  207eb0:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  207eb5:	09 c1                	or     ecx,eax
  207eb7:	c1 e1 08             	shl    ecx,0x8
  207eba:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  207ebf:	09 c8                	or     eax,ecx
  207ec1:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  207ec6:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  207ecb:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = try in.readInt(elf.endian, u64);
  207ecf:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  207ed4:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  207ed7:	48 8d bc 24 48 03 00 	lea    rdi,[rsp+0x348]
  207ede:	00 
  207edf:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  207ee4:	e8 97 15 00 00       	call   209480 <InStream(ReadError)_readInt.16>
  207ee9:	0f b7 ac 24 48 03 00 	movzx  ebp,WORD PTR [rsp+0x348]
  207ef0:	00 
  207ef1:	66 85 ed             	test   bp,bp
  207ef4:	0f 85 06 0b 00 00    	jne    208a00 <openSelfDebugInfo+0x3e70>
  207efa:	48 8b 84 24 50 03 00 	mov    rax,QWORD PTR [rsp+0x350]
  207f01:	00 
  207f02:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  207f07:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  207f0c:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = try in.readInt(elf.endian, u64);
  207f11:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  207f16:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  207f19:	48 8d bc 24 10 03 00 	lea    rdi,[rsp+0x310]
  207f20:	00 
  207f21:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  207f26:	e8 55 15 00 00       	call   209480 <InStream(ReadError)_readInt.16>
  207f2b:	0f b7 ac 24 10 03 00 	movzx  ebp,WORD PTR [rsp+0x310]
  207f32:	00 
  207f33:	66 85 ed             	test   bp,bp
  207f36:	0f 85 1a 0b 00 00    	jne    208a56 <openSelfDebugInfo+0x3ec6>
  207f3c:	48 8b 84 24 18 03 00 	mov    rax,QWORD PTR [rsp+0x318]
  207f43:	00 
  207f44:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  207f49:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  207f4e:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = try in.readInt(elf.endian, u64);
  207f53:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  207f58:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  207f5b:	48 8d bc 24 f0 02 00 	lea    rdi,[rsp+0x2f0]
  207f62:	00 
  207f63:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  207f68:	e8 13 15 00 00       	call   209480 <InStream(ReadError)_readInt.16>
  207f6d:	0f b7 ac 24 f0 02 00 	movzx  ebp,WORD PTR [rsp+0x2f0]
  207f74:	00 
  207f75:	66 85 ed             	test   bp,bp
  207f78:	0f 85 2e 0b 00 00    	jne    208aac <openSelfDebugInfo+0x3f1c>
  207f7e:	48 8b 84 24 f8 02 00 	mov    rax,QWORD PTR [rsp+0x2f8]
  207f85:	00 
  207f86:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  207f8b:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  207f90:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = try in.readInt(elf.endian, u64);
  207f95:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  207f9a:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  207f9d:	48 8d bc 24 88 01 00 	lea    rdi,[rsp+0x188]
  207fa4:	00 
  207fa5:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  207faa:	e8 d1 14 00 00       	call   209480 <InStream(ReadError)_readInt.16>
  207faf:	0f b7 ac 24 88 01 00 	movzx  ebp,WORD PTR [rsp+0x188]
  207fb6:	00 
  207fb7:	66 85 ed             	test   bp,bp
  207fba:	0f 85 42 0b 00 00    	jne    208b02 <openSelfDebugInfo+0x3f72>
  207fc0:	48 8b 84 24 90 01 00 	mov    rax,QWORD PTR [rsp+0x190]
  207fc7:	00 
  207fc8:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  207fcd:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  207fd2:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  207fd7:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  207fdc:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  207fdf:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  207fe3:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  207fe8:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  207fed:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  207ff4:	00 00 
            return self.readFn(self, buffer);
  207ff6:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  207ffd:	00 
  207ffe:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  208003:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  208008:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20800c:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  208013:	00 
            const amt_read = try self.read(buf);
  208014:	66 85 ed             	test   bp,bp
  208017:	0f 85 23 0c 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  20801d:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  208024:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  208025:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20802a:	0f 82 0c 0c 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  208030:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  208035:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20803a:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20803f:	74 1b                	je     20805c <openSelfDebugInfo+0x34cc>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  208041:	c1 e1 08             	shl    ecx,0x8
  208044:	09 c1                	or     ecx,eax
  208046:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20804b:	c1 e2 10             	shl    edx,0x10
  20804e:	09 ca                	or     edx,ecx
  208050:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  208055:	c1 e0 18             	shl    eax,0x18
  208058:	09 d0                	or     eax,edx
  20805a:	eb 19                	jmp    208075 <openSelfDebugInfo+0x34e5>
                result = (result << 8) | b;
  20805c:	c1 e0 08             	shl    eax,0x8
  20805f:	09 c8                	or     eax,ecx
  208061:	c1 e0 08             	shl    eax,0x8
  208064:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  208069:	09 c1                	or     ecx,eax
  20806b:	c1 e1 08             	shl    ecx,0x8
  20806e:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  208073:	09 c8                	or     eax,ecx
  208075:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20807a:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20807f:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  208083:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  208088:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20808b:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20808f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  208094:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  208099:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  2080a0:	00 00 
            return self.readFn(self, buffer);
  2080a2:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  2080a9:	00 
  2080aa:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  2080af:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  2080b4:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  2080b8:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  2080bf:	00 
            const amt_read = try self.read(buf);
  2080c0:	66 85 ed             	test   bp,bp
  2080c3:	0f 85 77 0b 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  2080c9:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2080d0:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2080d1:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  2080d6:	0f 82 60 0b 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  2080dc:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  2080e1:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  2080e6:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  2080eb:	74 1b                	je     208108 <openSelfDebugInfo+0x3578>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2080ed:	c1 e1 08             	shl    ecx,0x8
  2080f0:	09 c1                	or     ecx,eax
  2080f2:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  2080f7:	c1 e2 10             	shl    edx,0x10
  2080fa:	09 ca                	or     edx,ecx
  2080fc:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  208101:	c1 e0 18             	shl    eax,0x18
  208104:	09 d0                	or     eax,edx
  208106:	eb 19                	jmp    208121 <openSelfDebugInfo+0x3591>
                result = (result << 8) | b;
  208108:	c1 e0 08             	shl    eax,0x8
  20810b:	09 c8                	or     eax,ecx
  20810d:	c1 e0 08             	shl    eax,0x8
  208110:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  208115:	09 c1                	or     ecx,eax
  208117:	c1 e1 08             	shl    ecx,0x8
  20811a:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20811f:	09 c8                	or     eax,ecx
  208121:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  208126:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20812b:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  20812f:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  208134:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  208137:	48 8d bc 24 c0 01 00 	lea    rdi,[rsp+0x1c0]
  20813e:	00 
  20813f:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  208144:	e8 37 13 00 00       	call   209480 <InStream(ReadError)_readInt.16>
  208149:	0f b7 ac 24 c0 01 00 	movzx  ebp,WORD PTR [rsp+0x1c0]
  208150:	00 
  208151:	66 85 ed             	test   bp,bp
  208154:	0f 85 fe 09 00 00    	jne    208b58 <openSelfDebugInfo+0x3fc8>
  20815a:	48 8b 84 24 c8 01 00 	mov    rax,QWORD PTR [rsp+0x1c8]
  208161:	00 
  208162:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  208167:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20816c:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  208171:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  208176:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  208179:	48 8d bc 24 a0 01 00 	lea    rdi,[rsp+0x1a0]
  208180:	00 
  208181:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  208186:	e8 f5 12 00 00       	call   209480 <InStream(ReadError)_readInt.16>
  20818b:	0f b7 ac 24 a0 01 00 	movzx  ebp,WORD PTR [rsp+0x1a0]
  208192:	00 
  208193:	66 85 ed             	test   bp,bp
  208196:	0f 85 12 0a 00 00    	jne    208bae <openSelfDebugInfo+0x401e>
  20819c:	48 8b 84 24 a8 01 00 	mov    rax,QWORD PTR [rsp+0x1a8]
  2081a3:	00 
  2081a4:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  2081a9:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  2081ae:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  2081b2:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  2081b9:	00 
  2081ba:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  2081bd:	48 83 c1 01          	add    rcx,0x1
  2081c1:	48 89 c8             	mov    rax,rcx
  2081c4:	48 89 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rax
  2081cb:	00 
  2081cc:	48 3b 4c 24 38       	cmp    rcx,QWORD PTR [rsp+0x38]
  2081d1:	0f 83 90 0a 00 00    	jae    208c67 <openSelfDebugInfo+0x40d7>
  2081d7:	48 83 44 24 40 40    	add    QWORD PTR [rsp+0x40],0x40
  2081dd:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  2081e2:	48 8b 00             	mov    rax,QWORD PTR [rax]
                elf_section.name = try in.readInt(elf.endian, u32);
  2081e5:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  2081ea:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  2081ef:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  2081f2:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  2081f6:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2081fb:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  208200:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  208207:	00 00 
            return self.readFn(self, buffer);
  208209:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  208210:	00 
  208211:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  208216:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20821b:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20821f:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  208226:	00 
  208227:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20822e:	00 
            const amt_read = try self.read(buf);
  20822f:	66 85 ed             	test   bp,bp
  208232:	0f 84 8d fb ff ff    	je     207dc5 <openSelfDebugInfo+0x3235>
  208238:	e9 03 0a 00 00       	jmp    208c40 <openSelfDebugInfo+0x40b0>
  20823d:	66 bd 05 00          	mov    bp,0x5
  208241:	48 83 f9 4b          	cmp    rcx,0x4b
  208245:	0f 85 ef cb ff ff    	jne    204e3a <openSelfDebugInfo+0x2aa>
  20824b:	e9 b6 ce ff ff       	jmp    205106 <openSelfDebugInfo+0x576>
  208250:	66 bd 1c 00          	mov    bp,0x1c
            try st.elf.openFile(allocator, &st.self_exe_file);
  208254:	66 85 ed             	test   bp,bp
  208257:	0f 85 e6 cb ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
  20825d:	e9 58 d2 ff ff       	jmp    2054ba <openSelfDebugInfo+0x92a>
            @panic("assertion failure");
  208262:	c5 f8 77             	vzeroupper 
  208265:	e8 66 af ff ff       	call   2031d0 <panic>
  20826a:	66 bd 05 00          	mov    bp,0x5
            try st.elf.openFile(allocator, &st.self_exe_file);
  20826e:	66 85 ed             	test   bp,bp
  208271:	0f 85 cc cb ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
  208277:	e9 3e d2 ff ff       	jmp    2054ba <openSelfDebugInfo+0x92a>
  20827c:	66 bd 21 00          	mov    bp,0x21
  208280:	66 85 ed             	test   bp,bp
  208283:	0f 85 ba cb ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
  208289:	e9 2c d2 ff ff       	jmp    2054ba <openSelfDebugInfo+0x92a>
            if (sh_entry_size != 40) return error.InvalidFormat;
  20828e:	83 7c 24 40 28       	cmp    DWORD PTR [rsp+0x40],0x28
  208293:	0f 85 6b 09 00 00    	jne    208c04 <openSelfDebugInfo+0x4074>
                elf_section.name = try in.readInt(elf.endian, u32);
  208299:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20829e:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  2082a0:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  2082a4:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2082a9:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  2082ae:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  2082b5:	00 00 
  2082b7:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  2082be:	00 
  2082bf:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  2082c4:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  2082c9:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  2082cd:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  2082d4:	00 
            const amt_read = try self.read(buf);
  2082d5:	66 85 ed             	test   bp,bp
  2082d8:	0f 85 62 09 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  2082de:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2082e5:	00 
  2082e6:	31 c9                	xor    ecx,ecx
  2082e8:	48 89 8c 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rcx
  2082ef:	00 
  2082f0:	b9 38 00 00 00       	mov    ecx,0x38
  2082f5:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  2082fa:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  2082ff:	0f 82 37 09 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  208305:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20830a:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20830f:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  208314:	74 1b                	je     208331 <openSelfDebugInfo+0x37a1>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  208316:	c1 e1 08             	shl    ecx,0x8
  208319:	09 c1                	or     ecx,eax
  20831b:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  208320:	c1 e2 10             	shl    edx,0x10
  208323:	09 ca                	or     edx,ecx
  208325:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20832a:	c1 e0 18             	shl    eax,0x18
  20832d:	09 d0                	or     eax,edx
  20832f:	eb 19                	jmp    20834a <openSelfDebugInfo+0x37ba>
                result = (result << 8) | b;
  208331:	c1 e0 08             	shl    eax,0x8
  208334:	09 c8                	or     eax,ecx
  208336:	c1 e0 08             	shl    eax,0x8
  208339:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20833e:	09 c1                	or     ecx,eax
  208340:	c1 e1 08             	shl    ecx,0x8
  208343:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  208348:	09 c8                	or     eax,ecx
  20834a:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20834f:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  208354:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  208358:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20835d:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  208360:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  208364:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  208369:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20836e:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  208375:	00 00 
            return self.readFn(self, buffer);
  208377:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20837e:	00 
  20837f:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  208384:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  208389:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20838d:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  208394:	00 
            const amt_read = try self.read(buf);
  208395:	66 85 ed             	test   bp,bp
  208398:	0f 85 a2 08 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  20839e:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2083a5:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2083a6:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  2083ab:	0f 82 8b 08 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  2083b1:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  2083b6:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  2083bb:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  2083c0:	74 1b                	je     2083dd <openSelfDebugInfo+0x384d>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2083c2:	c1 e1 08             	shl    ecx,0x8
  2083c5:	09 c1                	or     ecx,eax
  2083c7:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  2083cc:	c1 e2 10             	shl    edx,0x10
  2083cf:	09 ca                	or     edx,ecx
  2083d1:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  2083d6:	c1 e0 18             	shl    eax,0x18
  2083d9:	09 d0                	or     eax,edx
  2083db:	eb 19                	jmp    2083f6 <openSelfDebugInfo+0x3866>
                result = (result << 8) | b;
  2083dd:	c1 e0 08             	shl    eax,0x8
  2083e0:	09 c8                	or     eax,ecx
  2083e2:	c1 e0 08             	shl    eax,0x8
  2083e5:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  2083ea:	09 c1                	or     ecx,eax
  2083ec:	c1 e1 08             	shl    ecx,0x8
  2083ef:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  2083f4:	09 c8                	or     eax,ecx
  2083f6:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  2083fb:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  208400:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = u64(try in.readInt(elf.endian, u32));
  208404:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  208409:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20840c:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  208410:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  208415:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20841a:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  208421:	00 00 
            return self.readFn(self, buffer);
  208423:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20842a:	00 
  20842b:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  208430:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  208435:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  208439:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  208440:	00 
            const amt_read = try self.read(buf);
  208441:	66 85 ed             	test   bp,bp
  208444:	0f 85 f6 07 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  20844a:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  208451:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  208452:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  208457:	0f 82 df 07 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  20845d:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  208462:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  208467:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20846c:	74 1b                	je     208489 <openSelfDebugInfo+0x38f9>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20846e:	c1 e1 08             	shl    ecx,0x8
  208471:	09 c1                	or     ecx,eax
  208473:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  208478:	c1 e2 10             	shl    edx,0x10
  20847b:	09 ca                	or     edx,ecx
  20847d:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  208482:	c1 e0 18             	shl    eax,0x18
  208485:	09 d0                	or     eax,edx
  208487:	eb 19                	jmp    2084a2 <openSelfDebugInfo+0x3912>
                result = (result << 8) | b;
  208489:	c1 e0 08             	shl    eax,0x8
  20848c:	09 c8                	or     eax,ecx
  20848e:	c1 e0 08             	shl    eax,0x8
  208491:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  208496:	09 c1                	or     ecx,eax
  208498:	c1 e1 08             	shl    ecx,0x8
  20849b:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  2084a0:	09 c8                	or     eax,ecx
  2084a2:	89 c0                	mov    eax,eax
  2084a4:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  2084a9:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  2084ae:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = u64(try in.readInt(elf.endian, u32));
  2084b3:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  2084b8:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  2084bb:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  2084bf:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2084c4:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  2084c9:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  2084d0:	00 00 
            return self.readFn(self, buffer);
  2084d2:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  2084d9:	00 
  2084da:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  2084df:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  2084e4:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  2084e8:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  2084ef:	00 
            const amt_read = try self.read(buf);
  2084f0:	66 85 ed             	test   bp,bp
  2084f3:	0f 85 47 07 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  2084f9:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  208500:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  208501:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  208506:	0f 82 30 07 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  20850c:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  208511:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  208516:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20851b:	74 1b                	je     208538 <openSelfDebugInfo+0x39a8>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20851d:	c1 e1 08             	shl    ecx,0x8
  208520:	09 c1                	or     ecx,eax
  208522:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  208527:	c1 e2 10             	shl    edx,0x10
  20852a:	09 ca                	or     edx,ecx
  20852c:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  208531:	c1 e0 18             	shl    eax,0x18
  208534:	09 d0                	or     eax,edx
  208536:	eb 19                	jmp    208551 <openSelfDebugInfo+0x39c1>
                result = (result << 8) | b;
  208538:	c1 e0 08             	shl    eax,0x8
  20853b:	09 c8                	or     eax,ecx
  20853d:	c1 e0 08             	shl    eax,0x8
  208540:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  208545:	09 c1                	or     ecx,eax
  208547:	c1 e1 08             	shl    ecx,0x8
  20854a:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20854f:	09 c8                	or     eax,ecx
  208551:	89 c0                	mov    eax,eax
  208553:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  208558:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20855d:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = u64(try in.readInt(elf.endian, u32));
  208562:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  208567:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20856a:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20856e:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  208573:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  208578:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20857f:	00 00 
            return self.readFn(self, buffer);
  208581:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  208588:	00 
  208589:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20858e:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  208593:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  208597:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20859e:	00 
            const amt_read = try self.read(buf);
  20859f:	66 85 ed             	test   bp,bp
  2085a2:	0f 85 98 06 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  2085a8:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2085af:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2085b0:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  2085b5:	0f 82 81 06 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  2085bb:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  2085c0:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  2085c5:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  2085ca:	74 1b                	je     2085e7 <openSelfDebugInfo+0x3a57>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2085cc:	c1 e1 08             	shl    ecx,0x8
  2085cf:	09 c1                	or     ecx,eax
  2085d1:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  2085d6:	c1 e2 10             	shl    edx,0x10
  2085d9:	09 ca                	or     edx,ecx
  2085db:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  2085e0:	c1 e0 18             	shl    eax,0x18
  2085e3:	09 d0                	or     eax,edx
  2085e5:	eb 19                	jmp    208600 <openSelfDebugInfo+0x3a70>
                result = (result << 8) | b;
  2085e7:	c1 e0 08             	shl    eax,0x8
  2085ea:	09 c8                	or     eax,ecx
  2085ec:	c1 e0 08             	shl    eax,0x8
  2085ef:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  2085f4:	09 c1                	or     ecx,eax
  2085f6:	c1 e1 08             	shl    ecx,0x8
  2085f9:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  2085fe:	09 c8                	or     eax,ecx
  208600:	89 c0                	mov    eax,eax
  208602:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  208607:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20860c:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = u64(try in.readInt(elf.endian, u32));
  208611:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  208616:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  208619:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20861d:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  208622:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  208627:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20862e:	00 00 
            return self.readFn(self, buffer);
  208630:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  208637:	00 
  208638:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20863d:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  208642:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  208646:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20864d:	00 
            const amt_read = try self.read(buf);
  20864e:	66 85 ed             	test   bp,bp
  208651:	0f 85 e9 05 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  208657:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20865e:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20865f:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  208664:	0f 82 d2 05 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  20866a:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20866f:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  208674:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  208679:	74 1b                	je     208696 <openSelfDebugInfo+0x3b06>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20867b:	c1 e1 08             	shl    ecx,0x8
  20867e:	09 c1                	or     ecx,eax
  208680:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  208685:	c1 e2 10             	shl    edx,0x10
  208688:	09 ca                	or     edx,ecx
  20868a:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20868f:	c1 e0 18             	shl    eax,0x18
  208692:	09 d0                	or     eax,edx
  208694:	eb 19                	jmp    2086af <openSelfDebugInfo+0x3b1f>
                result = (result << 8) | b;
  208696:	c1 e0 08             	shl    eax,0x8
  208699:	09 c8                	or     eax,ecx
  20869b:	c1 e0 08             	shl    eax,0x8
  20869e:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  2086a3:	09 c1                	or     ecx,eax
  2086a5:	c1 e1 08             	shl    ecx,0x8
  2086a8:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  2086ad:	09 c8                	or     eax,ecx
  2086af:	89 c0                	mov    eax,eax
  2086b1:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  2086b6:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  2086bb:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  2086c0:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  2086c5:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  2086c8:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  2086cc:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2086d1:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  2086d6:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  2086dd:	00 00 
            return self.readFn(self, buffer);
  2086df:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  2086e6:	00 
  2086e7:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  2086ec:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  2086f1:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  2086f5:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  2086fc:	00 
            const amt_read = try self.read(buf);
  2086fd:	66 85 ed             	test   bp,bp
  208700:	0f 85 3a 05 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  208706:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20870d:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20870e:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  208713:	0f 82 23 05 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  208719:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20871e:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  208723:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  208728:	74 1b                	je     208745 <openSelfDebugInfo+0x3bb5>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20872a:	c1 e1 08             	shl    ecx,0x8
  20872d:	09 c1                	or     ecx,eax
  20872f:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  208734:	c1 e2 10             	shl    edx,0x10
  208737:	09 ca                	or     edx,ecx
  208739:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20873e:	c1 e0 18             	shl    eax,0x18
  208741:	09 d0                	or     eax,edx
  208743:	eb 19                	jmp    20875e <openSelfDebugInfo+0x3bce>
                result = (result << 8) | b;
  208745:	c1 e0 08             	shl    eax,0x8
  208748:	09 c8                	or     eax,ecx
  20874a:	c1 e0 08             	shl    eax,0x8
  20874d:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  208752:	09 c1                	or     ecx,eax
  208754:	c1 e1 08             	shl    ecx,0x8
  208757:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20875c:	09 c8                	or     eax,ecx
  20875e:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  208763:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  208768:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  20876c:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  208771:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  208774:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  208778:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20877d:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  208782:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  208789:	00 00 
            return self.readFn(self, buffer);
  20878b:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  208792:	00 
  208793:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  208798:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20879d:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  2087a1:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  2087a8:	00 
            const amt_read = try self.read(buf);
  2087a9:	66 85 ed             	test   bp,bp
  2087ac:	0f 85 8e 04 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  2087b2:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2087b9:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2087ba:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  2087bf:	0f 82 77 04 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  2087c5:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  2087ca:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  2087cf:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  2087d4:	74 1b                	je     2087f1 <openSelfDebugInfo+0x3c61>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2087d6:	c1 e1 08             	shl    ecx,0x8
  2087d9:	09 c1                	or     ecx,eax
  2087db:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  2087e0:	c1 e2 10             	shl    edx,0x10
  2087e3:	09 ca                	or     edx,ecx
  2087e5:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  2087ea:	c1 e0 18             	shl    eax,0x18
  2087ed:	09 d0                	or     eax,edx
  2087ef:	eb 19                	jmp    20880a <openSelfDebugInfo+0x3c7a>
                result = (result << 8) | b;
  2087f1:	c1 e0 08             	shl    eax,0x8
  2087f4:	09 c8                	or     eax,ecx
  2087f6:	c1 e0 08             	shl    eax,0x8
  2087f9:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  2087fe:	09 c1                	or     ecx,eax
  208800:	c1 e1 08             	shl    ecx,0x8
  208803:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  208808:	09 c8                	or     eax,ecx
  20880a:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20880f:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  208814:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = u64(try in.readInt(elf.endian, u32));
  208818:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20881d:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  208820:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  208824:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  208829:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20882e:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  208835:	00 00 
            return self.readFn(self, buffer);
  208837:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20883e:	00 
  20883f:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  208844:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  208849:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20884d:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  208854:	00 
            const amt_read = try self.read(buf);
  208855:	66 85 ed             	test   bp,bp
  208858:	0f 85 e2 03 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  20885e:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  208865:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  208866:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20886b:	0f 82 cb 03 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  208871:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  208876:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20887b:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  208880:	74 1b                	je     20889d <openSelfDebugInfo+0x3d0d>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  208882:	c1 e1 08             	shl    ecx,0x8
  208885:	09 c1                	or     ecx,eax
  208887:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20888c:	c1 e2 10             	shl    edx,0x10
  20888f:	09 ca                	or     edx,ecx
  208891:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  208896:	c1 e0 18             	shl    eax,0x18
  208899:	09 d0                	or     eax,edx
  20889b:	eb 19                	jmp    2088b6 <openSelfDebugInfo+0x3d26>
                result = (result << 8) | b;
  20889d:	c1 e0 08             	shl    eax,0x8
  2088a0:	09 c8                	or     eax,ecx
  2088a2:	c1 e0 08             	shl    eax,0x8
  2088a5:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  2088aa:	09 c1                	or     ecx,eax
  2088ac:	c1 e1 08             	shl    ecx,0x8
  2088af:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  2088b4:	09 c8                	or     eax,ecx
  2088b6:	89 c0                	mov    eax,eax
  2088b8:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  2088bd:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  2088c2:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = u64(try in.readInt(elf.endian, u32));
  2088c7:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  2088cc:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  2088cf:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  2088d3:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2088d8:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  2088dd:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  2088e4:	00 00 
            return self.readFn(self, buffer);
  2088e6:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  2088ed:	00 
  2088ee:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  2088f3:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  2088f8:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  2088fc:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  208903:	00 
            const amt_read = try self.read(buf);
  208904:	66 85 ed             	test   bp,bp
  208907:	0f 85 33 03 00 00    	jne    208c40 <openSelfDebugInfo+0x40b0>
  20890d:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  208914:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  208915:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20891a:	0f 82 1c 03 00 00    	jb     208c3c <openSelfDebugInfo+0x40ac>
  208920:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  208925:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20892a:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20892f:	74 1b                	je     20894c <openSelfDebugInfo+0x3dbc>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  208931:	c1 e1 08             	shl    ecx,0x8
  208934:	09 c1                	or     ecx,eax
  208936:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20893b:	c1 e2 10             	shl    edx,0x10
  20893e:	09 ca                	or     edx,ecx
  208940:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  208945:	c1 e0 18             	shl    eax,0x18
  208948:	09 d0                	or     eax,edx
  20894a:	eb 19                	jmp    208965 <openSelfDebugInfo+0x3dd5>
                result = (result << 8) | b;
  20894c:	c1 e0 08             	shl    eax,0x8
  20894f:	09 c8                	or     eax,ecx
  208951:	c1 e0 08             	shl    eax,0x8
  208954:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  208959:	09 c1                	or     ecx,eax
  20895b:	c1 e1 08             	shl    ecx,0x8
  20895e:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  208963:	09 c8                	or     eax,ecx
  208965:	89 c0                	mov    eax,eax
  208967:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20896c:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  208971:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  208975:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  20897c:	00 
  20897d:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  208980:	48 83 c1 01          	add    rcx,0x1
  208984:	48 89 c8             	mov    rax,rcx
  208987:	48 89 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rax
  20898e:	00 
  20898f:	48 3b 4c 24 38       	cmp    rcx,QWORD PTR [rsp+0x38]
  208994:	0f 83 cd 02 00 00    	jae    208c67 <openSelfDebugInfo+0x40d7>
  20899a:	48 83 44 24 40 40    	add    QWORD PTR [rsp+0x40],0x40
  2089a0:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  2089a5:	48 8b 00             	mov    rax,QWORD PTR [rax]
                elf_section.name = try in.readInt(elf.endian, u32);
  2089a8:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  2089ad:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  2089b2:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  2089b5:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  2089b9:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2089be:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  2089c3:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  2089ca:	00 00 
            return self.readFn(self, buffer);
  2089cc:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  2089d3:	00 
  2089d4:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  2089d9:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  2089de:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  2089e2:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  2089e9:	00 
  2089ea:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  2089f1:	00 
            const amt_read = try self.read(buf);
  2089f2:	66 85 ed             	test   bp,bp
  2089f5:	0f 84 ff f8 ff ff    	je     2082fa <openSelfDebugInfo+0x376a>
  2089fb:	e9 40 02 00 00       	jmp    208c40 <openSelfDebugInfo+0x40b0>
        const bytes = @sliceToBytes(memory);
  208a00:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  208a05:	48 8b 00             	mov    rax,QWORD PTR [rax]
  208a08:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  208a0c:	0f 84 28 c4 ff ff    	je     204e3a <openSelfDebugInfo+0x2aa>
  208a12:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  208a17:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  208a1a:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  208a1f:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  208a22:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  208a26:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  208a2d:	00 
  208a2e:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  208a35:	00 
  208a36:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  208a3d:	00 
  208a3e:	ff d2                	call   rdx
                elf_section.flags = try in.readInt(elf.endian, u64);
  208a40:	0f b7 ac 24 48 03 00 	movzx  ebp,WORD PTR [rsp+0x348]
  208a47:	00 
  208a48:	66 85 ed             	test   bp,bp
  208a4b:	0f 85 f2 c3 ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
  208a51:	e9 64 ca ff ff       	jmp    2054ba <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  208a56:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  208a5b:	48 8b 00             	mov    rax,QWORD PTR [rax]
  208a5e:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  208a62:	0f 84 d2 c3 ff ff    	je     204e3a <openSelfDebugInfo+0x2aa>
  208a68:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  208a6d:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  208a70:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  208a75:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  208a78:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  208a7c:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  208a83:	00 
  208a84:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  208a8b:	00 
  208a8c:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  208a93:	00 
  208a94:	ff d2                	call   rdx
                elf_section.addr = try in.readInt(elf.endian, u64);
  208a96:	0f b7 ac 24 10 03 00 	movzx  ebp,WORD PTR [rsp+0x310]
  208a9d:	00 
  208a9e:	66 85 ed             	test   bp,bp
  208aa1:	0f 85 9c c3 ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
  208aa7:	e9 0e ca ff ff       	jmp    2054ba <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  208aac:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  208ab1:	48 8b 00             	mov    rax,QWORD PTR [rax]
  208ab4:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  208ab8:	0f 84 7c c3 ff ff    	je     204e3a <openSelfDebugInfo+0x2aa>
  208abe:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  208ac3:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  208ac6:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  208acb:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  208ace:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  208ad2:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  208ad9:	00 
  208ada:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  208ae1:	00 
  208ae2:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  208ae9:	00 
  208aea:	ff d2                	call   rdx
                elf_section.offset = try in.readInt(elf.endian, u64);
  208aec:	0f b7 ac 24 f0 02 00 	movzx  ebp,WORD PTR [rsp+0x2f0]
  208af3:	00 
  208af4:	66 85 ed             	test   bp,bp
  208af7:	0f 85 46 c3 ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
  208afd:	e9 b8 c9 ff ff       	jmp    2054ba <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  208b02:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  208b07:	48 8b 00             	mov    rax,QWORD PTR [rax]
  208b0a:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  208b0e:	0f 84 26 c3 ff ff    	je     204e3a <openSelfDebugInfo+0x2aa>
  208b14:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  208b19:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  208b1c:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  208b21:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  208b24:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  208b28:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  208b2f:	00 
  208b30:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  208b37:	00 
  208b38:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  208b3f:	00 
  208b40:	ff d2                	call   rdx
                elf_section.size = try in.readInt(elf.endian, u64);
  208b42:	0f b7 ac 24 88 01 00 	movzx  ebp,WORD PTR [rsp+0x188]
  208b49:	00 
  208b4a:	66 85 ed             	test   bp,bp
  208b4d:	0f 85 f0 c2 ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
  208b53:	e9 62 c9 ff ff       	jmp    2054ba <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  208b58:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  208b5d:	48 8b 00             	mov    rax,QWORD PTR [rax]
  208b60:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  208b64:	0f 84 d0 c2 ff ff    	je     204e3a <openSelfDebugInfo+0x2aa>
  208b6a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  208b6f:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  208b72:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  208b77:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  208b7a:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  208b7e:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  208b85:	00 
  208b86:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  208b8d:	00 
  208b8e:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  208b95:	00 
  208b96:	ff d2                	call   rdx
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  208b98:	0f b7 ac 24 c0 01 00 	movzx  ebp,WORD PTR [rsp+0x1c0]
  208b9f:	00 
  208ba0:	66 85 ed             	test   bp,bp
  208ba3:	0f 85 9a c2 ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
  208ba9:	e9 0c c9 ff ff       	jmp    2054ba <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  208bae:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  208bb3:	48 8b 00             	mov    rax,QWORD PTR [rax]
  208bb6:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  208bba:	0f 84 7a c2 ff ff    	je     204e3a <openSelfDebugInfo+0x2aa>
  208bc0:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  208bc5:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  208bc8:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  208bcd:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  208bd0:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  208bd4:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  208bdb:	00 
  208bdc:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  208be3:	00 
  208be4:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  208beb:	00 
  208bec:	ff d2                	call   rdx
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  208bee:	0f b7 ac 24 a0 01 00 	movzx  ebp,WORD PTR [rsp+0x1a0]
  208bf5:	00 
  208bf6:	66 85 ed             	test   bp,bp
  208bf9:	0f 85 44 c2 ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
  208bff:	e9 b6 c8 ff ff       	jmp    2054ba <openSelfDebugInfo+0x92a>
  208c04:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  208c09:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  208c0c:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  208c10:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  208c15:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  208c1c:	00 
  208c1d:	48 8b 8c 24 38 01 00 	mov    rcx,QWORD PTR [rsp+0x138]
  208c24:	00 
  208c25:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  208c2c:	00 
  208c2d:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  208c34:	00 
  208c35:	ff d0                	call   rax
  208c37:	e9 2e 01 00 00       	jmp    208d6a <openSelfDebugInfo+0x41da>
  208c3c:	66 bd 1e 00          	mov    bp,0x1e
        const bytes = @sliceToBytes(memory);
  208c40:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  208c45:	48 8b 00             	mov    rax,QWORD PTR [rax]
  208c48:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  208c4c:	0f 84 f1 c1 ff ff    	je     204e43 <openSelfDebugInfo+0x2b3>
  208c52:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  208c57:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  208c5a:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  208c5f:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
  208c62:	e9 b4 00 00 00       	jmp    208d1b <openSelfDebugInfo+0x418b>
        for (elf.section_headers) |*elf_section| {
  208c67:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  208c6c:	48 8b 00             	mov    rax,QWORD PTR [rax]
  208c6f:	48 85 c0             	test   rax,rax
  208c72:	74 66                	je     208cda <openSelfDebugInfo+0x414a>
  208c74:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  208c79:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
  208c7c:	48 8d 51 20          	lea    rdx,[rcx+0x20]
  208c80:	31 f6                	xor    esi,esi
  208c82:	4c 8d 05 37 99 ff ff 	lea    r8,[rip+0xffffffffffff9937]        # 2025c0 <__unnamed_48>
            if (elf_section.sh_type != SHT_NOBITS) {
  208c89:	83 7a e4 08          	cmp    DWORD PTR [rdx-0x1c],0x8
  208c8d:	74 3c                	je     208ccb <openSelfDebugInfo+0x413b>
                const file_end_offset = try math.add(u64, elf_section.offset, elf_section.size);
  208c8f:	48 8b 6a f8          	mov    rbp,QWORD PTR [rdx-0x8]
  208c93:	4c 89 c7             	mov    rdi,r8
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  208c96:	48 03 2a             	add    rbp,QWORD PTR [rdx]
  208c99:	72 1a                	jb     208cb5 <openSelfDebugInfo+0x4125>
  208c9b:	66 c7 84 24 a0 00 00 	mov    WORD PTR [rsp+0xa0],0x0
  208ca2:	00 00 00 
  208ca5:	48 89 ac 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rbp
  208cac:	00 
  208cad:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  208cb4:	00 
  208cb5:	0f b7 2f             	movzx  ebp,WORD PTR [rdi]
  208cb8:	66 85 ed             	test   bp,bp
  208cbb:	75 4c                	jne    208d09 <openSelfDebugInfo+0x4179>
                if (stream_end < file_end_offset) return error.InvalidFormat;
  208cbd:	48 8b ac 24 60 01 00 	mov    rbp,QWORD PTR [rsp+0x160]
  208cc4:	00 
  208cc5:	48 3b 6f 08          	cmp    rbp,QWORD PTR [rdi+0x8]
  208cc9:	72 73                	jb     208d3e <openSelfDebugInfo+0x41ae>
        for (elf.section_headers) |*elf_section| {
  208ccb:	48 83 c6 01          	add    rsi,0x1
  208ccf:	48 83 c2 40          	add    rdx,0x40
  208cd3:	48 39 c6             	cmp    rsi,rax
  208cd6:	72 b1                	jb     208c89 <openSelfDebugInfo+0x40f9>
  208cd8:	eb 08                	jmp    208ce2 <openSelfDebugInfo+0x4152>
        elf.string_section = &elf.section_headers[elf.string_section_index];
  208cda:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  208cdf:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
  208ce2:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  208ce6:	48 c1 e2 06          	shl    rdx,0x6
  208cea:	48 8d 34 11          	lea    rsi,[rcx+rdx*1]
  208cee:	48 89 73 38          	mov    QWORD PTR [rbx+0x38],rsi
        if (elf.string_section.sh_type != SHT_STRTAB) {
  208cf2:	83 7c 11 04 03       	cmp    DWORD PTR [rcx+rdx*1+0x4],0x3
  208cf7:	75 45                	jne    208d3e <openSelfDebugInfo+0x41ae>
  208cf9:	31 ed                	xor    ebp,ebp
  208cfb:	66 85 ed             	test   bp,bp
  208cfe:	0f 85 3f c1 ff ff    	jne    204e43 <openSelfDebugInfo+0x2b3>
  208d04:	e9 b1 c7 ff ff       	jmp    2054ba <openSelfDebugInfo+0x92a>
  208d09:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  208d0d:	0f 84 30 c1 ff ff    	je     204e43 <openSelfDebugInfo+0x2b3>
  208d13:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  208d18:	48 8b 3a             	mov    rdi,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  208d1b:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  208d1f:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  208d26:	00 
  208d27:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  208d2e:	00 
  208d2f:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  208d36:	00 
  208d37:	ff d2                	call   rdx
  208d39:	e9 05 c1 ff ff       	jmp    204e43 <openSelfDebugInfo+0x2b3>
        const bytes = @sliceToBytes(memory);
  208d3e:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  208d42:	74 26                	je     208d6a <openSelfDebugInfo+0x41da>
  208d44:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  208d49:	48 8b 3a             	mov    rdi,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  208d4c:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  208d50:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  208d57:	00 
  208d58:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  208d5f:	00 
  208d60:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  208d67:	00 
  208d68:	ff d2                	call   rdx
  208d6a:	66 bd 1f 00          	mov    bp,0x1f
  208d6e:	e9 d0 c0 ff ff       	jmp    204e43 <openSelfDebugInfo+0x2b3>
  208d73:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  208d7a:	84 00 00 00 00 00 

0000000000208d80 <Elf_findSection>:
    }

    pub fn findSection(elf: *Elf, name: []const u8) !?*SectionHeader {
  208d80:	55                   	push   rbp
  208d81:	41 57                	push   r15
  208d83:	41 56                	push   r14
  208d85:	41 55                	push   r13
  208d87:	41 54                	push   r12
  208d89:	53                   	push   rbx
  208d8a:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  208d91:	48 89 d3             	mov    rbx,rdx
  208d94:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
        var file_stream = io.FileInStream.init(elf.in_file);
  208d99:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  208d9c:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  208da1:	48 8d 05 18 09 00 00 	lea    rax,[rip+0x918]        # 2096c0 <FileInStream_readFn>
  208da8:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
        const in = &file_stream.stream;

        section_loop: for (elf.section_headers) |*elf_section| {
  208dad:	48 8b 46 40          	mov    rax,QWORD PTR [rsi+0x40]
  208db1:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  208db6:	48 85 c0             	test   rax,rax
  208db9:	0f 84 37 01 00 00    	je     208ef6 <Elf_findSection+0x176>
  208dbf:	45 31 e4             	xor    r12d,r12d
  208dc2:	48 89 74 24 20       	mov    QWORD PTR [rsp+0x20],rsi
  208dc7:	4c 8b 76 38          	mov    r14,QWORD PTR [rsi+0x38]
  208dcb:	4c 89 e0             	mov    rax,r12
  208dce:	48 c1 e0 06          	shl    rax,0x6
            if (elf_section.sh_type == SHT_NULL) continue;
  208dd2:	41 83 7c 06 04 00    	cmp    DWORD PTR [r14+rax*1+0x4],0x0
  208dd8:	0f 84 04 01 00 00    	je     208ee2 <Elf_findSection+0x162>
  208dde:	49 01 c6             	add    r14,rax
  208de1:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]

            const name_offset = elf.string_section.offset + elf_section.name;
  208de6:	48 8b 41 30          	mov    rax,QWORD PTR [rcx+0x30]
  208dea:	41 8b 36             	mov    esi,DWORD PTR [r14]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  208ded:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  208df1:	0f 88 3e 01 00 00    	js     208f35 <Elf_findSection+0x1b5>
            try elf.in_file.seekTo(name_offset);
  208df7:	48 8b 01             	mov    rax,QWORD PTR [rcx]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  208dfa:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  208dfd:	b8 08 00 00 00       	mov    eax,0x8
  208e02:	31 d2                	xor    edx,edx
  208e04:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  208e06:	48 89 c1             	mov    rcx,rax
  208e09:	48 f7 d9             	neg    rcx
  208e0c:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  208e12:	b8 00 00 00 00       	mov    eax,0x0
  208e17:	48 0f 46 c8          	cmovbe rcx,rax
  208e1b:	48 85 c9             	test   rcx,rcx
  208e1e:	0f 85 1c 01 00 00    	jne    208f40 <Elf_findSection+0x1c0>

            for (name) |expected_c| {
  208e24:	4c 8b 6b 08          	mov    r13,QWORD PTR [rbx+0x8]
  208e28:	4d 85 ed             	test   r13,r13
  208e2b:	74 66                	je     208e93 <Elf_findSection+0x113>
  208e2d:	31 ed                	xor    ebp,ebp
  208e2f:	90                   	nop
  208e30:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  208e33:	44 0f b6 3c 28       	movzx  r15d,BYTE PTR [rax+rbp*1]
            try self.readNoEof(result[0..]);
  208e38:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  208e3d:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  208e42:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  208e49:	00 00 
            return self.readFn(self, buffer);
  208e4b:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  208e50:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  208e55:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  208e5a:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  208e5e:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  208e63:	66 85 c0             	test   ax,ax
  208e66:	0f 85 9d 00 00 00    	jne    208f09 <Elf_findSection+0x189>
  208e6c:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  208e71:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  208e76:	0f 82 89 00 00 00    	jb     208f05 <Elf_findSection+0x185>
            return result[0];
  208e7c:	0f b6 44 24 07       	movzx  eax,BYTE PTR [rsp+0x7]
                const target_c = try in.readByte();
                if (target_c == 0 or expected_c != target_c) continue :section_loop;
  208e81:	84 c0                	test   al,al
  208e83:	74 5d                	je     208ee2 <Elf_findSection+0x162>
  208e85:	41 38 c7             	cmp    r15b,al
  208e88:	75 58                	jne    208ee2 <Elf_findSection+0x162>
  208e8a:	48 83 c5 01          	add    rbp,0x1
            for (name) |expected_c| {
  208e8e:	4c 39 ed             	cmp    rbp,r13
  208e91:	72 9d                	jb     208e30 <Elf_findSection+0xb0>
            try self.readNoEof(result[0..]);
  208e93:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  208e98:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  208e9d:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  208ea4:	00 00 
            return self.readFn(self, buffer);
  208ea6:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  208eab:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  208eb0:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  208eb5:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  208eb9:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  208ebe:	66 85 c0             	test   ax,ax
  208ec1:	0f 85 a6 00 00 00    	jne    208f6d <Elf_findSection+0x1ed>
  208ec7:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  208ecc:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  208ed1:	0f 82 92 00 00 00    	jb     208f69 <Elf_findSection+0x1e9>
            }

            {
                const null_byte = try in.readByte();
                if (null_byte == 0) return elf_section;
  208ed7:	80 7c 24 07 00       	cmp    BYTE PTR [rsp+0x7],0x0
  208edc:	0f 84 9f 00 00 00    	je     208f81 <Elf_findSection+0x201>
        section_loop: for (elf.section_headers) |*elf_section| {
  208ee2:	49 83 c4 01          	add    r12,0x1
  208ee6:	4c 3b 64 24 50       	cmp    r12,QWORD PTR [rsp+0x50]
  208eeb:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  208ef0:	0f 82 d1 fe ff ff    	jb     208dc7 <Elf_findSection+0x47>
            }
        }

        return null;
  208ef6:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  208efa:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  208eff:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  208f03:	eb 1e                	jmp    208f23 <Elf_findSection+0x1a3>
  208f05:	66 b8 1e 00          	mov    ax,0x1e
  208f09:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const target_c = try in.readByte();
  208f0e:	66 89 02             	mov    WORD PTR [rdx],ax
  208f11:	48 8b 44 24 6c       	mov    rax,QWORD PTR [rsp+0x6c]
  208f16:	48 8b 4c 24 72       	mov    rcx,QWORD PTR [rsp+0x72]
  208f1b:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  208f1f:	48 89 42 02          	mov    QWORD PTR [rdx+0x2],rax
  208f23:	48 81 c4 88 00 00 00 	add    rsp,0x88
  208f2a:	5b                   	pop    rbx
  208f2b:	41 5c                	pop    r12
  208f2d:	41 5d                	pop    r13
  208f2f:	41 5e                	pop    r14
  208f31:	41 5f                	pop    r15
  208f33:	5d                   	pop    rbp
  208f34:	c3                   	ret    
  208f35:	66 b8 21 00          	mov    ax,0x21
  208f39:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  208f3e:	eb 72                	jmp    208fb2 <Elf_findSection+0x232>
  208f40:	66 b8 05 00          	mov    ax,0x5
  208f44:	48 8d 51 fa          	lea    rdx,[rcx-0x6]
  208f48:	48 83 fa 17          	cmp    rdx,0x17
  208f4c:	77 53                	ja     208fa1 <Elf_findSection+0x221>
  208f4e:	48 8d 0d b7 78 ff ff 	lea    rcx,[rip+0xffffffffffff78b7]        # 20080c <__unnamed_128+0x5c4>
  208f55:	48 63 14 91          	movsxd rdx,DWORD PTR [rcx+rdx*4]
  208f59:	48 01 ca             	add    rdx,rcx
  208f5c:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  208f61:	ff e2                	jmp    rdx
  208f63:	66 b8 20 00          	mov    ax,0x20
  208f67:	eb 49                	jmp    208fb2 <Elf_findSection+0x232>
  208f69:	66 b8 1e 00          	mov    ax,0x1e
  208f6d:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const null_byte = try in.readByte();
  208f72:	66 89 02             	mov    WORD PTR [rdx],ax
  208f75:	48 8b 44 24 5e       	mov    rax,QWORD PTR [rsp+0x5e]
  208f7a:	48 8b 4c 24 64       	mov    rcx,QWORD PTR [rsp+0x64]
  208f7f:	eb 9a                	jmp    208f1b <Elf_findSection+0x19b>
  208f81:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
                if (null_byte == 0) return elf_section;
  208f86:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  208f8b:	0f b7 44 24 4e       	movzx  eax,WORD PTR [rsp+0x4e]
  208f90:	66 89 41 06          	mov    WORD PTR [rcx+0x6],ax
  208f94:	8b 44 24 4a          	mov    eax,DWORD PTR [rsp+0x4a]
  208f98:	89 41 02             	mov    DWORD PTR [rcx+0x2],eax
  208f9b:	4c 89 71 08          	mov    QWORD PTR [rcx+0x8],r14
  208f9f:	eb 82                	jmp    208f23 <Elf_findSection+0x1a3>
  208fa1:	48 83 f9 4b          	cmp    rcx,0x4b
  208fa5:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  208faa:	74 b7                	je     208f63 <Elf_findSection+0x1e3>
  208fac:	eb 04                	jmp    208fb2 <Elf_findSection+0x232>
  208fae:	66 b8 1c 00          	mov    ax,0x1c
            try elf.in_file.seekTo(name_offset);
  208fb2:	66 89 06             	mov    WORD PTR [rsi],ax
  208fb5:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  208fba:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  208fc1:	00 
  208fc2:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
  208fc6:	48 89 46 02          	mov    QWORD PTR [rsi+0x2],rax
  208fca:	e9 54 ff ff ff       	jmp    208f23 <Elf_findSection+0x1a3>
  208fcf:	90                   	nop

0000000000208fd0 <File_openRead>:
    pub fn openRead(allocator: *mem.Allocator, path: []const u8) OpenError!File {
  208fd0:	55                   	push   rbp
  208fd1:	41 57                	push   r15
  208fd3:	41 56                	push   r14
  208fd5:	41 54                	push   r12
  208fd7:	53                   	push   rbx
  208fd8:	48 83 ec 20          	sub    rsp,0x20
  208fdc:	48 89 d3             	mov    rbx,rdx
  208fdf:	49 89 f7             	mov    r15,rsi
  208fe2:	49 89 fe             	mov    r14,rdi
}

/// Returns a mutable slice with 1 more byte of length which is a null byte.
/// Caller owns the returned memory.
pub fn addNullByte(allocator: *mem.Allocator, slice: []const u8) ![]u8 {
    const result = try allocator.alloc(u8, slice.len + 1);
  208fe5:	4c 8b 63 08          	mov    r12,QWORD PTR [rbx+0x8]
  208fe9:	49 83 c4 01          	add    r12,0x1
  208fed:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  208ff2:	b9 01 00 00 00       	mov    ecx,0x1
  208ff7:	4c 89 e2             	mov    rdx,r12
  208ffa:	41 ff 17             	call   QWORD PTR [r15]
  208ffd:	0f b7 6c 24 08       	movzx  ebp,WORD PTR [rsp+0x8]
  209002:	66 85 ed             	test   bp,bp
  209005:	0f 85 95 01 00 00    	jne    2091a0 <File_openRead+0x1d0>
        assert(byte_slice.len == byte_count);
  20900b:	4c 39 64 24 18       	cmp    QWORD PTR [rsp+0x18],r12
    if (!ok) {
  209010:	0f 85 b9 01 00 00    	jne    2091cf <File_openRead+0x1ff>
    assert(dest.len >= source.len);
  209016:	48 8b 6b 08          	mov    rbp,QWORD PTR [rbx+0x8]
  20901a:	49 39 ec             	cmp    r12,rbp
  20901d:	0f 82 ac 01 00 00    	jb     2091cf <File_openRead+0x1ff>
  209023:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
    for (source) |s, i|
  209028:	48 85 ed             	test   rbp,rbp
  20902b:	74 1f                	je     20904c <File_openRead+0x7c>
  20902d:	48 8d 4d ff          	lea    rcx,[rbp-0x1]
  209031:	89 e8                	mov    eax,ebp
  209033:	83 e0 07             	and    eax,0x7
  209036:	48 83 f9 07          	cmp    rcx,0x7
  20903a:	73 17                	jae    209053 <File_openRead+0x83>
  20903c:	31 c9                	xor    ecx,ecx
  20903e:	48 85 c0             	test   rax,rax
  209041:	0f 85 85 00 00 00    	jne    2090cc <File_openRead+0xfc>
  209047:	e9 98 00 00 00       	jmp    2090e4 <File_openRead+0x114>
  20904c:	31 c0                	xor    eax,eax
  20904e:	e9 95 00 00 00       	jmp    2090e8 <File_openRead+0x118>
  209053:	48 29 c5             	sub    rbp,rax
  209056:	31 c9                	xor    ecx,ecx
  209058:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20905f:	00 
  209060:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  209063:	0f b6 14 0e          	movzx  edx,BYTE PTR [rsi+rcx*1]
        dest[i] = s;
  209067:	88 14 0f             	mov    BYTE PTR [rdi+rcx*1],dl
    for (source) |s, i|
  20906a:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20906d:	0f b6 54 0a 01       	movzx  edx,BYTE PTR [rdx+rcx*1+0x1]
        dest[i] = s;
  209072:	88 54 0f 01          	mov    BYTE PTR [rdi+rcx*1+0x1],dl
    for (source) |s, i|
  209076:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  209079:	0f b6 54 0a 02       	movzx  edx,BYTE PTR [rdx+rcx*1+0x2]
        dest[i] = s;
  20907e:	88 54 0f 02          	mov    BYTE PTR [rdi+rcx*1+0x2],dl
    for (source) |s, i|
  209082:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  209085:	0f b6 54 0a 03       	movzx  edx,BYTE PTR [rdx+rcx*1+0x3]
        dest[i] = s;
  20908a:	88 54 0f 03          	mov    BYTE PTR [rdi+rcx*1+0x3],dl
    for (source) |s, i|
  20908e:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  209091:	0f b6 54 0a 04       	movzx  edx,BYTE PTR [rdx+rcx*1+0x4]
        dest[i] = s;
  209096:	88 54 0f 04          	mov    BYTE PTR [rdi+rcx*1+0x4],dl
    for (source) |s, i|
  20909a:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20909d:	0f b6 54 0a 05       	movzx  edx,BYTE PTR [rdx+rcx*1+0x5]
        dest[i] = s;
  2090a2:	88 54 0f 05          	mov    BYTE PTR [rdi+rcx*1+0x5],dl
    for (source) |s, i|
  2090a6:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  2090a9:	0f b6 54 0a 06       	movzx  edx,BYTE PTR [rdx+rcx*1+0x6]
        dest[i] = s;
  2090ae:	88 54 0f 06          	mov    BYTE PTR [rdi+rcx*1+0x6],dl
    for (source) |s, i|
  2090b2:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  2090b5:	0f b6 54 0a 07       	movzx  edx,BYTE PTR [rdx+rcx*1+0x7]
        dest[i] = s;
  2090ba:	88 54 0f 07          	mov    BYTE PTR [rdi+rcx*1+0x7],dl
    for (source) |s, i|
  2090be:	48 83 c1 08          	add    rcx,0x8
  2090c2:	48 39 cd             	cmp    rbp,rcx
  2090c5:	75 99                	jne    209060 <File_openRead+0x90>
  2090c7:	48 85 c0             	test   rax,rax
  2090ca:	74 18                	je     2090e4 <File_openRead+0x114>
  2090cc:	48 f7 d8             	neg    rax
  2090cf:	90                   	nop
  2090d0:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  2090d3:	0f b6 14 0a          	movzx  edx,BYTE PTR [rdx+rcx*1]
        dest[i] = s;
  2090d7:	88 14 0f             	mov    BYTE PTR [rdi+rcx*1],dl
    for (source) |s, i|
  2090da:	48 83 c1 01          	add    rcx,0x1
  2090de:	48 83 c0 01          	add    rax,0x1
  2090e2:	75 ec                	jne    2090d0 <File_openRead+0x100>
    mem.copy(u8, result, slice);
    result[slice.len] = 0;
  2090e4:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]
  2090e8:	c6 04 07 00          	mov    BYTE PTR [rdi+rax*1],0x0
  2090ec:	31 ed                	xor    ebp,ebp
  2090ee:	66 90                	xchg   ax,ax
  2090f0:	b8 02 00 00 00       	mov    eax,0x2
  2090f5:	be 00 00 00 00       	mov    esi,0x0
  2090fa:	31 d2                	xor    edx,edx
  2090fc:	0f 05                	syscall 
  2090fe:	48 89 c3             	mov    rbx,rax
  209101:	48 f7 d8             	neg    rax
  209104:	48 81 fb 00 f0 ff ff 	cmp    rbx,0xfffffffffffff000
  20910b:	48 0f 46 c5          	cmovbe rax,rbp
        if (err > 0) {
  20910f:	48 83 f8 04          	cmp    rax,0x4
  209113:	74 db                	je     2090f0 <File_openRead+0x120>
  209115:	48 83 f8 4b          	cmp    rax,0x4b
  209119:	77 62                	ja     20917d <File_openRead+0x1ad>
  20911b:	48 8d 0d 4a 77 ff ff 	lea    rcx,[rip+0xffffffffffff774a]        # 20086c <__unnamed_128+0x624>
  209122:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  209126:	48 01 c8             	add    rax,rcx
  209129:	ff e0                	jmp    rax
  20912b:	66 bd 0d 00          	mov    bp,0xd
  20912f:	eb 50                	jmp    209181 <File_openRead+0x1b1>
  209131:	66 bd 0a 00          	mov    bp,0xa
  209135:	eb 4a                	jmp    209181 <File_openRead+0x1b1>
  209137:	66 bd 11 00          	mov    bp,0x11
  20913b:	eb 44                	jmp    209181 <File_openRead+0x1b1>
  20913d:	66 bd 18 00          	mov    bp,0x18
  209141:	eb 3e                	jmp    209181 <File_openRead+0x1b1>
  209143:	66 bd 16 00          	mov    bp,0x16
  209147:	eb 38                	jmp    209181 <File_openRead+0x1b1>
  209149:	66 bd 0c 00          	mov    bp,0xc
  20914d:	eb 32                	jmp    209181 <File_openRead+0x1b1>
  20914f:	66 bd 15 00          	mov    bp,0x15
  209153:	eb 2c                	jmp    209181 <File_openRead+0x1b1>
  209155:	31 ed                	xor    ebp,ebp
  209157:	eb 2a                	jmp    209183 <File_openRead+0x1b3>
  209159:	66 bd 1a 00          	mov    bp,0x1a
  20915d:	eb 22                	jmp    209181 <File_openRead+0x1b1>
  20915f:	66 bd 01 00          	mov    bp,0x1
  209163:	eb 1c                	jmp    209181 <File_openRead+0x1b1>
  209165:	66 bd 19 00          	mov    bp,0x19
  209169:	eb 16                	jmp    209181 <File_openRead+0x1b1>
  20916b:	66 bd 1b 00          	mov    bp,0x1b
  20916f:	eb 10                	jmp    209181 <File_openRead+0x1b1>
  209171:	66 bd 17 00          	mov    bp,0x17
  209175:	eb 0a                	jmp    209181 <File_openRead+0x1b1>
  209177:	66 bd 14 00          	mov    bp,0x14
  20917b:	eb 04                	jmp    209181 <File_openRead+0x1b1>
  20917d:	66 bd 05 00          	mov    bp,0x5
  209181:	31 db                	xor    ebx,ebx
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  209183:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  209187:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  20918c:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  209191:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  209196:	4c 89 ff             	mov    rdi,r15
  209199:	ff d0                	call   rax
            const fd = try os.posixOpen(allocator, path, flags, 0);
  20919b:	66 85 ed             	test   bp,bp
  20919e:	74 23                	je     2091c3 <File_openRead+0x1f3>
  2091a0:	66 41 89 2e          	mov    WORD PTR [r14],bp
  2091a4:	0f b7 44 24 06       	movzx  eax,WORD PTR [rsp+0x6]
  2091a9:	66 41 89 46 06       	mov    WORD PTR [r14+0x6],ax
  2091ae:	8b 44 24 02          	mov    eax,DWORD PTR [rsp+0x2]
  2091b2:	41 89 46 02          	mov    DWORD PTR [r14+0x2],eax
  2091b6:	48 83 c4 20          	add    rsp,0x20
  2091ba:	5b                   	pop    rbx
  2091bb:	41 5c                	pop    r12
  2091bd:	41 5e                	pop    r14
  2091bf:	41 5f                	pop    r15
  2091c1:	5d                   	pop    rbp
  2091c2:	c3                   	ret    
            return openHandle(fd);
  2091c3:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  2091c9:	41 89 5e 04          	mov    DWORD PTR [r14+0x4],ebx
  2091cd:	eb e7                	jmp    2091b6 <File_openRead+0x1e6>
            @panic("assertion failure");
  2091cf:	e8 fc 9f ff ff       	call   2031d0 <panic>
  2091d4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2091db:	00 00 00 00 00 

00000000002091e0 <FixedBufferAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  2091e0:	49 89 d0             	mov    r8,rdx
        const addr = @ptrToInt(self.buffer.ptr) + self.end_index;
  2091e3:	4c 8b 56 18          	mov    r10,QWORD PTR [rsi+0x18]
  2091e7:	4c 8b 4e 20          	mov    r9,QWORD PTR [rsi+0x20]
  2091eb:	4b 8d 04 0a          	lea    rax,[r10+r9*1]
        const rem = @rem(addr, alignment);
  2091ef:	81 e1 ff ff ff 1f    	and    ecx,0x1fffffff
  2091f5:	48 89 c2             	mov    rdx,rax
  2091f8:	48 c1 ea 20          	shr    rdx,0x20
  2091fc:	74 07                	je     209205 <FixedBufferAllocator_alloc+0x25>
  2091fe:	31 d2                	xor    edx,edx
  209200:	48 f7 f1             	div    rcx
  209203:	eb 04                	jmp    209209 <FixedBufferAllocator_alloc+0x29>
  209205:	31 d2                	xor    edx,edx
  209207:	f7 f1                	div    ecx
        const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  209209:	48 29 d1             	sub    rcx,rdx
  20920c:	48 85 d2             	test   rdx,rdx
  20920f:	48 0f 44 ca          	cmove  rcx,rdx
        const adjusted_index = self.end_index + march_forward_bytes;
  209213:	4c 01 d1             	add    rcx,r10
        const new_end_index = adjusted_index + n;
  209216:	4a 8d 04 01          	lea    rax,[rcx+r8*1]
        if (new_end_index > self.buffer.len) {
  20921a:	48 3b 46 28          	cmp    rax,QWORD PTR [rsi+0x28]
  20921e:	76 1b                	jbe    20923b <FixedBufferAllocator_alloc+0x5b>
            return error.OutOfMemory;
  209220:	48 8b 05 d1 92 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff92d1]        # 2024f8 <__unnamed_50+0x10>
  209227:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  20922b:	c5 f8 10 05 b5 92 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff92b5]        # 2024e8 <__unnamed_50>
  209232:	ff 
  209233:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
  209237:	48 89 f8             	mov    rax,rdi
  20923a:	c3                   	ret    
        }
        const result = self.buffer[adjusted_index..new_end_index];
        self.end_index = new_end_index;
  20923b:	48 89 46 18          	mov    QWORD PTR [rsi+0x18],rax

        return result;
  20923f:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  209244:	0f b7 44 24 fe       	movzx  eax,WORD PTR [rsp-0x2]
  209249:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
        const result = self.buffer[adjusted_index..new_end_index];
  20924d:	49 01 c9             	add    r9,rcx
        return result;
  209250:	8b 44 24 fa          	mov    eax,DWORD PTR [rsp-0x6]
  209254:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  209257:	4c 89 4f 08          	mov    QWORD PTR [rdi+0x8],r9
  20925b:	4c 89 47 10          	mov    QWORD PTR [rdi+0x10],r8
  20925f:	48 89 f8             	mov    rax,rdi
  209262:	c3                   	ret    
  209263:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20926a:	84 00 00 00 00 00 

0000000000209270 <FixedBufferAllocator_realloc>:
    }

    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  209270:	41 56                	push   r14
  209272:	53                   	push   rbx
  209273:	48 83 ec 28          	sub    rsp,0x28
  209277:	49 89 d1             	mov    r9,rdx
        const self = @fieldParentPtr(FixedBufferAllocator, "allocator", allocator);
        assert(old_mem.len <= self.end_index);
  20927a:	49 8b 59 08          	mov    rbx,QWORD PTR [r9+0x8]
  20927e:	4c 8b 5e 18          	mov    r11,QWORD PTR [rsi+0x18]
  209282:	4d 89 de             	mov    r14,r11
  209285:	49 29 de             	sub    r14,rbx
    if (!ok) {
  209288:	0f 82 de 01 00 00    	jb     20946c <FixedBufferAllocator_realloc+0x1fc>
        if (new_size <= old_mem.len) {
  20928e:	48 39 cb             	cmp    rbx,rcx
  209291:	73 2a                	jae    2092bd <FixedBufferAllocator_realloc+0x4d>
            return old_mem[0..new_size];
        } else if (old_mem.ptr == self.buffer.ptr + self.end_index - old_mem.len) {
  209293:	4c 8b 56 20          	mov    r10,QWORD PTR [rsi+0x20]
  209297:	4b 8d 04 1a          	lea    rax,[r10+r11*1]
  20929b:	48 89 c2             	mov    rdx,rax
  20929e:	48 29 da             	sub    rdx,rbx
  2092a1:	49 39 11             	cmp    QWORD PTR [r9],rdx
  2092a4:	74 38                	je     2092de <FixedBufferAllocator_realloc+0x6e>
        const rem = @rem(addr, alignment);
  2092a6:	41 81 e0 ff ff ff 1f 	and    r8d,0x1fffffff
  2092ad:	48 89 c2             	mov    rdx,rax
  2092b0:	48 c1 ea 20          	shr    rdx,0x20
  2092b4:	74 52                	je     209308 <FixedBufferAllocator_realloc+0x98>
  2092b6:	31 d2                	xor    edx,edx
  2092b8:	49 f7 f0             	div    r8
  2092bb:	eb 50                	jmp    20930d <FixedBufferAllocator_realloc+0x9d>
            return old_mem[0..new_size];
  2092bd:	49 8b 01             	mov    rax,QWORD PTR [r9]
  2092c0:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  2092c5:	0f b7 54 24 10       	movzx  edx,WORD PTR [rsp+0x10]
  2092ca:	66 89 57 06          	mov    WORD PTR [rdi+0x6],dx
  2092ce:	8b 54 24 0c          	mov    edx,DWORD PTR [rsp+0xc]
  2092d2:	89 57 02             	mov    DWORD PTR [rdi+0x2],edx
  2092d5:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  2092d9:	e9 7f 01 00 00       	jmp    20945d <FixedBufferAllocator_realloc+0x1ed>
            const start_index = self.end_index - old_mem.len;
            const new_end_index = start_index + new_size;
  2092de:	49 8d 04 0e          	lea    rax,[r14+rcx*1]
            if (new_end_index > self.buffer.len) return error.OutOfMemory;
  2092e2:	48 3b 46 28          	cmp    rax,QWORD PTR [rsi+0x28]
  2092e6:	0f 86 94 00 00 00    	jbe    209380 <FixedBufferAllocator_realloc+0x110>
  2092ec:	48 8b 05 05 92 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff9205]        # 2024f8 <__unnamed_50+0x10>
  2092f3:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  2092f7:	c5 f8 10 05 e9 91 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff91e9]        # 2024e8 <__unnamed_50>
  2092fe:	ff 
  2092ff:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
  209303:	e9 59 01 00 00       	jmp    209461 <FixedBufferAllocator_realloc+0x1f1>
  209308:	31 d2                	xor    edx,edx
  20930a:	41 f7 f0             	div    r8d
        const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  20930d:	49 29 d0             	sub    r8,rdx
  209310:	48 85 d2             	test   rdx,rdx
  209313:	4c 0f 44 c2          	cmove  r8,rdx
        const adjusted_index = self.end_index + march_forward_bytes;
  209317:	4d 01 d8             	add    r8,r11
        const new_end_index = adjusted_index + n;
  20931a:	49 8d 04 08          	lea    rax,[r8+rcx*1]
        if (new_end_index > self.buffer.len) {
  20931e:	48 3b 46 28          	cmp    rax,QWORD PTR [rsi+0x28]
  209322:	76 1e                	jbe    209342 <FixedBufferAllocator_realloc+0xd2>
            const result = self.buffer[start_index..new_end_index];
            self.end_index = new_end_index;
            return result;
        } else {
            const result = try alloc(allocator, new_size, alignment);
  209324:	66 c7 07 0f 00       	mov    WORD PTR [rdi],0xf
  209329:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  20932e:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  209332:	c5 f8 10 44 24 12    	vmovups xmm0,XMMWORD PTR [rsp+0x12]
  209338:	c5 f8 11 47 02       	vmovups XMMWORD PTR [rdi+0x2],xmm0
  20933d:	e9 1f 01 00 00       	jmp    209461 <FixedBufferAllocator_realloc+0x1f1>
        self.end_index = new_end_index;
  209342:	48 89 46 18          	mov    QWORD PTR [rsi+0x18],rax
    assert(dest.len >= source.len);
  209346:	4d 8b 71 08          	mov    r14,QWORD PTR [r9+0x8]
  20934a:	49 39 ce             	cmp    r14,rcx
  20934d:	0f 87 19 01 00 00    	ja     20946c <FixedBufferAllocator_realloc+0x1fc>
  209353:	4f 8d 1c 02          	lea    r11,[r10+r8*1]
    for (source) |s, i|
  209357:	4d 85 f6             	test   r14,r14
  20935a:	0f 84 e5 00 00 00    	je     209445 <FixedBufferAllocator_realloc+0x1d5>
  209360:	49 8d 46 ff          	lea    rax,[r14-0x1]
  209364:	44 89 f2             	mov    edx,r14d
  209367:	83 e2 07             	and    edx,0x7
  20936a:	48 83 f8 07          	cmp    rax,0x7
  20936e:	73 35                	jae    2093a5 <FixedBufferAllocator_realloc+0x135>
  209370:	31 f6                	xor    esi,esi
  209372:	48 85 d2             	test   rdx,rdx
  209375:	0f 85 b1 00 00 00    	jne    20942c <FixedBufferAllocator_realloc+0x1bc>
  20937b:	e9 c5 00 00 00       	jmp    209445 <FixedBufferAllocator_realloc+0x1d5>
            self.end_index = new_end_index;
  209380:	48 89 46 18          	mov    QWORD PTR [rsi+0x18],rax
            return result;
  209384:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  209389:	0f b7 44 24 0a       	movzx  eax,WORD PTR [rsp+0xa]
  20938e:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
            const result = self.buffer[start_index..new_end_index];
  209392:	4d 01 f2             	add    r10,r14
            return result;
  209395:	8b 44 24 06          	mov    eax,DWORD PTR [rsp+0x6]
  209399:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  20939c:	4c 89 57 08          	mov    QWORD PTR [rdi+0x8],r10
  2093a0:	e9 b8 00 00 00       	jmp    20945d <FixedBufferAllocator_realloc+0x1ed>
  2093a5:	49 29 d6             	sub    r14,rdx
  2093a8:	4b 8d 04 02          	lea    rax,[r10+r8*1]
  2093ac:	48 83 c0 07          	add    rax,0x7
  2093b0:	31 f6                	xor    esi,esi
  2093b2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2093b9:	1f 84 00 00 00 00 00 
  2093c0:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  2093c3:	0f b6 1c 33          	movzx  ebx,BYTE PTR [rbx+rsi*1]
        dest[i] = s;
  2093c7:	88 5c 30 f9          	mov    BYTE PTR [rax+rsi*1-0x7],bl
    for (source) |s, i|
  2093cb:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  2093ce:	0f b6 5c 33 01       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x1]
        dest[i] = s;
  2093d3:	88 5c 30 fa          	mov    BYTE PTR [rax+rsi*1-0x6],bl
    for (source) |s, i|
  2093d7:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  2093da:	0f b6 5c 33 02       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x2]
        dest[i] = s;
  2093df:	88 5c 30 fb          	mov    BYTE PTR [rax+rsi*1-0x5],bl
    for (source) |s, i|
  2093e3:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  2093e6:	0f b6 5c 33 03       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x3]
        dest[i] = s;
  2093eb:	88 5c 30 fc          	mov    BYTE PTR [rax+rsi*1-0x4],bl
    for (source) |s, i|
  2093ef:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  2093f2:	0f b6 5c 33 04       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x4]
        dest[i] = s;
  2093f7:	88 5c 30 fd          	mov    BYTE PTR [rax+rsi*1-0x3],bl
    for (source) |s, i|
  2093fb:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  2093fe:	0f b6 5c 33 05       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x5]
        dest[i] = s;
  209403:	88 5c 30 fe          	mov    BYTE PTR [rax+rsi*1-0x2],bl
    for (source) |s, i|
  209407:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  20940a:	0f b6 5c 33 06       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x6]
        dest[i] = s;
  20940f:	88 5c 30 ff          	mov    BYTE PTR [rax+rsi*1-0x1],bl
    for (source) |s, i|
  209413:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  209416:	0f b6 5c 33 07       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x7]
        dest[i] = s;
  20941b:	88 1c 30             	mov    BYTE PTR [rax+rsi*1],bl
    for (source) |s, i|
  20941e:	48 83 c6 08          	add    rsi,0x8
  209422:	49 39 f6             	cmp    r14,rsi
  209425:	75 99                	jne    2093c0 <FixedBufferAllocator_realloc+0x150>
  209427:	48 85 d2             	test   rdx,rdx
  20942a:	74 19                	je     209445 <FixedBufferAllocator_realloc+0x1d5>
  20942c:	48 f7 da             	neg    rdx
  20942f:	90                   	nop
  209430:	49 8b 01             	mov    rax,QWORD PTR [r9]
  209433:	0f b6 04 30          	movzx  eax,BYTE PTR [rax+rsi*1]
        dest[i] = s;
  209437:	41 88 04 33          	mov    BYTE PTR [r11+rsi*1],al
    for (source) |s, i|
  20943b:	48 83 c6 01          	add    rsi,0x1
  20943f:	48 83 c2 01          	add    rdx,0x1
  209443:	75 eb                	jne    209430 <FixedBufferAllocator_realloc+0x1c0>
            mem.copy(u8, result, old_mem);
            return result;
  209445:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  20944a:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  20944f:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
  209453:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  209456:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  209459:	4c 89 5f 08          	mov    QWORD PTR [rdi+0x8],r11
  20945d:	48 89 4f 10          	mov    QWORD PTR [rdi+0x10],rcx
  209461:	48 89 f8             	mov    rax,rdi
  209464:	48 83 c4 28          	add    rsp,0x28
  209468:	5b                   	pop    rbx
  209469:	41 5e                	pop    r14
  20946b:	c3                   	ret    
            @panic("assertion failure");
  20946c:	e8 5f 9d ff ff       	call   2031d0 <panic>
  209471:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  209478:	0f 1f 84 00 00 00 00 
  20947f:	00 

0000000000209480 <InStream(ReadError)_readInt.16>:
        pub fn readInt(self: *Self, endian: builtin.Endian, comptime T: type) !T {
  209480:	55                   	push   rbp
  209481:	53                   	push   rbx
  209482:	48 83 ec 48          	sub    rsp,0x48
  209486:	89 d5                	mov    ebp,edx
  209488:	48 89 fb             	mov    rbx,rdi
  20948b:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            try self.readNoEof(bytes[0..]);
  209490:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  209495:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  20949c:	00 00 
  20949e:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  2094a3:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2094a8:	ff 16                	call   QWORD PTR [rsi]
  2094aa:	0f b7 44 24 28       	movzx  eax,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2094af:	66 85 c0             	test   ax,ax
  2094b2:	75 10                	jne    2094c4 <InStream(ReadError)_readInt.16+0x44>
  2094b4:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  2094b9:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  2094bd:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2094c2:	73 1c                	jae    2094e0 <InStream(ReadError)_readInt.16+0x60>
            try self.readNoEof(bytes[0..]);
  2094c4:	66 89 03             	mov    WORD PTR [rbx],ax
  2094c7:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  2094cc:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  2094d1:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  2094d5:	48 89 43 02          	mov    QWORD PTR [rbx+0x2],rax
  2094d9:	48 83 c4 48          	add    rsp,0x48
  2094dd:	5b                   	pop    rbx
  2094de:	5d                   	pop    rbp
  2094df:	c3                   	ret    
  2094e0:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  2094e5:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  2094ea:	40 f6 c5 01          	test   bpl,0x1
  2094ee:	74 51                	je     209541 <InStream(ReadError)_readInt.16+0xc1>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2094f0:	48 c1 e1 08          	shl    rcx,0x8
  2094f4:	48 09 c1             	or     rcx,rax
  2094f7:	0f b6 44 24 0a       	movzx  eax,BYTE PTR [rsp+0xa]
  2094fc:	48 c1 e0 10          	shl    rax,0x10
  209500:	48 09 c8             	or     rax,rcx
  209503:	0f b6 4c 24 0b       	movzx  ecx,BYTE PTR [rsp+0xb]
  209508:	48 c1 e1 18          	shl    rcx,0x18
  20950c:	48 09 c1             	or     rcx,rax
  20950f:	0f b6 44 24 0c       	movzx  eax,BYTE PTR [rsp+0xc]
  209514:	48 c1 e0 20          	shl    rax,0x20
  209518:	48 09 c8             	or     rax,rcx
  20951b:	0f b6 4c 24 0d       	movzx  ecx,BYTE PTR [rsp+0xd]
  209520:	48 c1 e1 28          	shl    rcx,0x28
  209524:	48 09 c1             	or     rcx,rax
  209527:	0f b6 54 24 0e       	movzx  edx,BYTE PTR [rsp+0xe]
  20952c:	48 c1 e2 30          	shl    rdx,0x30
  209530:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  209535:	48 c1 e0 38          	shl    rax,0x38
  209539:	48 09 d0             	or     rax,rdx
  20953c:	48 09 c8             	or     rax,rcx
  20953f:	eb 4f                	jmp    209590 <InStream(ReadError)_readInt.16+0x110>
                result = (result << 8) | b;
  209541:	48 c1 e0 08          	shl    rax,0x8
  209545:	48 09 c8             	or     rax,rcx
  209548:	48 c1 e0 08          	shl    rax,0x8
  20954c:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  209551:	48 09 c1             	or     rcx,rax
  209554:	48 c1 e1 08          	shl    rcx,0x8
  209558:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20955d:	48 09 c8             	or     rax,rcx
  209560:	48 c1 e0 08          	shl    rax,0x8
  209564:	0f b6 4c 24 0c       	movzx  ecx,BYTE PTR [rsp+0xc]
  209569:	48 09 c1             	or     rcx,rax
  20956c:	48 c1 e1 08          	shl    rcx,0x8
  209570:	0f b6 44 24 0d       	movzx  eax,BYTE PTR [rsp+0xd]
  209575:	48 09 c8             	or     rax,rcx
  209578:	48 c1 e0 08          	shl    rax,0x8
  20957c:	0f b6 4c 24 0e       	movzx  ecx,BYTE PTR [rsp+0xe]
  209581:	48 09 c1             	or     rcx,rax
  209584:	48 c1 e1 08          	shl    rcx,0x8
  209588:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  20958d:	48 09 c8             	or     rax,rcx
            return mem.readInt(bytes, T, endian);
  209590:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  209595:	0f b7 4c 24 16       	movzx  ecx,WORD PTR [rsp+0x16]
  20959a:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20959e:	8b 4c 24 12          	mov    ecx,DWORD PTR [rsp+0x12]
  2095a2:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  2095a5:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  2095a9:	48 83 c4 48          	add    rsp,0x48
  2095ad:	5b                   	pop    rbx
  2095ae:	5d                   	pop    rbp
  2095af:	c3                   	ret    

00000000002095b0 <File_read>:
        IsDir,

        Unexpected,
    };

    pub fn read(self: *File, buffer: []u8) ReadError!usize {
  2095b0:	41 57                	push   r15
  2095b2:	41 56                	push   r14
  2095b4:	53                   	push   rbx
  2095b5:	49 89 d1             	mov    r9,rdx
  2095b8:	49 89 f2             	mov    r10,rsi
  2095bb:	49 89 f8             	mov    r8,rdi
        if (is_posix) {
            var index: usize = 0;
            while (index < buffer.len) {
  2095be:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  2095c2:	48 85 d2             	test   rdx,rdx
  2095c5:	74 6c                	je     209633 <File_read+0x83>
  2095c7:	45 31 f6             	xor    r14d,r14d
  2095ca:	4c 8d 3d cb 73 ff ff 	lea    r15,[rip+0xffffffffffff73cb]        # 20099c <__unnamed_128+0x754>
  2095d1:	31 db                	xor    ebx,ebx
  2095d3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2095da:	84 00 00 00 00 00 
  2095e0:	49 8b 31             	mov    rsi,QWORD PTR [r9]
                const amt_read = posix.read(self.handle, buffer.ptr + index, buffer.len - index);
  2095e3:	48 01 de             	add    rsi,rbx
  2095e6:	48 29 da             	sub    rdx,rbx
    return syscall3(SYS_read, @intCast(usize, fd), @ptrToInt(buf), count);
  2095e9:	49 63 3a             	movsxd rdi,DWORD PTR [r10]
  2095ec:	31 c0                	xor    eax,eax
  2095ee:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2095f0:	48 89 c1             	mov    rcx,rax
  2095f3:	48 f7 d9             	neg    rcx
  2095f6:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2095fc:	49 0f 46 ce          	cmovbe rcx,r14
                const read_err = posix.getErrno(amt_read);
                if (read_err > 0) {
  209600:	48 83 f9 04          	cmp    rcx,0x4
  209604:	75 0b                	jne    209611 <File_read+0x61>
            while (index < buffer.len) {
  209606:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  20960a:	48 39 da             	cmp    rdx,rbx
  20960d:	77 d1                	ja     2095e0 <File_read+0x30>
  20960f:	eb 24                	jmp    209635 <File_read+0x85>
  209611:	48 83 f9 15          	cmp    rcx,0x15
  209615:	77 67                	ja     20967e <File_read+0xce>
  209617:	49 63 0c 8f          	movsxd rcx,DWORD PTR [r15+rcx*4]
  20961b:	4c 01 f9             	add    rcx,r15
  20961e:	ff e1                	jmp    rcx
                        posix.EIO => return error.Io,
                        posix.EISDIR => return error.IsDir,
                        else => return os.unexpectedErrorPosix(read_err),
                    }
                }
                if (amt_read == 0) return index;
  209620:	48 85 c0             	test   rax,rax
  209623:	74 77                	je     20969c <File_read+0xec>
  209625:	48 01 c3             	add    rbx,rax
            while (index < buffer.len) {
  209628:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  20962c:	48 39 da             	cmp    rdx,rbx
  20962f:	77 af                	ja     2095e0 <File_read+0x30>
  209631:	eb 02                	jmp    209635 <File_read+0x85>
  209633:	31 db                	xor    ebx,ebx
                index += amt_read;
            }
            return index;
  209635:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  20963b:	0f b7 44 24 ea       	movzx  eax,WORD PTR [rsp-0x16]
  209640:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  209645:	8b 44 24 e6          	mov    eax,DWORD PTR [rsp-0x1a]
  209649:	41 89 40 02          	mov    DWORD PTR [r8+0x2],eax
  20964d:	49 89 58 08          	mov    QWORD PTR [r8+0x8],rbx
  209651:	5b                   	pop    rbx
  209652:	41 5e                	pop    r14
  209654:	41 5f                	pop    r15
  209656:	c3                   	ret    
                        posix.EIO => return error.Io,
  209657:	c5 f8 10 05 a1 8f ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff8fa1]        # 202600 <__unnamed_51>
  20965e:	ff 
  20965f:	eb 12                	jmp    209673 <File_read+0xc3>
                        posix.EBADF => return error.BadFd,
  209661:	c5 f8 10 05 77 8f ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff8f77]        # 2025e0 <__unnamed_52>
  209668:	ff 
  209669:	eb 08                	jmp    209673 <File_read+0xc3>
                        posix.EISDIR => return error.IsDir,
  20966b:	c5 f8 10 05 9d 8f ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff8f9d]        # 202610 <__unnamed_53>
  209672:	ff 
  209673:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
  209678:	5b                   	pop    rbx
  209679:	41 5e                	pop    r14
  20967b:	41 5f                	pop    r15
  20967d:	c3                   	ret    
                        else => return os.unexpectedErrorPosix(read_err),
  20967e:	66 41 c7 00 05 00    	mov    WORD PTR [r8],0x5
  209684:	48 8b 44 24 f2       	mov    rax,QWORD PTR [rsp-0xe]
  209689:	48 8b 4c 24 f8       	mov    rcx,QWORD PTR [rsp-0x8]
  20968e:	49 89 48 08          	mov    QWORD PTR [r8+0x8],rcx
  209692:	49 89 40 02          	mov    QWORD PTR [r8+0x2],rax
  209696:	5b                   	pop    rbx
  209697:	41 5e                	pop    r14
  209699:	41 5f                	pop    r15
  20969b:	c3                   	ret    
                if (amt_read == 0) return index;
  20969c:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  2096a2:	0f b7 44 24 f0       	movzx  eax,WORD PTR [rsp-0x10]
  2096a7:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  2096ac:	8b 44 24 ec          	mov    eax,DWORD PTR [rsp-0x14]
  2096b0:	eb 97                	jmp    209649 <File_read+0x99>
  2096b2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2096b9:	1f 84 00 00 00 00 00 

00000000002096c0 <FileInStream_readFn>:
    fn readFn(in_stream: *Stream, buffer: []u8) Error!usize {
  2096c0:	53                   	push   rbx
  2096c1:	48 83 ec 10          	sub    rsp,0x10
  2096c5:	48 89 fb             	mov    rbx,rdi
        return self.file.read(buffer);
  2096c8:	48 8b 76 f8          	mov    rsi,QWORD PTR [rsi-0x8]
  2096cc:	48 89 e7             	mov    rdi,rsp
  2096cf:	e8 dc fe ff ff       	call   2095b0 <File_read>
  2096d4:	c5 f8 10 04 24       	vmovups xmm0,XMMWORD PTR [rsp]
  2096d9:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2096dd:	48 89 d8             	mov    rax,rbx
  2096e0:	48 83 c4 10          	add    rsp,0x10
  2096e4:	5b                   	pop    rbx
  2096e5:	c3                   	ret    
  2096e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2096ed:	00 00 00 

00000000002096f0 <parseAbbrevTable>:
fn parseAbbrevTable(st: *ElfStackTrace) !AbbrevTable {
  2096f0:	55                   	push   rbp
  2096f1:	41 57                	push   r15
  2096f3:	41 56                	push   r14
  2096f5:	41 55                	push   r13
  2096f7:	41 54                	push   r12
  2096f9:	53                   	push   rbx
  2096fa:	48 81 ec f8 01 00 00 	sub    rsp,0x1f8
  209701:	49 89 f4             	mov    r12,rsi
    var in_file_stream = io.FileInStream.init(in_file);
  209704:	4c 89 64 24 28       	mov    QWORD PTR [rsp+0x28],r12
  209709:	48 89 fb             	mov    rbx,rdi
  20970c:	48 8d 05 ad ff ff ff 	lea    rax,[rip+0xffffffffffffffad]        # 2096c0 <FileInStream_readFn>
  209713:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  209718:	4d 8b b4 24 a0 00 00 	mov    r14,QWORD PTR [r12+0xa0]
  20971f:	00 
            return Self{
  209720:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  209724:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20972b:	00 00 
  20972d:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x0
  209734:	00 00 00 00 00 
    var result = AbbrevTable.init(st.allocator());
  209739:	4c 89 b4 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],r14
  209740:	00 
  209741:	4c 8d 6c 24 0f       	lea    r13,[rsp+0xf]
            try self.readNoEof(result[0..]);
  209746:	4c 89 6c 24 60       	mov    QWORD PTR [rsp+0x60],r13
  20974b:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  209752:	00 00 
        return self.file.read(buffer);
  209754:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  209759:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20975e:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  209763:	e8 48 fe ff ff       	call   2095b0 <File_read>
  209768:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  20976e:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
            return self.readFn(self, buffer);
  209774:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
            const amt_read = try self.read(buf);
  209779:	66 85 c9             	test   cx,cx
  20977c:	74 32                	je     2097b0 <parseAbbrevTable+0xc0>
        const abbrev_code = try readULeb128(in_stream);
  20977e:	66 89 0b             	mov    WORD PTR [rbx],cx
  209781:	48 8b 84 24 f0 01 00 	mov    rax,QWORD PTR [rsp+0x1f0]
  209788:	00 
  209789:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
  20978d:	c5 fc 10 84 24 d2 01 	vmovups ymm0,YMMWORD PTR [rsp+0x1d2]
  209794:	00 00 
  209796:	c5 fc 11 43 02       	vmovups YMMWORD PTR [rbx+0x2],ymm0
  20979b:	48 81 c4 f8 01 00 00 	add    rsp,0x1f8
  2097a2:	5b                   	pop    rbx
  2097a3:	41 5c                	pop    r12
  2097a5:	41 5d                	pop    r13
  2097a7:	41 5e                	pop    r14
  2097a9:	41 5f                	pop    r15
  2097ab:	5d                   	pop    rbp
  2097ac:	c5 f8 77             	vzeroupper 
  2097af:	c3                   	ret    
  2097b0:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  2097b5:	31 c9                	xor    ecx,ecx
  2097b7:	48 89 4c 24 70       	mov    QWORD PTR [rsp+0x70],rcx
  2097bc:	31 c9                	xor    ecx,ecx
  2097be:	48 89 4c 24 58       	mov    QWORD PTR [rsp+0x58],rcx
  2097c3:	45 31 ff             	xor    r15d,r15d
  2097c6:	31 ed                	xor    ebp,ebp
  2097c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2097cf:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  2097d0:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  2097d5:	0f 82 f8 04 00 00    	jb     209cd3 <parseAbbrevTable+0x5e3>
            return result[0];
  2097db:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2097e0:	89 c2                	mov    edx,eax
  2097e2:	83 e2 7f             	and    edx,0x7f
  2097e5:	89 ee                	mov    esi,ebp
  2097e7:	83 e6 3f             	and    esi,0x3f
  2097ea:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2097ef:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2097f4:	48 39 d6             	cmp    rsi,rdx
  2097f7:	0f 85 df 04 00 00    	jne    209cdc <parseAbbrevTable+0x5ec>
        result |= operand;
  2097fd:	49 09 cf             	or     r15,rcx
        if ((byte & 0b10000000) == 0) return result;
  209800:	84 c0                	test   al,al
  209802:	79 39                	jns    20983d <parseAbbrevTable+0x14d>
        shift += 7;
  209804:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  209808:	4c 89 6c 24 60       	mov    QWORD PTR [rsp+0x60],r13
  20980d:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  209814:	00 00 
            return self.readFn(self, buffer);
  209816:	48 8d 7c 24 10       	lea    rdi,[rsp+0x10]
  20981b:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  209820:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  209825:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  209829:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
  20982e:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
            const amt_read = try self.read(buf);
  209833:	66 85 c9             	test   cx,cx
  209836:	74 98                	je     2097d0 <parseAbbrevTable+0xe0>
  209838:	e9 41 ff ff ff       	jmp    20977e <parseAbbrevTable+0x8e>
        if (abbrev_code == 0) return result;
  20983d:	4d 85 ff             	test   r15,r15
  209840:	0f 84 01 05 00 00    	je     209d47 <parseAbbrevTable+0x657>
  209846:	48 89 5c 24 38       	mov    QWORD PTR [rsp+0x38],rbx
  20984b:	4c 89 a4 24 88 00 00 	mov    QWORD PTR [rsp+0x88],r12
  209852:	00 
            try self.readNoEof(result[0..]);
  209853:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  209858:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20985f:	00 00 
  209861:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
            return self.readFn(self, buffer);
  209866:	48 89 df             	mov    rdi,rbx
  209869:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20986e:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  209873:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  209877:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20987c:	66 85 c0             	test   ax,ax
  20987f:	0f 85 6a 04 00 00    	jne    209cef <parseAbbrevTable+0x5ff>
  209885:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20988a:	45 31 e4             	xor    r12d,r12d
  20988d:	31 ed                	xor    ebp,ebp
  20988f:	90                   	nop
            if (amt_read < buf.len) return error.EndOfStream;
  209890:	48 3b 4c 24 18       	cmp    rcx,QWORD PTR [rsp+0x18]
  209895:	0f 82 4a 04 00 00    	jb     209ce5 <parseAbbrevTable+0x5f5>
            return result[0];
  20989b:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2098a0:	89 c2                	mov    edx,eax
  2098a2:	83 e2 7f             	and    edx,0x7f
  2098a5:	89 ee                	mov    esi,ebp
  2098a7:	83 e6 3f             	and    esi,0x3f
  2098aa:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2098af:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2098b4:	48 39 d6             	cmp    rsi,rdx
  2098b7:	0f 85 2e 04 00 00    	jne    209ceb <parseAbbrevTable+0x5fb>
        result |= operand;
  2098bd:	49 09 cc             	or     r12,rcx
        if ((byte & 0b10000000) == 0) return result;
  2098c0:	84 c0                	test   al,al
  2098c2:	79 3c                	jns    209900 <parseAbbrevTable+0x210>
        shift += 7;
  2098c4:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2098c8:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  2098cd:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2098d2:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2098d9:	00 00 
            return self.readFn(self, buffer);
  2098db:	48 89 df             	mov    rdi,rbx
  2098de:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2098e3:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2098e8:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  2098ec:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2098f1:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  2098f6:	66 85 c0             	test   ax,ax
  2098f9:	74 95                	je     209890 <parseAbbrevTable+0x1a0>
  2098fb:	e9 ef 03 00 00       	jmp    209cef <parseAbbrevTable+0x5ff>
            try self.readNoEof(result[0..]);
  209900:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  209905:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20990a:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  209911:	00 00 
            return self.readFn(self, buffer);
  209913:	48 89 df             	mov    rdi,rbx
  209916:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20991b:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  209920:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  209924:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  209929:	66 85 c0             	test   ax,ax
  20992c:	0f 85 7b 04 00 00    	jne    209dad <parseAbbrevTable+0x6bd>
  209932:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
            if (amt_read < buf.len) return error.EndOfStream;
  209937:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  20993c:	0f 82 67 04 00 00    	jb     209da9 <parseAbbrevTable+0x6b9>
  209942:	4c 89 b4 24 80 00 00 	mov    QWORD PTR [rsp+0x80],r14
  209949:	00 
  20994a:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  209951:	00 
  209952:	4c 8b a8 a0 00 00 00 	mov    r13,QWORD PTR [rax+0xa0]
  209959:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  20995d:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  209964:	00 00 
            return result[0];
  209966:	8a 5c 24 0f          	mov    bl,BYTE PTR [rsp+0xf]
  20996a:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x0
  209971:	00 00 00 00 00 
            var better_capacity = self.items.len;
  209976:	48 8b 8c 24 98 00 00 	mov    rcx,QWORD PTR [rsp+0x98]
  20997d:	00 
  20997e:	4c 8b 74 24 58       	mov    r14,QWORD PTR [rsp+0x58]
            if (better_capacity >= new_capacity) return;
  209983:	4c 39 f1             	cmp    rcx,r14
  209986:	76 08                	jbe    209990 <parseAbbrevTable+0x2a0>
  209988:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  20998d:	eb 55                	jmp    2099e4 <parseAbbrevTable+0x2f4>
  20998f:	90                   	nop
                better_capacity += better_capacity / 2 + 8;
  209990:	48 89 c8             	mov    rax,rcx
  209993:	48 d1 e8             	shr    rax,1
  209996:	48 01 c1             	add    rcx,rax
  209999:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20999d:	4c 39 f1             	cmp    rcx,r14
  2099a0:	76 ee                	jbe    209990 <parseAbbrevTable+0x2a0>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2099a2:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2099a7:	48 8b b4 24 80 00 00 	mov    rsi,QWORD PTR [rsp+0x80]
  2099ae:	00 
  2099af:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  2099b6:	00 
  2099b7:	e8 74 04 00 00       	call   209e30 <Allocator_alignedRealloc>
  2099bc:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2099c1:	66 85 c0             	test   ax,ax
  2099c4:	0f 85 0a 04 00 00    	jne    209dd4 <parseAbbrevTable+0x6e4>
  2099ca:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2099cf:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2099d3:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2099da:	00 00 
            const result = &self.items[self.len];
  2099dc:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  2099e3:	00 
  2099e4:	49 6b ee 38          	imul   rbp,r14,0x38
  2099e8:	49 83 c6 01          	add    r14,0x1
            self.len = new_length;
  2099ec:	4c 89 b4 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],r14
  2099f3:	00 
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  2099f4:	80 fb 01             	cmp    bl,0x1
            new_item_ptr.* = item;
  2099f7:	0f 94 04 29          	sete   BYTE PTR [rcx+rbp*1]
  2099fb:	8a 44 24 7f          	mov    al,BYTE PTR [rsp+0x7f]
  2099ff:	88 44 29 07          	mov    BYTE PTR [rcx+rbp*1+0x7],al
  209a03:	0f b7 44 24 7d       	movzx  eax,WORD PTR [rsp+0x7d]
  209a08:	66 89 44 29 05       	mov    WORD PTR [rcx+rbp*1+0x5],ax
  209a0d:	8b 44 24 79          	mov    eax,DWORD PTR [rsp+0x79]
  209a11:	89 44 29 01          	mov    DWORD PTR [rcx+rbp*1+0x1],eax
  209a15:	4c 89 7c 29 08       	mov    QWORD PTR [rcx+rbp*1+0x8],r15
  209a1a:	4c 89 64 29 10       	mov    QWORD PTR [rcx+rbp*1+0x10],r12
  209a1f:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  209a26:	00 
  209a27:	48 89 44 29 28       	mov    QWORD PTR [rcx+rbp*1+0x28],rax
  209a2c:	c5 f8 28 84 24 b0 00 	vmovaps xmm0,XMMWORD PTR [rsp+0xb0]
  209a33:	00 00 
  209a35:	c5 f8 11 44 29 18    	vmovups XMMWORD PTR [rcx+rbp*1+0x18],xmm0
  209a3b:	48 89 c8             	mov    rax,rcx
  209a3e:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  209a43:	4c 89 6c 29 30       	mov    QWORD PTR [rcx+rbp*1+0x30],r13
  209a48:	4c 8d 6c 24 0f       	lea    r13,[rsp+0xf]
            try self.readNoEof(result[0..]);
  209a4d:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  209a52:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  209a59:	00 00 
  209a5b:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
            return self.readFn(self, buffer);
  209a60:	48 89 df             	mov    rdi,rbx
  209a63:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  209a68:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  209a6d:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  209a71:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  209a76:	66 85 c0             	test   ax,ax
  209a79:	0f 85 fd 02 00 00    	jne    209d7c <parseAbbrevTable+0x68c>
  209a7f:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  209a84:	48 01 e8             	add    rax,rbp
  209a87:	48 83 c0 18          	add    rax,0x18
  209a8b:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  209a90:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  209a95:	45 31 ff             	xor    r15d,r15d
  209a98:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  209a9a:	48 3b 4c 24 18       	cmp    rcx,QWORD PTR [rsp+0x18]
  209a9f:	0f 82 d3 02 00 00    	jb     209d78 <parseAbbrevTable+0x688>
            return result[0];
  209aa5:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  209aaa:	89 c2                	mov    edx,eax
  209aac:	83 e2 7f             	and    edx,0x7f
  209aaf:	89 ee                	mov    esi,ebp
  209ab1:	83 e6 3f             	and    esi,0x3f
  209ab4:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  209ab9:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  209abe:	48 39 d6             	cmp    rsi,rdx
  209ac1:	48 8b 54 24 38       	mov    rdx,QWORD PTR [rsp+0x38]
  209ac6:	0f 85 b7 02 00 00    	jne    209d83 <parseAbbrevTable+0x693>
        result |= operand;
  209acc:	49 09 cf             	or     r15,rcx
        if ((byte & 0b10000000) == 0) return result;
  209acf:	84 c0                	test   al,al
  209ad1:	0f 88 a2 00 00 00    	js     209b79 <parseAbbrevTable+0x489>
            try self.readNoEof(result[0..]);
  209ad7:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  209adc:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  209ae3:	00 00 
            return self.readFn(self, buffer);
  209ae5:	48 89 df             	mov    rdi,rbx
  209ae8:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  209aed:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  209af2:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  209af6:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  209afb:	66 85 c0             	test   ax,ax
  209afe:	0f 85 1c 02 00 00    	jne    209d20 <parseAbbrevTable+0x630>
  209b04:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  209b09:	45 31 e4             	xor    r12d,r12d
  209b0c:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  209b0e:	48 3b 4c 24 18       	cmp    rcx,QWORD PTR [rsp+0x18]
  209b13:	0f 82 fd 01 00 00    	jb     209d16 <parseAbbrevTable+0x626>
            return result[0];
  209b19:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  209b1e:	89 c2                	mov    edx,eax
  209b20:	83 e2 7f             	and    edx,0x7f
  209b23:	89 ee                	mov    esi,ebp
  209b25:	83 e6 3f             	and    esi,0x3f
  209b28:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  209b2d:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  209b32:	48 39 d6             	cmp    rsi,rdx
  209b35:	0f 85 e1 01 00 00    	jne    209d1c <parseAbbrevTable+0x62c>
        result |= operand;
  209b3b:	49 09 cc             	or     r12,rcx
        if ((byte & 0b10000000) == 0) return result;
  209b3e:	84 c0                	test   al,al
  209b40:	79 72                	jns    209bb4 <parseAbbrevTable+0x4c4>
        shift += 7;
  209b42:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  209b46:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  209b4b:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  209b52:	00 00 
            return self.readFn(self, buffer);
  209b54:	48 89 df             	mov    rdi,rbx
  209b57:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  209b5c:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  209b61:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  209b65:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  209b6a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  209b6f:	66 85 c0             	test   ax,ax
  209b72:	74 9a                	je     209b0e <parseAbbrevTable+0x41e>
  209b74:	e9 a7 01 00 00       	jmp    209d20 <parseAbbrevTable+0x630>
  209b79:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  209b7d:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  209b82:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  209b89:	00 00 
            return self.readFn(self, buffer);
  209b8b:	48 89 df             	mov    rdi,rbx
  209b8e:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  209b93:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  209b98:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  209b9c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  209ba1:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  209ba6:	66 85 c0             	test   ax,ax
  209ba9:	0f 84 eb fe ff ff    	je     209a9a <parseAbbrevTable+0x3aa>
  209baf:	e9 c8 01 00 00       	jmp    209d7c <parseAbbrevTable+0x68c>
            if (attr_id == 0 and form_id == 0) break;
  209bb4:	4c 89 e0             	mov    rax,r12
  209bb7:	4c 09 f8             	or     rax,r15
  209bba:	0f 84 c0 00 00 00    	je     209c80 <parseAbbrevTable+0x590>
  209bc0:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
            const new_length = self.len + 1;
  209bc5:	48 8b 68 10          	mov    rbp,QWORD PTR [rax+0x10]
            var better_capacity = self.items.len;
  209bc9:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
            if (better_capacity >= new_capacity) return;
  209bcd:	48 39 e9             	cmp    rcx,rbp
  209bd0:	76 0a                	jbe    209bdc <parseAbbrevTable+0x4ec>
            const result = &self.items[self.len];
  209bd2:	48 89 e8             	mov    rax,rbp
  209bd5:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  209bda:	eb 47                	jmp    209c23 <parseAbbrevTable+0x533>
                better_capacity += better_capacity / 2 + 8;
  209bdc:	48 89 c8             	mov    rax,rcx
  209bdf:	48 d1 e8             	shr    rax,1
  209be2:	48 01 c1             	add    rcx,rax
  209be5:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  209be9:	48 39 e9             	cmp    rcx,rbp
  209bec:	76 ee                	jbe    209bdc <parseAbbrevTable+0x4ec>
  209bee:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  209bf3:	48 8b 72 18          	mov    rsi,QWORD PTR [rdx+0x18]
  209bf7:	48 89 df             	mov    rdi,rbx
  209bfa:	e8 c1 04 00 00       	call   20a0c0 <Allocator_alignedRealloc.24>
  209bff:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  209c04:	66 85 c0             	test   ax,ax
  209c07:	0f 85 ee 01 00 00    	jne    209dfb <parseAbbrevTable+0x70b>
  209c0d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  209c12:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  209c16:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  209c1b:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
            const result = &self.items[self.len];
  209c1f:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
  209c23:	48 83 c5 01          	add    rbp,0x1
  209c27:	48 89 ca             	mov    rdx,rcx
  209c2a:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
            self.len = new_length;
  209c2d:	48 89 6a 10          	mov    QWORD PTR [rdx+0x10],rbp
            new_item_ptr.* = item;
  209c31:	48 c1 e0 04          	shl    rax,0x4
  209c35:	4c 89 3c 01          	mov    QWORD PTR [rcx+rax*1],r15
  209c39:	4c 89 64 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],r12
            try self.readNoEof(result[0..]);
  209c3e:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  209c43:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  209c4a:	00 00 
            return self.readFn(self, buffer);
  209c4c:	48 89 df             	mov    rdi,rbx
  209c4f:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  209c54:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  209c59:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  209c5d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  209c62:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  209c67:	41 bf 00 00 00 00    	mov    r15d,0x0
  209c6d:	bd 00 00 00 00       	mov    ebp,0x0
            const amt_read = try self.read(buf);
  209c72:	66 85 c0             	test   ax,ax
  209c75:	0f 84 1f fe ff ff    	je     209a9a <parseAbbrevTable+0x3aa>
  209c7b:	e9 fc 00 00 00       	jmp    209d7c <parseAbbrevTable+0x68c>
            try self.readNoEof(result[0..]);
  209c80:	4c 89 74 24 58       	mov    QWORD PTR [rsp+0x58],r14
  209c85:	4c 89 6c 24 60       	mov    QWORD PTR [rsp+0x60],r13
  209c8a:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  209c91:	00 00 
            return self.readFn(self, buffer);
  209c93:	48 8d 7c 24 10       	lea    rdi,[rsp+0x10]
  209c98:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  209c9d:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  209ca2:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  209ca6:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
  209cab:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
            const amt_read = try self.read(buf);
  209cb0:	66 85 c9             	test   cx,cx
  209cb3:	4c 8b b4 24 80 00 00 	mov    r14,QWORD PTR [rsp+0x80]
  209cba:	00 
  209cbb:	4c 8b a4 24 88 00 00 	mov    r12,QWORD PTR [rsp+0x88]
  209cc2:	00 
  209cc3:	48 8b 5c 24 38       	mov    rbx,QWORD PTR [rsp+0x38]
  209cc8:	0f 84 f5 fa ff ff    	je     2097c3 <parseAbbrevTable+0xd3>
  209cce:	e9 ab fa ff ff       	jmp    20977e <parseAbbrevTable+0x8e>
  209cd3:	66 b9 1e 00          	mov    cx,0x1e
  209cd7:	e9 a2 fa ff ff       	jmp    20977e <parseAbbrevTable+0x8e>
  209cdc:	66 b9 23 00          	mov    cx,0x23
  209ce0:	e9 99 fa ff ff       	jmp    20977e <parseAbbrevTable+0x8e>
  209ce5:	66 b8 1e 00          	mov    ax,0x1e
  209ce9:	eb 04                	jmp    209cef <parseAbbrevTable+0x5ff>
  209ceb:	66 b8 23 00          	mov    ax,0x23
  209cef:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
            .tag_id = try readULeb128(in_stream),
  209cf4:	66 89 01             	mov    WORD PTR [rcx],ax
  209cf7:	48 8b 84 24 ca 01 00 	mov    rax,QWORD PTR [rsp+0x1ca]
  209cfe:	00 
  209cff:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  209d03:	c5 fc 10 84 24 ac 01 	vmovups ymm0,YMMWORD PTR [rsp+0x1ac]
  209d0a:	00 00 
  209d0c:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  209d11:	e9 85 fa ff ff       	jmp    20979b <parseAbbrevTable+0xab>
  209d16:	66 b8 1e 00          	mov    ax,0x1e
  209d1a:	eb 04                	jmp    209d20 <parseAbbrevTable+0x630>
  209d1c:	66 b8 23 00          	mov    ax,0x23
  209d20:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
            const form_id = try readULeb128(in_stream);
  209d25:	66 89 01             	mov    WORD PTR [rcx],ax
  209d28:	48 8b 84 24 32 01 00 	mov    rax,QWORD PTR [rsp+0x132]
  209d2f:	00 
  209d30:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  209d34:	c5 fc 10 84 24 14 01 	vmovups ymm0,YMMWORD PTR [rsp+0x114]
  209d3b:	00 00 
  209d3d:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  209d42:	e9 54 fa ff ff       	jmp    20979b <parseAbbrevTable+0xab>
        if (abbrev_code == 0) return result;
  209d47:	c5 fc 10 84 24 90 00 	vmovups ymm0,YMMWORD PTR [rsp+0x90]
  209d4e:	00 00 
  209d50:	c5 fc 11 84 24 ce 00 	vmovups YMMWORD PTR [rsp+0xce],ymm0
  209d57:	00 00 
  209d59:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  209d5e:	48 8b 84 24 e6 00 00 	mov    rax,QWORD PTR [rsp+0xe6]
  209d65:	00 
  209d66:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
  209d6a:	c5 fc 10 84 24 c8 00 	vmovups ymm0,YMMWORD PTR [rsp+0xc8]
  209d71:	00 00 
  209d73:	e9 1e fa ff ff       	jmp    209796 <parseAbbrevTable+0xa6>
  209d78:	66 b8 1e 00          	mov    ax,0x1e
  209d7c:	48 8b 54 24 38       	mov    rdx,QWORD PTR [rsp+0x38]
  209d81:	eb 04                	jmp    209d87 <parseAbbrevTable+0x697>
  209d83:	66 b8 23 00          	mov    ax,0x23
            const attr_id = try readULeb128(in_stream);
  209d87:	66 89 02             	mov    WORD PTR [rdx],ax
  209d8a:	48 8b 84 24 58 01 00 	mov    rax,QWORD PTR [rsp+0x158]
  209d91:	00 
  209d92:	48 89 42 20          	mov    QWORD PTR [rdx+0x20],rax
  209d96:	c5 fc 10 84 24 3a 01 	vmovups ymm0,YMMWORD PTR [rsp+0x13a]
  209d9d:	00 00 
  209d9f:	c5 fc 11 42 02       	vmovups YMMWORD PTR [rdx+0x2],ymm0
  209da4:	e9 f2 f9 ff ff       	jmp    20979b <parseAbbrevTable+0xab>
  209da9:	66 b8 1e 00          	mov    ax,0x1e
  209dad:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  209db2:	66 89 01             	mov    WORD PTR [rcx],ax
  209db5:	48 8b 84 24 a4 01 00 	mov    rax,QWORD PTR [rsp+0x1a4]
  209dbc:	00 
  209dbd:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  209dc1:	c5 fc 10 84 24 86 01 	vmovups ymm0,YMMWORD PTR [rsp+0x186]
  209dc8:	00 00 
  209dca:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  209dcf:	e9 c7 f9 ff ff       	jmp    20979b <parseAbbrevTable+0xab>
  209dd4:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
        try result.append(AbbrevTableEntry{
  209dd9:	66 89 01             	mov    WORD PTR [rcx],ax
  209ddc:	48 8b 84 24 7e 01 00 	mov    rax,QWORD PTR [rsp+0x17e]
  209de3:	00 
  209de4:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  209de8:	c5 fc 10 84 24 60 01 	vmovups ymm0,YMMWORD PTR [rsp+0x160]
  209def:	00 00 
  209df1:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  209df6:	e9 a0 f9 ff ff       	jmp    20979b <parseAbbrevTable+0xab>
  209dfb:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
            try attrs.append(AbbrevAttr{
  209e00:	66 89 01             	mov    WORD PTR [rcx],ax
  209e03:	48 8b 84 24 0c 01 00 	mov    rax,QWORD PTR [rsp+0x10c]
  209e0a:	00 
  209e0b:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  209e0f:	c5 fc 10 84 24 ee 00 	vmovups ymm0,YMMWORD PTR [rsp+0xee]
  209e16:	00 00 
  209e18:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  209e1d:	e9 79 f9 ff ff       	jmp    20979b <parseAbbrevTable+0xab>
  209e22:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  209e29:	1f 84 00 00 00 00 00 

0000000000209e30 <Allocator_alignedRealloc>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  209e30:	41 56                	push   r14
  209e32:	53                   	push   rbx
  209e33:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  209e3a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  209e3d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  209e41:	48 85 c0             	test   rax,rax
  209e44:	74 54                	je     209e9a <Allocator_alignedRealloc+0x6a>
        if (n == 0) {
  209e46:	48 85 c9             	test   rcx,rcx
  209e49:	0f 84 9b 00 00 00    	je     209eea <Allocator_alignedRealloc+0xba>
        const old_byte_slice = @sliceToBytes(old_mem);
  209e4f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  209e52:	48 6b c0 38          	imul   rax,rax,0x38
  209e56:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  209e5b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  209e60:	ba 38 00 00 00       	mov    edx,0x38
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  209e65:	48 89 c8             	mov    rax,rcx
  209e68:	48 f7 e2             	mul    rdx
  209e6b:	0f 81 c2 00 00 00    	jno    209f33 <Allocator_alignedRealloc+0x103>
  209e71:	48 8d 0d 48 87 ff ff 	lea    rcx,[rip+0xffffffffffff8748]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  209e78:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  209e7c:	0f 84 cc 00 00 00    	je     209f4e <Allocator_alignedRealloc+0x11e>
  209e82:	48 8b 05 2f 72 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff722f]        # 2010b8 <__unnamed_54+0x10>
  209e89:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  209e8d:	c5 f8 10 05 13 72 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff7213]        # 2010a8 <__unnamed_54>
  209e94:	ff 
  209e95:	e9 8a 00 00 00       	jmp    209f24 <Allocator_alignedRealloc+0xf4>
        if (n == 0) {
  209e9a:	48 85 c9             	test   rcx,rcx
  209e9d:	0f 84 f8 00 00 00    	je     209f9b <Allocator_alignedRealloc+0x16b>
  209ea3:	ba 38 00 00 00       	mov    edx,0x38
  209ea8:	48 89 c8             	mov    rax,rcx
  209eab:	48 f7 e2             	mul    rdx
  209eae:	0f 81 08 01 00 00    	jno    209fbc <Allocator_alignedRealloc+0x18c>
  209eb4:	48 8d 0d 05 87 ff ff 	lea    rcx,[rip+0xffffffffffff8705]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  209ebb:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  209ebf:	0f 84 12 01 00 00    	je     209fd7 <Allocator_alignedRealloc+0x1a7>
  209ec5:	0f b7 05 e2 71 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff71e2]        # 2010ae <__unnamed_54+0x6>
  209ecc:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  209ed1:	8b 05 d3 71 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff71d3]        # 2010aa <__unnamed_54+0x2>
  209ed7:	89 04 24             	mov    DWORD PTR [rsp],eax
  209eda:	48 89 e0             	mov    rax,rsp
  209edd:	66 b9 0f 00          	mov    cx,0xf
  209ee1:	31 f6                	xor    esi,esi
  209ee3:	31 d2                	xor    edx,edx
  209ee5:	e9 a9 01 00 00       	jmp    20a093 <Allocator_alignedRealloc+0x263>
        const bytes = @sliceToBytes(memory);
  209eea:	48 6b c0 38          	imul   rax,rax,0x38
        if (bytes.len == 0) return;
  209eee:	48 85 c0             	test   rax,rax
  209ef1:	74 1e                	je     209f11 <Allocator_alignedRealloc+0xe1>
        const bytes = @sliceToBytes(memory);
  209ef3:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  209ef6:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  209efa:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  209eff:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  209f04:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  209f09:	48 89 f7             	mov    rdi,rsi
  209f0c:	48 89 c6             	mov    rsi,rax
  209f0f:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  209f11:	48 8b 05 88 71 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff7188]        # 2010a0 <__unnamed_55+0x10>
  209f18:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  209f1c:	c5 f8 10 05 6c 71 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff716c]        # 201090 <__unnamed_55>
  209f23:	ff 
  209f24:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  209f28:	48 81 c4 88 00 00 00 	add    rsp,0x88
  209f2f:	5b                   	pop    rbx
  209f30:	41 5e                	pop    r14
  209f32:	c3                   	ret    
  209f33:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  209f38:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  209f3f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  209f44:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  209f48:	0f 85 34 ff ff ff    	jne    209e82 <Allocator_alignedRealloc+0x52>
  209f4e:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  209f52:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  209f57:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  209f5c:	41 b8 01 00 00 00    	mov    r8d,0x1
  209f62:	4c 89 f1             	mov    rcx,r14
  209f65:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  209f68:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  209f6d:	66 85 c0             	test   ax,ax
  209f70:	0f 84 97 00 00 00    	je     20a00d <Allocator_alignedRealloc+0x1dd>
  209f76:	66 89 03             	mov    WORD PTR [rbx],ax
  209f79:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  209f80:	00 
  209f81:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  209f85:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  209f8b:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  209f90:	48 81 c4 88 00 00 00 	add    rsp,0x88
  209f97:	5b                   	pop    rbx
  209f98:	41 5e                	pop    r14
  209f9a:	c3                   	ret    
  209f9b:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  209f9e:	0f b7 0d f1 70 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff70f1]        # 201096 <__unnamed_55+0x6>
  209fa5:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  209faa:	8b 0d e2 70 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff70e2]        # 201092 <__unnamed_55+0x2>
  209fb0:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  209fb3:	31 c9                	xor    ecx,ecx
  209fb5:	31 d2                	xor    edx,edx
  209fb7:	e9 d7 00 00 00       	jmp    20a093 <Allocator_alignedRealloc+0x263>
  209fbc:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  209fc1:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  209fc8:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  209fcd:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  209fd1:	0f 85 ee fe ff ff    	jne    209ec5 <Allocator_alignedRealloc+0x95>
  209fd7:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  209fdb:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  209fe0:	b9 01 00 00 00       	mov    ecx,0x1
  209fe5:	4c 89 f2             	mov    rdx,r14
  209fe8:	ff 16                	call   QWORD PTR [rsi]
  209fea:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  209fef:	66 85 c9             	test   cx,cx
  209ff2:	74 67                	je     20a05b <Allocator_alignedRealloc+0x22b>
  209ff4:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  209ff9:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  209ffe:	48 89 e0             	mov    rax,rsp
  20a001:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  20a005:	89 14 24             	mov    DWORD PTR [rsp],edx
  20a008:	e9 86 00 00 00       	jmp    20a093 <Allocator_alignedRealloc+0x263>
        assert(byte_slice.len == byte_count);
  20a00d:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  20a012:	0f 85 9e 00 00 00    	jne    20a0b6 <Allocator_alignedRealloc+0x286>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20a018:	49 c1 ee 03          	shr    r14,0x3
  20a01c:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  20a023:	49 92 24 
  20a026:	4c 89 f2             	mov    rdx,r14
  20a029:	c4 e2 f3 f6 c0       	mulx   rax,rcx,rax
  20a02e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  20a033:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  20a038:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20a03c:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20a041:	8b 54 24 26          	mov    edx,DWORD PTR [rsp+0x26]
  20a045:	89 53 02             	mov    DWORD PTR [rbx+0x2],edx
  20a048:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  20a04c:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20a050:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20a057:	5b                   	pop    rbx
  20a058:	41 5e                	pop    r14
  20a05a:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  20a05b:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  20a060:	75 54                	jne    20a0b6 <Allocator_alignedRealloc+0x286>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20a062:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20a067:	49 c1 ee 03          	shr    r14,0x3
  20a06b:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  20a072:	49 92 24 
  20a075:	4c 89 f2             	mov    rdx,r14
  20a078:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  20a07d:	48 89 e0             	mov    rax,rsp
  20a080:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  20a084:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20a087:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  20a08c:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20a091:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  20a093:	66 89 0b             	mov    WORD PTR [rbx],cx
  20a096:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  20a09a:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20a09e:	8b 00                	mov    eax,DWORD PTR [rax]
  20a0a0:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  20a0a3:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  20a0a7:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  20a0ab:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20a0b2:	5b                   	pop    rbx
  20a0b3:	41 5e                	pop    r14
  20a0b5:	c3                   	ret    
            @panic("assertion failure");
  20a0b6:	e8 15 91 ff ff       	call   2031d0 <panic>
  20a0bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000020a0c0 <Allocator_alignedRealloc.24>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  20a0c0:	41 56                	push   r14
  20a0c2:	53                   	push   rbx
  20a0c3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  20a0ca:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  20a0cd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  20a0d1:	48 85 c0             	test   rax,rax
  20a0d4:	74 5e                	je     20a134 <Allocator_alignedRealloc.24+0x74>
        if (n == 0) {
  20a0d6:	48 85 c9             	test   rcx,rcx
  20a0d9:	0f 84 a6 00 00 00    	je     20a185 <Allocator_alignedRealloc.24+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  20a0df:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  20a0e2:	48 c1 e0 04          	shl    rax,0x4
  20a0e6:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  20a0eb:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  20a0f0:	ba 10 00 00 00       	mov    edx,0x10
  20a0f5:	48 89 c8             	mov    rax,rcx
  20a0f8:	48 f7 e2             	mul    rdx
  20a0fb:	0f 81 ca 00 00 00    	jno    20a1cb <Allocator_alignedRealloc.24+0x10b>
  20a101:	48 8d 0d b8 84 ff ff 	lea    rcx,[rip+0xffffffffffff84b8]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20a108:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20a10c:	0f 84 d4 00 00 00    	je     20a1e6 <Allocator_alignedRealloc.24+0x126>
  20a112:	48 8b 05 cf 6f ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff6fcf]        # 2010e8 <__unnamed_56+0x10>
  20a119:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20a11d:	c5 f8 10 05 b3 6f ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff6fb3]        # 2010d8 <__unnamed_56>
  20a124:	ff 
  20a125:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  20a129:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20a130:	5b                   	pop    rbx
  20a131:	41 5e                	pop    r14
  20a133:	c3                   	ret    
        if (n == 0) {
  20a134:	48 85 c9             	test   rcx,rcx
  20a137:	0f 84 f6 00 00 00    	je     20a233 <Allocator_alignedRealloc.24+0x173>
  20a13d:	ba 10 00 00 00       	mov    edx,0x10
  20a142:	48 89 c8             	mov    rax,rcx
  20a145:	48 f7 e2             	mul    rdx
  20a148:	0f 81 07 01 00 00    	jno    20a255 <Allocator_alignedRealloc.24+0x195>
  20a14e:	48 8d 0d 6b 84 ff ff 	lea    rcx,[rip+0xffffffffffff846b]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20a155:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20a159:	0f 84 11 01 00 00    	je     20a270 <Allocator_alignedRealloc.24+0x1b0>
  20a15f:	0f b7 05 78 6f ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff6f78]        # 2010de <__unnamed_56+0x6>
  20a166:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20a16b:	8b 05 69 6f ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff6f69]        # 2010da <__unnamed_56+0x2>
  20a171:	89 04 24             	mov    DWORD PTR [rsp],eax
  20a174:	48 89 e0             	mov    rax,rsp
  20a177:	66 b9 0f 00          	mov    cx,0xf
  20a17b:	31 d2                	xor    edx,edx
  20a17d:	45 31 f6             	xor    r14d,r14d
  20a180:	e9 6f 01 00 00       	jmp    20a2f4 <Allocator_alignedRealloc.24+0x234>
        const bytes = @sliceToBytes(memory);
  20a185:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  20a189:	74 1e                	je     20a1a9 <Allocator_alignedRealloc.24+0xe9>
        const bytes = @sliceToBytes(memory);
  20a18b:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20a18e:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  20a192:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  20a197:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20a19c:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20a1a1:	48 89 f7             	mov    rdi,rsi
  20a1a4:	48 89 c6             	mov    rsi,rax
  20a1a7:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  20a1a9:	48 8b 05 20 6f ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff6f20]        # 2010d0 <__unnamed_57+0x10>
  20a1b0:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20a1b4:	c5 f8 10 05 04 6f ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff6f04]        # 2010c0 <__unnamed_57>
  20a1bb:	ff 
  20a1bc:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  20a1c0:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20a1c7:	5b                   	pop    rbx
  20a1c8:	41 5e                	pop    r14
  20a1ca:	c3                   	ret    
  20a1cb:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  20a1d0:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  20a1d7:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20a1dc:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20a1e0:	0f 85 2c ff ff ff    	jne    20a112 <Allocator_alignedRealloc.24+0x52>
  20a1e6:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  20a1ea:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  20a1ef:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20a1f4:	41 b8 08 00 00 00    	mov    r8d,0x8
  20a1fa:	4c 89 f1             	mov    rcx,r14
  20a1fd:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  20a200:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  20a205:	66 85 c0             	test   ax,ax
  20a208:	0f 84 95 00 00 00    	je     20a2a3 <Allocator_alignedRealloc.24+0x1e3>
  20a20e:	66 89 03             	mov    WORD PTR [rbx],ax
  20a211:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  20a218:	00 
  20a219:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20a21d:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  20a223:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  20a228:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20a22f:	5b                   	pop    rbx
  20a230:	41 5e                	pop    r14
  20a232:	c3                   	ret    
  20a233:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  20a236:	0f b7 0d 89 6e ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff6e89]        # 2010c6 <__unnamed_57+0x6>
  20a23d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20a242:	8b 0d 7a 6e ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff6e7a]        # 2010c2 <__unnamed_57+0x2>
  20a248:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20a24b:	31 c9                	xor    ecx,ecx
  20a24d:	45 31 f6             	xor    r14d,r14d
  20a250:	e9 9f 00 00 00       	jmp    20a2f4 <Allocator_alignedRealloc.24+0x234>
  20a255:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  20a25a:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  20a261:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20a266:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20a26a:	0f 85 ef fe ff ff    	jne    20a15f <Allocator_alignedRealloc.24+0x9f>
  20a270:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  20a274:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20a279:	b9 08 00 00 00       	mov    ecx,0x8
  20a27e:	4c 89 f2             	mov    rdx,r14
  20a281:	ff 16                	call   QWORD PTR [rsi]
  20a283:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  20a288:	66 85 c9             	test   cx,cx
  20a28b:	74 41                	je     20a2ce <Allocator_alignedRealloc.24+0x20e>
  20a28d:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  20a292:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20a297:	48 89 e0             	mov    rax,rsp
  20a29a:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  20a29e:	89 14 24             	mov    DWORD PTR [rsp],edx
  20a2a1:	eb 51                	jmp    20a2f4 <Allocator_alignedRealloc.24+0x234>
        assert(byte_slice.len == byte_count);
  20a2a3:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  20a2a8:	75 6d                	jne    20a317 <Allocator_alignedRealloc.24+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20a2aa:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20a2af:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  20a2b4:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  20a2b9:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20a2bd:	49 c1 ee 04          	shr    r14,0x4
  20a2c1:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  20a2c5:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  20a2c8:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  20a2cc:	eb 3a                	jmp    20a308 <Allocator_alignedRealloc.24+0x248>
        assert(byte_slice.len == byte_count);
  20a2ce:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  20a2d3:	75 42                	jne    20a317 <Allocator_alignedRealloc.24+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20a2d5:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20a2da:	49 c1 ee 04          	shr    r14,0x4
  20a2de:	48 89 e0             	mov    rax,rsp
  20a2e1:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  20a2e5:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20a2e8:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  20a2ed:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20a2f2:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  20a2f4:	66 89 0b             	mov    WORD PTR [rbx],cx
  20a2f7:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  20a2fb:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20a2ff:	8b 00                	mov    eax,DWORD PTR [rax]
  20a301:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  20a304:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  20a308:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  20a30c:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20a313:	5b                   	pop    rbx
  20a314:	41 5e                	pop    r14
  20a316:	c3                   	ret    
            @panic("assertion failure");
  20a317:	e8 b4 8e ff ff       	call   2031d0 <panic>
  20a31c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000020a320 <Allocator_alignedRealloc.27>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  20a320:	41 56                	push   r14
  20a322:	53                   	push   rbx
  20a323:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  20a32a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  20a32d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  20a331:	48 85 c0             	test   rax,rax
  20a334:	74 62                	je     20a398 <Allocator_alignedRealloc.27+0x78>
        if (n == 0) {
  20a336:	48 85 c9             	test   rcx,rcx
  20a339:	0f 84 a9 00 00 00    	je     20a3e8 <Allocator_alignedRealloc.27+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  20a33f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  20a342:	48 c1 e0 03          	shl    rax,0x3
  20a346:	48 8d 04 80          	lea    rax,[rax+rax*4]
  20a34a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  20a34f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  20a354:	ba 28 00 00 00       	mov    edx,0x28
  20a359:	48 89 c8             	mov    rax,rcx
  20a35c:	48 f7 e2             	mul    rdx
  20a35f:	0f 81 d0 00 00 00    	jno    20a435 <Allocator_alignedRealloc.27+0x115>
  20a365:	48 8d 0d 54 82 ff ff 	lea    rcx,[rip+0xffffffffffff8254]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20a36c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20a370:	0f 84 da 00 00 00    	je     20a450 <Allocator_alignedRealloc.27+0x130>
  20a376:	48 8b 05 9b 6d ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff6d9b]        # 201118 <__unnamed_58+0x10>
  20a37d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20a381:	c5 f8 10 05 7f 6d ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff6d7f]        # 201108 <__unnamed_58>
  20a388:	ff 
  20a389:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  20a38d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20a394:	5b                   	pop    rbx
  20a395:	41 5e                	pop    r14
  20a397:	c3                   	ret    
        if (n == 0) {
  20a398:	48 85 c9             	test   rcx,rcx
  20a39b:	0f 84 fc 00 00 00    	je     20a49d <Allocator_alignedRealloc.27+0x17d>
  20a3a1:	ba 28 00 00 00       	mov    edx,0x28
  20a3a6:	48 89 c8             	mov    rax,rcx
  20a3a9:	48 f7 e2             	mul    rdx
  20a3ac:	0f 81 0c 01 00 00    	jno    20a4be <Allocator_alignedRealloc.27+0x19e>
  20a3b2:	48 8d 0d 07 82 ff ff 	lea    rcx,[rip+0xffffffffffff8207]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20a3b9:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20a3bd:	0f 84 16 01 00 00    	je     20a4d9 <Allocator_alignedRealloc.27+0x1b9>
  20a3c3:	0f b7 05 44 6d ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff6d44]        # 20110e <__unnamed_58+0x6>
  20a3ca:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20a3cf:	8b 05 35 6d ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff6d35]        # 20110a <__unnamed_58+0x2>
  20a3d5:	89 04 24             	mov    DWORD PTR [rsp],eax
  20a3d8:	48 89 e0             	mov    rax,rsp
  20a3db:	66 b9 0f 00          	mov    cx,0xf
  20a3df:	31 f6                	xor    esi,esi
  20a3e1:	31 d2                	xor    edx,edx
  20a3e3:	e9 9d 01 00 00       	jmp    20a585 <Allocator_alignedRealloc.27+0x265>
        const bytes = @sliceToBytes(memory);
  20a3e8:	48 c1 e0 03          	shl    rax,0x3
  20a3ec:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  20a3f0:	48 85 c0             	test   rax,rax
  20a3f3:	74 1e                	je     20a413 <Allocator_alignedRealloc.27+0xf3>
        const bytes = @sliceToBytes(memory);
  20a3f5:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20a3f8:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  20a3fc:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  20a401:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20a406:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20a40b:	48 89 f7             	mov    rdi,rsi
  20a40e:	48 89 c6             	mov    rsi,rax
  20a411:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  20a413:	48 8b 05 e6 6c ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff6ce6]        # 201100 <__unnamed_59+0x10>
  20a41a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20a41e:	c5 f8 10 05 ca 6c ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff6cca]        # 2010f0 <__unnamed_59>
  20a425:	ff 
  20a426:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  20a42a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20a431:	5b                   	pop    rbx
  20a432:	41 5e                	pop    r14
  20a434:	c3                   	ret    
  20a435:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  20a43a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  20a441:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20a446:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20a44a:	0f 85 26 ff ff ff    	jne    20a376 <Allocator_alignedRealloc.27+0x56>
  20a450:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  20a454:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  20a459:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20a45e:	41 b8 08 00 00 00    	mov    r8d,0x8
  20a464:	4c 89 f1             	mov    rcx,r14
  20a467:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  20a46a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  20a46f:	66 85 c0             	test   ax,ax
  20a472:	0f 84 94 00 00 00    	je     20a50c <Allocator_alignedRealloc.27+0x1ec>
  20a478:	66 89 03             	mov    WORD PTR [rbx],ax
  20a47b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  20a482:	00 
  20a483:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20a487:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  20a48d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  20a492:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20a499:	5b                   	pop    rbx
  20a49a:	41 5e                	pop    r14
  20a49c:	c3                   	ret    
  20a49d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  20a4a0:	0f b7 0d 4f 6c ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff6c4f]        # 2010f6 <__unnamed_59+0x6>
  20a4a7:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20a4ac:	8b 0d 40 6c ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff6c40]        # 2010f2 <__unnamed_59+0x2>
  20a4b2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20a4b5:	31 c9                	xor    ecx,ecx
  20a4b7:	31 d2                	xor    edx,edx
  20a4b9:	e9 c7 00 00 00       	jmp    20a585 <Allocator_alignedRealloc.27+0x265>
  20a4be:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  20a4c3:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  20a4ca:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20a4cf:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20a4d3:	0f 85 ea fe ff ff    	jne    20a3c3 <Allocator_alignedRealloc.27+0xa3>
  20a4d9:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  20a4dd:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20a4e2:	b9 08 00 00 00       	mov    ecx,0x8
  20a4e7:	4c 89 f2             	mov    rdx,r14
  20a4ea:	ff 16                	call   QWORD PTR [rsi]
  20a4ec:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  20a4f1:	66 85 c9             	test   cx,cx
  20a4f4:	74 57                	je     20a54d <Allocator_alignedRealloc.27+0x22d>
  20a4f6:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  20a4fb:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20a500:	48 89 e0             	mov    rax,rsp
  20a503:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  20a507:	89 14 24             	mov    DWORD PTR [rsp],edx
  20a50a:	eb 79                	jmp    20a585 <Allocator_alignedRealloc.27+0x265>
        assert(byte_slice.len == byte_count);
  20a50c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  20a511:	0f 85 91 00 00 00    	jne    20a5a8 <Allocator_alignedRealloc.27+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20a517:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20a51c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  20a523:	cc cc cc 
  20a526:	4c 89 f2             	mov    rdx,r14
  20a529:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  20a52e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  20a533:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  20a538:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20a53c:	48 c1 ea 05          	shr    rdx,0x5
  20a540:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  20a544:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  20a547:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  20a54b:	eb 4c                	jmp    20a599 <Allocator_alignedRealloc.27+0x279>
        assert(byte_slice.len == byte_count);
  20a54d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  20a552:	75 54                	jne    20a5a8 <Allocator_alignedRealloc.27+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20a554:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20a559:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  20a560:	cc cc cc 
  20a563:	4c 89 f2             	mov    rdx,r14
  20a566:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  20a56b:	48 c1 ea 05          	shr    rdx,0x5
  20a56f:	48 89 e0             	mov    rax,rsp
  20a572:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  20a576:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20a579:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  20a57e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20a583:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  20a585:	66 89 0b             	mov    WORD PTR [rbx],cx
  20a588:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  20a58c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20a590:	8b 00                	mov    eax,DWORD PTR [rax]
  20a592:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  20a595:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  20a599:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  20a59d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20a5a4:	5b                   	pop    rbx
  20a5a5:	41 5e                	pop    r14
  20a5a7:	c3                   	ret    
            @panic("assertion failure");
  20a5a8:	e8 23 8c ff ff       	call   2031d0 <panic>
  20a5ad:	0f 1f 00             	nop    DWORD PTR [rax]

000000000020a5b0 <parseFormValue>:
fn parseFormValue(allocator: *mem.Allocator, in_stream: var, form_id: u64, is_64: bool) ParseFormValueError!FormValue {
  20a5b0:	55                   	push   rbp
  20a5b1:	41 57                	push   r15
  20a5b3:	41 56                	push   r14
  20a5b5:	41 55                	push   r13
  20a5b7:	41 54                	push   r12
  20a5b9:	53                   	push   rbx
  20a5ba:	48 81 ec 08 07 00 00 	sub    rsp,0x708
  20a5c1:	44 89 c5             	mov    ebp,r8d
  20a5c4:	48 89 cb             	mov    rbx,rcx
  20a5c7:	49 89 d4             	mov    r12,rdx
  20a5ca:	49 89 f7             	mov    r15,rsi
  20a5cd:	49 89 fe             	mov    r14,rdi
  20a5d0:	48 8d 05 b1 6b ff ff 	lea    rax,[rip+0xffffffffffff6bb1]        # 201188 <__unnamed_60>
    return switch (form_id) {
  20a5d7:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  20a5db:	48 83 f9 1f          	cmp    rcx,0x1f
  20a5df:	0f 87 d1 19 00 00    	ja     20bfb6 <parseFormValue+0x1a06>
  20a5e5:	48 8d 15 08 64 ff ff 	lea    rdx,[rip+0xffffffffffff6408]        # 2009f4 <__unnamed_128+0x7ac>
  20a5ec:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  20a5f0:	48 01 d1             	add    rcx,rdx
  20a5f3:	ff e1                	jmp    rcx
  20a5f5:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  20a5fc:	00 
  20a5fd:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  20a602:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  20a609:	00 
            try self.readNoEof(result[0..]);
  20a60a:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  20a60f:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  20a616:	00 00 
  20a618:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20a61d:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20a622:	4c 89 e6             	mov    rsi,r12
  20a625:	41 ff 14 24          	call   QWORD PTR [r12]
  20a629:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20a62e:	66 85 c0             	test   ax,ax
  20a631:	0f 84 f2 0b 00 00    	je     20b229 <parseFormValue+0xc79>
  20a637:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  20a63c:	66 89 01             	mov    WORD PTR [rcx],ax
  20a63f:	48 8b 84 24 b4 06 00 	mov    rax,QWORD PTR [rsp+0x6b4]
  20a646:	00 
  20a647:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  20a64b:	c5 fc 10 84 24 96 06 	vmovups ymm0,YMMWORD PTR [rsp+0x696]
  20a652:	00 00 
  20a654:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  20a659:	e9 69 19 00 00       	jmp    20bfc7 <parseFormValue+0x1a17>
  20a65e:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  20a663:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20a668:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  20a66f:	00 00 
  20a671:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20a676:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20a67b:	4c 89 e6             	mov    rsi,r12
  20a67e:	41 ff 14 24          	call   QWORD PTR [r12]
  20a682:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20a687:	66 85 c0             	test   ax,ax
  20a68a:	75 14                	jne    20a6a0 <parseFormValue+0xf0>
  20a68c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20a691:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20a695:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20a69a:	0f 83 ce 12 00 00    	jae    20b96e <parseFormValue+0x13be>
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  20a6a0:	66 41 89 06          	mov    WORD PTR [r14],ax
  20a6a4:	48 8b 84 24 00 07 00 	mov    rax,QWORD PTR [rsp+0x700]
  20a6ab:	00 
  20a6ac:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  20a6b0:	c5 fc 10 84 24 e2 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6e2]
  20a6b7:	00 00 
  20a6b9:	e9 0b 0d 00 00       	jmp    20b3c9 <parseFormValue+0xe19>
  20a6be:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  20a6c3:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20a6c8:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  20a6cf:	00 00 
  20a6d1:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20a6d6:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20a6db:	4c 89 e6             	mov    rsi,r12
  20a6de:	41 ff 14 24          	call   QWORD PTR [r12]
  20a6e2:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20a6e7:	66 85 c9             	test   cx,cx
  20a6ea:	75 14                	jne    20a700 <parseFormValue+0x150>
            if (amt_read < buf.len) return error.EndOfStream;
  20a6ec:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  20a6f1:	66 b9 1e 00          	mov    cx,0x1e
  20a6f5:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  20a6fa:	0f 83 d8 12 00 00    	jae    20b9d8 <parseFormValue+0x1428>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  20a700:	66 89 8c 24 90 02 00 	mov    WORD PTR [rsp+0x290],cx
  20a707:	00 
  20a708:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20a70c:	89 84 24 92 02 00 00 	mov    DWORD PTR [rsp+0x292],eax
  20a713:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20a718:	66 89 84 24 96 02 00 	mov    WORD PTR [rsp+0x296],ax
  20a71f:	00 
  20a720:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20a724:	89 84 24 a9 02 00 00 	mov    DWORD PTR [rsp+0x2a9],eax
  20a72b:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20a730:	66 89 84 24 ad 02 00 	mov    WORD PTR [rsp+0x2ad],ax
  20a737:	00 
  20a738:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20a73c:	88 84 24 af 02 00 00 	mov    BYTE PTR [rsp+0x2af],al
  20a743:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20a747:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  20a74e:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  20a753:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  20a75a:	00 
  20a75b:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  20a75f:	88 84 24 b7 02 00 00 	mov    BYTE PTR [rsp+0x2b7],al
  20a766:	48 8d 84 24 90 02 00 	lea    rax,[rsp+0x290]
  20a76d:	00 
  20a76e:	e9 43 18 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20a773:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  20a778:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20a77d:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  20a784:	00 00 
  20a786:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20a78b:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20a790:	4c 89 e6             	mov    rsi,r12
  20a793:	41 ff 14 24          	call   QWORD PTR [r12]
  20a797:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20a79c:	66 85 c9             	test   cx,cx
  20a79f:	75 14                	jne    20a7b5 <parseFormValue+0x205>
            if (amt_read < buf.len) return error.EndOfStream;
  20a7a1:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  20a7a6:	66 b9 1e 00          	mov    cx,0x1e
  20a7aa:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  20a7af:	0f 83 44 12 00 00    	jae    20b9f9 <parseFormValue+0x1449>
  20a7b5:	66 89 8c 24 68 02 00 	mov    WORD PTR [rsp+0x268],cx
  20a7bc:	00 
  20a7bd:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20a7c1:	89 84 24 6a 02 00 00 	mov    DWORD PTR [rsp+0x26a],eax
  20a7c8:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20a7cd:	66 89 84 24 6e 02 00 	mov    WORD PTR [rsp+0x26e],ax
  20a7d4:	00 
  20a7d5:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20a7d9:	89 84 24 81 02 00 00 	mov    DWORD PTR [rsp+0x281],eax
  20a7e0:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20a7e5:	66 89 84 24 85 02 00 	mov    WORD PTR [rsp+0x285],ax
  20a7ec:	00 
  20a7ed:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20a7f1:	88 84 24 87 02 00 00 	mov    BYTE PTR [rsp+0x287],al
  20a7f8:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20a7fc:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  20a803:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  20a808:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  20a80f:	00 
  20a810:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  20a814:	88 84 24 8f 02 00 00 	mov    BYTE PTR [rsp+0x28f],al
  20a81b:	48 8d 84 24 68 02 00 	lea    rax,[rsp+0x268]
  20a822:	00 
  20a823:	e9 8e 17 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20a828:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  20a82d:	b9 02 00 00 00       	mov    ecx,0x2
  20a832:	4c 89 fe             	mov    rsi,r15
  20a835:	4c 89 e2             	mov    rdx,r12
  20a838:	e8 03 2b 00 00       	call   20d340 <readAllocBytes>
  20a83d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  20a842:	66 85 c0             	test   ax,ax
  20a845:	0f 84 89 0b 00 00    	je     20b3d4 <parseFormValue+0xe24>
  20a84b:	66 89 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],ax
  20a852:	00 
  20a853:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20a857:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
  20a85e:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20a863:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  20a86a:	00 
  20a86b:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20a86f:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  20a876:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20a87b:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  20a882:	00 
  20a883:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20a887:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  20a88e:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20a892:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  20a899:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  20a89e:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  20a8a5:	00 
  20a8a6:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  20a8aa:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  20a8b1:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  20a8b8:	00 
  20a8b9:	e9 f8 16 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20a8be:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20a8c3:	b9 04 00 00 00       	mov    ecx,0x4
  20a8c8:	4c 89 fe             	mov    rsi,r15
  20a8cb:	4c 89 e2             	mov    rdx,r12
  20a8ce:	e8 6d 2a 00 00       	call   20d340 <readAllocBytes>
  20a8d3:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  20a8d8:	66 85 c0             	test   ax,ax
  20a8db:	0f 84 9d 0b 00 00    	je     20b47e <parseFormValue+0xece>
  20a8e1:	66 89 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],ax
  20a8e8:	00 
  20a8e9:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20a8ed:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
  20a8f4:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20a8f9:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  20a900:	00 
  20a901:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20a905:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  20a90c:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20a911:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  20a918:	00 
  20a919:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20a91d:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  20a924:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20a928:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  20a92f:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  20a934:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  20a93b:	00 
  20a93c:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  20a940:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  20a947:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  20a94e:	00 
  20a94f:	e9 62 16 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20a954:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20a959:	b9 08 00 00 00       	mov    ecx,0x8
  20a95e:	4c 89 fe             	mov    rsi,r15
  20a961:	4c 89 e2             	mov    rdx,r12
  20a964:	e8 d7 29 00 00       	call   20d340 <readAllocBytes>
  20a969:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  20a96e:	66 85 c0             	test   ax,ax
  20a971:	0f 84 b1 0b 00 00    	je     20b528 <parseFormValue+0xf78>
  20a977:	66 89 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],ax
  20a97e:	00 
  20a97f:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20a983:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
  20a98a:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20a98f:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  20a996:	00 
  20a997:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20a99b:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  20a9a2:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20a9a7:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  20a9ae:	00 
  20a9af:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20a9b3:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  20a9ba:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20a9be:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  20a9c5:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  20a9ca:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  20a9d1:	00 
  20a9d2:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  20a9d6:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  20a9dd:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  20a9e4:	00 
  20a9e5:	e9 cc 15 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20a9ea:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
            return Self{
  20a9ef:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  20a9f3:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  20a9f9:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  20aa00:	00 00 
  20aa02:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  20aa09:	00 
    var buf = ArrayList(u8).init(allocator);
  20aa0a:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  20aa0f:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  20aa16:	00 
            try self.readNoEof(result[0..]);
  20aa17:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  20aa1e:	00 
  20aa1f:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  20aa26:	00 01 00 00 00 
  20aa2b:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  20aa30:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  20aa37:	00 
            return self.readFn(self, buffer);
  20aa38:	4c 89 e6             	mov    rsi,r12
  20aa3b:	41 ff 14 24          	call   QWORD PTR [r12]
  20aa3f:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
            const amt_read = try self.read(buf);
  20aa44:	66 85 c0             	test   ax,ax
  20aa47:	0f 84 85 0b 00 00    	je     20b5d2 <parseFormValue+0x1022>
  20aa4d:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  20aa52:	66 89 01             	mov    WORD PTR [rcx],ax
  20aa55:	48 8b 84 24 84 05 00 	mov    rax,QWORD PTR [rsp+0x584]
  20aa5c:	00 
  20aa5d:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  20aa61:	c5 fc 10 84 24 66 05 	vmovups ymm0,YMMWORD PTR [rsp+0x566]
  20aa68:	00 00 
  20aa6a:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  20aa6f:	e9 53 15 00 00       	jmp    20bfc7 <parseFormValue+0x1a17>
  20aa74:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  20aa7b:	00 
  20aa7c:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  20aa81:	4c 8d ac 24 b0 00 00 	lea    r13,[rsp+0xb0]
  20aa88:	00 
            try self.readNoEof(result[0..]);
  20aa89:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  20aa8e:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  20aa95:	00 00 
  20aa97:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20aa9c:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20aaa1:	4c 89 e6             	mov    rsi,r12
  20aaa4:	41 ff 14 24          	call   QWORD PTR [r12]
  20aaa8:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20aaad:	66 85 c0             	test   ax,ax
  20aab0:	0f 84 fa 0b 00 00    	je     20b6b0 <parseFormValue+0x1100>
  20aab6:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  20aabb:	66 89 01             	mov    WORD PTR [rcx],ax
  20aabe:	48 8b 84 24 da 06 00 	mov    rax,QWORD PTR [rsp+0x6da]
  20aac5:	00 
  20aac6:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  20aaca:	c5 fc 10 84 24 bc 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6bc]
  20aad1:	00 00 
  20aad3:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  20aad8:	e9 ea 14 00 00       	jmp    20bfc7 <parseFormValue+0x1a17>
  20aadd:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  20aae2:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20aae7:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  20aaee:	00 00 
  20aaf0:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20aaf5:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20aafa:	4c 89 e6             	mov    rsi,r12
  20aafd:	41 ff 14 24          	call   QWORD PTR [r12]
  20ab01:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20ab06:	66 85 c9             	test   cx,cx
  20ab09:	75 14                	jne    20ab1f <parseFormValue+0x56f>
            if (amt_read < buf.len) return error.EndOfStream;
  20ab0b:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  20ab10:	66 b9 1e 00          	mov    cx,0x1e
  20ab14:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  20ab19:	0f 83 fb 0e 00 00    	jae    20ba1a <parseFormValue+0x146a>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  20ab1f:	66 89 8c 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],cx
  20ab26:	00 
  20ab27:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20ab2b:	89 84 24 ba 02 00 00 	mov    DWORD PTR [rsp+0x2ba],eax
  20ab32:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20ab37:	66 89 84 24 be 02 00 	mov    WORD PTR [rsp+0x2be],ax
  20ab3e:	00 
  20ab3f:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20ab43:	89 84 24 d1 02 00 00 	mov    DWORD PTR [rsp+0x2d1],eax
  20ab4a:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20ab4f:	66 89 84 24 d5 02 00 	mov    WORD PTR [rsp+0x2d5],ax
  20ab56:	00 
  20ab57:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20ab5b:	88 84 24 d7 02 00 00 	mov    BYTE PTR [rsp+0x2d7],al
  20ab62:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20ab66:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  20ab6d:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  20ab72:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  20ab79:	00 
  20ab7a:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  20ab7e:	88 84 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],al
  20ab85:	48 8d 84 24 b8 02 00 	lea    rax,[rsp+0x2b8]
  20ab8c:	00 
  20ab8d:	e9 24 14 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20ab92:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  20ab97:	b9 01 00 00 00       	mov    ecx,0x1
  20ab9c:	4c 89 fe             	mov    rsi,r15
  20ab9f:	4c 89 e2             	mov    rdx,r12
  20aba2:	e8 99 27 00 00       	call   20d340 <readAllocBytes>
  20aba7:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  20abac:	66 85 c0             	test   ax,ax
  20abaf:	0f 84 7c 0b 00 00    	je     20b731 <parseFormValue+0x1181>
  20abb5:	66 89 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],ax
  20abbc:	00 
  20abbd:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20abc1:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
  20abc8:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20abcd:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  20abd4:	00 
  20abd5:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20abd9:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  20abe0:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20abe5:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  20abec:	00 
  20abed:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20abf1:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  20abf8:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20abfc:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  20ac03:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  20ac08:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  20ac0f:	00 
  20ac10:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  20ac14:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  20ac1b:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  20ac22:	00 
  20ac23:	e9 8e 13 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20ac28:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  20ac2f:	00 
            try self.readNoEof(result[0..]);
  20ac30:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20ac35:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  20ac3c:	00 00 
  20ac3e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20ac43:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20ac48:	4c 89 e6             	mov    rsi,r12
  20ac4b:	41 ff 14 24          	call   QWORD PTR [r12]
  20ac4f:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20ac54:	66 85 c0             	test   ax,ax
  20ac57:	75 14                	jne    20ac6d <parseFormValue+0x6bd>
  20ac59:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20ac5e:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20ac62:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20ac67:	0f 83 ce 0d 00 00    	jae    20ba3b <parseFormValue+0x148b>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  20ac6d:	66 41 89 06          	mov    WORD PTR [r14],ax
  20ac71:	48 8b 84 24 42 06 00 	mov    rax,QWORD PTR [rsp+0x642]
  20ac78:	00 
  20ac79:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  20ac7d:	c5 fc 10 84 24 24 06 	vmovups ymm0,YMMWORD PTR [rsp+0x624]
  20ac84:	00 00 
  20ac86:	e9 3e 07 00 00       	jmp    20b3c9 <parseFormValue+0xe19>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  20ac8b:	40 f6 c5 01          	test   bpl,0x1
  20ac8f:	0f 84 1c 06 00 00    	je     20b2b1 <parseFormValue+0xd01>
  20ac95:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  20ac9c:	00 
            try self.readNoEof(bytes[0..]);
  20ac9d:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20aca2:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  20aca9:	00 00 
  20acab:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20acb0:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20acb5:	4c 89 e6             	mov    rsi,r12
  20acb8:	41 ff 14 24          	call   QWORD PTR [r12]
  20acbc:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20acc1:	66 85 c0             	test   ax,ax
  20acc4:	0f 85 29 06 00 00    	jne    20b2f3 <parseFormValue+0xd43>
  20acca:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20accf:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20acd3:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20acd8:	0f 82 15 06 00 00    	jb     20b2f3 <parseFormValue+0xd43>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20acde:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  20ace5:	00 
  20ace6:	e9 4f 11 00 00       	jmp    20be3a <parseFormValue+0x188a>
  20aceb:	40 f6 c5 01          	test   bpl,0x1
  20acef:	0f 84 1c 06 00 00    	je     20b311 <parseFormValue+0xd61>
  20acf5:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  20acfc:	00 
            try self.readNoEof(bytes[0..]);
  20acfd:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20ad02:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  20ad09:	00 00 
  20ad0b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20ad10:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20ad15:	4c 89 e6             	mov    rsi,r12
  20ad18:	41 ff 14 24          	call   QWORD PTR [r12]
  20ad1c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20ad21:	66 85 c0             	test   ax,ax
  20ad24:	0f 85 29 06 00 00    	jne    20b353 <parseFormValue+0xda3>
  20ad2a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20ad2f:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20ad33:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20ad38:	0f 82 15 06 00 00    	jb     20b353 <parseFormValue+0xda3>
  20ad3e:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  20ad45:	00 
  20ad46:	e9 7d 11 00 00       	jmp    20bec8 <parseFormValue+0x1918>
  20ad4b:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  20ad52:	00 
            try self.readNoEof(bytes[0..]);
  20ad53:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20ad58:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  20ad5f:	00 00 
  20ad61:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20ad66:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20ad6b:	4c 89 e6             	mov    rsi,r12
  20ad6e:	41 ff 14 24          	call   QWORD PTR [r12]
  20ad72:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20ad77:	66 85 c0             	test   ax,ax
  20ad7a:	75 14                	jne    20ad90 <parseFormValue+0x7e0>
  20ad7c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20ad81:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20ad85:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20ad8a:	0f 83 30 0d 00 00    	jae    20bac0 <parseFormValue+0x1510>
    const block_len = try in_stream.readIntLe(T);
  20ad90:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  20ad97:	00 
  20ad98:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20ad9c:	89 84 24 42 02 00 00 	mov    DWORD PTR [rsp+0x242],eax
  20ada3:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20ada8:	66 89 84 24 46 02 00 	mov    WORD PTR [rsp+0x246],ax
  20adaf:	00 
  20adb0:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20adb4:	89 84 24 59 02 00 00 	mov    DWORD PTR [rsp+0x259],eax
  20adbb:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20adc0:	66 89 84 24 5d 02 00 	mov    WORD PTR [rsp+0x25d],ax
  20adc7:	00 
  20adc8:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20adcc:	88 84 24 5f 02 00 00 	mov    BYTE PTR [rsp+0x25f],al
  20add3:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20add7:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  20adde:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  20ade3:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  20adea:	00 
  20adeb:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  20adef:	88 84 24 67 02 00 00 	mov    BYTE PTR [rsp+0x267],al
  20adf6:	48 8d 84 24 40 02 00 	lea    rax,[rsp+0x240]
  20adfd:	00 
  20adfe:	e9 b3 11 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20ae03:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  20ae08:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20ae0d:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  20ae14:	00 00 
  20ae16:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20ae1b:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20ae20:	4c 89 e6             	mov    rsi,r12
  20ae23:	41 ff 14 24          	call   QWORD PTR [r12]
  20ae27:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20ae2c:	66 85 c0             	test   ax,ax
  20ae2f:	75 14                	jne    20ae45 <parseFormValue+0x895>
  20ae31:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20ae36:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20ae3a:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20ae3f:	0f 83 dd 0c 00 00    	jae    20bb22 <parseFormValue+0x1572>
  20ae45:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  20ae4c:	00 
  20ae4d:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20ae51:	89 84 24 1a 02 00 00 	mov    DWORD PTR [rsp+0x21a],eax
  20ae58:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20ae5d:	66 89 84 24 1e 02 00 	mov    WORD PTR [rsp+0x21e],ax
  20ae64:	00 
  20ae65:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20ae69:	89 84 24 31 02 00 00 	mov    DWORD PTR [rsp+0x231],eax
  20ae70:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20ae75:	66 89 84 24 35 02 00 	mov    WORD PTR [rsp+0x235],ax
  20ae7c:	00 
  20ae7d:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20ae81:	88 84 24 37 02 00 00 	mov    BYTE PTR [rsp+0x237],al
  20ae88:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20ae8c:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  20ae93:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  20ae98:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  20ae9f:	00 
  20aea0:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  20aea4:	88 84 24 3f 02 00 00 	mov    BYTE PTR [rsp+0x23f],al
  20aeab:	48 8d 84 24 18 02 00 	lea    rax,[rsp+0x218]
  20aeb2:	00 
  20aeb3:	e9 fe 10 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20aeb8:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  20aebd:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20aec2:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  20aec9:	00 00 
  20aecb:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20aed0:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20aed5:	4c 89 e6             	mov    rsi,r12
  20aed8:	41 ff 14 24          	call   QWORD PTR [r12]
  20aedc:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20aee1:	66 85 c0             	test   ax,ax
  20aee4:	75 14                	jne    20aefa <parseFormValue+0x94a>
  20aee6:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20aeeb:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20aeef:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20aef4:	0f 83 93 0c 00 00    	jae    20bb8d <parseFormValue+0x15dd>
  20aefa:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  20af01:	00 
  20af02:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20af06:	89 84 24 f2 01 00 00 	mov    DWORD PTR [rsp+0x1f2],eax
  20af0d:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20af12:	66 89 84 24 f6 01 00 	mov    WORD PTR [rsp+0x1f6],ax
  20af19:	00 
  20af1a:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20af1e:	89 84 24 09 02 00 00 	mov    DWORD PTR [rsp+0x209],eax
  20af25:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20af2a:	66 89 84 24 0d 02 00 	mov    WORD PTR [rsp+0x20d],ax
  20af31:	00 
  20af32:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20af36:	88 84 24 0f 02 00 00 	mov    BYTE PTR [rsp+0x20f],al
  20af3d:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20af41:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  20af48:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  20af4d:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  20af54:	00 
  20af55:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  20af59:	88 84 24 17 02 00 00 	mov    BYTE PTR [rsp+0x217],al
  20af60:	48 8d 84 24 f0 01 00 	lea    rax,[rsp+0x1f0]
  20af67:	00 
  20af68:	e9 49 10 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20af6d:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  20af72:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20af77:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  20af7e:	00 00 
  20af80:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20af85:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20af8a:	4c 89 e6             	mov    rsi,r12
  20af8d:	41 ff 14 24          	call   QWORD PTR [r12]
  20af91:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20af96:	66 85 c0             	test   ax,ax
  20af99:	75 14                	jne    20afaf <parseFormValue+0x9ff>
  20af9b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20afa0:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20afa4:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20afa9:	0f 83 61 0c 00 00    	jae    20bc10 <parseFormValue+0x1660>
  20afaf:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  20afb6:	00 
  20afb7:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20afbb:	89 84 24 ca 01 00 00 	mov    DWORD PTR [rsp+0x1ca],eax
  20afc2:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20afc7:	66 89 84 24 ce 01 00 	mov    WORD PTR [rsp+0x1ce],ax
  20afce:	00 
  20afcf:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20afd3:	89 84 24 e1 01 00 00 	mov    DWORD PTR [rsp+0x1e1],eax
  20afda:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20afdf:	66 89 84 24 e5 01 00 	mov    WORD PTR [rsp+0x1e5],ax
  20afe6:	00 
  20afe7:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20afeb:	88 84 24 e7 01 00 00 	mov    BYTE PTR [rsp+0x1e7],al
  20aff2:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20aff6:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  20affd:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  20b002:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  20b009:	00 
  20b00a:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  20b00e:	88 84 24 ef 01 00 00 	mov    BYTE PTR [rsp+0x1ef],al
  20b015:	48 8d 84 24 c8 01 00 	lea    rax,[rsp+0x1c8]
  20b01c:	00 
  20b01d:	e9 94 0f 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20b022:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  20b029:	00 
  20b02a:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  20b02f:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  20b036:	00 
            try self.readNoEof(result[0..]);
  20b037:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  20b03c:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  20b043:	00 00 
  20b045:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20b04a:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20b04f:	4c 89 e6             	mov    rsi,r12
  20b052:	41 ff 14 24          	call   QWORD PTR [r12]
  20b056:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20b05b:	66 85 c0             	test   ax,ax
  20b05e:	0f 84 77 07 00 00    	je     20b7db <parseFormValue+0x122b>
  20b064:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const ref_len = try readULeb128(in_stream);
  20b069:	66 89 01             	mov    WORD PTR [rcx],ax
  20b06c:	48 8b 84 24 f6 05 00 	mov    rax,QWORD PTR [rsp+0x5f6]
  20b073:	00 
  20b074:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  20b078:	c5 fc 10 84 24 d8 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5d8]
  20b07f:	00 00 
  20b081:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  20b086:	e9 3c 0f 00 00       	jmp    20bfc7 <parseFormValue+0x1a17>
  20b08b:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  20b092:	00 
  20b093:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  20b098:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  20b09f:	00 
            try self.readNoEof(result[0..]);
  20b0a0:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  20b0a5:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  20b0ac:	00 00 
  20b0ae:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20b0b3:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20b0b8:	4c 89 e6             	mov    rsi,r12
  20b0bb:	41 ff 14 24          	call   QWORD PTR [r12]
  20b0bf:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20b0c4:	66 85 c0             	test   ax,ax
  20b0c7:	0f 84 8f 07 00 00    	je     20b85c <parseFormValue+0x12ac>
  20b0cd:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const child_form_id = try readULeb128(in_stream);
  20b0d2:	66 89 01             	mov    WORD PTR [rcx],ax
  20b0d5:	48 8b 84 24 38 05 00 	mov    rax,QWORD PTR [rsp+0x538]
  20b0dc:	00 
  20b0dd:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  20b0e1:	c5 fc 10 84 24 1a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x51a]
  20b0e8:	00 00 
  20b0ea:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  20b0ef:	e9 d3 0e 00 00       	jmp    20bfc7 <parseFormValue+0x1a17>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  20b0f4:	40 f6 c5 01          	test   bpl,0x1
  20b0f8:	0f 84 70 02 00 00    	je     20b36e <parseFormValue+0xdbe>
  20b0fe:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  20b105:	00 
            try self.readNoEof(bytes[0..]);
  20b106:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20b10b:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  20b112:	00 00 
  20b114:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20b119:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20b11e:	4c 89 e6             	mov    rsi,r12
  20b121:	41 ff 14 24          	call   QWORD PTR [r12]
  20b125:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20b12a:	66 85 c0             	test   ax,ax
  20b12d:	0f 85 7d 02 00 00    	jne    20b3b0 <parseFormValue+0xe00>
  20b133:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20b138:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20b13c:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20b141:	0f 82 69 02 00 00    	jb     20b3b0 <parseFormValue+0xe00>
  20b147:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  20b14e:	00 
  20b14f:	e9 02 0e 00 00       	jmp    20bf56 <parseFormValue+0x19a6>
  20b154:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  20b15b:	00 
  20b15c:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  20b161:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  20b168:	00 
            try self.readNoEof(result[0..]);
  20b169:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  20b16e:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  20b175:	00 00 
  20b177:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20b17c:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20b181:	4c 89 e6             	mov    rsi,r12
  20b184:	41 ff 14 24          	call   QWORD PTR [r12]
  20b188:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20b18d:	66 85 c0             	test   ax,ax
  20b190:	0f 84 45 07 00 00    	je     20b8db <parseFormValue+0x132b>
  20b196:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const size = try readULeb128(in_stream);
  20b19b:	66 89 01             	mov    WORD PTR [rcx],ax
  20b19e:	48 8b 84 24 8e 06 00 	mov    rax,QWORD PTR [rsp+0x68e]
  20b1a5:	00 
  20b1a6:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  20b1aa:	c5 fc 10 84 24 70 06 	vmovups ymm0,YMMWORD PTR [rsp+0x670]
  20b1b1:	00 00 
  20b1b3:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  20b1b8:	e9 0a 0e 00 00       	jmp    20bfc7 <parseFormValue+0x1a17>
  20b1bd:	48 8d 05 ec 5f ff ff 	lea    rax,[rip+0xffffffffffff5fec]        # 2011b0 <__unnamed_61>
  20b1c4:	e9 ed 0d 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20b1c9:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  20b1ce:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20b1d3:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  20b1da:	00 00 
  20b1dc:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20b1e1:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20b1e6:	4c 89 e6             	mov    rsi,r12
  20b1e9:	41 ff 14 24          	call   QWORD PTR [r12]
  20b1ed:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20b1f2:	66 85 c0             	test   ax,ax
  20b1f5:	75 14                	jne    20b20b <parseFormValue+0xc5b>
  20b1f7:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20b1fc:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20b200:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20b205:	0f 83 64 0a 00 00    	jae    20bc6f <parseFormValue+0x16bf>
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  20b20b:	66 41 89 06          	mov    WORD PTR [r14],ax
  20b20f:	48 8b 84 24 aa 05 00 	mov    rax,QWORD PTR [rsp+0x5aa]
  20b216:	00 
  20b217:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  20b21b:	c5 fc 10 84 24 8c 05 	vmovups ymm0,YMMWORD PTR [rsp+0x58c]
  20b222:	00 00 
  20b224:	e9 a0 01 00 00       	jmp    20b3c9 <parseFormValue+0xe19>
  20b229:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20b22e:	31 ed                	xor    ebp,ebp
  20b230:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  20b235:	45 31 ed             	xor    r13d,r13d
  20b238:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20b23f:	00 
  20b240:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20b245:	0f 82 11 07 00 00    	jb     20b95c <parseFormValue+0x13ac>
            return result[0];
  20b24b:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  20b252:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20b253:	89 c2                	mov    edx,eax
  20b255:	83 e2 7f             	and    edx,0x7f
  20b258:	44 89 ee             	mov    esi,r13d
  20b25b:	83 e6 3f             	and    esi,0x3f
  20b25e:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20b263:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20b268:	48 39 d6             	cmp    rsi,rdx
  20b26b:	0f 85 f4 06 00 00    	jne    20b965 <parseFormValue+0x13b5>
        result |= operand;
  20b271:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  20b274:	84 c0                	test   al,al
  20b276:	0f 89 5d 0a 00 00    	jns    20bcd9 <parseFormValue+0x1729>
        shift += 7;
  20b27c:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  20b280:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  20b285:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  20b28c:	00 00 
            return self.readFn(self, buffer);
  20b28e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20b293:	4c 89 e6             	mov    rsi,r12
  20b296:	4c 89 fa             	mov    rdx,r15
  20b299:	41 ff 14 24          	call   QWORD PTR [r12]
  20b29d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  20b2a2:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  20b2a7:	66 85 c0             	test   ax,ax
  20b2aa:	74 94                	je     20b240 <parseFormValue+0xc90>
  20b2ac:	e9 86 f3 ff ff       	jmp    20a637 <parseFormValue+0x87>
  20b2b1:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  20b2b6:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20b2bb:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  20b2c2:	00 00 
  20b2c4:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20b2c9:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20b2ce:	4c 89 e6             	mov    rsi,r12
  20b2d1:	41 ff 14 24          	call   QWORD PTR [r12]
  20b2d5:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20b2da:	66 85 c0             	test   ax,ax
  20b2dd:	75 14                	jne    20b2f3 <parseFormValue+0xd43>
  20b2df:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20b2e4:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20b2e8:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20b2ed:	0f 83 1e 0b 00 00    	jae    20be11 <parseFormValue+0x1861>
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  20b2f3:	66 41 89 06          	mov    WORD PTR [r14],ax
  20b2f7:	48 8b 84 24 5e 05 00 	mov    rax,QWORD PTR [rsp+0x55e]
  20b2fe:	00 
  20b2ff:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  20b303:	c5 fc 10 84 24 40 05 	vmovups ymm0,YMMWORD PTR [rsp+0x540]
  20b30a:	00 00 
  20b30c:	e9 b8 00 00 00       	jmp    20b3c9 <parseFormValue+0xe19>
  20b311:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  20b316:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20b31b:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  20b322:	00 00 
  20b324:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20b329:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20b32e:	4c 89 e6             	mov    rsi,r12
  20b331:	41 ff 14 24          	call   QWORD PTR [r12]
  20b335:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20b33a:	66 85 c0             	test   ax,ax
  20b33d:	75 14                	jne    20b353 <parseFormValue+0xda3>
  20b33f:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20b344:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20b348:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20b34d:	0f 83 4c 0b 00 00    	jae    20be9f <parseFormValue+0x18ef>
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  20b353:	66 41 89 06          	mov    WORD PTR [r14],ax
  20b357:	48 8b 84 24 d0 05 00 	mov    rax,QWORD PTR [rsp+0x5d0]
  20b35e:	00 
  20b35f:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  20b363:	c5 fc 10 84 24 b2 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5b2]
  20b36a:	00 00 
  20b36c:	eb 5b                	jmp    20b3c9 <parseFormValue+0xe19>
  20b36e:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  20b373:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20b378:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  20b37f:	00 00 
  20b381:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20b386:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20b38b:	4c 89 e6             	mov    rsi,r12
  20b38e:	41 ff 14 24          	call   QWORD PTR [r12]
  20b392:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  20b397:	66 85 c0             	test   ax,ax
  20b39a:	75 14                	jne    20b3b0 <parseFormValue+0xe00>
  20b39c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20b3a1:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20b3a5:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20b3aa:	0f 83 7d 0b 00 00    	jae    20bf2d <parseFormValue+0x197d>
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  20b3b0:	66 41 89 06          	mov    WORD PTR [r14],ax
  20b3b4:	48 8b 84 24 1c 06 00 	mov    rax,QWORD PTR [rsp+0x61c]
  20b3bb:	00 
  20b3bc:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  20b3c0:	c5 fc 10 84 24 fe 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5fe]
  20b3c7:	00 00 
  20b3c9:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  20b3cf:	e9 f3 0b 00 00       	jmp    20bfc7 <parseFormValue+0x1a17>
    return FormValue{
  20b3d4:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  20b3db:	00 
  20b3dc:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  20b3e1:	66 c7 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],0x0
  20b3e8:	00 00 00 
  20b3eb:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  20b3ef:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
        .Const = Constant{
  20b3f6:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  20b3fc:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  20b401:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  20b408:	00 
  20b409:	c5 f8 11 84 24 80 01 	vmovups XMMWORD PTR [rsp+0x180],xmm0
  20b410:	00 00 
  20b412:	c6 84 24 90 01 00 00 	mov    BYTE PTR [rsp+0x190],0x0
  20b419:	00 
  20b41a:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  20b421:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  20b428:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  20b42f:	00 
  20b430:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  20b437:	00 
  20b438:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  20b43f:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  20b446:	c6 84 24 98 01 00 00 	mov    BYTE PTR [rsp+0x198],0x2
  20b44d:	02 
  20b44e:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  20b452:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  20b459:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  20b45e:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  20b465:	00 
  20b466:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  20b46a:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  20b471:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  20b478:	00 
  20b479:	e9 38 0b 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20b47e:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  20b485:	00 
  20b486:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  20b48b:	66 c7 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],0x0
  20b492:	00 00 00 
  20b495:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  20b499:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
        .Const = Constant{
  20b4a0:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  20b4a6:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  20b4ab:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  20b4b2:	00 
  20b4b3:	c5 f8 11 84 24 58 01 	vmovups XMMWORD PTR [rsp+0x158],xmm0
  20b4ba:	00 00 
  20b4bc:	c6 84 24 68 01 00 00 	mov    BYTE PTR [rsp+0x168],0x0
  20b4c3:	00 
  20b4c4:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  20b4cb:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  20b4d2:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  20b4d9:	00 
  20b4da:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  20b4e1:	00 
  20b4e2:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  20b4e9:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  20b4f0:	c6 84 24 70 01 00 00 	mov    BYTE PTR [rsp+0x170],0x2
  20b4f7:	02 
  20b4f8:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  20b4fc:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  20b503:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  20b508:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  20b50f:	00 
  20b510:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  20b514:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  20b51b:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  20b522:	00 
  20b523:	e9 8e 0a 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20b528:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  20b52f:	00 
  20b530:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  20b535:	66 c7 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],0x0
  20b53c:	00 00 00 
  20b53f:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  20b543:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
        .Const = Constant{
  20b54a:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  20b550:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  20b555:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  20b55c:	00 
  20b55d:	c5 f8 11 84 24 30 01 	vmovups XMMWORD PTR [rsp+0x130],xmm0
  20b564:	00 00 
  20b566:	c6 84 24 40 01 00 00 	mov    BYTE PTR [rsp+0x140],0x0
  20b56d:	00 
  20b56e:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  20b575:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  20b57c:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  20b583:	00 
  20b584:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  20b58b:	00 
  20b58c:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  20b593:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  20b59a:	c6 84 24 48 01 00 00 	mov    BYTE PTR [rsp+0x148],0x2
  20b5a1:	02 
  20b5a2:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  20b5a6:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  20b5ad:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  20b5b2:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  20b5b9:	00 
  20b5ba:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  20b5be:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  20b5c5:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  20b5cc:	00 
  20b5cd:	e9 e4 09 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20b5d2:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  20b5d7:	45 31 ed             	xor    r13d,r13d
  20b5da:	48 8d 5c 24 18       	lea    rbx,[rsp+0x18]
  20b5df:	31 ed                	xor    ebp,ebp
  20b5e1:	48 3b 8c 24 98 00 00 	cmp    rcx,QWORD PTR [rsp+0x98]
  20b5e8:	00 
  20b5e9:	0f 82 90 07 00 00    	jb     20bd7f <parseFormValue+0x17cf>
            return result[0];
  20b5ef:	44 8a bc 24 b0 00 00 	mov    r15b,BYTE PTR [rsp+0xb0]
  20b5f6:	00 
        if (byte == 0) break;
  20b5f7:	45 84 ff             	test   r15b,r15b
  20b5fa:	0f 84 88 07 00 00    	je     20bd88 <parseFormValue+0x17d8>
            var better_capacity = self.items.len;
  20b600:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  20b605:	48 39 e9             	cmp    rcx,rbp
  20b608:	77 4f                	ja     20b659 <parseFormValue+0x10a9>
  20b60a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                better_capacity += better_capacity / 2 + 8;
  20b610:	48 89 c8             	mov    rax,rcx
  20b613:	48 d1 e8             	shr    rax,1
  20b616:	48 01 c1             	add    rcx,rax
  20b619:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20b61d:	48 39 e9             	cmp    rcx,rbp
  20b620:	76 ee                	jbe    20b610 <parseFormValue+0x1060>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20b622:	48 89 df             	mov    rdi,rbx
  20b625:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  20b62c:	00 
  20b62d:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  20b632:	e8 f9 46 00 00       	call   20fd30 <Allocator_alignedRealloc.54>
  20b637:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  20b63c:	66 85 c0             	test   ax,ax
  20b63f:	0f 85 08 f4 ff ff    	jne    20aa4d <parseFormValue+0x49d>
  20b645:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20b64a:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20b64e:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  20b654:	4c 8b 6c 24 40       	mov    r13,QWORD PTR [rsp+0x40]
  20b659:	4c 8d 75 01          	lea    r14,[rbp+0x1]
            self.len = new_length;
  20b65d:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  20b662:	45 88 7c 2d 00       	mov    BYTE PTR [r13+rbp*1+0x0],r15b
            try self.readNoEof(result[0..]);
  20b667:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  20b66e:	00 
  20b66f:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  20b676:	00 
  20b677:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  20b67e:	00 01 00 00 00 
            return self.readFn(self, buffer);
  20b683:	48 89 df             	mov    rdi,rbx
  20b686:	4c 89 e6             	mov    rsi,r12
  20b689:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  20b690:	00 
  20b691:	41 ff 14 24          	call   QWORD PTR [r12]
  20b695:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  20b69a:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  20b69f:	4c 89 f5             	mov    rbp,r14
            const amt_read = try self.read(buf);
  20b6a2:	66 85 c0             	test   ax,ax
  20b6a5:	0f 84 36 ff ff ff    	je     20b5e1 <parseFormValue+0x1031>
  20b6ab:	e9 9d f3 ff ff       	jmp    20aa4d <parseFormValue+0x49d>
  20b6b0:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20b6b5:	31 db                	xor    ebx,ebx
  20b6b7:	4c 8d 7c 24 40       	lea    r15,[rsp+0x40]
  20b6bc:	4c 8d 74 24 18       	lea    r14,[rsp+0x18]
  20b6c1:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  20b6c3:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20b6c8:	0f 82 1f 07 00 00    	jb     20bded <parseFormValue+0x183d>
            return result[0];
  20b6ce:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  20b6d5:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20b6d6:	89 c2                	mov    edx,eax
  20b6d8:	83 e2 7f             	and    edx,0x7f
  20b6db:	89 ee                	mov    esi,ebp
  20b6dd:	83 e6 3f             	and    esi,0x3f
  20b6e0:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20b6e5:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20b6ea:	48 39 d6             	cmp    rsi,rdx
  20b6ed:	0f 85 e9 08 00 00    	jne    20bfdc <parseFormValue+0x1a2c>
        result |= operand;
  20b6f3:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  20b6f6:	84 c0                	test   al,al
  20b6f8:	0f 89 02 09 00 00    	jns    20c000 <parseFormValue+0x1a50>
        shift += 7;
  20b6fe:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  20b702:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  20b707:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  20b70e:	00 00 
            return self.readFn(self, buffer);
  20b710:	4c 89 ff             	mov    rdi,r15
  20b713:	4c 89 e6             	mov    rsi,r12
  20b716:	4c 89 f2             	mov    rdx,r14
  20b719:	41 ff 14 24          	call   QWORD PTR [r12]
  20b71d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  20b722:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  20b727:	66 85 c0             	test   ax,ax
  20b72a:	74 97                	je     20b6c3 <parseFormValue+0x1113>
  20b72c:	e9 85 f3 ff ff       	jmp    20aab6 <parseFormValue+0x506>
    return FormValue{
  20b731:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  20b738:	00 
  20b739:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  20b73e:	66 c7 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],0x0
  20b745:	00 00 00 
  20b748:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  20b74c:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
        .Const = Constant{
  20b753:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  20b759:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  20b75e:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  20b765:	00 
  20b766:	c5 f8 11 84 24 a8 01 	vmovups XMMWORD PTR [rsp+0x1a8],xmm0
  20b76d:	00 00 
  20b76f:	c6 84 24 b8 01 00 00 	mov    BYTE PTR [rsp+0x1b8],0x0
  20b776:	00 
  20b777:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  20b77e:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  20b785:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  20b78c:	00 
  20b78d:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  20b794:	00 
  20b795:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  20b79c:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  20b7a3:	c6 84 24 c0 01 00 00 	mov    BYTE PTR [rsp+0x1c0],0x2
  20b7aa:	02 
  20b7ab:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  20b7af:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  20b7b6:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  20b7bb:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  20b7c2:	00 
  20b7c3:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  20b7c7:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  20b7ce:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  20b7d5:	00 
  20b7d6:	e9 db 07 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20b7db:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20b7e0:	31 db                	xor    ebx,ebx
  20b7e2:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  20b7e7:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  20b7ec:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  20b7ee:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20b7f3:	0f 82 fd 05 00 00    	jb     20bdf6 <parseFormValue+0x1846>
            return result[0];
  20b7f9:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  20b800:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20b801:	89 c2                	mov    edx,eax
  20b803:	83 e2 7f             	and    edx,0x7f
  20b806:	89 ee                	mov    esi,ebp
  20b808:	83 e6 3f             	and    esi,0x3f
  20b80b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20b810:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20b815:	48 39 d6             	cmp    rsi,rdx
  20b818:	0f 85 c7 07 00 00    	jne    20bfe5 <parseFormValue+0x1a35>
        result |= operand;
  20b81e:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  20b821:	84 c0                	test   al,al
  20b823:	0f 89 7d 08 00 00    	jns    20c0a6 <parseFormValue+0x1af6>
        shift += 7;
  20b829:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  20b82d:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  20b832:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  20b839:	00 00 
            return self.readFn(self, buffer);
  20b83b:	4c 89 ef             	mov    rdi,r13
  20b83e:	4c 89 e6             	mov    rsi,r12
  20b841:	4c 89 fa             	mov    rdx,r15
  20b844:	41 ff 14 24          	call   QWORD PTR [r12]
  20b848:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  20b84d:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  20b852:	66 85 c0             	test   ax,ax
  20b855:	74 97                	je     20b7ee <parseFormValue+0x123e>
  20b857:	e9 08 f8 ff ff       	jmp    20b064 <parseFormValue+0xab4>
  20b85c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20b861:	45 31 f6             	xor    r14d,r14d
  20b864:	4c 8d 6c 24 18       	lea    r13,[rsp+0x18]
  20b869:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  20b86b:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20b870:	0f 82 89 05 00 00    	jb     20bdff <parseFormValue+0x184f>
            return result[0];
  20b876:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  20b87d:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20b87e:	89 c2                	mov    edx,eax
  20b880:	83 e2 7f             	and    edx,0x7f
  20b883:	89 de                	mov    esi,ebx
  20b885:	83 e6 3f             	and    esi,0x3f
  20b888:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20b88d:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20b892:	48 39 d6             	cmp    rsi,rdx
  20b895:	0f 85 53 07 00 00    	jne    20bfee <parseFormValue+0x1a3e>
        result |= operand;
  20b89b:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  20b89e:	84 c0                	test   al,al
  20b8a0:	0f 89 a6 08 00 00    	jns    20c14c <parseFormValue+0x1b9c>
        shift += 7;
  20b8a6:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  20b8aa:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  20b8af:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  20b8b6:	00 00 
            return self.readFn(self, buffer);
  20b8b8:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  20b8bd:	4c 89 e6             	mov    rsi,r12
  20b8c0:	4c 89 ea             	mov    rdx,r13
  20b8c3:	41 ff 14 24          	call   QWORD PTR [r12]
  20b8c7:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  20b8cc:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  20b8d1:	66 85 c0             	test   ax,ax
  20b8d4:	74 95                	je     20b86b <parseFormValue+0x12bb>
  20b8d6:	e9 f2 f7 ff ff       	jmp    20b0cd <parseFormValue+0xb1d>
  20b8db:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20b8e0:	31 db                	xor    ebx,ebx
  20b8e2:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  20b8e7:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  20b8ec:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  20b8ee:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  20b8f3:	0f 82 0f 05 00 00    	jb     20be08 <parseFormValue+0x1858>
            return result[0];
  20b8f9:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  20b900:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20b901:	89 c2                	mov    edx,eax
  20b903:	83 e2 7f             	and    edx,0x7f
  20b906:	89 ee                	mov    esi,ebp
  20b908:	83 e6 3f             	and    esi,0x3f
  20b90b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20b910:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20b915:	48 39 d6             	cmp    rsi,rdx
  20b918:	0f 85 d9 06 00 00    	jne    20bff7 <parseFormValue+0x1a47>
        result |= operand;
  20b91e:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  20b921:	84 c0                	test   al,al
  20b923:	0f 89 65 08 00 00    	jns    20c18e <parseFormValue+0x1bde>
        shift += 7;
  20b929:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  20b92d:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  20b932:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  20b939:	00 00 
            return self.readFn(self, buffer);
  20b93b:	4c 89 ef             	mov    rdi,r13
  20b93e:	4c 89 e6             	mov    rsi,r12
  20b941:	4c 89 fa             	mov    rdx,r15
  20b944:	41 ff 14 24          	call   QWORD PTR [r12]
  20b948:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  20b94d:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  20b952:	66 85 c0             	test   ax,ax
  20b955:	74 97                	je     20b8ee <parseFormValue+0x133e>
  20b957:	e9 3a f8 ff ff       	jmp    20b196 <parseFormValue+0xbe6>
  20b95c:	66 b8 1e 00          	mov    ax,0x1e
  20b960:	e9 d2 ec ff ff       	jmp    20a637 <parseFormValue+0x87>
  20b965:	66 b8 23 00          	mov    ax,0x23
  20b969:	e9 c9 ec ff ff       	jmp    20a637 <parseFormValue+0x87>
  20b96e:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  20b973:	66 c7 84 24 08 04 00 	mov    WORD PTR [rsp+0x408],0x0
  20b97a:	00 00 00 
  20b97d:	48 89 84 24 10 04 00 	mov    QWORD PTR [rsp+0x410],rax
  20b984:	00 
  20b985:	c5 f8 10 84 24 08 05 	vmovups xmm0,XMMWORD PTR [rsp+0x508]
  20b98c:	00 00 
  20b98e:	c5 f8 11 84 24 18 04 	vmovups XMMWORD PTR [rsp+0x418],xmm0
  20b995:	00 00 
  20b997:	c6 84 24 28 04 00 00 	mov    BYTE PTR [rsp+0x428],0x0
  20b99e:	00 
  20b99f:	8b 84 24 11 03 00 00 	mov    eax,DWORD PTR [rsp+0x311]
  20b9a6:	89 84 24 29 04 00 00 	mov    DWORD PTR [rsp+0x429],eax
  20b9ad:	0f b7 84 24 15 03 00 	movzx  eax,WORD PTR [rsp+0x315]
  20b9b4:	00 
  20b9b5:	66 89 84 24 2d 04 00 	mov    WORD PTR [rsp+0x42d],ax
  20b9bc:	00 
  20b9bd:	8a 84 24 17 03 00 00 	mov    al,BYTE PTR [rsp+0x317]
  20b9c4:	88 84 24 2f 04 00 00 	mov    BYTE PTR [rsp+0x42f],al
  20b9cb:	48 8d 84 24 08 04 00 	lea    rax,[rsp+0x408]
  20b9d2:	00 
  20b9d3:	e9 de 05 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20b9d8:	48 85 c0             	test   rax,rax
            for (bytes) |b, index| {
  20b9db:	0f 84 00 08 00 00    	je     20c1e1 <parseFormValue+0x1c31>
  20b9e1:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  20b9e6:	48 83 f8 10          	cmp    rax,0x10
  20b9ea:	0f 83 cc 0b 00 00    	jae    20c5bc <parseFormValue+0x200c>
  20b9f0:	31 db                	xor    ebx,ebx
  20b9f2:	31 c9                	xor    ecx,ecx
  20b9f4:	e9 b7 11 00 00       	jmp    20cbb0 <parseFormValue+0x2600>
  20b9f9:	48 85 c0             	test   rax,rax
  20b9fc:	0f 84 e6 07 00 00    	je     20c1e8 <parseFormValue+0x1c38>
  20ba02:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  20ba07:	48 83 f8 10          	cmp    rax,0x10
  20ba0b:	0f 83 c9 0c 00 00    	jae    20c6da <parseFormValue+0x212a>
  20ba11:	31 db                	xor    ebx,ebx
  20ba13:	31 c9                	xor    ecx,ecx
  20ba15:	e9 77 13 00 00       	jmp    20cd91 <parseFormValue+0x27e1>
  20ba1a:	48 85 c0             	test   rax,rax
  20ba1d:	0f 84 cc 07 00 00    	je     20c1ef <parseFormValue+0x1c3f>
  20ba23:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  20ba28:	48 83 f8 10          	cmp    rax,0x10
  20ba2c:	0f 83 c6 0d 00 00    	jae    20c7f8 <parseFormValue+0x2248>
  20ba32:	31 db                	xor    ebx,ebx
  20ba34:	31 c9                	xor    ecx,ecx
  20ba36:	e9 37 15 00 00       	jmp    20cf72 <parseFormValue+0x29c2>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  20ba3b:	80 bc 24 b0 00 00 00 	cmp    BYTE PTR [rsp+0xb0],0x0
  20ba42:	00 
  20ba43:	0f 95 84 24 08 01 00 	setne  BYTE PTR [rsp+0x108]
  20ba4a:	00 
  20ba4b:	66 c7 84 24 18 03 00 	mov    WORD PTR [rsp+0x318],0x0
  20ba52:	00 00 00 
  20ba55:	0f 95 84 24 20 03 00 	setne  BYTE PTR [rsp+0x320]
  20ba5c:	00 
  20ba5d:	c5 f8 10 84 24 69 04 	vmovups xmm0,XMMWORD PTR [rsp+0x469]
  20ba64:	00 00 
  20ba66:	c5 f8 11 84 24 21 03 	vmovups XMMWORD PTR [rsp+0x321],xmm0
  20ba6d:	00 00 
  20ba6f:	48 8b 84 24 78 04 00 	mov    rax,QWORD PTR [rsp+0x478]
  20ba76:	00 
  20ba77:	48 89 84 24 30 03 00 	mov    QWORD PTR [rsp+0x330],rax
  20ba7e:	00 
  20ba7f:	c6 84 24 38 03 00 00 	mov    BYTE PTR [rsp+0x338],0x4
  20ba86:	04 
  20ba87:	8b 84 24 03 03 00 00 	mov    eax,DWORD PTR [rsp+0x303]
  20ba8e:	89 84 24 39 03 00 00 	mov    DWORD PTR [rsp+0x339],eax
  20ba95:	0f b7 84 24 07 03 00 	movzx  eax,WORD PTR [rsp+0x307]
  20ba9c:	00 
  20ba9d:	66 89 84 24 3d 03 00 	mov    WORD PTR [rsp+0x33d],ax
  20baa4:	00 
  20baa5:	8a 84 24 09 03 00 00 	mov    al,BYTE PTR [rsp+0x309]
  20baac:	88 84 24 3f 03 00 00 	mov    BYTE PTR [rsp+0x33f],al
  20bab3:	48 8d 84 24 18 03 00 	lea    rax,[rsp+0x318]
  20baba:	00 
  20babb:	e9 f6 04 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
            return mem.readInt(bytes, T, endian);
  20bac0:	0f b6 8c 24 b0 00 00 	movzx  ecx,BYTE PTR [rsp+0xb0]
  20bac7:	00 
  20bac8:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  20bacd:	4c 89 fe             	mov    rsi,r15
  20bad0:	4c 89 e2             	mov    rdx,r12
  20bad3:	e8 68 18 00 00       	call   20d340 <readAllocBytes>
  20bad8:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  20badd:	66 85 c0             	test   ax,ax
  20bae0:	0f 84 10 07 00 00    	je     20c1f6 <parseFormValue+0x1c46>
  20bae6:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  20baec:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  20baf2:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  20baf9:	00 00 
  20bafb:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20bb02:	00 00 
  20bb04:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  20bb08:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20bb0b:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  20bb10:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20bb15:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  20bb19:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  20bb1d:	e9 39 07 00 00       	jmp    20c25b <parseFormValue+0x1cab>
  20bb22:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20bb27:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  20bb2c:	48 c1 e1 08          	shl    rcx,0x8
  20bb30:	48 09 c1             	or     rcx,rax
  20bb33:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  20bb38:	4c 89 fe             	mov    rsi,r15
  20bb3b:	4c 89 e2             	mov    rdx,r12
  20bb3e:	e8 fd 17 00 00       	call   20d340 <readAllocBytes>
  20bb43:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  20bb48:	66 85 c0             	test   ax,ax
  20bb4b:	0f 84 5d 07 00 00    	je     20c2ae <parseFormValue+0x1cfe>
  20bb51:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  20bb57:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  20bb5d:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  20bb64:	00 00 
  20bb66:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20bb6d:	00 00 
  20bb6f:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  20bb73:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20bb76:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  20bb7b:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20bb80:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  20bb84:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  20bb88:	e9 86 07 00 00       	jmp    20c313 <parseFormValue+0x1d63>
  20bb8d:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  20bb92:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  20bb97:	48 c1 e1 08          	shl    rcx,0x8
  20bb9b:	48 09 c1             	or     rcx,rax
  20bb9e:	0f b6 44 24 7a       	movzx  eax,BYTE PTR [rsp+0x7a]
  20bba3:	48 c1 e0 10          	shl    rax,0x10
  20bba7:	48 09 c8             	or     rax,rcx
  20bbaa:	0f b6 4c 24 7b       	movzx  ecx,BYTE PTR [rsp+0x7b]
  20bbaf:	48 c1 e1 18          	shl    rcx,0x18
  20bbb3:	48 09 c1             	or     rcx,rax
  20bbb6:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  20bbbb:	4c 89 fe             	mov    rsi,r15
  20bbbe:	4c 89 e2             	mov    rdx,r12
  20bbc1:	e8 7a 17 00 00       	call   20d340 <readAllocBytes>
  20bbc6:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  20bbcb:	66 85 c0             	test   ax,ax
  20bbce:	0f 84 92 07 00 00    	je     20c366 <parseFormValue+0x1db6>
  20bbd4:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  20bbda:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  20bbe0:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  20bbe7:	00 00 
  20bbe9:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20bbf0:	00 00 
  20bbf2:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  20bbf6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20bbf9:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  20bbfe:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20bc03:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  20bc07:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  20bc0b:	e9 bb 07 00 00       	jmp    20c3cb <parseFormValue+0x1e1b>
  20bc10:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  20bc15:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  20bc1a:	4c 89 fe             	mov    rsi,r15
  20bc1d:	4c 89 e2             	mov    rdx,r12
  20bc20:	e8 1b 17 00 00       	call   20d340 <readAllocBytes>
  20bc25:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  20bc2a:	66 85 c0             	test   ax,ax
  20bc2d:	0f 84 eb 07 00 00    	je     20c41e <parseFormValue+0x1e6e>
  20bc33:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  20bc39:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  20bc3f:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  20bc46:	00 00 
  20bc48:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20bc4f:	00 00 
  20bc51:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  20bc55:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20bc58:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  20bc5d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20bc62:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  20bc66:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  20bc6a:	e9 14 08 00 00       	jmp    20c483 <parseFormValue+0x1ed3>
  20bc6f:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  20bc74:	66 c7 84 24 90 03 00 	mov    WORD PTR [rsp+0x390],0x0
  20bc7b:	00 00 00 
  20bc7e:	48 89 84 24 98 03 00 	mov    QWORD PTR [rsp+0x398],rax
  20bc85:	00 
  20bc86:	c5 f8 10 84 24 d8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4d8]
  20bc8d:	00 00 
  20bc8f:	c5 f8 11 84 24 a0 03 	vmovups XMMWORD PTR [rsp+0x3a0],xmm0
  20bc96:	00 00 
  20bc98:	c6 84 24 b0 03 00 00 	mov    BYTE PTR [rsp+0x3b0],0x8
  20bc9f:	08 
  20bca0:	8b 84 24 ee 02 00 00 	mov    eax,DWORD PTR [rsp+0x2ee]
  20bca7:	89 84 24 b1 03 00 00 	mov    DWORD PTR [rsp+0x3b1],eax
  20bcae:	0f b7 84 24 f2 02 00 	movzx  eax,WORD PTR [rsp+0x2f2]
  20bcb5:	00 
  20bcb6:	66 89 84 24 b5 03 00 	mov    WORD PTR [rsp+0x3b5],ax
  20bcbd:	00 
  20bcbe:	8a 84 24 f4 02 00 00 	mov    al,BYTE PTR [rsp+0x2f4]
  20bcc5:	88 84 24 b7 03 00 00 	mov    BYTE PTR [rsp+0x3b7],al
  20bccc:	48 8d 84 24 90 03 00 	lea    rax,[rsp+0x390]
  20bcd3:	00 
  20bcd4:	e9 dd 02 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20bcd9:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  20bcde:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  20bce5:	00 
  20bce6:	4c 89 e2             	mov    rdx,r12
  20bce9:	48 89 e9             	mov    rcx,rbp
  20bcec:	e8 4f 16 00 00       	call   20d340 <readAllocBytes>
  20bcf1:	0f b7 54 24 40       	movzx  edx,WORD PTR [rsp+0x40]
  20bcf6:	66 85 d2             	test   dx,dx
  20bcf9:	48 8b 6c 24 68       	mov    rbp,QWORD PTR [rsp+0x68]
  20bcfe:	0f 84 d2 07 00 00    	je     20c4d6 <parseFormValue+0x1f26>
  20bd04:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20bd09:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  20bd10:	00 
  20bd11:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20bd15:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
  20bd1c:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20bd20:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  20bd27:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20bd2c:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  20bd33:	00 
  20bd34:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20bd38:	88 84 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],al
  20bd3f:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  20bd46:	00 
  20bd47:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20bd4b:	89 84 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],eax
  20bd52:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  20bd59:	00 
  20bd5a:	0f b7 4c 24 0e       	movzx  ecx,WORD PTR [rsp+0xe]
  20bd5f:	66 89 8c 24 ec 00 00 	mov    WORD PTR [rsp+0xec],cx
  20bd66:	00 
  20bd67:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  20bd6e:	00 
  20bd6f:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  20bd73:	88 9c 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],bl
  20bd7a:	e9 f5 07 00 00       	jmp    20c574 <parseFormValue+0x1fc4>
  20bd7f:	66 b8 1e 00          	mov    ax,0x1e
  20bd83:	e9 c5 ec ff ff       	jmp    20aa4d <parseFormValue+0x49d>
            return self.items[0..self.len];
  20bd88:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  20bd8d:	66 c7 84 24 68 03 00 	mov    WORD PTR [rsp+0x368],0x0
  20bd94:	00 00 00 
  20bd97:	48 89 84 24 70 03 00 	mov    QWORD PTR [rsp+0x370],rax
  20bd9e:	00 
  20bd9f:	48 89 ac 24 78 03 00 	mov    QWORD PTR [rsp+0x378],rbp
  20bda6:	00 
  20bda7:	c6 84 24 88 03 00 00 	mov    BYTE PTR [rsp+0x388],0x9
  20bdae:	09 
  20bdaf:	8b 84 24 e7 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e7]
  20bdb6:	89 84 24 89 03 00 00 	mov    DWORD PTR [rsp+0x389],eax
  20bdbd:	0f b7 84 24 eb 02 00 	movzx  eax,WORD PTR [rsp+0x2eb]
  20bdc4:	00 
  20bdc5:	66 89 84 24 8d 03 00 	mov    WORD PTR [rsp+0x38d],ax
  20bdcc:	00 
  20bdcd:	8a 84 24 ed 02 00 00 	mov    al,BYTE PTR [rsp+0x2ed]
  20bdd4:	88 84 24 8f 03 00 00 	mov    BYTE PTR [rsp+0x38f],al
  20bddb:	48 8d 84 24 68 03 00 	lea    rax,[rsp+0x368]
  20bde2:	00 
  20bde3:	4c 8b 74 24 68       	mov    r14,QWORD PTR [rsp+0x68]
  20bde8:	e9 c9 01 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20bded:	66 b8 1e 00          	mov    ax,0x1e
  20bdf1:	e9 c0 ec ff ff       	jmp    20aab6 <parseFormValue+0x506>
  20bdf6:	66 b8 1e 00          	mov    ax,0x1e
  20bdfa:	e9 65 f2 ff ff       	jmp    20b064 <parseFormValue+0xab4>
  20bdff:	66 b8 1e 00          	mov    ax,0x1e
  20be03:	e9 c5 f2 ff ff       	jmp    20b0cd <parseFormValue+0xb1d>
  20be08:	66 b8 1e 00          	mov    ax,0x1e
  20be0c:	e9 85 f3 ff ff       	jmp    20b196 <parseFormValue+0xbe6>
  20be11:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  20be16:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  20be1b:	48 c1 e1 08          	shl    rcx,0x8
  20be1f:	48 09 c1             	or     rcx,rax
  20be22:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  20be27:	48 c1 e2 10          	shl    rdx,0x10
  20be2b:	48 09 ca             	or     rdx,rcx
  20be2e:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  20be33:	48 c1 e0 18          	shl    rax,0x18
  20be37:	48 09 d0             	or     rax,rdx
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  20be3a:	66 c7 84 24 40 03 00 	mov    WORD PTR [rsp+0x340],0x0
  20be41:	00 00 00 
  20be44:	48 89 84 24 48 03 00 	mov    QWORD PTR [rsp+0x348],rax
  20be4b:	00 
  20be4c:	c5 f8 10 84 24 c8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4c8]
  20be53:	00 00 
  20be55:	c5 f8 11 84 24 50 03 	vmovups XMMWORD PTR [rsp+0x350],xmm0
  20be5c:	00 00 
  20be5e:	c6 84 24 60 03 00 00 	mov    BYTE PTR [rsp+0x360],0xa
  20be65:	0a 
  20be66:	8b 84 24 e0 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e0]
  20be6d:	89 84 24 61 03 00 00 	mov    DWORD PTR [rsp+0x361],eax
  20be74:	0f b7 84 24 e4 02 00 	movzx  eax,WORD PTR [rsp+0x2e4]
  20be7b:	00 
  20be7c:	66 89 84 24 65 03 00 	mov    WORD PTR [rsp+0x365],ax
  20be83:	00 
  20be84:	8a 84 24 e6 02 00 00 	mov    al,BYTE PTR [rsp+0x2e6]
  20be8b:	88 84 24 67 03 00 00 	mov    BYTE PTR [rsp+0x367],al
  20be92:	48 8d 84 24 40 03 00 	lea    rax,[rsp+0x340]
  20be99:	00 
  20be9a:	e9 17 01 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20be9f:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  20bea4:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  20bea9:	48 c1 e1 08          	shl    rcx,0x8
  20bead:	48 09 c1             	or     rcx,rax
  20beb0:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  20beb5:	48 c1 e2 10          	shl    rdx,0x10
  20beb9:	48 09 ca             	or     rdx,rcx
  20bebc:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  20bec1:	48 c1 e0 18          	shl    rax,0x18
  20bec5:	48 09 d0             	or     rax,rdx
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  20bec8:	66 c7 84 24 b8 03 00 	mov    WORD PTR [rsp+0x3b8],0x0
  20becf:	00 00 00 
  20bed2:	48 89 84 24 c0 03 00 	mov    QWORD PTR [rsp+0x3c0],rax
  20bed9:	00 
  20beda:	c5 f8 10 84 24 e8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4e8]
  20bee1:	00 00 
  20bee3:	c5 f8 11 84 24 c8 03 	vmovups XMMWORD PTR [rsp+0x3c8],xmm0
  20beea:	00 00 
  20beec:	c6 84 24 d8 03 00 00 	mov    BYTE PTR [rsp+0x3d8],0x7
  20bef3:	07 
  20bef4:	8b 84 24 f5 02 00 00 	mov    eax,DWORD PTR [rsp+0x2f5]
  20befb:	89 84 24 d9 03 00 00 	mov    DWORD PTR [rsp+0x3d9],eax
  20bf02:	0f b7 84 24 f9 02 00 	movzx  eax,WORD PTR [rsp+0x2f9]
  20bf09:	00 
  20bf0a:	66 89 84 24 dd 03 00 	mov    WORD PTR [rsp+0x3dd],ax
  20bf11:	00 
  20bf12:	8a 84 24 fb 02 00 00 	mov    al,BYTE PTR [rsp+0x2fb]
  20bf19:	88 84 24 df 03 00 00 	mov    BYTE PTR [rsp+0x3df],al
  20bf20:	48 8d 84 24 b8 03 00 	lea    rax,[rsp+0x3b8]
  20bf27:	00 
  20bf28:	e9 89 00 00 00       	jmp    20bfb6 <parseFormValue+0x1a06>
  20bf2d:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  20bf32:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  20bf37:	48 c1 e1 08          	shl    rcx,0x8
  20bf3b:	48 09 c1             	or     rcx,rax
  20bf3e:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  20bf43:	48 c1 e2 10          	shl    rdx,0x10
  20bf47:	48 09 ca             	or     rdx,rcx
  20bf4a:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  20bf4f:	48 c1 e0 18          	shl    rax,0x18
  20bf53:	48 09 d0             	or     rax,rdx
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  20bf56:	66 c7 84 24 e0 03 00 	mov    WORD PTR [rsp+0x3e0],0x0
  20bf5d:	00 00 00 
  20bf60:	48 89 84 24 e8 03 00 	mov    QWORD PTR [rsp+0x3e8],rax
  20bf67:	00 
  20bf68:	c5 f8 10 84 24 f8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4f8]
  20bf6f:	00 00 
  20bf71:	c5 f8 11 84 24 f0 03 	vmovups XMMWORD PTR [rsp+0x3f0],xmm0
  20bf78:	00 00 
  20bf7a:	c6 84 24 00 04 00 00 	mov    BYTE PTR [rsp+0x400],0x5
  20bf81:	05 
  20bf82:	8b 84 24 fc 02 00 00 	mov    eax,DWORD PTR [rsp+0x2fc]
  20bf89:	89 84 24 01 04 00 00 	mov    DWORD PTR [rsp+0x401],eax
  20bf90:	0f b7 84 24 00 03 00 	movzx  eax,WORD PTR [rsp+0x300]
  20bf97:	00 
  20bf98:	66 89 84 24 05 04 00 	mov    WORD PTR [rsp+0x405],ax
  20bf9f:	00 
  20bfa0:	8a 84 24 02 03 00 00 	mov    al,BYTE PTR [rsp+0x302]
  20bfa7:	88 84 24 07 04 00 00 	mov    BYTE PTR [rsp+0x407],al
  20bfae:	48 8d 84 24 e0 03 00 	lea    rax,[rsp+0x3e0]
  20bfb5:	00 
    return switch (form_id) {
  20bfb6:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
  20bfba:	49 89 4e 20          	mov    QWORD PTR [r14+0x20],rcx
  20bfbe:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  20bfc2:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  20bfc7:	48 81 c4 08 07 00 00 	add    rsp,0x708
  20bfce:	5b                   	pop    rbx
  20bfcf:	41 5c                	pop    r12
  20bfd1:	41 5d                	pop    r13
  20bfd3:	41 5e                	pop    r14
  20bfd5:	41 5f                	pop    r15
  20bfd7:	5d                   	pop    rbp
  20bfd8:	c5 f8 77             	vzeroupper 
  20bfdb:	c3                   	ret    
  20bfdc:	66 b8 23 00          	mov    ax,0x23
  20bfe0:	e9 d1 ea ff ff       	jmp    20aab6 <parseFormValue+0x506>
  20bfe5:	66 b8 23 00          	mov    ax,0x23
  20bfe9:	e9 76 f0 ff ff       	jmp    20b064 <parseFormValue+0xab4>
  20bfee:	66 b8 23 00          	mov    ax,0x23
  20bff2:	e9 d6 f0 ff ff       	jmp    20b0cd <parseFormValue+0xb1d>
  20bff7:	66 b8 23 00          	mov    ax,0x23
  20bffb:	e9 96 f1 ff ff       	jmp    20b196 <parseFormValue+0xbe6>
  20c000:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  20c005:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  20c00c:	00 
  20c00d:	4c 89 e2             	mov    rdx,r12
  20c010:	48 89 d9             	mov    rcx,rbx
  20c013:	e8 28 13 00 00       	call   20d340 <readAllocBytes>
  20c018:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  20c01d:	66 85 c9             	test   cx,cx
  20c020:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  20c025:	0f 84 eb 08 00 00    	je     20c916 <parseFormValue+0x2366>
  20c02b:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20c030:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  20c037:	00 
  20c038:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20c03c:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  20c043:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20c047:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  20c04e:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20c053:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  20c05a:	00 
  20c05b:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20c05f:	88 84 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],al
  20c066:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  20c06d:	00 
  20c06e:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20c072:	89 84 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],eax
  20c079:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  20c080:	00 
  20c081:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  20c086:	66 89 94 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],dx
  20c08d:	00 
  20c08e:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  20c095:	00 
  20c096:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  20c09a:	88 9c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],bl
  20c0a1:	e9 a1 00 00 00       	jmp    20c147 <parseFormValue+0x1b97>
  20c0a6:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  20c0ab:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  20c0b2:	00 
  20c0b3:	4c 89 e2             	mov    rdx,r12
  20c0b6:	48 89 d9             	mov    rcx,rbx
  20c0b9:	e8 82 12 00 00       	call   20d340 <readAllocBytes>
  20c0be:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  20c0c3:	66 85 c9             	test   cx,cx
  20c0c6:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  20c0cb:	0f 84 d9 08 00 00    	je     20c9aa <parseFormValue+0x23fa>
  20c0d1:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20c0d6:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  20c0dd:	00 
  20c0de:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  20c0e2:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  20c0e9:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  20c0ed:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  20c0f4:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  20c0f9:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  20c100:	00 
  20c101:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  20c105:	88 84 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],al
  20c10c:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  20c113:	00 
  20c114:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  20c118:	89 84 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],eax
  20c11f:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  20c126:	00 
  20c127:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  20c12c:	66 89 94 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],dx
  20c133:	00 
  20c134:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  20c13b:	00 
  20c13c:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  20c140:	88 9c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],bl
  20c147:	e9 ef 08 00 00       	jmp    20ca3b <parseFormValue+0x248b>
            return parseFormValue(allocator, in_stream, child_form_id, is_64);
  20c14c:	44 0f b6 c5          	movzx  r8d,bpl
  20c150:	48 8d bc 24 a0 04 00 	lea    rdi,[rsp+0x4a0]
  20c157:	00 
  20c158:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  20c15f:	00 
  20c160:	4c 89 e2             	mov    rdx,r12
  20c163:	4c 89 f1             	mov    rcx,r14
  20c166:	e8 45 e4 ff ff       	call   20a5b0 <parseFormValue>
  20c16b:	48 8b 84 24 c0 04 00 	mov    rax,QWORD PTR [rsp+0x4c0]
  20c172:	00 
  20c173:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  20c178:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  20c17c:	c5 fc 10 84 24 a0 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4a0]
  20c183:	00 00 
  20c185:	c5 fc 11 01          	vmovups YMMWORD PTR [rcx],ymm0
  20c189:	e9 39 fe ff ff       	jmp    20bfc7 <parseFormValue+0x1a17>
  20c18e:	48 8d bc 24 50 04 00 	lea    rdi,[rsp+0x450]
  20c195:	00 
            const buf = try readAllocBytes(allocator, in_stream, size);
  20c196:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  20c19d:	00 
  20c19e:	4c 89 e2             	mov    rdx,r12
  20c1a1:	48 89 d9             	mov    rcx,rbx
  20c1a4:	e8 97 11 00 00       	call   20d340 <readAllocBytes>
  20c1a9:	0f b7 84 24 50 04 00 	movzx  eax,WORD PTR [rsp+0x450]
  20c1b0:	00 
  20c1b1:	66 85 c0             	test   ax,ax
  20c1b4:	0f 84 c4 08 00 00    	je     20ca7e <parseFormValue+0x24ce>
  20c1ba:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  20c1bf:	66 89 01             	mov    WORD PTR [rcx],ax
  20c1c2:	48 8b 84 24 68 06 00 	mov    rax,QWORD PTR [rsp+0x668]
  20c1c9:	00 
  20c1ca:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  20c1ce:	c5 fc 10 84 24 4a 06 	vmovups ymm0,YMMWORD PTR [rsp+0x64a]
  20c1d5:	00 00 
  20c1d7:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  20c1dc:	e9 e6 fd ff ff       	jmp    20bfc7 <parseFormValue+0x1a17>
  20c1e1:	31 c9                	xor    ecx,ecx
  20c1e3:	e9 f1 09 00 00       	jmp    20cbd9 <parseFormValue+0x2629>
  20c1e8:	31 c9                	xor    ecx,ecx
  20c1ea:	e9 cb 0b 00 00       	jmp    20cdba <parseFormValue+0x280a>
  20c1ef:	31 c9                	xor    ecx,ecx
  20c1f1:	e9 a5 0d 00 00       	jmp    20cf9b <parseFormValue+0x29eb>
    const buf = try readAllocBytes(allocator, in_stream, size);
  20c1f6:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  20c1fd:	00 00 
  20c1ff:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  20c206:	00 00 
    return FormValue{ .Ref = buf };
  20c208:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  20c20e:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  20c215:	00 
  20c216:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  20c21b:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  20c220:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  20c224:	89 04 24             	mov    DWORD PTR [rsp],eax
  20c227:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  20c22c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20c231:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  20c235:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  20c239:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  20c23f:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20c246:	00 00 
  20c248:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  20c24e:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  20c255:	00 00 
  20c257:	b1 06                	mov    cl,0x6
  20c259:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  20c25b:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  20c262:	00 
  20c263:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  20c26a:	00 00 
  20c26c:	c5 f8 11 84 24 42 02 	vmovups XMMWORD PTR [rsp+0x242],xmm0
  20c273:	00 00 
  20c275:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  20c27c:	00 00 
  20c27e:	c5 f8 11 84 24 50 02 	vmovups XMMWORD PTR [rsp+0x250],xmm0
  20c285:	00 00 
  20c287:	88 8c 24 60 02 00 00 	mov    BYTE PTR [rsp+0x260],cl
  20c28e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  20c291:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  20c298:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  20c29d:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  20c2a4:	00 
  20c2a5:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  20c2a9:	e9 41 eb ff ff       	jmp    20adef <parseFormValue+0x83f>
    const buf = try readAllocBytes(allocator, in_stream, size);
  20c2ae:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  20c2b5:	00 00 
  20c2b7:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  20c2be:	00 00 
    return FormValue{ .Ref = buf };
  20c2c0:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  20c2c6:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  20c2cd:	00 
  20c2ce:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  20c2d3:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  20c2d8:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  20c2dc:	89 04 24             	mov    DWORD PTR [rsp],eax
  20c2df:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  20c2e4:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20c2e9:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  20c2ed:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  20c2f1:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  20c2f7:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20c2fe:	00 00 
  20c300:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  20c306:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  20c30d:	00 00 
  20c30f:	b1 06                	mov    cl,0x6
  20c311:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  20c313:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  20c31a:	00 
  20c31b:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  20c322:	00 00 
  20c324:	c5 f8 11 84 24 1a 02 	vmovups XMMWORD PTR [rsp+0x21a],xmm0
  20c32b:	00 00 
  20c32d:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  20c334:	00 00 
  20c336:	c5 f8 11 84 24 28 02 	vmovups XMMWORD PTR [rsp+0x228],xmm0
  20c33d:	00 00 
  20c33f:	88 8c 24 38 02 00 00 	mov    BYTE PTR [rsp+0x238],cl
  20c346:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  20c349:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  20c350:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  20c355:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  20c35c:	00 
  20c35d:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  20c361:	e9 3e eb ff ff       	jmp    20aea4 <parseFormValue+0x8f4>
    const buf = try readAllocBytes(allocator, in_stream, size);
  20c366:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  20c36d:	00 00 
  20c36f:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  20c376:	00 00 
    return FormValue{ .Ref = buf };
  20c378:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  20c37e:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  20c385:	00 
  20c386:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  20c38b:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  20c390:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  20c394:	89 04 24             	mov    DWORD PTR [rsp],eax
  20c397:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  20c39c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20c3a1:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  20c3a5:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  20c3a9:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  20c3af:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20c3b6:	00 00 
  20c3b8:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  20c3be:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  20c3c5:	00 00 
  20c3c7:	b1 06                	mov    cl,0x6
  20c3c9:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  20c3cb:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  20c3d2:	00 
  20c3d3:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  20c3da:	00 00 
  20c3dc:	c5 f8 11 84 24 f2 01 	vmovups XMMWORD PTR [rsp+0x1f2],xmm0
  20c3e3:	00 00 
  20c3e5:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  20c3ec:	00 00 
  20c3ee:	c5 f8 11 84 24 00 02 	vmovups XMMWORD PTR [rsp+0x200],xmm0
  20c3f5:	00 00 
  20c3f7:	88 8c 24 10 02 00 00 	mov    BYTE PTR [rsp+0x210],cl
  20c3fe:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  20c401:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  20c408:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  20c40d:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  20c414:	00 
  20c415:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  20c419:	e9 3b eb ff ff       	jmp    20af59 <parseFormValue+0x9a9>
    const buf = try readAllocBytes(allocator, in_stream, size);
  20c41e:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  20c425:	00 00 
  20c427:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  20c42e:	00 00 
    return FormValue{ .Ref = buf };
  20c430:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  20c436:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  20c43d:	00 
  20c43e:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  20c443:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  20c448:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  20c44c:	89 04 24             	mov    DWORD PTR [rsp],eax
  20c44f:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  20c454:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20c459:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  20c45d:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  20c461:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  20c467:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20c46e:	00 00 
  20c470:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  20c476:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  20c47d:	00 00 
  20c47f:	b1 06                	mov    cl,0x6
  20c481:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  20c483:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  20c48a:	00 
  20c48b:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  20c492:	00 00 
  20c494:	c5 f8 11 84 24 ca 01 	vmovups XMMWORD PTR [rsp+0x1ca],xmm0
  20c49b:	00 00 
  20c49d:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  20c4a4:	00 00 
  20c4a6:	c5 f8 11 84 24 d8 01 	vmovups XMMWORD PTR [rsp+0x1d8],xmm0
  20c4ad:	00 00 
  20c4af:	88 8c 24 e8 01 00 00 	mov    BYTE PTR [rsp+0x1e8],cl
  20c4b6:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  20c4b9:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  20c4c0:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  20c4c5:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  20c4cc:	00 
  20c4cd:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  20c4d1:	e9 38 eb ff ff       	jmp    20b00e <parseFormValue+0xa5e>
            const signed = form_id == DW.FORM_sdata;
  20c4d6:	48 83 fb 0d          	cmp    rbx,0xd
    return FormValue{
  20c4da:	0f 94 84 24 b0 00 00 	sete   BYTE PTR [rsp+0xb0]
  20c4e1:	00 
  20c4e2:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  20c4e7:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  20c4eb:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
            const signed = form_id == DW.FORM_sdata;
  20c4f2:	40 0f 94 c7          	sete   dil
    return FormValue{
  20c4f6:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  20c4fb:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  20c502:	00 
        .Const = Constant{
  20c503:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  20c509:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  20c510:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  20c517:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  20c51e:	00 
  20c51f:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  20c526:	00 
  20c527:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  20c52e:	00 
  20c52f:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  20c536:	00 
  20c537:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  20c53e:	88 8c 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],cl
  20c545:	b3 02                	mov    bl,0x2
  20c547:	8b 4c 24 18          	mov    ecx,DWORD PTR [rsp+0x18]
  20c54b:	89 8c 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],ecx
  20c552:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  20c559:	00 
  20c55a:	0f b7 54 24 1c       	movzx  edx,WORD PTR [rsp+0x1c]
  20c55f:	66 89 94 24 ec 00 00 	mov    WORD PTR [rsp+0xec],dx
  20c566:	00 
  20c567:	8a 54 24 1e          	mov    dl,BYTE PTR [rsp+0x1e]
  20c56b:	88 94 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],dl
  20c572:	31 d2                	xor    edx,edx
            return parseFormValueConstant(allocator, in_stream, signed, block_len);
  20c574:	66 89 55 00          	mov    WORD PTR [rbp+0x0],dx
  20c578:	0f b7 56 04          	movzx  edx,WORD PTR [rsi+0x4]
  20c57c:	66 89 55 06          	mov    WORD PTR [rbp+0x6],dx
  20c580:	8b 16                	mov    edx,DWORD PTR [rsi]
  20c582:	89 55 02             	mov    DWORD PTR [rbp+0x2],edx
  20c585:	c5 f8 11 45 08       	vmovups XMMWORD PTR [rbp+0x8],xmm0
  20c58a:	40 88 7d 18          	mov    BYTE PTR [rbp+0x18],dil
  20c58e:	8a 50 06             	mov    dl,BYTE PTR [rax+0x6]
  20c591:	88 55 1f             	mov    BYTE PTR [rbp+0x1f],dl
  20c594:	0f b7 50 04          	movzx  edx,WORD PTR [rax+0x4]
  20c598:	66 89 55 1d          	mov    WORD PTR [rbp+0x1d],dx
  20c59c:	8b 00                	mov    eax,DWORD PTR [rax]
  20c59e:	89 45 19             	mov    DWORD PTR [rbp+0x19],eax
  20c5a1:	88 5d 20             	mov    BYTE PTR [rbp+0x20],bl
  20c5a4:	0f b7 41 04          	movzx  eax,WORD PTR [rcx+0x4]
  20c5a8:	66 89 45 25          	mov    WORD PTR [rbp+0x25],ax
  20c5ac:	8b 01                	mov    eax,DWORD PTR [rcx]
  20c5ae:	89 45 21             	mov    DWORD PTR [rbp+0x21],eax
  20c5b1:	8a 41 06             	mov    al,BYTE PTR [rcx+0x6]
  20c5b4:	88 45 27             	mov    BYTE PTR [rbp+0x27],al
  20c5b7:	e9 0b fa ff ff       	jmp    20bfc7 <parseFormValue+0x1a17>
            for (bytes) |b, index| {
  20c5bc:	48 89 c3             	mov    rbx,rax
  20c5bf:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  20c5c3:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  20c5c7:	48 89 e9             	mov    rcx,rbp
  20c5ca:	48 c1 e9 04          	shr    rcx,0x4
  20c5ce:	8d 79 01             	lea    edi,[rcx+0x1]
  20c5d1:	83 e7 01             	and    edi,0x1
  20c5d4:	48 85 ed             	test   rbp,rbp
  20c5d7:	0f 84 29 05 00 00    	je     20cb06 <parseFormValue+0x2556>
  20c5dd:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  20c5e1:	48 29 cd             	sub    rbp,rcx
  20c5e4:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20c5e8:	c5 fd 6f 0d b0 3b ff 	vmovdqa ymm1,YMMWORD PTR [rip+0xffffffffffff3bb0]        # 2001a0 <app_mask-0x80>
  20c5ef:	ff 
  20c5f0:	31 c9                	xor    ecx,ecx
  20c5f2:	c4 e2 7d 59 2d 0d 3c 	vpbroadcastq ymm5,QWORD PTR [rip+0xffffffffffff3c0d]        # 200208 <app_mask-0x18>
  20c5f9:	ff ff 
  20c5fb:	c4 e2 7d 59 35 3c 3c 	vpbroadcastq ymm6,QWORD PTR [rip+0xffffffffffff3c3c]        # 200240 <app_mask+0x20>
  20c602:	ff ff 
  20c604:	c4 e2 7d 59 3d 2b 3c 	vpbroadcastq ymm7,QWORD PTR [rip+0xffffffffffff3c2b]        # 200238 <app_mask+0x18>
  20c60b:	ff ff 
  20c60d:	c4 62 7d 59 05 d2 3b 	vpbroadcastq ymm8,QWORD PTR [rip+0xffffffffffff3bd2]        # 2001e8 <app_mask-0x38>
  20c614:	ff ff 
  20c616:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20c61a:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  20c61e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20c622:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  20c628:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  20c62f:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  20c636:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  20c63d:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  20c642:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  20c646:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  20c64a:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  20c64e:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  20c653:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  20c657:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  20c65c:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  20c660:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  20c665:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  20c669:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  20c66e:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  20c675:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  20c67c:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  20c683:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  20c68a:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  20c68e:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  20c692:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  20c697:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  20c69b:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  20c69f:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  20c6a4:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  20c6a8:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  20c6ad:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  20c6b1:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  20c6b6:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  20c6ba:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  20c6bf:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  20c6c3:	48 83 c1 20          	add    rcx,0x20
  20c6c7:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  20c6cb:	48 83 c5 02          	add    rbp,0x2
  20c6cf:	0f 85 4d ff ff ff    	jne    20c622 <parseFormValue+0x2072>
  20c6d5:	e9 46 04 00 00       	jmp    20cb20 <parseFormValue+0x2570>
  20c6da:	48 89 c3             	mov    rbx,rax
  20c6dd:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  20c6e1:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  20c6e5:	48 89 e9             	mov    rcx,rbp
  20c6e8:	48 c1 e9 04          	shr    rcx,0x4
  20c6ec:	8d 79 01             	lea    edi,[rcx+0x1]
  20c6ef:	83 e7 01             	and    edi,0x1
  20c6f2:	48 85 ed             	test   rbp,rbp
  20c6f5:	0f 84 ec 05 00 00    	je     20cce7 <parseFormValue+0x2737>
  20c6fb:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  20c6ff:	48 29 cd             	sub    rbp,rcx
  20c702:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20c706:	c5 fd 6f 0d 92 3a ff 	vmovdqa ymm1,YMMWORD PTR [rip+0xffffffffffff3a92]        # 2001a0 <app_mask-0x80>
  20c70d:	ff 
  20c70e:	31 c9                	xor    ecx,ecx
  20c710:	c4 e2 7d 59 2d ef 3a 	vpbroadcastq ymm5,QWORD PTR [rip+0xffffffffffff3aef]        # 200208 <app_mask-0x18>
  20c717:	ff ff 
  20c719:	c4 e2 7d 59 35 1e 3b 	vpbroadcastq ymm6,QWORD PTR [rip+0xffffffffffff3b1e]        # 200240 <app_mask+0x20>
  20c720:	ff ff 
  20c722:	c4 e2 7d 59 3d 0d 3b 	vpbroadcastq ymm7,QWORD PTR [rip+0xffffffffffff3b0d]        # 200238 <app_mask+0x18>
  20c729:	ff ff 
  20c72b:	c4 62 7d 59 05 b4 3a 	vpbroadcastq ymm8,QWORD PTR [rip+0xffffffffffff3ab4]        # 2001e8 <app_mask-0x38>
  20c732:	ff ff 
  20c734:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20c738:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  20c73c:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20c740:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  20c746:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  20c74d:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  20c754:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  20c75b:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  20c760:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  20c764:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  20c768:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  20c76c:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  20c771:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  20c775:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  20c77a:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  20c77e:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  20c783:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  20c787:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  20c78c:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  20c793:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  20c79a:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  20c7a1:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  20c7a8:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  20c7ac:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  20c7b0:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  20c7b5:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  20c7b9:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  20c7bd:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  20c7c2:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  20c7c6:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  20c7cb:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  20c7cf:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  20c7d4:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  20c7d8:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  20c7dd:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  20c7e1:	48 83 c1 20          	add    rcx,0x20
  20c7e5:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  20c7e9:	48 83 c5 02          	add    rbp,0x2
  20c7ed:	0f 85 4d ff ff ff    	jne    20c740 <parseFormValue+0x2190>
  20c7f3:	e9 09 05 00 00       	jmp    20cd01 <parseFormValue+0x2751>
  20c7f8:	48 89 c3             	mov    rbx,rax
  20c7fb:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  20c7ff:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  20c803:	48 89 e9             	mov    rcx,rbp
  20c806:	48 c1 e9 04          	shr    rcx,0x4
  20c80a:	8d 79 01             	lea    edi,[rcx+0x1]
  20c80d:	83 e7 01             	and    edi,0x1
  20c810:	48 85 ed             	test   rbp,rbp
  20c813:	0f 84 af 06 00 00    	je     20cec8 <parseFormValue+0x2918>
  20c819:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  20c81d:	48 29 cd             	sub    rbp,rcx
  20c820:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20c824:	c5 fd 6f 0d 74 39 ff 	vmovdqa ymm1,YMMWORD PTR [rip+0xffffffffffff3974]        # 2001a0 <app_mask-0x80>
  20c82b:	ff 
  20c82c:	31 c9                	xor    ecx,ecx
  20c82e:	c4 e2 7d 59 2d d1 39 	vpbroadcastq ymm5,QWORD PTR [rip+0xffffffffffff39d1]        # 200208 <app_mask-0x18>
  20c835:	ff ff 
  20c837:	c4 e2 7d 59 35 00 3a 	vpbroadcastq ymm6,QWORD PTR [rip+0xffffffffffff3a00]        # 200240 <app_mask+0x20>
  20c83e:	ff ff 
  20c840:	c4 e2 7d 59 3d ef 39 	vpbroadcastq ymm7,QWORD PTR [rip+0xffffffffffff39ef]        # 200238 <app_mask+0x18>
  20c847:	ff ff 
  20c849:	c4 62 7d 59 05 96 39 	vpbroadcastq ymm8,QWORD PTR [rip+0xffffffffffff3996]        # 2001e8 <app_mask-0x38>
  20c850:	ff ff 
  20c852:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20c856:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  20c85a:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20c85e:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  20c864:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  20c86b:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  20c872:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  20c879:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  20c87e:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  20c882:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  20c886:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  20c88a:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  20c88f:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  20c893:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  20c898:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  20c89c:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  20c8a1:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  20c8a5:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  20c8aa:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  20c8b1:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  20c8b8:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  20c8bf:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  20c8c6:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  20c8ca:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  20c8ce:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  20c8d3:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  20c8d7:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  20c8db:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  20c8e0:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  20c8e4:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  20c8e9:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  20c8ed:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  20c8f2:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  20c8f6:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  20c8fb:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  20c8ff:	48 83 c1 20          	add    rcx,0x20
  20c903:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  20c907:	48 83 c5 02          	add    rbp,0x2
  20c90b:	0f 85 4d ff ff ff    	jne    20c85e <parseFormValue+0x22ae>
  20c911:	e9 cc 05 00 00       	jmp    20cee2 <parseFormValue+0x2932>
    return FormValue{ .Block = buf };
  20c916:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x1
  20c91d:	01 
  20c91e:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  20c922:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  20c929:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  20c92e:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  20c935:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  20c936:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Block = buf };
  20c93c:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  20c940:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  20c947:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  20c94e:	00 
  20c94f:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  20c954:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  20c95b:	00 
  20c95c:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  20c963:	00 
  20c964:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  20c968:	88 8c 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],cl
  20c96f:	b3 01                	mov    bl,0x1
  20c971:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  20c978:	89 8c 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],ecx
  20c97f:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  20c986:	00 
  20c987:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  20c98e:	00 
  20c98f:	66 89 8c 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],cx
  20c996:	00 
  20c997:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  20c99e:	88 8c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],cl
  20c9a5:	e9 8f 00 00 00       	jmp    20ca39 <parseFormValue+0x2489>
    return FormValue{ .Ref = buf };
  20c9aa:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x6
  20c9b1:	06 
  20c9b2:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  20c9b6:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  20c9bd:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  20c9c2:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  20c9c9:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  20c9ca:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Ref = buf };
  20c9d0:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  20c9d4:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  20c9db:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  20c9e2:	00 
  20c9e3:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  20c9e8:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  20c9ef:	00 
  20c9f0:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  20c9f7:	00 
  20c9f8:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  20c9fc:	88 8c 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],cl
  20ca03:	b3 06                	mov    bl,0x6
  20ca05:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  20ca0c:	89 8c 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],ecx
  20ca13:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  20ca1a:	00 
  20ca1b:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  20ca22:	00 
  20ca23:	66 89 8c 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],cx
  20ca2a:	00 
  20ca2b:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  20ca32:	88 8c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],cl
  20ca39:	31 c9                	xor    ecx,ecx
  20ca3b:	66 89 0f             	mov    WORD PTR [rdi],cx
  20ca3e:	0f b7 4e 04          	movzx  ecx,WORD PTR [rsi+0x4]
  20ca42:	66 89 4f 06          	mov    WORD PTR [rdi+0x6],cx
  20ca46:	8b 0e                	mov    ecx,DWORD PTR [rsi]
  20ca48:	89 4f 02             	mov    DWORD PTR [rdi+0x2],ecx
  20ca4b:	c5 f8 11 47 08       	vmovups XMMWORD PTR [rdi+0x8],xmm0
  20ca50:	8a 48 06             	mov    cl,BYTE PTR [rax+0x6]
  20ca53:	88 4f 1f             	mov    BYTE PTR [rdi+0x1f],cl
  20ca56:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  20ca5a:	66 89 4f 1d          	mov    WORD PTR [rdi+0x1d],cx
  20ca5e:	8b 00                	mov    eax,DWORD PTR [rax]
  20ca60:	89 47 19             	mov    DWORD PTR [rdi+0x19],eax
  20ca63:	88 5f 20             	mov    BYTE PTR [rdi+0x20],bl
  20ca66:	0f b7 42 04          	movzx  eax,WORD PTR [rdx+0x4]
  20ca6a:	66 89 47 25          	mov    WORD PTR [rdi+0x25],ax
  20ca6e:	8b 02                	mov    eax,DWORD PTR [rdx]
  20ca70:	89 47 21             	mov    DWORD PTR [rdi+0x21],eax
  20ca73:	8a 42 06             	mov    al,BYTE PTR [rdx+0x6]
  20ca76:	88 47 27             	mov    BYTE PTR [rdi+0x27],al
  20ca79:	e9 49 f5 ff ff       	jmp    20bfc7 <parseFormValue+0x1a17>
            const buf = try readAllocBytes(allocator, in_stream, size);
  20ca7e:	c5 f8 10 84 24 58 04 	vmovups xmm0,XMMWORD PTR [rsp+0x458]
  20ca85:	00 00 
  20ca87:	c5 f8 29 84 24 80 04 	vmovaps XMMWORD PTR [rsp+0x480],xmm0
  20ca8e:	00 00 
            return FormValue{ .ExprLoc = buf };
  20ca90:	c5 f8 11 84 24 38 04 	vmovups XMMWORD PTR [rsp+0x438],xmm0
  20ca97:	00 00 
  20ca99:	48 8b 84 24 90 04 00 	mov    rax,QWORD PTR [rsp+0x490]
  20caa0:	00 
  20caa1:	48 89 84 24 48 04 00 	mov    QWORD PTR [rsp+0x448],rax
  20caa8:	00 
  20caa9:	c6 84 24 ae 00 00 00 	mov    BYTE PTR [rsp+0xae],0x3
  20cab0:	03 
  20cab1:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  20cab6:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  20cabb:	c5 f8 10 84 24 32 04 	vmovups xmm0,XMMWORD PTR [rsp+0x432]
  20cac2:	00 00 
  20cac4:	c5 fa 6f 8c 24 40 04 	vmovdqu xmm1,XMMWORD PTR [rsp+0x440]
  20cacb:	00 00 
  20cacd:	c5 fa 7f 49 10       	vmovdqu XMMWORD PTR [rcx+0x10],xmm1
  20cad2:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  20cad7:	8a 84 24 ae 00 00 00 	mov    al,BYTE PTR [rsp+0xae]
  20cade:	88 41 20             	mov    BYTE PTR [rcx+0x20],al
  20cae1:	8a 84 24 10 03 00 00 	mov    al,BYTE PTR [rsp+0x310]
  20cae8:	88 41 27             	mov    BYTE PTR [rcx+0x27],al
  20caeb:	0f b7 84 24 0e 03 00 	movzx  eax,WORD PTR [rsp+0x30e]
  20caf2:	00 
  20caf3:	66 89 41 25          	mov    WORD PTR [rcx+0x25],ax
  20caf7:	8b 84 24 0a 03 00 00 	mov    eax,DWORD PTR [rsp+0x30a]
  20cafe:	89 41 21             	mov    DWORD PTR [rcx+0x21],eax
  20cb01:	e9 c1 f4 ff ff       	jmp    20bfc7 <parseFormValue+0x1a17>
  20cb06:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20cb0a:	c5 fd 6f 0d 8e 36 ff 	vmovdqa ymm1,YMMWORD PTR [rip+0xffffffffffff368e]        # 2001a0 <app_mask-0x80>
  20cb11:	ff 
  20cb12:	31 c9                	xor    ecx,ecx
  20cb14:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20cb18:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  20cb1c:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  20cb20:	48 85 ff             	test   rdi,rdi
  20cb23:	74 62                	je     20cb87 <parseFormValue+0x25d7>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20cb25:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  20cb2c:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  20cb31:	c4 e2 7d 59 35 ce 36 	vpbroadcastq ymm6,QWORD PTR [rip+0xffffffffffff36ce]        # 200208 <app_mask-0x18>
  20cb38:	ff ff 
  20cb3a:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  20cb3e:	c4 e2 7d 59 3d f9 36 	vpbroadcastq ymm7,QWORD PTR [rip+0xffffffffffff36f9]        # 200240 <app_mask+0x20>
  20cb45:	ff ff 
  20cb47:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  20cb4b:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20cb50:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  20cb57:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  20cb5b:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  20cb5f:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  20cb64:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  20cb68:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  20cb6f:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20cb74:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  20cb78:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  20cb7e:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  20cb83:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  20cb87:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  20cb8b:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  20cb8f:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20cb93:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  20cb99:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20cb9d:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  20cba2:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20cba6:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  20cbab:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  20cbae:	74 29                	je     20cbd9 <parseFormValue+0x2629>
  20cbb0:	48 29 d8             	sub    rax,rbx
  20cbb3:	48 01 da             	add    rdx,rbx
  20cbb6:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20cbba:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  20cbbd:	89 de                	mov    esi,ebx
  20cbbf:	40 80 e6 38          	and    sil,0x38
  20cbc3:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  20cbc8:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  20cbcb:	48 83 c3 08          	add    rbx,0x8
  20cbcf:	48 83 c2 01          	add    rdx,0x1
  20cbd3:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20cbd7:	75 e1                	jne    20cbba <parseFormValue+0x260a>
  20cbd9:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  20cbde:	4c 89 fe             	mov    rsi,r15
  20cbe1:	4c 89 e2             	mov    rdx,r12
  20cbe4:	c5 f8 77             	vzeroupper 
  20cbe7:	e8 54 07 00 00       	call   20d340 <readAllocBytes>
  20cbec:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  20cbf1:	66 85 c0             	test   ax,ax
  20cbf4:	74 39                	je     20cc2f <parseFormValue+0x267f>
  20cbf6:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  20cbfc:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  20cc02:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  20cc09:	00 00 
  20cc0b:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20cc12:	00 00 
  20cc14:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  20cc18:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20cc1b:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  20cc20:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20cc25:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  20cc29:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  20cc2d:	eb 65                	jmp    20cc94 <parseFormValue+0x26e4>
  20cc2f:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  20cc36:	00 00 
  20cc38:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  20cc3f:	00 00 
    return FormValue{ .Block = buf };
  20cc41:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  20cc47:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  20cc4e:	00 
  20cc4f:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  20cc54:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  20cc59:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  20cc5d:	89 04 24             	mov    DWORD PTR [rsp],eax
  20cc60:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  20cc65:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20cc6a:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  20cc6e:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  20cc72:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  20cc78:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20cc7f:	00 00 
  20cc81:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  20cc87:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  20cc8e:	00 00 
  20cc90:	b1 01                	mov    cl,0x1
  20cc92:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  20cc94:	66 89 84 24 90 02 00 	mov    WORD PTR [rsp+0x290],ax
  20cc9b:	00 
  20cc9c:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  20cca3:	00 00 
  20cca5:	c5 f8 11 84 24 92 02 	vmovups XMMWORD PTR [rsp+0x292],xmm0
  20ccac:	00 00 
  20ccae:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  20ccb5:	00 00 
  20ccb7:	c5 f8 11 84 24 a0 02 	vmovups XMMWORD PTR [rsp+0x2a0],xmm0
  20ccbe:	00 00 
  20ccc0:	88 8c 24 b0 02 00 00 	mov    BYTE PTR [rsp+0x2b0],cl
  20ccc7:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  20ccca:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  20ccd1:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  20ccd6:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  20ccdd:	00 
  20ccde:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  20cce2:	e9 78 da ff ff       	jmp    20a75f <parseFormValue+0x1af>
  20cce7:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20cceb:	c5 fd 6f 0d ad 34 ff 	vmovdqa ymm1,YMMWORD PTR [rip+0xffffffffffff34ad]        # 2001a0 <app_mask-0x80>
  20ccf2:	ff 
  20ccf3:	31 c9                	xor    ecx,ecx
  20ccf5:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20ccf9:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  20ccfd:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  20cd01:	48 85 ff             	test   rdi,rdi
  20cd04:	74 62                	je     20cd68 <parseFormValue+0x27b8>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20cd06:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  20cd0d:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  20cd12:	c4 e2 7d 59 35 ed 34 	vpbroadcastq ymm6,QWORD PTR [rip+0xffffffffffff34ed]        # 200208 <app_mask-0x18>
  20cd19:	ff ff 
  20cd1b:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  20cd1f:	c4 e2 7d 59 3d 18 35 	vpbroadcastq ymm7,QWORD PTR [rip+0xffffffffffff3518]        # 200240 <app_mask+0x20>
  20cd26:	ff ff 
  20cd28:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  20cd2c:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20cd31:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  20cd38:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  20cd3c:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  20cd40:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  20cd45:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  20cd49:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  20cd50:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20cd55:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  20cd59:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  20cd5f:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  20cd64:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  20cd68:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  20cd6c:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  20cd70:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20cd74:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  20cd7a:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20cd7e:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  20cd83:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20cd87:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  20cd8c:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  20cd8f:	74 29                	je     20cdba <parseFormValue+0x280a>
  20cd91:	48 29 d8             	sub    rax,rbx
  20cd94:	48 01 da             	add    rdx,rbx
  20cd97:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20cd9b:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  20cd9e:	89 de                	mov    esi,ebx
  20cda0:	40 80 e6 38          	and    sil,0x38
  20cda4:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  20cda9:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  20cdac:	48 83 c3 08          	add    rbx,0x8
  20cdb0:	48 83 c2 01          	add    rdx,0x1
  20cdb4:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20cdb8:	75 e1                	jne    20cd9b <parseFormValue+0x27eb>
  20cdba:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  20cdbf:	4c 89 fe             	mov    rsi,r15
  20cdc2:	4c 89 e2             	mov    rdx,r12
  20cdc5:	c5 f8 77             	vzeroupper 
  20cdc8:	e8 73 05 00 00       	call   20d340 <readAllocBytes>
  20cdcd:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  20cdd2:	66 85 c0             	test   ax,ax
  20cdd5:	74 39                	je     20ce10 <parseFormValue+0x2860>
  20cdd7:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  20cddd:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  20cde3:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  20cdea:	00 00 
  20cdec:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20cdf3:	00 00 
  20cdf5:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  20cdf9:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20cdfc:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  20ce01:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20ce06:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  20ce0a:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  20ce0e:	eb 65                	jmp    20ce75 <parseFormValue+0x28c5>
  20ce10:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  20ce17:	00 00 
  20ce19:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  20ce20:	00 00 
    return FormValue{ .Block = buf };
  20ce22:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  20ce28:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  20ce2f:	00 
  20ce30:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  20ce35:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  20ce3a:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  20ce3e:	89 04 24             	mov    DWORD PTR [rsp],eax
  20ce41:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  20ce46:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20ce4b:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  20ce4f:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  20ce53:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  20ce59:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20ce60:	00 00 
  20ce62:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  20ce68:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  20ce6f:	00 00 
  20ce71:	b1 01                	mov    cl,0x1
  20ce73:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  20ce75:	66 89 84 24 68 02 00 	mov    WORD PTR [rsp+0x268],ax
  20ce7c:	00 
  20ce7d:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  20ce84:	00 00 
  20ce86:	c5 f8 11 84 24 6a 02 	vmovups XMMWORD PTR [rsp+0x26a],xmm0
  20ce8d:	00 00 
  20ce8f:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  20ce96:	00 00 
  20ce98:	c5 f8 11 84 24 78 02 	vmovups XMMWORD PTR [rsp+0x278],xmm0
  20ce9f:	00 00 
  20cea1:	88 8c 24 88 02 00 00 	mov    BYTE PTR [rsp+0x288],cl
  20cea8:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  20ceab:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  20ceb2:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  20ceb7:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  20cebe:	00 
  20cebf:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  20cec3:	e9 4c d9 ff ff       	jmp    20a814 <parseFormValue+0x264>
  20cec8:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20cecc:	c5 fd 6f 0d cc 32 ff 	vmovdqa ymm1,YMMWORD PTR [rip+0xffffffffffff32cc]        # 2001a0 <app_mask-0x80>
  20ced3:	ff 
  20ced4:	31 c9                	xor    ecx,ecx
  20ced6:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20ceda:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  20cede:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  20cee2:	48 85 ff             	test   rdi,rdi
  20cee5:	74 62                	je     20cf49 <parseFormValue+0x2999>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20cee7:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  20ceee:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  20cef3:	c4 e2 7d 59 35 0c 33 	vpbroadcastq ymm6,QWORD PTR [rip+0xffffffffffff330c]        # 200208 <app_mask-0x18>
  20cefa:	ff ff 
  20cefc:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  20cf00:	c4 e2 7d 59 3d 37 33 	vpbroadcastq ymm7,QWORD PTR [rip+0xffffffffffff3337]        # 200240 <app_mask+0x20>
  20cf07:	ff ff 
  20cf09:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  20cf0d:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20cf12:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  20cf19:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  20cf1d:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  20cf21:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  20cf26:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  20cf2a:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  20cf31:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20cf36:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  20cf3a:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  20cf40:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  20cf45:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  20cf49:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  20cf4d:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  20cf51:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20cf55:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  20cf5b:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20cf5f:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  20cf64:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20cf68:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  20cf6d:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  20cf70:	74 29                	je     20cf9b <parseFormValue+0x29eb>
  20cf72:	48 29 d8             	sub    rax,rbx
  20cf75:	48 01 da             	add    rdx,rbx
  20cf78:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20cf7c:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  20cf7f:	89 de                	mov    esi,ebx
  20cf81:	40 80 e6 38          	and    sil,0x38
  20cf85:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  20cf8a:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  20cf8d:	48 83 c3 08          	add    rbx,0x8
  20cf91:	48 83 c2 01          	add    rdx,0x1
  20cf95:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20cf99:	75 e1                	jne    20cf7c <parseFormValue+0x29cc>
  20cf9b:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  20cfa0:	4c 89 fe             	mov    rsi,r15
  20cfa3:	4c 89 e2             	mov    rdx,r12
  20cfa6:	c5 f8 77             	vzeroupper 
  20cfa9:	e8 92 03 00 00       	call   20d340 <readAllocBytes>
  20cfae:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  20cfb3:	66 85 c0             	test   ax,ax
  20cfb6:	74 39                	je     20cff1 <parseFormValue+0x2a41>
  20cfb8:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  20cfbe:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  20cfc4:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  20cfcb:	00 00 
  20cfcd:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20cfd4:	00 00 
  20cfd6:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  20cfda:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20cfdd:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  20cfe2:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20cfe7:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  20cfeb:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  20cfef:	eb 65                	jmp    20d056 <parseFormValue+0x2aa6>
  20cff1:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  20cff8:	00 00 
  20cffa:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  20d001:	00 00 
    return FormValue{ .Block = buf };
  20d003:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  20d009:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  20d010:	00 
  20d011:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  20d016:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  20d01b:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  20d01f:	89 04 24             	mov    DWORD PTR [rsp],eax
  20d022:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  20d027:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20d02c:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  20d030:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  20d034:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  20d03a:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  20d041:	00 00 
  20d043:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  20d049:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  20d050:	00 00 
  20d052:	b1 01                	mov    cl,0x1
  20d054:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  20d056:	66 89 84 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],ax
  20d05d:	00 
  20d05e:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  20d065:	00 00 
  20d067:	c5 f8 11 84 24 ba 02 	vmovups XMMWORD PTR [rsp+0x2ba],xmm0
  20d06e:	00 00 
  20d070:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  20d077:	00 00 
  20d079:	c5 f8 11 84 24 c8 02 	vmovups XMMWORD PTR [rsp+0x2c8],xmm0
  20d080:	00 00 
  20d082:	88 8c 24 d8 02 00 00 	mov    BYTE PTR [rsp+0x2d8],cl
  20d089:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  20d08c:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  20d093:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  20d098:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  20d09f:	00 
  20d0a0:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  20d0a4:	e9 d5 da ff ff       	jmp    20ab7e <parseFormValue+0x5ce>
  20d0a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000020d0b0 <Allocator_alignedRealloc.30>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  20d0b0:	41 56                	push   r14
  20d0b2:	53                   	push   rbx
  20d0b3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  20d0ba:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  20d0bd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  20d0c1:	48 85 c0             	test   rax,rax
  20d0c4:	74 62                	je     20d128 <Allocator_alignedRealloc.30+0x78>
        if (n == 0) {
  20d0c6:	48 85 c9             	test   rcx,rcx
  20d0c9:	0f 84 a9 00 00 00    	je     20d178 <Allocator_alignedRealloc.30+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  20d0cf:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  20d0d2:	48 c1 e0 03          	shl    rax,0x3
  20d0d6:	48 8d 04 80          	lea    rax,[rax+rax*4]
  20d0da:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  20d0df:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  20d0e4:	ba 28 00 00 00       	mov    edx,0x28
  20d0e9:	48 89 c8             	mov    rax,rcx
  20d0ec:	48 f7 e2             	mul    rdx
  20d0ef:	0f 81 d0 00 00 00    	jno    20d1c5 <Allocator_alignedRealloc.30+0x115>
  20d0f5:	48 8d 0d c4 54 ff ff 	lea    rcx,[rip+0xffffffffffff54c4]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20d0fc:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20d100:	0f 84 da 00 00 00    	je     20d1e0 <Allocator_alignedRealloc.30+0x130>
  20d106:	48 8b 05 73 40 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff4073]        # 201180 <__unnamed_62+0x10>
  20d10d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20d111:	c5 f8 10 05 57 40 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff4057]        # 201170 <__unnamed_62>
  20d118:	ff 
  20d119:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  20d11d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20d124:	5b                   	pop    rbx
  20d125:	41 5e                	pop    r14
  20d127:	c3                   	ret    
        if (n == 0) {
  20d128:	48 85 c9             	test   rcx,rcx
  20d12b:	0f 84 fc 00 00 00    	je     20d22d <Allocator_alignedRealloc.30+0x17d>
  20d131:	ba 28 00 00 00       	mov    edx,0x28
  20d136:	48 89 c8             	mov    rax,rcx
  20d139:	48 f7 e2             	mul    rdx
  20d13c:	0f 81 0c 01 00 00    	jno    20d24e <Allocator_alignedRealloc.30+0x19e>
  20d142:	48 8d 0d 77 54 ff ff 	lea    rcx,[rip+0xffffffffffff5477]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20d149:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20d14d:	0f 84 16 01 00 00    	je     20d269 <Allocator_alignedRealloc.30+0x1b9>
  20d153:	0f b7 05 1c 40 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff401c]        # 201176 <__unnamed_62+0x6>
  20d15a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20d15f:	8b 05 0d 40 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff400d]        # 201172 <__unnamed_62+0x2>
  20d165:	89 04 24             	mov    DWORD PTR [rsp],eax
  20d168:	48 89 e0             	mov    rax,rsp
  20d16b:	66 b9 0f 00          	mov    cx,0xf
  20d16f:	31 f6                	xor    esi,esi
  20d171:	31 d2                	xor    edx,edx
  20d173:	e9 9d 01 00 00       	jmp    20d315 <Allocator_alignedRealloc.30+0x265>
        const bytes = @sliceToBytes(memory);
  20d178:	48 c1 e0 03          	shl    rax,0x3
  20d17c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  20d180:	48 85 c0             	test   rax,rax
  20d183:	74 1e                	je     20d1a3 <Allocator_alignedRealloc.30+0xf3>
        const bytes = @sliceToBytes(memory);
  20d185:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20d188:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  20d18c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  20d191:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20d196:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20d19b:	48 89 f7             	mov    rdi,rsi
  20d19e:	48 89 c6             	mov    rsi,rax
  20d1a1:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  20d1a3:	48 8b 05 be 3f ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff3fbe]        # 201168 <__unnamed_63+0x10>
  20d1aa:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20d1ae:	c5 f8 10 05 a2 3f ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff3fa2]        # 201158 <__unnamed_63>
  20d1b5:	ff 
  20d1b6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  20d1ba:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20d1c1:	5b                   	pop    rbx
  20d1c2:	41 5e                	pop    r14
  20d1c4:	c3                   	ret    
  20d1c5:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  20d1ca:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  20d1d1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20d1d6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20d1da:	0f 85 26 ff ff ff    	jne    20d106 <Allocator_alignedRealloc.30+0x56>
  20d1e0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  20d1e4:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  20d1e9:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20d1ee:	41 b8 08 00 00 00    	mov    r8d,0x8
  20d1f4:	4c 89 f1             	mov    rcx,r14
  20d1f7:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  20d1fa:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  20d1ff:	66 85 c0             	test   ax,ax
  20d202:	0f 84 94 00 00 00    	je     20d29c <Allocator_alignedRealloc.30+0x1ec>
  20d208:	66 89 03             	mov    WORD PTR [rbx],ax
  20d20b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  20d212:	00 
  20d213:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20d217:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  20d21d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  20d222:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20d229:	5b                   	pop    rbx
  20d22a:	41 5e                	pop    r14
  20d22c:	c3                   	ret    
  20d22d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  20d230:	0f b7 0d 27 3f ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff3f27]        # 20115e <__unnamed_63+0x6>
  20d237:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20d23c:	8b 0d 18 3f ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff3f18]        # 20115a <__unnamed_63+0x2>
  20d242:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20d245:	31 c9                	xor    ecx,ecx
  20d247:	31 d2                	xor    edx,edx
  20d249:	e9 c7 00 00 00       	jmp    20d315 <Allocator_alignedRealloc.30+0x265>
  20d24e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  20d253:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  20d25a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20d25f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20d263:	0f 85 ea fe ff ff    	jne    20d153 <Allocator_alignedRealloc.30+0xa3>
  20d269:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  20d26d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20d272:	b9 08 00 00 00       	mov    ecx,0x8
  20d277:	4c 89 f2             	mov    rdx,r14
  20d27a:	ff 16                	call   QWORD PTR [rsi]
  20d27c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  20d281:	66 85 c9             	test   cx,cx
  20d284:	74 57                	je     20d2dd <Allocator_alignedRealloc.30+0x22d>
  20d286:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  20d28b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20d290:	48 89 e0             	mov    rax,rsp
  20d293:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  20d297:	89 14 24             	mov    DWORD PTR [rsp],edx
  20d29a:	eb 79                	jmp    20d315 <Allocator_alignedRealloc.30+0x265>
        assert(byte_slice.len == byte_count);
  20d29c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  20d2a1:	0f 85 91 00 00 00    	jne    20d338 <Allocator_alignedRealloc.30+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20d2a7:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20d2ac:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  20d2b3:	cc cc cc 
  20d2b6:	4c 89 f2             	mov    rdx,r14
  20d2b9:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  20d2be:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  20d2c3:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  20d2c8:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20d2cc:	48 c1 ea 05          	shr    rdx,0x5
  20d2d0:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  20d2d4:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  20d2d7:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  20d2db:	eb 4c                	jmp    20d329 <Allocator_alignedRealloc.30+0x279>
        assert(byte_slice.len == byte_count);
  20d2dd:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  20d2e2:	75 54                	jne    20d338 <Allocator_alignedRealloc.30+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20d2e4:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20d2e9:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  20d2f0:	cc cc cc 
  20d2f3:	4c 89 f2             	mov    rdx,r14
  20d2f6:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  20d2fb:	48 c1 ea 05          	shr    rdx,0x5
  20d2ff:	48 89 e0             	mov    rax,rsp
  20d302:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  20d306:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20d309:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  20d30e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20d313:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  20d315:	66 89 0b             	mov    WORD PTR [rbx],cx
  20d318:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  20d31c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20d320:	8b 00                	mov    eax,DWORD PTR [rax]
  20d322:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  20d325:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  20d329:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  20d32d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20d334:	5b                   	pop    rbx
  20d335:	41 5e                	pop    r14
  20d337:	c3                   	ret    
            @panic("assertion failure");
  20d338:	e8 93 5e ff ff       	call   2031d0 <panic>
  20d33d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000020d340 <readAllocBytes>:
fn readAllocBytes(allocator: *mem.Allocator, in_stream: var, size: usize) ![]u8 {
  20d340:	55                   	push   rbp
  20d341:	41 57                	push   r15
  20d343:	41 56                	push   r14
  20d345:	41 54                	push   r12
  20d347:	53                   	push   rbx
  20d348:	48 83 ec 70          	sub    rsp,0x70
  20d34c:	48 89 cb             	mov    rbx,rcx
  20d34f:	49 89 d4             	mov    r12,rdx
  20d352:	49 89 f6             	mov    r14,rsi
  20d355:	49 89 ff             	mov    r15,rdi
        if (n == 0) {
  20d358:	48 85 db             	test   rbx,rbx
  20d35b:	74 32                	je     20d38f <readAllocBytes+0x4f>
  20d35d:	48 89 e7             	mov    rdi,rsp
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20d360:	b9 01 00 00 00       	mov    ecx,0x1
  20d365:	4c 89 f6             	mov    rsi,r14
  20d368:	48 89 da             	mov    rdx,rbx
  20d36b:	41 ff 16             	call   QWORD PTR [r14]
  20d36e:	0f b7 04 24          	movzx  eax,WORD PTR [rsp]
  20d372:	66 85 c0             	test   ax,ax
  20d375:	74 1c                	je     20d393 <readAllocBytes+0x53>
    const buf = try allocator.alloc(u8, size);
  20d377:	66 41 89 07          	mov    WORD PTR [r15],ax
  20d37b:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  20d380:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  20d384:	c5 f8 10 44 24 5a    	vmovups xmm0,XMMWORD PTR [rsp+0x5a]
  20d38a:	e9 d8 00 00 00       	jmp    20d467 <readAllocBytes+0x127>
  20d38f:	31 c0                	xor    eax,eax
  20d391:	eb 13                	jmp    20d3a6 <readAllocBytes+0x66>
        assert(byte_slice.len == byte_count);
  20d393:	48 39 5c 24 10       	cmp    QWORD PTR [rsp+0x10],rbx
    if (!ok) {
  20d398:	0f 85 dc 00 00 00    	jne    20d47a <readAllocBytes+0x13a>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20d39e:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  20d3a3:	48 89 d8             	mov    rax,rbx
    const buf = try allocator.alloc(u8, size);
  20d3a6:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  20d3ab:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  20d3b0:	48 89 e7             	mov    rdi,rsp
  20d3b3:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  20d3b8:	4c 89 e6             	mov    rsi,r12
  20d3bb:	41 ff 14 24          	call   QWORD PTR [r12]
  20d3bf:	0f b7 2c 24          	movzx  ebp,WORD PTR [rsp]
    if ((try in_stream.read(buf)) < size) return error.EndOfFile;
  20d3c3:	66 85 ed             	test   bp,bp
  20d3c6:	74 39                	je     20d401 <readAllocBytes+0xc1>
        const bytes = @sliceToBytes(memory);
  20d3c8:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  20d3cd:	48 85 c0             	test   rax,rax
  20d3d0:	74 1a                	je     20d3ec <readAllocBytes+0xac>
        const bytes = @sliceToBytes(memory);
  20d3d2:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20d3d7:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  20d3db:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  20d3df:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20d3e4:	48 89 e6             	mov    rsi,rsp
  20d3e7:	4c 89 f7             	mov    rdi,r14
  20d3ea:	ff d2                	call   rdx
  20d3ec:	66 41 89 2f          	mov    WORD PTR [r15],bp
  20d3f0:	48 8b 44 24 52       	mov    rax,QWORD PTR [rsp+0x52]
  20d3f5:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  20d3f9:	c5 f8 10 44 24 44    	vmovups xmm0,XMMWORD PTR [rsp+0x44]
  20d3ff:	eb 66                	jmp    20d467 <readAllocBytes+0x127>
  20d401:	48 39 5c 24 08       	cmp    QWORD PTR [rsp+0x8],rbx
  20d406:	73 3e                	jae    20d446 <readAllocBytes+0x106>
        const bytes = @sliceToBytes(memory);
  20d408:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  20d40d:	48 85 c0             	test   rax,rax
  20d410:	74 1a                	je     20d42c <readAllocBytes+0xec>
        const bytes = @sliceToBytes(memory);
  20d412:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20d417:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  20d41b:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  20d41f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20d424:	48 89 e6             	mov    rsi,rsp
  20d427:	4c 89 f7             	mov    rdi,r14
  20d42a:	ff d2                	call   rdx
  20d42c:	48 8b 05 ad 50 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff50ad]        # 2024e0 <__unnamed_64+0x10>
  20d433:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  20d437:	c5 f8 10 05 91 50 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff5091]        # 2024d0 <__unnamed_64>
  20d43e:	ff 
  20d43f:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  20d444:	eb 27                	jmp    20d46d <readAllocBytes+0x12d>
    return buf;
  20d446:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  20d44c:	c5 f8 11 44 24 34    	vmovups XMMWORD PTR [rsp+0x34],xmm0
  20d452:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  20d458:	48 8b 44 24 3c       	mov    rax,QWORD PTR [rsp+0x3c]
  20d45d:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  20d461:	c5 f8 10 44 24 2e    	vmovups xmm0,XMMWORD PTR [rsp+0x2e]
  20d467:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  20d46d:	48 83 c4 70          	add    rsp,0x70
  20d471:	5b                   	pop    rbx
  20d472:	41 5c                	pop    r12
  20d474:	41 5e                	pop    r14
  20d476:	41 5f                	pop    r15
  20d478:	5d                   	pop    rbp
  20d479:	c3                   	ret    
            @panic("assertion failure");
  20d47a:	e8 51 5d ff ff       	call   2031d0 <panic>
  20d47f:	90                   	nop

000000000020d480 <readStringRaw>:
            return Self{
  20d480:	55                   	push   rbp
  20d481:	41 57                	push   r15
  20d483:	41 56                	push   r14
  20d485:	41 55                	push   r13
  20d487:	41 54                	push   r12
  20d489:	53                   	push   rbx
  20d48a:	48 81 ec 98 00 00 00 	sub    rsp,0x98
  20d491:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  20d495:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  20d49b:	48 89 d3             	mov    rbx,rdx
  20d49e:	49 89 f7             	mov    r15,rsi
  20d4a1:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  20d4a6:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  20d4ad:	00 00 
    var buf = ArrayList(u8).init(allocator);
  20d4af:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  20d4b4:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
            try self.readNoEof(result[0..]);
  20d4b9:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20d4be:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20d4c5:	00 00 
  20d4c7:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20d4cc:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  20d4d1:	48 89 de             	mov    rsi,rbx
  20d4d4:	ff 13                	call   QWORD PTR [rbx]
  20d4d6:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20d4db:	66 85 c9             	test   cx,cx
  20d4de:	74 34                	je     20d514 <readStringRaw+0x94>
  20d4e0:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
        const byte = try in_stream.readByte();
  20d4e5:	66 89 0a             	mov    WORD PTR [rdx],cx
  20d4e8:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  20d4ef:	00 
  20d4f0:	48 89 42 10          	mov    QWORD PTR [rdx+0x10],rax
  20d4f4:	c5 f8 10 84 24 82 00 	vmovups xmm0,XMMWORD PTR [rsp+0x82]
  20d4fb:	00 00 
  20d4fd:	c5 f8 11 42 02       	vmovups XMMWORD PTR [rdx+0x2],xmm0
  20d502:	48 81 c4 98 00 00 00 	add    rsp,0x98
  20d509:	5b                   	pop    rbx
  20d50a:	41 5c                	pop    r12
  20d50c:	41 5d                	pop    r13
  20d50e:	41 5e                	pop    r14
  20d510:	41 5f                	pop    r15
  20d512:	5d                   	pop    rbp
  20d513:	c3                   	ret    
  20d514:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20d519:	31 ed                	xor    ebp,ebp
  20d51b:	45 31 ed             	xor    r13d,r13d
  20d51e:	66 90                	xchg   ax,ax
            if (amt_read < buf.len) return error.EndOfStream;
  20d520:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  20d525:	0f 82 b6 00 00 00    	jb     20d5e1 <readStringRaw+0x161>
            return result[0];
  20d52b:	44 8a 64 24 07       	mov    r12b,BYTE PTR [rsp+0x7]
        if (byte == 0) break;
  20d530:	45 84 e4             	test   r12b,r12b
  20d533:	0f 84 b1 00 00 00    	je     20d5ea <readStringRaw+0x16a>
            var better_capacity = self.items.len;
  20d539:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  20d53e:	4c 39 e9             	cmp    rcx,r13
  20d541:	77 53                	ja     20d596 <readStringRaw+0x116>
  20d543:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20d54a:	84 00 00 00 00 00 
                better_capacity += better_capacity / 2 + 8;
  20d550:	48 89 c8             	mov    rax,rcx
  20d553:	48 d1 e8             	shr    rax,1
  20d556:	48 01 c1             	add    rcx,rax
  20d559:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20d55d:	4c 39 e9             	cmp    rcx,r13
  20d560:	76 ee                	jbe    20d550 <readStringRaw+0xd0>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20d562:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20d567:	4c 89 fe             	mov    rsi,r15
  20d56a:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  20d56f:	e8 bc 27 00 00       	call   20fd30 <Allocator_alignedRealloc.54>
  20d574:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20d579:	66 85 c0             	test   ax,ax
  20d57c:	0f 85 94 00 00 00    	jne    20d616 <readStringRaw+0x196>
  20d582:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  20d587:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  20d58b:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  20d591:	48 8b 6c 24 40       	mov    rbp,QWORD PTR [rsp+0x40]
  20d596:	4d 8d 75 01          	lea    r14,[r13+0x1]
            self.len = new_length;
  20d59a:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  20d59f:	46 88 64 2d 00       	mov    BYTE PTR [rbp+r13*1+0x0],r12b
            try self.readNoEof(result[0..]);
  20d5a4:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20d5a9:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20d5ae:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20d5b5:	00 00 
            return self.readFn(self, buffer);
  20d5b7:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20d5bc:	48 89 de             	mov    rsi,rbx
  20d5bf:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20d5c4:	ff 13                	call   QWORD PTR [rbx]
  20d5c6:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  20d5cb:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20d5d0:	4d 89 f5             	mov    r13,r14
            const amt_read = try self.read(buf);
  20d5d3:	66 85 c9             	test   cx,cx
  20d5d6:	0f 84 44 ff ff ff    	je     20d520 <readStringRaw+0xa0>
  20d5dc:	e9 ff fe ff ff       	jmp    20d4e0 <readStringRaw+0x60>
  20d5e1:	66 b9 1e 00          	mov    cx,0x1e
  20d5e5:	e9 f6 fe ff ff       	jmp    20d4e0 <readStringRaw+0x60>
  20d5ea:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
    return buf.toSlice();
  20d5ef:	66 c7 02 00 00       	mov    WORD PTR [rdx],0x0
  20d5f4:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  20d5f9:	66 89 42 06          	mov    WORD PTR [rdx+0x6],ax
            return self.items[0..self.len];
  20d5fd:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  20d602:	8b 4c 24 3a          	mov    ecx,DWORD PTR [rsp+0x3a]
  20d606:	89 4a 02             	mov    DWORD PTR [rdx+0x2],ecx
  20d609:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
  20d60d:	4c 89 6a 10          	mov    QWORD PTR [rdx+0x10],r13
  20d611:	e9 ec fe ff ff       	jmp    20d502 <readStringRaw+0x82>
  20d616:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
        try buf.append(byte);
  20d61b:	66 89 01             	mov    WORD PTR [rcx],ax
  20d61e:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  20d623:	48 89 41 10          	mov    QWORD PTR [rcx+0x10],rax
  20d627:	c5 f8 10 44 24 6c    	vmovups xmm0,XMMWORD PTR [rsp+0x6c]
  20d62d:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  20d632:	e9 cb fe ff ff       	jmp    20d502 <readStringRaw+0x82>
  20d637:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20d63e:	00 00 

000000000020d640 <Allocator_alignedRealloc.37>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  20d640:	41 56                	push   r14
  20d642:	53                   	push   rbx
  20d643:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  20d64a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  20d64d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  20d651:	48 85 c0             	test   rax,rax
  20d654:	74 62                	je     20d6b8 <Allocator_alignedRealloc.37+0x78>
        if (n == 0) {
  20d656:	48 85 c9             	test   rcx,rcx
  20d659:	0f 84 a9 00 00 00    	je     20d708 <Allocator_alignedRealloc.37+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  20d65f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  20d662:	48 c1 e0 04          	shl    rax,0x4
  20d666:	48 8d 04 40          	lea    rax,[rax+rax*2]
  20d66a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  20d66f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  20d674:	ba 30 00 00 00       	mov    edx,0x30
  20d679:	48 89 c8             	mov    rax,rcx
  20d67c:	48 f7 e2             	mul    rdx
  20d67f:	0f 81 d0 00 00 00    	jno    20d755 <Allocator_alignedRealloc.37+0x115>
  20d685:	48 8d 0d 34 4f ff ff 	lea    rcx,[rip+0xffffffffffff4f34]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20d68c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20d690:	0f 84 da 00 00 00    	je     20d770 <Allocator_alignedRealloc.37+0x130>
  20d696:	48 8b 05 5b 3b ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff3b5b]        # 2011f8 <__unnamed_65+0x10>
  20d69d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20d6a1:	c5 f8 10 05 3f 3b ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff3b3f]        # 2011e8 <__unnamed_65>
  20d6a8:	ff 
  20d6a9:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  20d6ad:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20d6b4:	5b                   	pop    rbx
  20d6b5:	41 5e                	pop    r14
  20d6b7:	c3                   	ret    
        if (n == 0) {
  20d6b8:	48 85 c9             	test   rcx,rcx
  20d6bb:	0f 84 fc 00 00 00    	je     20d7bd <Allocator_alignedRealloc.37+0x17d>
  20d6c1:	ba 30 00 00 00       	mov    edx,0x30
  20d6c6:	48 89 c8             	mov    rax,rcx
  20d6c9:	48 f7 e2             	mul    rdx
  20d6cc:	0f 81 0c 01 00 00    	jno    20d7de <Allocator_alignedRealloc.37+0x19e>
  20d6d2:	48 8d 0d e7 4e ff ff 	lea    rcx,[rip+0xffffffffffff4ee7]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20d6d9:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20d6dd:	0f 84 16 01 00 00    	je     20d7f9 <Allocator_alignedRealloc.37+0x1b9>
  20d6e3:	0f b7 05 04 3b ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff3b04]        # 2011ee <__unnamed_65+0x6>
  20d6ea:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20d6ef:	8b 05 f5 3a ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff3af5]        # 2011ea <__unnamed_65+0x2>
  20d6f5:	89 04 24             	mov    DWORD PTR [rsp],eax
  20d6f8:	48 89 e0             	mov    rax,rsp
  20d6fb:	66 b9 0f 00          	mov    cx,0xf
  20d6ff:	31 f6                	xor    esi,esi
  20d701:	31 d2                	xor    edx,edx
  20d703:	e9 9d 01 00 00       	jmp    20d8a5 <Allocator_alignedRealloc.37+0x265>
        const bytes = @sliceToBytes(memory);
  20d708:	48 c1 e0 04          	shl    rax,0x4
  20d70c:	48 8d 04 40          	lea    rax,[rax+rax*2]
        if (bytes.len == 0) return;
  20d710:	48 85 c0             	test   rax,rax
  20d713:	74 1e                	je     20d733 <Allocator_alignedRealloc.37+0xf3>
        const bytes = @sliceToBytes(memory);
  20d715:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20d718:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  20d71c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  20d721:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20d726:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20d72b:	48 89 f7             	mov    rdi,rsi
  20d72e:	48 89 c6             	mov    rsi,rax
  20d731:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  20d733:	48 8b 05 a6 3a ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff3aa6]        # 2011e0 <__unnamed_66+0x10>
  20d73a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20d73e:	c5 f8 10 05 8a 3a ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff3a8a]        # 2011d0 <__unnamed_66>
  20d745:	ff 
  20d746:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  20d74a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20d751:	5b                   	pop    rbx
  20d752:	41 5e                	pop    r14
  20d754:	c3                   	ret    
  20d755:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  20d75a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  20d761:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20d766:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20d76a:	0f 85 26 ff ff ff    	jne    20d696 <Allocator_alignedRealloc.37+0x56>
  20d770:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  20d774:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  20d779:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20d77e:	41 b8 02 00 00 00    	mov    r8d,0x2
  20d784:	4c 89 f1             	mov    rcx,r14
  20d787:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  20d78a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  20d78f:	66 85 c0             	test   ax,ax
  20d792:	0f 84 94 00 00 00    	je     20d82c <Allocator_alignedRealloc.37+0x1ec>
  20d798:	66 89 03             	mov    WORD PTR [rbx],ax
  20d79b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  20d7a2:	00 
  20d7a3:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20d7a7:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  20d7ad:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  20d7b2:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20d7b9:	5b                   	pop    rbx
  20d7ba:	41 5e                	pop    r14
  20d7bc:	c3                   	ret    
  20d7bd:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  20d7c0:	0f b7 0d 0f 3a ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff3a0f]        # 2011d6 <__unnamed_66+0x6>
  20d7c7:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20d7cc:	8b 0d 00 3a ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff3a00]        # 2011d2 <__unnamed_66+0x2>
  20d7d2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20d7d5:	31 c9                	xor    ecx,ecx
  20d7d7:	31 d2                	xor    edx,edx
  20d7d9:	e9 c7 00 00 00       	jmp    20d8a5 <Allocator_alignedRealloc.37+0x265>
  20d7de:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  20d7e3:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  20d7ea:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  20d7ef:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  20d7f3:	0f 85 ea fe ff ff    	jne    20d6e3 <Allocator_alignedRealloc.37+0xa3>
  20d7f9:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  20d7fd:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20d802:	b9 02 00 00 00       	mov    ecx,0x2
  20d807:	4c 89 f2             	mov    rdx,r14
  20d80a:	ff 16                	call   QWORD PTR [rsi]
  20d80c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  20d811:	66 85 c9             	test   cx,cx
  20d814:	74 57                	je     20d86d <Allocator_alignedRealloc.37+0x22d>
  20d816:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  20d81b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  20d820:	48 89 e0             	mov    rax,rsp
  20d823:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  20d827:	89 14 24             	mov    DWORD PTR [rsp],edx
  20d82a:	eb 79                	jmp    20d8a5 <Allocator_alignedRealloc.37+0x265>
        assert(byte_slice.len == byte_count);
  20d82c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  20d831:	0f 85 91 00 00 00    	jne    20d8c8 <Allocator_alignedRealloc.37+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20d837:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20d83c:	48 b9 ab aa aa aa aa 	movabs rcx,0xaaaaaaaaaaaaaaab
  20d843:	aa aa aa 
  20d846:	4c 89 f2             	mov    rdx,r14
  20d849:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  20d84e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  20d853:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  20d858:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20d85c:	48 c1 ea 05          	shr    rdx,0x5
  20d860:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  20d864:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  20d867:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  20d86b:	eb 4c                	jmp    20d8b9 <Allocator_alignedRealloc.37+0x279>
        assert(byte_slice.len == byte_count);
  20d86d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  20d872:	75 54                	jne    20d8c8 <Allocator_alignedRealloc.37+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20d874:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20d879:	48 b8 ab aa aa aa aa 	movabs rax,0xaaaaaaaaaaaaaaab
  20d880:	aa aa aa 
  20d883:	4c 89 f2             	mov    rdx,r14
  20d886:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  20d88b:	48 c1 ea 05          	shr    rdx,0x5
  20d88f:	48 89 e0             	mov    rax,rsp
  20d892:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  20d896:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  20d899:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  20d89e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  20d8a3:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  20d8a5:	66 89 0b             	mov    WORD PTR [rbx],cx
  20d8a8:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  20d8ac:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20d8b0:	8b 00                	mov    eax,DWORD PTR [rax]
  20d8b2:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  20d8b5:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  20d8b9:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  20d8bd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20d8c4:	5b                   	pop    rbx
  20d8c5:	41 5e                	pop    r14
  20d8c7:	c3                   	ret    
            @panic("assertion failure");
  20d8c8:	e8 03 59 ff ff       	call   2031d0 <panic>
  20d8cd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000020d8d0 <getLineNumberInfo>:
fn getLineNumberInfo(st: *ElfStackTrace, compile_unit: *const CompileUnit, target_address: usize) !LineInfo {
  20d8d0:	55                   	push   rbp
  20d8d1:	41 57                	push   r15
  20d8d3:	41 56                	push   r14
  20d8d5:	41 55                	push   r13
  20d8d7:	41 54                	push   r12
  20d8d9:	53                   	push   rbx
  20d8da:	48 81 ec 18 0b 00 00 	sub    rsp,0xb18
  20d8e1:	49 89 cc             	mov    r12,rcx
  20d8e4:	49 89 d6             	mov    r14,rdx
  20d8e7:	49 89 f7             	mov    r15,rsi
  20d8ea:	48 89 fd             	mov    rbp,rdi
    const compile_unit_cwd = try compile_unit.die.getAttrString(st, DW.AT_comp_dir);
  20d8ed:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
            return self.items[0..self.len];
  20d8f1:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  20d8f5:	48 85 c9             	test   rcx,rcx
  20d8f8:	74 19                	je     20d913 <getLineNumberInfo+0x43>
  20d8fa:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  20d8fe:	31 d2                	xor    edx,edx
            if (attr.id == id) return &attr.value;
  20d900:	48 83 38 1b          	cmp    QWORD PTR [rax],0x1b
  20d904:	74 36                	je     20d93c <getLineNumberInfo+0x6c>
        for (self.attrs.toSliceConst()) |*attr| {
  20d906:	48 83 c2 01          	add    rdx,0x1
  20d90a:	48 83 c0 28          	add    rax,0x28
  20d90e:	48 39 ca             	cmp    rdx,rcx
  20d911:	72 ed                	jb     20d900 <getLineNumberInfo+0x30>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  20d913:	48 8b 05 96 39 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff3996]        # 2012b0 <__unnamed_32+0x10>
  20d91a:	48 89 84 24 7e 01 00 	mov    QWORD PTR [rsp+0x17e],rax
  20d921:	00 
  20d922:	c5 f8 10 05 78 39 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff3978]        # 2012a2 <__unnamed_32+0x2>
  20d929:	ff 
  20d92a:	c5 f8 29 84 24 70 01 	vmovaps XMMWORD PTR [rsp+0x170],xmm0
  20d931:	00 00 
  20d933:	66 b8 22 00          	mov    ax,0x22
  20d937:	e9 c5 00 00 00       	jmp    20da01 <getLineNumberInfo+0x131>
  20d93c:	8a 48 20             	mov    cl,BYTE PTR [rax+0x20]
  20d93f:	80 f9 0a             	cmp    cl,0xa
        return switch (form_value.*) {
  20d942:	74 1e                	je     20d962 <getLineNumberInfo+0x92>
  20d944:	80 f9 09             	cmp    cl,0x9
  20d947:	75 69                	jne    20d9b2 <getLineNumberInfo+0xe2>
            FormValue.String => |value| value,
  20d949:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  20d950:	c5 f8 10 40 08       	vmovups xmm0,XMMWORD PTR [rax+0x8]
  20d955:	c5 f8 11 44 24 10    	vmovups XMMWORD PTR [rsp+0x10],xmm0
  20d95b:	48 8d 5c 24 08       	lea    rbx,[rsp+0x8]
  20d960:	eb 7d                	jmp    20d9df <getLineNumberInfo+0x10f>
            FormValue.StrPtr => |offset| getString(st, offset),
  20d962:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
    const pos = st.debug_str.offset + offset;
  20d966:	49 8b 47 70          	mov    rax,QWORD PTR [r15+0x70]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  20d96a:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  20d96e:	78 4b                	js     20d9bb <getLineNumberInfo+0xeb>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20d970:	49 63 3f             	movsxd rdi,DWORD PTR [r15]
  20d973:	31 db                	xor    ebx,ebx
  20d975:	b8 08 00 00 00       	mov    eax,0x8
  20d97a:	31 d2                	xor    edx,edx
  20d97c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20d97e:	48 89 c1             	mov    rcx,rax
  20d981:	48 f7 d9             	neg    rcx
  20d984:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20d98a:	48 0f 46 cb          	cmovbe rcx,rbx
  20d98e:	66 b8 05 00          	mov    ax,0x5
                if (err > 0) {
  20d992:	48 83 f9 1d          	cmp    rcx,0x1d
  20d996:	0f 87 44 02 00 00    	ja     20dbe0 <getLineNumberInfo+0x310>
  20d99c:	48 8d 15 d1 30 ff ff 	lea    rdx,[rip+0xffffffffffff30d1]        # 200a74 <__unnamed_128+0x82c>
  20d9a3:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  20d9a7:	48 01 d1             	add    rcx,rdx
  20d9aa:	ff e1                	jmp    rcx
  20d9ac:	66 b8 20 00          	mov    ax,0x20
  20d9b0:	eb 0d                	jmp    20d9bf <getLineNumberInfo+0xef>
  20d9b2:	48 8d 1d ff 38 ff ff 	lea    rbx,[rip+0xffffffffffff38ff]        # 2012b8 <__unnamed_15>
  20d9b9:	eb 24                	jmp    20d9df <getLineNumberInfo+0x10f>
  20d9bb:	66 b8 21 00          	mov    ax,0x21
    try st.self_exe_file.seekTo(pos);
  20d9bf:	66 89 44 24 20       	mov    WORD PTR [rsp+0x20],ax
  20d9c4:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
  20d9ca:	c5 f8 11 44 24 22    	vmovups XMMWORD PTR [rsp+0x22],xmm0
  20d9d0:	48 8b 44 24 56       	mov    rax,QWORD PTR [rsp+0x56]
  20d9d5:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20d9da:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
        return switch (form_value.*) {
  20d9df:	0f b7 03             	movzx  eax,WORD PTR [rbx]
  20d9e2:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  20d9e6:	48 89 8c 24 7e 01 00 	mov    QWORD PTR [rsp+0x17e],rcx
  20d9ed:	00 
  20d9ee:	c5 f8 10 43 02       	vmovups xmm0,XMMWORD PTR [rbx+0x2]
  20d9f3:	c5 f8 29 84 24 70 01 	vmovaps XMMWORD PTR [rsp+0x170],xmm0
  20d9fa:	00 00 
    const compile_unit_cwd = try compile_unit.die.getAttrString(st, DW.AT_comp_dir);
  20d9fc:	66 85 c0             	test   ax,ax
  20d9ff:	74 35                	je     20da36 <getLineNumberInfo+0x166>
  20da01:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  20da05:	c5 fe 6f 84 24 ca 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xaca]
  20da0c:	00 00 
  20da0e:	c5 fc 10 8c 24 d8 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xad8]
  20da15:	00 00 
  20da17:	c5 fc 11 4d 10       	vmovups YMMWORD PTR [rbp+0x10],ymm1
  20da1c:	c5 fe 7f 45 02       	vmovdqu YMMWORD PTR [rbp+0x2],ymm0
  20da21:	48 81 c4 18 0b 00 00 	add    rsp,0xb18
  20da28:	5b                   	pop    rbx
  20da29:	41 5c                	pop    r12
  20da2b:	41 5d                	pop    r13
  20da2d:	41 5e                	pop    r14
  20da2f:	41 5f                	pop    r15
  20da31:	5d                   	pop    rbp
  20da32:	c5 f8 77             	vzeroupper 
  20da35:	c3                   	ret    
  20da36:	4c 89 a4 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],r12
  20da3d:	00 
  20da3e:	48 89 2c 24          	mov    QWORD PTR [rsp],rbp
  20da42:	c5 fa 6f 84 24 76 01 	vmovdqu xmm0,XMMWORD PTR [rsp+0x176]
  20da49:	00 00 
  20da4b:	c5 f9 7f 84 24 e0 01 	vmovdqa XMMWORD PTR [rsp+0x1e0],xmm0
  20da52:	00 00 
    const debug_line_end = st.debug_line.offset + st.debug_line.size;
  20da54:	49 8b 47 78          	mov    rax,QWORD PTR [r15+0x78]
  20da58:	48 8b 58 18          	mov    rbx,QWORD PTR [rax+0x18]
  20da5c:	4c 8b 60 20          	mov    r12,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(in_file);
  20da60:	4c 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],r15
  20da65:	48 8d 05 54 bc ff ff 	lea    rax,[rip+0xffffffffffffbc54]        # 2096c0 <FileInStream_readFn>
  20da6c:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
    while (this_offset < debug_line_end) : (this_index += 1) {
  20da71:	4d 85 e4             	test   r12,r12
  20da74:	0f 84 44 01 00 00    	je     20dbbe <getLineNumberInfo+0x2ee>
  20da7a:	49 01 dc             	add    r12,rbx
  20da7d:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  20da84:	4c 89 7c 24 60       	mov    QWORD PTR [rsp+0x60],r15
  20da89:	48 85 db             	test   rbx,rbx
  20da8c:	0f 88 66 01 00 00    	js     20dbf8 <getLineNumberInfo+0x328>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20da92:	49 63 3f             	movsxd rdi,DWORD PTR [r15]
  20da95:	b8 08 00 00 00       	mov    eax,0x8
  20da9a:	31 d2                	xor    edx,edx
  20da9c:	48 89 de             	mov    rsi,rbx
  20da9f:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20daa1:	48 89 c1             	mov    rcx,rax
  20daa4:	48 f7 d9             	neg    rcx
  20daa7:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20daad:	b8 00 00 00 00       	mov    eax,0x0
  20dab2:	48 0f 46 c8          	cmovbe rcx,rax
  20dab6:	48 85 c9             	test   rcx,rcx
  20dab9:	0f 85 46 01 00 00    	jne    20dc05 <getLineNumberInfo+0x335>
            try self.readNoEof(bytes[0..]);
  20dabf:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20dac4:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20dac9:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  20dad0:	00 00 
            return self.readFn(self, buffer);
  20dad2:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20dad7:	48 8d 6c 24 40       	lea    rbp,[rsp+0x40]
  20dadc:	48 89 ee             	mov    rsi,rbp
  20dadf:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20dae4:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20dae8:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20daed:	66 85 c0             	test   ax,ax
  20daf0:	0f 85 e6 01 00 00    	jne    20dcdc <getLineNumberInfo+0x40c>
  20daf6:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  20dafb:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  20db00:	0f 82 e9 00 00 00    	jb     20dbef <getLineNumberInfo+0x31f>
  20db06:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20db0b:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  20db10:	48 c1 e1 08          	shl    rcx,0x8
  20db14:	48 09 c1             	or     rcx,rax
  20db17:	0f b6 54 24 4a       	movzx  edx,BYTE PTR [rsp+0x4a]
  20db1c:	48 c1 e2 10          	shl    rdx,0x10
  20db20:	48 09 ca             	or     rdx,rcx
  20db23:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  20db28:	48 c1 e0 18          	shl    rax,0x18
  20db2c:	48 09 d0             	or     rax,rdx
    is_64.* = (first_32_bits == 0xffffffff);
  20db2f:	83 f8 ff             	cmp    eax,0xffffffff
    if (is_64.*) {
  20db32:	74 3f                	je     20db73 <getLineNumberInfo+0x2a3>
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  20db34:	83 f8 ef             	cmp    eax,0xffffffef
  20db37:	0f 87 9b 01 00 00    	ja     20dcd8 <getLineNumberInfo+0x408>
  20db3d:	45 31 ff             	xor    r15d,r15d
        if (unit_length == 0) return error.MissingDebugInfo;
  20db40:	48 85 c0             	test   rax,rax
  20db43:	74 79                	je     20dbbe <getLineNumberInfo+0x2ee>
        if (compile_unit.index != this_index) {
  20db45:	49 83 c5 01          	add    r13,0x1
  20db49:	4d 3b 6e 10          	cmp    r13,QWORD PTR [r14+0x10]
  20db4d:	0f 84 22 01 00 00    	je     20dc75 <getLineNumberInfo+0x3a5>
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  20db53:	41 0f b6 cf          	movzx  ecx,r15b
  20db57:	48 8d 0c cb          	lea    rcx,[rbx+rcx*8]
            this_offset += next_offset;
  20db5b:	48 8d 1c 08          	lea    rbx,[rax+rcx*1]
  20db5f:	48 83 c3 04          	add    rbx,0x4
    while (this_offset < debug_line_end) : (this_index += 1) {
  20db63:	4c 39 e3             	cmp    rbx,r12
  20db66:	4c 8b 7c 24 60       	mov    r15,QWORD PTR [rsp+0x60]
  20db6b:	0f 82 18 ff ff ff    	jb     20da89 <getLineNumberInfo+0x1b9>
  20db71:	eb 4b                	jmp    20dbbe <getLineNumberInfo+0x2ee>
            try self.readNoEof(bytes[0..]);
  20db73:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20db78:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20db7d:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  20db84:	00 00 
            return self.readFn(self, buffer);
  20db86:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20db8b:	48 89 ee             	mov    rsi,rbp
  20db8e:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20db93:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20db97:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20db9c:	66 85 c0             	test   ax,ax
  20db9f:	0f 85 37 01 00 00    	jne    20dcdc <getLineNumberInfo+0x40c>
  20dba5:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  20dbaa:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  20dbaf:	72 3e                	jb     20dbef <getLineNumberInfo+0x31f>
  20dbb1:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  20dbb6:	41 b7 01             	mov    r15b,0x1
        if (unit_length == 0) return error.MissingDebugInfo;
  20dbb9:	48 85 c0             	test   rax,rax
  20dbbc:	75 87                	jne    20db45 <getLineNumberInfo+0x275>
  20dbbe:	c5 fc 10 05 62 37 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff3762]        # 201328 <__unnamed_67+0x10>
  20dbc5:	ff 
  20dbc6:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  20dbca:	c5 fc 11 40 10       	vmovups YMMWORD PTR [rax+0x10],ymm0
  20dbcf:	c5 fe 6f 05 41 37 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff3741]        # 201318 <__unnamed_67>
  20dbd6:	ff 
  20dbd7:	c5 fe 7f 00          	vmovdqu YMMWORD PTR [rax],ymm0
  20dbdb:	e9 41 fe ff ff       	jmp    20da21 <getLineNumberInfo+0x151>
  20dbe0:	48 83 f9 4b          	cmp    rcx,0x4b
  20dbe4:	0f 85 d5 fd ff ff    	jne    20d9bf <getLineNumberInfo+0xef>
  20dbea:	e9 bd fd ff ff       	jmp    20d9ac <getLineNumberInfo+0xdc>
  20dbef:	66 b8 1e 00          	mov    ax,0x1e
  20dbf3:	e9 e4 00 00 00       	jmp    20dcdc <getLineNumberInfo+0x40c>
  20dbf8:	66 b8 21 00          	mov    ax,0x21
  20dbfc:	48 8b 34 24          	mov    rsi,QWORD PTR [rsp]
  20dc00:	e9 0e 01 00 00       	jmp    20dd13 <getLineNumberInfo+0x443>
  20dc05:	66 b8 05 00          	mov    ax,0x5
  20dc09:	48 8d 51 fa          	lea    rdx,[rcx-0x6]
  20dc0d:	48 83 fa 17          	cmp    rdx,0x17
  20dc11:	48 8b 34 24          	mov    rsi,QWORD PTR [rsp]
  20dc15:	0f 87 e9 00 00 00    	ja     20dd04 <getLineNumberInfo+0x434>
  20dc1b:	48 8d 0d ca 2e ff ff 	lea    rcx,[rip+0xffffffffffff2eca]        # 200aec <__unnamed_128+0x8a4>
  20dc22:	48 63 14 91          	movsxd rdx,DWORD PTR [rcx+rdx*4]
  20dc26:	48 01 ca             	add    rdx,rcx
  20dc29:	ff e2                	jmp    rdx
  20dc2b:	66 b8 20 00          	mov    ax,0x20
  20dc2f:	e9 df 00 00 00       	jmp    20dd13 <getLineNumberInfo+0x443>
  20dc34:	66 b8 1c 00          	mov    ax,0x1c
  20dc38:	e9 82 fd ff ff       	jmp    20d9bf <getLineNumberInfo+0xef>
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  20dc3d:	4c 89 bc 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],r15
  20dc44:	00 
  20dc45:	48 8d 94 24 a8 01 00 	lea    rdx,[rsp+0x1a8]
  20dc4c:	00 
  20dc4d:	48 8d 05 6c ba ff ff 	lea    rax,[rip+0xffffffffffffba6c]        # 2096c0 <FileInStream_readFn>
  20dc54:	48 89 84 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rax
  20dc5b:	00 
  20dc5c:	49 8b b7 a0 00 00 00 	mov    rsi,QWORD PTR [r15+0xa0]
  20dc63:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  20dc68:	48 89 df             	mov    rdi,rbx
  20dc6b:	e8 10 f8 ff ff       	call   20d480 <readStringRaw>
  20dc70:	e9 6a fd ff ff       	jmp    20d9df <getLineNumberInfo+0x10f>
        const version = try in_stream.readInt(st.elf.endian, u16);
  20dc75:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  20dc7a:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  20dc7d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20dc82:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20dc87:	48 c7 44 24 10 02 00 	mov    QWORD PTR [rsp+0x10],0x2
  20dc8e:	00 00 
  20dc90:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20dc95:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  20dc9a:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20dc9f:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20dca3:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20dca8:	66 85 c0             	test   ax,ax
  20dcab:	75 10                	jne    20dcbd <getLineNumberInfo+0x3ed>
  20dcad:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20dcb2:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20dcb6:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20dcbb:	73 7a                	jae    20dd37 <getLineNumberInfo+0x467>
  20dcbd:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  20dcc1:	66 89 01             	mov    WORD PTR [rcx],ax
  20dcc4:	c5 fe 6f 84 24 40 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa40]
  20dccb:	00 00 
  20dccd:	c5 fc 10 8c 24 4e 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa4e]
  20dcd4:	00 00 
  20dcd6:	eb 1d                	jmp    20dcf5 <getLineNumberInfo+0x425>
  20dcd8:	66 b8 23 00          	mov    ax,0x23
  20dcdc:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  20dce0:	66 89 01             	mov    WORD PTR [rcx],ax
  20dce3:	c5 fe 6f 84 24 6e 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa6e]
  20dcea:	00 00 
  20dcec:	c5 fc 10 8c 24 7c 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa7c]
  20dcf3:	00 00 
  20dcf5:	c5 fc 11 49 10       	vmovups YMMWORD PTR [rcx+0x10],ymm1
  20dcfa:	c5 fe 7f 41 02       	vmovdqu YMMWORD PTR [rcx+0x2],ymm0
  20dcff:	e9 1d fd ff ff       	jmp    20da21 <getLineNumberInfo+0x151>
  20dd04:	48 83 f9 4b          	cmp    rcx,0x4b
  20dd08:	75 09                	jne    20dd13 <getLineNumberInfo+0x443>
  20dd0a:	e9 1c ff ff ff       	jmp    20dc2b <getLineNumberInfo+0x35b>
  20dd0f:	66 b8 1c 00          	mov    ax,0x1c
        try in_file.seekTo(this_offset);
  20dd13:	66 89 06             	mov    WORD PTR [rsi],ax
  20dd16:	c5 fe 6f 84 24 9c 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa9c]
  20dd1d:	00 00 
  20dd1f:	c5 fc 10 8c 24 aa 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xaaa]
  20dd26:	00 00 
  20dd28:	c5 fc 11 4e 10       	vmovups YMMWORD PTR [rsi+0x10],ymm1
  20dd2d:	c5 fe 7f 46 02       	vmovdqu YMMWORD PTR [rsi+0x2],ymm0
  20dd32:	e9 ea fc ff ff       	jmp    20da21 <getLineNumberInfo+0x151>
  20dd37:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  20dd3c:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  20dd41:	89 ca                	mov    edx,ecx
  20dd43:	c1 e2 08             	shl    edx,0x8
  20dd46:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20dd48:	c1 e0 08             	shl    eax,0x8
  20dd4b:	09 c8                	or     eax,ecx
    switch (endian) {
  20dd4d:	f6 c3 01             	test   bl,0x1
  20dd50:	66 0f 45 c2          	cmovne ax,dx
        if (version != 2 and version != 4) return error.InvalidDebugInfo;
  20dd54:	44 0f b7 e0          	movzx  r12d,ax
  20dd58:	41 83 fc 02          	cmp    r12d,0x2
  20dd5c:	48 8b 2c 24          	mov    rbp,QWORD PTR [rsp]
  20dd60:	74 0a                	je     20dd6c <getLineNumberInfo+0x49c>
  20dd62:	41 83 fc 04          	cmp    r12d,0x4
  20dd66:	0f 85 ac 00 00 00    	jne    20de18 <getLineNumberInfo+0x548>
  20dd6c:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  20dd71:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
        const prologue_length = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  20dd74:	45 84 ff             	test   r15b,r15b
  20dd77:	74 44                	je     20ddbd <getLineNumberInfo+0x4ed>
  20dd79:	0f b6 d3             	movzx  edx,bl
  20dd7c:	48 8d bc 24 90 01 00 	lea    rdi,[rsp+0x190]
  20dd83:	00 
  20dd84:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
  20dd89:	48 89 de             	mov    rsi,rbx
  20dd8c:	e8 ef b6 ff ff       	call   209480 <InStream(ReadError)_readInt.16>
  20dd91:	0f b7 84 24 90 01 00 	movzx  eax,WORD PTR [rsp+0x190]
  20dd98:	00 
  20dd99:	66 85 c0             	test   ax,ax
  20dd9c:	0f 84 95 00 00 00    	je     20de37 <getLineNumberInfo+0x567>
  20dda2:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  20dda6:	c5 fe 6f 84 24 12 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa12]
  20ddad:	00 00 
  20ddaf:	c5 fc 10 8c 24 20 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa20]
  20ddb6:	00 00 
  20ddb8:	e9 5a fc ff ff       	jmp    20da17 <getLineNumberInfo+0x147>
            try self.readNoEof(bytes[0..]);
  20ddbd:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20ddc2:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20ddc7:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  20ddce:	00 00 
  20ddd0:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20ddd5:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  20ddda:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20dddf:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20dde3:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20dde8:	66 85 c0             	test   ax,ax
  20ddeb:	75 10                	jne    20ddfd <getLineNumberInfo+0x52d>
  20dded:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20ddf2:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20ddf6:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20ddfb:	73 44                	jae    20de41 <getLineNumberInfo+0x571>
  20ddfd:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  20de01:	c5 fe 6f 84 24 e4 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x9e4]
  20de08:	00 00 
  20de0a:	c5 fc 10 8c 24 f2 09 	vmovups ymm1,YMMWORD PTR [rsp+0x9f2]
  20de11:	00 00 
  20de13:	e9 ff fb ff ff       	jmp    20da17 <getLineNumberInfo+0x147>
        if (version != 2 and version != 4) return error.InvalidDebugInfo;
  20de18:	c5 fc 10 05 d8 34 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff34d8]        # 2012f8 <__unnamed_68+0x10>
  20de1f:	ff 
  20de20:	c5 fc 11 45 10       	vmovups YMMWORD PTR [rbp+0x10],ymm0
  20de25:	c5 fe 6f 05 bb 34 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff34bb]        # 2012e8 <__unnamed_68>
  20de2c:	ff 
  20de2d:	c5 fe 7f 45 00       	vmovdqu YMMWORD PTR [rbp+0x0],ymm0
  20de32:	e9 ea fb ff ff       	jmp    20da21 <getLineNumberInfo+0x151>
        const prologue_length = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  20de37:	4c 8b b4 24 98 01 00 	mov    r14,QWORD PTR [rsp+0x198]
  20de3e:	00 
  20de3f:	eb 4f                	jmp    20de90 <getLineNumberInfo+0x5c0>
  20de41:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  20de46:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  20de4b:	f6 c3 01             	test   bl,0x1
  20de4e:	74 1b                	je     20de6b <getLineNumberInfo+0x59b>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20de50:	c1 e1 08             	shl    ecx,0x8
  20de53:	09 c1                	or     ecx,eax
  20de55:	0f b6 54 24 4a       	movzx  edx,BYTE PTR [rsp+0x4a]
  20de5a:	c1 e2 10             	shl    edx,0x10
  20de5d:	09 ca                	or     edx,ecx
  20de5f:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  20de64:	c1 e0 18             	shl    eax,0x18
  20de67:	09 d0                	or     eax,edx
  20de69:	eb 19                	jmp    20de84 <getLineNumberInfo+0x5b4>
                result = (result << 8) | b;
  20de6b:	c1 e0 08             	shl    eax,0x8
  20de6e:	09 c8                	or     eax,ecx
  20de70:	c1 e0 08             	shl    eax,0x8
  20de73:	0f b6 4c 24 4a       	movzx  ecx,BYTE PTR [rsp+0x4a]
  20de78:	09 c1                	or     ecx,eax
  20de7a:	c1 e1 08             	shl    ecx,0x8
  20de7d:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  20de82:	09 c8                	or     eax,ecx
  20de84:	41 89 c6             	mov    r14d,eax
  20de87:	48 8b 2c 24          	mov    rbp,QWORD PTR [rsp]
  20de8b:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20de90:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  20de95:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20de98:	45 31 c0             	xor    r8d,r8d
  20de9b:	b8 08 00 00 00       	mov    eax,0x8
  20dea0:	be 00 00 00 00       	mov    esi,0x0
  20dea5:	ba 01 00 00 00       	mov    edx,0x1
  20deaa:	0f 05                	syscall 
  20deac:	49 89 c5             	mov    r13,rax
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20deaf:	4c 89 e9             	mov    rcx,r13
  20deb2:	48 f7 d9             	neg    rcx
  20deb5:	49 81 fd 00 f0 ff ff 	cmp    r13,0xfffffffffffff000
  20debc:	49 0f 46 c8          	cmovbe rcx,r8
                if (err > 0) {
  20dec0:	48 83 f9 1d          	cmp    rcx,0x1d
  20dec4:	77 1a                	ja     20dee0 <getLineNumberInfo+0x610>
  20dec6:	66 b8 1c 00          	mov    ax,0x1c
  20deca:	48 8d 15 7b 2c ff ff 	lea    rdx,[rip+0xffffffffffff2c7b]        # 200b4c <__unnamed_128+0x904>
  20ded1:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  20ded5:	48 01 d1             	add    rcx,rdx
  20ded8:	ff e1                	jmp    rcx
  20deda:	66 b8 20 00          	mov    ax,0x20
  20dede:	eb 0a                	jmp    20deea <getLineNumberInfo+0x61a>
  20dee0:	48 83 f9 4b          	cmp    rcx,0x4b
  20dee4:	74 f4                	je     20deda <getLineNumberInfo+0x60a>
  20dee6:	66 b8 05 00          	mov    ax,0x5
        const prog_start_offset = (try in_file.getPos()) + prologue_length;
  20deea:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  20deee:	c5 fe 6f 84 24 b6 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x9b6]
  20def5:	00 00 
  20def7:	c5 fc 10 8c 24 c4 09 	vmovups ymm1,YMMWORD PTR [rsp+0x9c4]
  20defe:	00 00 
  20df00:	e9 12 fb ff ff       	jmp    20da17 <getLineNumberInfo+0x147>
            try self.readNoEof(result[0..]);
  20df05:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20df0a:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20df0f:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20df16:	00 00 
  20df18:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20df1d:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  20df22:	48 89 de             	mov    rsi,rbx
  20df25:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20df29:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20df2e:	66 85 c0             	test   ax,ax
  20df31:	75 10                	jne    20df43 <getLineNumberInfo+0x673>
  20df33:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20df38:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20df3c:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20df41:	73 1e                	jae    20df61 <getLineNumberInfo+0x691>
  20df43:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const minimum_instruction_length = try in_stream.readByte();
  20df47:	66 89 01             	mov    WORD PTR [rcx],ax
  20df4a:	c5 fe 6f 84 24 88 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x988]
  20df51:	00 00 
  20df53:	c5 fc 10 8c 24 96 09 	vmovups ymm1,YMMWORD PTR [rsp+0x996]
  20df5a:	00 00 
  20df5c:	e9 94 fd ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
            return result[0];
  20df61:	44 0f b6 7c 24 48    	movzx  r15d,BYTE PTR [rsp+0x48]
  20df67:	4d 85 ff             	test   r15,r15
        if (minimum_instruction_length == 0) return error.InvalidDebugInfo;
  20df6a:	0f 84 62 15 00 00    	je     20f4d2 <getLineNumberInfo+0x1c02>
        if (version >= 4) {
  20df70:	41 83 fc 04          	cmp    r12d,0x4
  20df74:	72 5e                	jb     20dfd4 <getLineNumberInfo+0x704>
            try self.readNoEof(result[0..]);
  20df76:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20df7b:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20df80:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20df87:	00 00 
  20df89:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20df8e:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  20df93:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20df98:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20df9c:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20dfa1:	66 85 c0             	test   ax,ax
  20dfa4:	75 10                	jne    20dfb6 <getLineNumberInfo+0x6e6>
  20dfa6:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20dfab:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20dfaf:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20dfb4:	73 1e                	jae    20dfd4 <getLineNumberInfo+0x704>
  20dfb6:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            _ = try in_stream.readByte();
  20dfba:	66 89 01             	mov    WORD PTR [rcx],ax
  20dfbd:	c5 fe 6f 84 24 5a 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x95a]
  20dfc4:	00 00 
  20dfc6:	c5 fc 10 8c 24 68 09 	vmovups ymm1,YMMWORD PTR [rsp+0x968]
  20dfcd:	00 00 
  20dfcf:	e9 21 fd ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
            try self.readNoEof(result[0..]);
  20dfd4:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20dfd9:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20dfde:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20dfe5:	00 00 
  20dfe7:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20dfec:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  20dff1:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20dff6:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20dffa:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20dfff:	66 85 c0             	test   ax,ax
  20e002:	75 10                	jne    20e014 <getLineNumberInfo+0x744>
  20e004:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20e009:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20e00d:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20e012:	73 1e                	jae    20e032 <getLineNumberInfo+0x762>
  20e014:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const default_is_stmt = (try in_stream.readByte()) != 0;
  20e018:	66 89 01             	mov    WORD PTR [rcx],ax
  20e01b:	c5 fe 6f 84 24 2c 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x92c]
  20e022:	00 00 
  20e024:	c5 fc 10 8c 24 3a 09 	vmovups ymm1,YMMWORD PTR [rsp+0x93a]
  20e02b:	00 00 
  20e02d:	e9 c3 fc ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
            return result[0];
  20e032:	40 8a 6c 24 48       	mov    bpl,BYTE PTR [rsp+0x48]
            try self.readNoEof(result[0..]);
  20e037:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20e03c:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e041:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e048:	00 00 
  20e04a:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e04f:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  20e054:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20e059:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20e05d:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20e062:	66 85 c0             	test   ax,ax
  20e065:	75 10                	jne    20e077 <getLineNumberInfo+0x7a7>
  20e067:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20e06c:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20e070:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20e075:	73 1e                	jae    20e095 <getLineNumberInfo+0x7c5>
  20e077:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const line_base = try in_stream.readByteSigned();
  20e07b:	66 89 01             	mov    WORD PTR [rcx],ax
  20e07e:	c5 fe 6f 84 24 fe 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8fe]
  20e085:	00 00 
  20e087:	c5 fc 10 8c 24 0c 09 	vmovups ymm1,YMMWORD PTR [rsp+0x90c]
  20e08e:	00 00 
  20e090:	e9 60 fc ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
            return result[0];
  20e095:	48 0f be 44 24 48    	movsx  rax,BYTE PTR [rsp+0x48]
            try self.readNoEof(result[0..]);
  20e09b:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  20e0a2:	00 
  20e0a3:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20e0a8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e0ad:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e0b4:	00 00 
  20e0b6:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e0bb:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  20e0c0:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20e0c5:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20e0c9:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20e0ce:	66 85 c0             	test   ax,ax
  20e0d1:	75 10                	jne    20e0e3 <getLineNumberInfo+0x813>
  20e0d3:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20e0d8:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20e0dc:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20e0e1:	73 1e                	jae    20e101 <getLineNumberInfo+0x831>
  20e0e3:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const line_range = try in_stream.readByte();
  20e0e7:	66 89 01             	mov    WORD PTR [rcx],ax
  20e0ea:	c5 fe 6f 84 24 d0 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8d0]
  20e0f1:	00 00 
  20e0f3:	c5 fc 10 8c 24 de 08 	vmovups ymm1,YMMWORD PTR [rsp+0x8de]
  20e0fa:	00 00 
  20e0fc:	e9 f4 fb ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
            return result[0];
  20e101:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
  20e105:	88 44 24 5f          	mov    BYTE PTR [rsp+0x5f],al
        if (line_range == 0) return error.InvalidDebugInfo;
  20e109:	84 c0                	test   al,al
  20e10b:	0f 84 c1 13 00 00    	je     20f4d2 <getLineNumberInfo+0x1c02>
            try self.readNoEof(result[0..]);
  20e111:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20e116:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e11b:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e122:	00 00 
  20e124:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e129:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  20e12e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20e133:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20e137:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20e13c:	66 85 c0             	test   ax,ax
  20e13f:	75 10                	jne    20e151 <getLineNumberInfo+0x881>
  20e141:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20e146:	66 b8 1e 00          	mov    ax,0x1e
            if (amt_read < buf.len) return error.EndOfStream;
  20e14a:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20e14f:	73 1e                	jae    20e16f <getLineNumberInfo+0x89f>
  20e151:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const opcode_base = try in_stream.readByte();
  20e155:	66 89 01             	mov    WORD PTR [rcx],ax
  20e158:	c5 fe 6f 84 24 a2 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8a2]
  20e15f:	00 00 
  20e161:	c5 fc 10 8c 24 b0 08 	vmovups ymm1,YMMWORD PTR [rsp+0x8b0]
  20e168:	00 00 
  20e16a:	e9 86 fb ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
            return result[0];
  20e16f:	8a 4c 24 48          	mov    cl,BYTE PTR [rsp+0x48]
  20e173:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  20e178:	48 8b 80 a0 00 00 00 	mov    rax,QWORD PTR [rax+0xa0]
  20e17f:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  20e184:	88 4c 24 5e          	mov    BYTE PTR [rsp+0x5e],cl
        const standard_opcode_lengths = try st.allocator().alloc(u8, opcode_base - 1);
  20e188:	89 c8                	mov    eax,ecx
  20e18a:	04 ff                	add    al,0xff
        if (n == 0) {
  20e18c:	74 48                	je     20e1d6 <getLineNumberInfo+0x906>
  20e18e:	0f b6 d0             	movzx  edx,al
  20e191:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20e196:	b9 01 00 00 00       	mov    ecx,0x1
  20e19b:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  20e1a0:	48 89 94 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rdx
  20e1a7:	00 
  20e1a8:	ff 16                	call   QWORD PTR [rsi]
  20e1aa:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20e1af:	66 85 c0             	test   ax,ax
  20e1b2:	0f 84 91 00 00 00    	je     20e249 <getLineNumberInfo+0x979>
  20e1b8:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  20e1bc:	66 89 01             	mov    WORD PTR [rcx],ax
  20e1bf:	c5 fe 6f 84 24 74 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x874]
  20e1c6:	00 00 
  20e1c8:	c5 fc 10 8c 24 82 08 	vmovups ymm1,YMMWORD PTR [rsp+0x882]
  20e1cf:	00 00 
  20e1d1:	e9 1f fb ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20e1d6:	31 c0                	xor    eax,eax
  20e1d8:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  20e1df:	00 
            return Self{
  20e1e0:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20e1e4:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  20e1eb:	00 00 
  20e1ed:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x0
  20e1f4:	00 00 00 00 00 
  20e1f9:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
        var include_directories = ArrayList([]u8).init(st.allocator());
  20e1fe:	48 89 b4 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rsi
  20e205:	00 
  20e206:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e20b:	48 8d 94 24 b0 00 00 	lea    rdx,[rsp+0xb0]
  20e212:	00 
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20e213:	b9 08 00 00 00       	mov    ecx,0x8
  20e218:	e8 d3 23 00 00       	call   2105f0 <Allocator_alignedRealloc.59>
  20e21d:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20e222:	66 85 c0             	test   ax,ax
  20e225:	0f 84 bd 00 00 00    	je     20e2e8 <getLineNumberInfo+0xa18>
  20e22b:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try include_directories.append(compile_unit_cwd);
  20e22f:	66 89 01             	mov    WORD PTR [rcx],ax
  20e232:	c5 fe 6f 84 24 18 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x818]
  20e239:	00 00 
  20e23b:	c5 fc 10 8c 24 26 08 	vmovups ymm1,YMMWORD PTR [rsp+0x826]
  20e242:	00 00 
  20e244:	e9 ac fa ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
        assert(byte_slice.len == byte_count);
  20e249:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20e250:	00 
  20e251:	48 39 44 24 30       	cmp    QWORD PTR [rsp+0x30],rax
    if (!ok) {
  20e256:	0f 85 7d 16 00 00    	jne    20f8d9 <getLineNumberInfo+0x2009>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20e25c:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20e261:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  20e268:	00 
  20e269:	45 31 e4             	xor    r12d,r12d
  20e26c:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
            try self.readNoEof(result[0..]);
  20e271:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20e276:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e27b:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e282:	00 00 
            return self.readFn(self, buffer);
  20e284:	48 89 df             	mov    rdi,rbx
  20e287:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20e28c:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20e291:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20e295:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20e29a:	66 85 c0             	test   ax,ax
  20e29d:	0f 85 cf 00 00 00    	jne    20e372 <getLineNumberInfo+0xaa2>
  20e2a3:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  20e2a8:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  20e2ad:	0f 82 bb 00 00 00    	jb     20e36e <getLineNumberInfo+0xa9e>
            return result[0];
  20e2b3:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                standard_opcode_lengths[i] = try in_stream.readByte();
  20e2b8:	48 8b 8c 24 d8 00 00 	mov    rcx,QWORD PTR [rsp+0xd8]
  20e2bf:	00 
  20e2c0:	42 88 04 21          	mov    BYTE PTR [rcx+r12*1],al
            while (i < opcode_base - 1) : (i += 1) {
  20e2c4:	49 83 c4 01          	add    r12,0x1
  20e2c8:	4c 3b a4 24 98 00 00 	cmp    r12,QWORD PTR [rsp+0x98]
  20e2cf:	00 
  20e2d0:	72 9f                	jb     20e271 <getLineNumberInfo+0x9a1>
  20e2d2:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  20e2d7:	48 8b 80 a0 00 00 00 	mov    rax,QWORD PTR [rax+0xa0]
  20e2de:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  20e2e3:	e9 f8 fe ff ff       	jmp    20e1e0 <getLineNumberInfo+0x910>
  20e2e8:	c5 f8 10 44 24 28    	vmovups xmm0,XMMWORD PTR [rsp+0x28]
  20e2ee:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  20e2f5:	00 00 
            const result = &self.items[self.len];
  20e2f7:	4c 8b a4 24 b0 00 00 	mov    r12,QWORD PTR [rsp+0xb0]
  20e2fe:	00 
            self.len = new_length;
  20e2ff:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x1
  20e306:	00 01 00 00 00 
            new_item_ptr.* = item;
  20e30b:	c5 f9 6f 84 24 e0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1e0]
  20e312:	00 00 
  20e314:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
  20e31a:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  20e31f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e324:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20e329:	48 8d 0d 90 b3 ff ff 	lea    rcx,[rip+0xffffffffffffb390]        # 2096c0 <FileInStream_readFn>
  20e330:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20e335:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
  20e33c:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  20e341:	e8 3a f1 ff ff       	call   20d480 <readStringRaw>
  20e346:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const dir = try st.readString();
  20e34b:	66 85 c0             	test   ax,ax
  20e34e:	74 40                	je     20e390 <getLineNumberInfo+0xac0>
  20e350:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  20e354:	66 89 01             	mov    WORD PTR [rcx],ax
  20e357:	c5 fe 6f 84 24 ea 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x7ea]
  20e35e:	00 00 
  20e360:	c5 fc 10 8c 24 f8 07 	vmovups ymm1,YMMWORD PTR [rsp+0x7f8]
  20e367:	00 00 
  20e369:	e9 87 f9 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20e36e:	66 b8 1e 00          	mov    ax,0x1e
  20e372:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                standard_opcode_lengths[i] = try in_stream.readByte();
  20e376:	66 89 01             	mov    WORD PTR [rcx],ax
  20e379:	c5 fe 6f 84 24 46 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x846]
  20e380:	00 00 
  20e382:	c5 fc 10 8c 24 54 08 	vmovups ymm1,YMMWORD PTR [rsp+0x854]
  20e389:	00 00 
  20e38b:	e9 65 f9 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20e390:	4d 01 f5             	add    r13,r14
  20e393:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  20e399:	c5 f9 7f 84 24 50 01 	vmovdqa XMMWORD PTR [rsp+0x150],xmm0
  20e3a0:	00 00 
  20e3a2:	41 be 01 00 00 00    	mov    r14d,0x1
            if (dir.len == 0) break;
  20e3a8:	c5 f9 6f 84 24 50 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x150]
  20e3af:	00 00 
  20e3b1:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  20e3b7:	48 85 c0             	test   rax,rax
  20e3ba:	0f 84 ce 00 00 00    	je     20e48e <getLineNumberInfo+0xbbe>
            var better_capacity = self.items.len;
  20e3c0:	48 8b 8c 24 b8 00 00 	mov    rcx,QWORD PTR [rsp+0xb8]
  20e3c7:	00 
            if (better_capacity >= new_capacity) return;
  20e3c8:	4c 39 f1             	cmp    rcx,r14
  20e3cb:	77 51                	ja     20e41e <getLineNumberInfo+0xb4e>
                better_capacity += better_capacity / 2 + 8;
  20e3cd:	48 89 c8             	mov    rax,rcx
  20e3d0:	48 d1 e8             	shr    rax,1
  20e3d3:	48 01 c1             	add    rcx,rax
  20e3d6:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20e3da:	4c 39 f1             	cmp    rcx,r14
  20e3dd:	76 ee                	jbe    20e3cd <getLineNumberInfo+0xafd>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20e3df:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e3e4:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  20e3e9:	48 8d 94 24 b0 00 00 	lea    rdx,[rsp+0xb0]
  20e3f0:	00 
  20e3f1:	e8 fa 21 00 00       	call   2105f0 <Allocator_alignedRealloc.59>
  20e3f6:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20e3fb:	66 85 c0             	test   ax,ax
  20e3fe:	0f 85 94 01 00 00    	jne    20e598 <getLineNumberInfo+0xcc8>
  20e404:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  20e409:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20e40d:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  20e414:	00 00 
            const result = &self.items[self.len];
  20e416:	4c 8b a4 24 b0 00 00 	mov    r12,QWORD PTR [rsp+0xb0]
  20e41d:	00 
  20e41e:	49 8d 5e 01          	lea    rbx,[r14+0x1]
  20e422:	49 c1 e6 04          	shl    r14,0x4
            self.len = new_length;
  20e426:	48 89 9c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rbx
  20e42d:	00 
            new_item_ptr.* = item;
  20e42e:	c5 f8 28 84 24 50 01 	vmovaps xmm0,XMMWORD PTR [rsp+0x150]
  20e435:	00 00 
  20e437:	c4 81 78 11 04 34    	vmovups XMMWORD PTR [r12+r14*1],xmm0
  20e43d:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  20e442:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e447:	48 8d 0d 72 b2 ff ff 	lea    rcx,[rip+0xffffffffffffb272]        # 2096c0 <FileInStream_readFn>
  20e44e:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20e453:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  20e45a:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e45f:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20e464:	e8 17 f0 ff ff       	call   20d480 <readStringRaw>
  20e469:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20e46e:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  20e474:	c5 f9 7f 84 24 50 01 	vmovdqa XMMWORD PTR [rsp+0x150],xmm0
  20e47b:	00 00 
  20e47d:	49 89 de             	mov    r14,rbx
            const dir = try st.readString();
  20e480:	66 85 c0             	test   ax,ax
  20e483:	0f 84 1f ff ff ff    	je     20e3a8 <getLineNumberInfo+0xad8>
  20e489:	e9 c2 fe ff ff       	jmp    20e350 <getLineNumberInfo+0xa80>
  20e48e:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  20e493:	48 8b b2 a0 00 00 00 	mov    rsi,QWORD PTR [rdx+0xa0]
            return Self{
  20e49a:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20e49e:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
  20e4a4:	48 c7 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],0x0
  20e4ab:	00 00 00 00 00 
        var file_entries = ArrayList(FileEntry).init(st.allocator());
  20e4b0:	48 89 b4 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rsi
  20e4b7:	00 
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  20e4b8:	c5 fc 28 05 00 1d ff 	vmovaps ymm0,YMMWORD PTR [rip+0xffffffffffff1d00]        # 2001c0 <app_mask-0x60>
  20e4bf:	ff 
  20e4c0:	c5 fc 11 84 24 e0 00 	vmovups YMMWORD PTR [rsp+0xe0],ymm0
  20e4c7:	00 00 
        const default_is_stmt = (try in_stream.readByte()) != 0;
  20e4c9:	40 84 ed             	test   bpl,bpl
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  20e4cc:	0f 95 84 24 00 01 00 	setne  BYTE PTR [rsp+0x100]
  20e4d3:	00 
  20e4d4:	66 c7 84 24 01 01 00 	mov    WORD PTR [rsp+0x101],0x0
  20e4db:	00 00 00 
  20e4de:	8b 84 24 d3 00 00 00 	mov    eax,DWORD PTR [rsp+0xd3]
  20e4e5:	89 84 24 03 01 00 00 	mov    DWORD PTR [rsp+0x103],eax
            return self.items[0..self.len];
  20e4ec:	48 8b 84 24 b0 00 00 	mov    rax,QWORD PTR [rsp+0xb0]
  20e4f3:	00 
  20e4f4:	8a 8c 24 d7 00 00 00 	mov    cl,BYTE PTR [rsp+0xd7]
  20e4fb:	88 8c 24 07 01 00 00 	mov    BYTE PTR [rsp+0x107],cl
  20e502:	48 8b 8c 24 a0 00 00 	mov    rcx,QWORD PTR [rsp+0xa0]
  20e509:	00 
  20e50a:	48 89 8c 24 08 01 00 	mov    QWORD PTR [rsp+0x108],rcx
  20e511:	00 
  20e512:	48 89 84 24 10 01 00 	mov    QWORD PTR [rsp+0x110],rax
  20e519:	00 
  20e51a:	4c 89 b4 24 18 01 00 	mov    QWORD PTR [rsp+0x118],r14
  20e521:	00 
  20e522:	48 8d 44 24 70       	lea    rax,[rsp+0x70]
  20e527:	48 89 84 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rax
  20e52e:	00 
  20e52f:	48 c7 84 24 28 01 00 	mov    QWORD PTR [rsp+0x128],0x0
  20e536:	00 00 00 00 00 
  20e53b:	c5 fe 6f 84 24 f8 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xaf8]
  20e542:	00 00 
  20e544:	c5 fe 7f 84 24 30 01 	vmovdqu YMMWORD PTR [rsp+0x130],ymm0
  20e54b:	00 00 
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  20e54d:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  20e552:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20e557:	48 8d 05 62 b1 ff ff 	lea    rax,[rip+0xffffffffffffb162]        # 2096c0 <FileInStream_readFn>
  20e55e:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20e563:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  20e568:	c5 f8 77             	vzeroupper 
  20e56b:	e8 10 ef ff ff       	call   20d480 <readStringRaw>
  20e570:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const file_name = try st.readString();
  20e575:	66 85 c0             	test   ax,ax
  20e578:	74 3c                	je     20e5b6 <getLineNumberInfo+0xce6>
  20e57a:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  20e57e:	66 89 01             	mov    WORD PTR [rcx],ax
  20e581:	c5 fe 6f 84 24 8e 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x78e]
  20e588:	00 00 
  20e58a:	c5 fc 10 8c 24 9c 07 	vmovups ymm1,YMMWORD PTR [rsp+0x79c]
  20e591:	00 00 
  20e593:	e9 5d f7 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20e598:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            try include_directories.append(dir);
  20e59c:	66 89 01             	mov    WORD PTR [rcx],ax
  20e59f:	c5 fc 10 84 24 bc 07 	vmovups ymm0,YMMWORD PTR [rsp+0x7bc]
  20e5a6:	00 00 
  20e5a8:	c5 fc 10 8c 24 ca 07 	vmovups ymm1,YMMWORD PTR [rsp+0x7ca]
  20e5af:	00 00 
  20e5b1:	e9 3f f7 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20e5b6:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  20e5bc:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  20e5c3:	00 00 
            if (file_name.len == 0) break;
  20e5c5:	c5 f9 6f 84 24 a0 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0xa0]
  20e5cc:	00 00 
  20e5ce:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  20e5d4:	48 85 c0             	test   rax,rax
  20e5d7:	0f 84 44 03 00 00    	je     20e921 <getLineNumberInfo+0x1051>
            try self.readNoEof(result[0..]);
  20e5dd:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20e5e2:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e5e7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e5ee:	00 00 
            return self.readFn(self, buffer);
  20e5f0:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e5f5:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20e5fa:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20e5ff:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20e603:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20e608:	66 85 c0             	test   ax,ax
  20e60b:	0f 85 ca 02 00 00    	jne    20e8db <getLineNumberInfo+0x100b>
  20e611:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20e616:	45 31 e4             	xor    r12d,r12d
  20e619:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  20e61b:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20e620:	0f 82 ab 02 00 00    	jb     20e8d1 <getLineNumberInfo+0x1001>
            return result[0];
  20e626:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20e62b:	89 c2                	mov    edx,eax
  20e62d:	83 e2 7f             	and    edx,0x7f
  20e630:	89 ee                	mov    esi,ebp
  20e632:	83 e6 3f             	and    esi,0x3f
  20e635:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20e63a:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20e63f:	48 39 d6             	cmp    rsi,rdx
  20e642:	0f 85 8f 02 00 00    	jne    20e8d7 <getLineNumberInfo+0x1007>
        result |= operand;
  20e648:	49 09 cc             	or     r12,rcx
        if ((byte & 0b10000000) == 0) return result;
  20e64b:	84 c0                	test   al,al
  20e64d:	79 3e                	jns    20e68d <getLineNumberInfo+0xdbd>
        shift += 7;
  20e64f:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  20e653:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20e658:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e65d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e664:	00 00 
            return self.readFn(self, buffer);
  20e666:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e66b:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20e670:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20e675:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20e679:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20e67e:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20e683:	66 85 c0             	test   ax,ax
  20e686:	74 93                	je     20e61b <getLineNumberInfo+0xd4b>
  20e688:	e9 4e 02 00 00       	jmp    20e8db <getLineNumberInfo+0x100b>
            try self.readNoEof(result[0..]);
  20e68d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20e692:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e697:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e69e:	00 00 
            return self.readFn(self, buffer);
  20e6a0:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e6a5:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20e6aa:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20e6af:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20e6b3:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20e6b8:	66 85 c0             	test   ax,ax
  20e6bb:	0f 85 42 02 00 00    	jne    20e903 <getLineNumberInfo+0x1033>
  20e6c1:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20e6c6:	45 31 f6             	xor    r14d,r14d
  20e6c9:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  20e6cb:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20e6d0:	0f 82 23 02 00 00    	jb     20e8f9 <getLineNumberInfo+0x1029>
            return result[0];
  20e6d6:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20e6db:	89 c2                	mov    edx,eax
  20e6dd:	83 e2 7f             	and    edx,0x7f
  20e6e0:	89 ee                	mov    esi,ebp
  20e6e2:	83 e6 3f             	and    esi,0x3f
  20e6e5:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20e6ea:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20e6ef:	48 39 d6             	cmp    rsi,rdx
  20e6f2:	0f 85 07 02 00 00    	jne    20e8ff <getLineNumberInfo+0x102f>
        result |= operand;
  20e6f8:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  20e6fb:	84 c0                	test   al,al
  20e6fd:	79 3e                	jns    20e73d <getLineNumberInfo+0xe6d>
        shift += 7;
  20e6ff:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  20e703:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20e708:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e70d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e714:	00 00 
            return self.readFn(self, buffer);
  20e716:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e71b:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20e720:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20e725:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20e729:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20e72e:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20e733:	66 85 c0             	test   ax,ax
  20e736:	74 93                	je     20e6cb <getLineNumberInfo+0xdfb>
  20e738:	e9 c6 01 00 00       	jmp    20e903 <getLineNumberInfo+0x1033>
            try self.readNoEof(result[0..]);
  20e73d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20e742:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e747:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e74e:	00 00 
            return self.readFn(self, buffer);
  20e750:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e755:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20e75a:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20e75f:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20e763:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20e768:	66 85 c0             	test   ax,ax
  20e76b:	0f 85 05 02 00 00    	jne    20e976 <getLineNumberInfo+0x10a6>
  20e771:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20e776:	31 db                	xor    ebx,ebx
  20e778:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  20e77a:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20e77f:	0f 82 e7 01 00 00    	jb     20e96c <getLineNumberInfo+0x109c>
            return result[0];
  20e785:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20e78a:	89 c2                	mov    edx,eax
  20e78c:	83 e2 7f             	and    edx,0x7f
  20e78f:	89 ee                	mov    esi,ebp
  20e791:	83 e6 3f             	and    esi,0x3f
  20e794:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20e799:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20e79e:	48 39 d6             	cmp    rsi,rdx
  20e7a1:	0f 85 cb 01 00 00    	jne    20e972 <getLineNumberInfo+0x10a2>
        result |= operand;
  20e7a7:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  20e7aa:	84 c0                	test   al,al
  20e7ac:	79 3e                	jns    20e7ec <getLineNumberInfo+0xf1c>
        shift += 7;
  20e7ae:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  20e7b2:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20e7b7:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e7bc:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e7c3:	00 00 
            return self.readFn(self, buffer);
  20e7c5:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e7ca:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20e7cf:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20e7d4:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20e7d8:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20e7dd:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20e7e2:	66 85 c0             	test   ax,ax
  20e7e5:	74 93                	je     20e77a <getLineNumberInfo+0xeaa>
  20e7e7:	e9 8a 01 00 00       	jmp    20e976 <getLineNumberInfo+0x10a6>
            const new_length = self.len + 1;
  20e7ec:	48 8b ac 24 80 00 00 	mov    rbp,QWORD PTR [rsp+0x80]
  20e7f3:	00 
            var better_capacity = self.items.len;
  20e7f4:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
            if (better_capacity >= new_capacity) return;
  20e7f9:	48 39 e9             	cmp    rcx,rbp
  20e7fc:	76 05                	jbe    20e803 <getLineNumberInfo+0xf33>
            const result = &self.items[self.len];
  20e7fe:	48 89 e8             	mov    rax,rbp
  20e801:	eb 4e                	jmp    20e851 <getLineNumberInfo+0xf81>
                better_capacity += better_capacity / 2 + 8;
  20e803:	48 89 c8             	mov    rax,rcx
  20e806:	48 d1 e8             	shr    rax,1
  20e809:	48 01 c1             	add    rcx,rax
  20e80c:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20e810:	48 39 e9             	cmp    rcx,rbp
  20e813:	76 ee                	jbe    20e803 <getLineNumberInfo+0xf33>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20e815:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  20e81c:	00 
  20e81d:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e822:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  20e827:	e8 24 20 00 00       	call   210850 <Allocator_alignedRealloc.62>
  20e82c:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20e831:	66 85 c0             	test   ax,ax
  20e834:	0f 85 bc 0c 00 00    	jne    20f4f6 <getLineNumberInfo+0x1c26>
  20e83a:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  20e83f:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20e843:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
            const result = &self.items[self.len];
  20e849:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  20e850:	00 
  20e851:	48 83 c5 01          	add    rbp,0x1
  20e855:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  20e85a:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  20e85e:	48 89 ac 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rbp
  20e865:	00 
            new_item_ptr.* = item;
  20e866:	c5 f8 28 84 24 a0 00 	vmovaps xmm0,XMMWORD PTR [rsp+0xa0]
  20e86d:	00 00 
  20e86f:	c5 f8 11 04 c1       	vmovups XMMWORD PTR [rcx+rax*8],xmm0
  20e874:	4c 89 64 c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],r12
  20e879:	4c 89 74 c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],r14
  20e87e:	48 89 5c c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rbx
  20e883:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  20e888:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e88d:	48 8d 0d 2c ae ff ff 	lea    rcx,[rip+0xffffffffffffae2c]        # 2096c0 <FileInStream_readFn>
  20e894:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20e899:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  20e8a0:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e8a5:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20e8aa:	e8 d1 eb ff ff       	call   20d480 <readStringRaw>
  20e8af:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20e8b4:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
            const file_name = try st.readString();
  20e8ba:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  20e8c1:	00 00 
  20e8c3:	66 85 c0             	test   ax,ax
  20e8c6:	0f 84 f9 fc ff ff    	je     20e5c5 <getLineNumberInfo+0xcf5>
  20e8cc:	e9 a9 fc ff ff       	jmp    20e57a <getLineNumberInfo+0xcaa>
  20e8d1:	66 b8 1e 00          	mov    ax,0x1e
  20e8d5:	eb 04                	jmp    20e8db <getLineNumberInfo+0x100b>
  20e8d7:	66 b8 23 00          	mov    ax,0x23
  20e8db:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const dir_index = try readULeb128(in_stream);
  20e8df:	66 89 01             	mov    WORD PTR [rcx],ax
  20e8e2:	c5 fe 6f 84 24 60 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x760]
  20e8e9:	00 00 
  20e8eb:	c5 fc 10 8c 24 6e 07 	vmovups ymm1,YMMWORD PTR [rsp+0x76e]
  20e8f2:	00 00 
  20e8f4:	e9 fc f3 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20e8f9:	66 b8 1e 00          	mov    ax,0x1e
  20e8fd:	eb 04                	jmp    20e903 <getLineNumberInfo+0x1033>
  20e8ff:	66 b8 23 00          	mov    ax,0x23
  20e903:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const mtime = try readULeb128(in_stream);
  20e907:	66 89 01             	mov    WORD PTR [rcx],ax
  20e90a:	c5 fe 6f 84 24 32 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x732]
  20e911:	00 00 
  20e913:	c5 fc 10 8c 24 40 07 	vmovups ymm1,YMMWORD PTR [rsp+0x740]
  20e91a:	00 00 
  20e91c:	e9 d4 f3 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20e921:	4d 85 ed             	test   r13,r13
  20e924:	78 6e                	js     20e994 <getLineNumberInfo+0x10c4>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20e926:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  20e92b:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20e92e:	31 ed                	xor    ebp,ebp
  20e930:	b8 08 00 00 00       	mov    eax,0x8
  20e935:	31 d2                	xor    edx,edx
  20e937:	4c 89 ee             	mov    rsi,r13
  20e93a:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20e93c:	48 89 c1             	mov    rcx,rax
  20e93f:	48 f7 d9             	neg    rcx
  20e942:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20e948:	48 0f 46 cd          	cmovbe rcx,rbp
  20e94c:	66 b8 05 00          	mov    ax,0x5
                if (err > 0) {
  20e950:	48 83 f9 1d          	cmp    rcx,0x1d
  20e954:	77 60                	ja     20e9b6 <getLineNumberInfo+0x10e6>
  20e956:	48 8d 15 67 22 ff ff 	lea    rdx,[rip+0xffffffffffff2267]        # 200bc4 <__unnamed_128+0x97c>
  20e95d:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  20e961:	48 01 d1             	add    rcx,rdx
  20e964:	ff e1                	jmp    rcx
  20e966:	66 b8 20 00          	mov    ax,0x20
  20e96a:	eb 2c                	jmp    20e998 <getLineNumberInfo+0x10c8>
  20e96c:	66 b8 1e 00          	mov    ax,0x1e
  20e970:	eb 04                	jmp    20e976 <getLineNumberInfo+0x10a6>
  20e972:	66 b8 23 00          	mov    ax,0x23
  20e976:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const len_bytes = try readULeb128(in_stream);
  20e97a:	66 89 01             	mov    WORD PTR [rcx],ax
  20e97d:	c5 fe 6f 84 24 04 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x704]
  20e984:	00 00 
  20e986:	c5 fc 10 8c 24 12 07 	vmovups ymm1,YMMWORD PTR [rsp+0x712]
  20e98d:	00 00 
  20e98f:	e9 61 f3 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20e994:	66 b8 21 00          	mov    ax,0x21
  20e998:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try in_file.seekTo(prog_start_offset);
  20e99c:	66 89 01             	mov    WORD PTR [rcx],ax
  20e99f:	c5 fe 6f 84 24 a8 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x6a8]
  20e9a6:	00 00 
  20e9a8:	c5 fc 10 8c 24 b6 06 	vmovups ymm1,YMMWORD PTR [rsp+0x6b6]
  20e9af:	00 00 
  20e9b1:	e9 3f f3 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20e9b6:	48 83 f9 4b          	cmp    rcx,0x4b
  20e9ba:	75 dc                	jne    20e998 <getLineNumberInfo+0x10c8>
  20e9bc:	eb a8                	jmp    20e966 <getLineNumberInfo+0x1096>
            try self.readNoEof(result[0..]);
  20e9be:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20e9c3:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20e9c8:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20e9cf:	00 00 
  20e9d1:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20e9d6:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  20e9db:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20e9e0:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20e9e4:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20e9e9:	66 85 c9             	test   cx,cx
  20e9ec:	74 31                	je     20ea1f <getLineNumberInfo+0x114f>
  20e9ee:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
            const opcode = try in_stream.readByte();
  20e9f2:	66 89 08             	mov    WORD PTR [rax],cx
  20e9f5:	c5 fe 6f 84 24 7a 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x67a]
  20e9fc:	00 00 
  20e9fe:	c5 fc 10 8c 24 88 06 	vmovups ymm1,YMMWORD PTR [rsp+0x688]
  20ea05:	00 00 
  20ea07:	c5 fc 11 48 10       	vmovups YMMWORD PTR [rax+0x10],ymm1
  20ea0c:	c5 fe 7f 40 02       	vmovdqu YMMWORD PTR [rax+0x2],ymm0
  20ea11:	e9 0b f0 ff ff       	jmp    20da21 <getLineNumberInfo+0x151>
  20ea16:	66 b8 1c 00          	mov    ax,0x1c
  20ea1a:	e9 79 ff ff ff       	jmp    20e998 <getLineNumberInfo+0x10c8>
  20ea1f:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20ea24:	8a 4c 24 5e          	mov    cl,BYTE PTR [rsp+0x5e]
  20ea28:	f6 d1                	not    cl
  20ea2a:	88 8c 24 a0 00 00 00 	mov    BYTE PTR [rsp+0xa0],cl
  20ea31:	4c 8d 64 24 20       	lea    r12,[rsp+0x20]
  20ea36:	4c 8d 6c 24 08       	lea    r13,[rsp+0x8]
            if (amt_read < buf.len) return error.EndOfStream;
  20ea3b:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  20ea40:	0f 82 f0 0a 00 00    	jb     20f536 <getLineNumberInfo+0x1c66>
            return result[0];
  20ea46:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
            if (opcode == DW.LNS_extended_op) {
  20ea4a:	84 c0                	test   al,al
  20ea4c:	74 62                	je     20eab0 <getLineNumberInfo+0x11e0>
            } else if (opcode >= opcode_base) {
  20ea4e:	89 c1                	mov    ecx,eax
  20ea50:	2a 4c 24 5e          	sub    cl,BYTE PTR [rsp+0x5e]
  20ea54:	0f 83 01 01 00 00    	jae    20eb5b <getLineNumberInfo+0x128b>
                switch (opcode) {
  20ea5a:	04 ff                	add    al,0xff
  20ea5c:	0f b6 c0             	movzx  eax,al
  20ea5f:	3c 09                	cmp    al,0x9
  20ea61:	0f 87 3b 02 00 00    	ja     20eca2 <getLineNumberInfo+0x13d2>
  20ea67:	48 8d 0d ce 21 ff ff 	lea    rcx,[rip+0xffffffffffff21ce]        # 200c3c <__unnamed_128+0x9f4>
  20ea6e:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  20ea72:	48 01 c8             	add    rax,rcx
  20ea75:	ff e0                	jmp    rax
                        if (try prog.checkLineMatch()) |info| return info;
  20ea77:	48 8d bc 24 08 02 00 	lea    rdi,[rsp+0x208]
  20ea7e:	00 
  20ea7f:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  20ea86:	00 
  20ea87:	e8 34 14 00 00       	call   20fec0 <LineNumberProgram_checkLineMatch>
  20ea8c:	0f b7 84 24 08 02 00 	movzx  eax,WORD PTR [rsp+0x208]
  20ea93:	00 
  20ea94:	66 85 c0             	test   ax,ax
  20ea97:	0f 85 ac 0c 00 00    	jne    20f749 <getLineNumberInfo+0x1e79>
  20ea9d:	80 bc 24 38 02 00 00 	cmp    BYTE PTR [rsp+0x238],0x1
  20eaa4:	01 
  20eaa5:	0f 85 0c 01 00 00    	jne    20ebb7 <getLineNumberInfo+0x12e7>
  20eaab:	e9 b7 0c 00 00       	jmp    20f767 <getLineNumberInfo+0x1e97>
            try self.readNoEof(result[0..]);
  20eab0:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20eab5:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20eaba:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20eac1:	00 00 
            return self.readFn(self, buffer);
  20eac3:	4c 89 e7             	mov    rdi,r12
  20eac6:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20eacb:	4c 89 ea             	mov    rdx,r13
  20eace:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20ead2:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20ead7:	66 85 c0             	test   ax,ax
  20eada:	0f 85 38 0a 00 00    	jne    20f518 <getLineNumberInfo+0x1c48>
  20eae0:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20eae5:	31 ed                	xor    ebp,ebp
  20eae7:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  20eae9:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20eaee:	0f 82 fc 09 00 00    	jb     20f4f0 <getLineNumberInfo+0x1c20>
            return result[0];
  20eaf4:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20eaf9:	89 c2                	mov    edx,eax
  20eafb:	83 e2 7f             	and    edx,0x7f
  20eafe:	89 de                	mov    esi,ebx
  20eb00:	83 e6 3f             	and    esi,0x3f
  20eb03:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20eb08:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20eb0d:	48 39 d6             	cmp    rsi,rdx
  20eb10:	0f 85 fe 09 00 00    	jne    20f514 <getLineNumberInfo+0x1c44>
        result |= operand;
  20eb16:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  20eb19:	84 c0                	test   al,al
  20eb1b:	0f 89 d8 00 00 00    	jns    20ebf9 <getLineNumberInfo+0x1329>
        shift += 7;
  20eb21:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  20eb25:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20eb2a:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20eb2f:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20eb36:	00 00 
            return self.readFn(self, buffer);
  20eb38:	4c 89 e7             	mov    rdi,r12
  20eb3b:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20eb40:	4c 89 ea             	mov    rdx,r13
  20eb43:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20eb47:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20eb4c:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20eb51:	66 85 c0             	test   ax,ax
  20eb54:	74 93                	je     20eae9 <getLineNumberInfo+0x1219>
  20eb56:	e9 bd 09 00 00       	jmp    20f518 <getLineNumberInfo+0x1c48>
                const inc_line = i32(line_base) + i32(adjusted_opcode % line_range);
  20eb5b:	0f b6 c1             	movzx  eax,cl
  20eb5e:	f6 74 24 5f          	div    BYTE PTR [rsp+0x5f]
  20eb62:	0f b6 cc             	movzx  ecx,ah
  20eb65:	48 03 8c 24 68 01 00 	add    rcx,QWORD PTR [rsp+0x168]
  20eb6c:	00 
                prog.line += inc_line;
  20eb6d:	48 01 8c 24 f0 00 00 	add    QWORD PTR [rsp+0xf0],rcx
  20eb74:	00 
                const inc_addr = minimum_instruction_length * (adjusted_opcode / line_range);
  20eb75:	41 f6 e7             	mul    r15b
                prog.address += inc_addr;
  20eb78:	0f b6 c0             	movzx  eax,al
  20eb7b:	48 01 84 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rax
  20eb82:	00 
                if (try prog.checkLineMatch()) |info| return info;
  20eb83:	48 8d bc 24 40 02 00 	lea    rdi,[rsp+0x240]
  20eb8a:	00 
  20eb8b:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  20eb92:	00 
  20eb93:	e8 28 13 00 00       	call   20fec0 <LineNumberProgram_checkLineMatch>
  20eb98:	0f b7 84 24 40 02 00 	movzx  eax,WORD PTR [rsp+0x240]
  20eb9f:	00 
  20eba0:	66 85 c0             	test   ax,ax
  20eba3:	0f 85 96 09 00 00    	jne    20f53f <getLineNumberInfo+0x1c6f>
  20eba9:	80 bc 24 70 02 00 00 	cmp    BYTE PTR [rsp+0x270],0x1
  20ebb0:	01 
  20ebb1:	0f 84 a6 09 00 00    	je     20f55d <getLineNumberInfo+0x1c8d>
  20ebb7:	c6 84 24 01 01 00 00 	mov    BYTE PTR [rsp+0x101],0x0
  20ebbe:	00 
            try self.readNoEof(result[0..]);
  20ebbf:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20ebc4:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20ebc9:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20ebd0:	00 00 
            return self.readFn(self, buffer);
  20ebd2:	4c 89 e7             	mov    rdi,r12
  20ebd5:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20ebda:	4c 89 ea             	mov    rdx,r13
  20ebdd:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20ebe1:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  20ebe6:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20ebeb:	66 85 c9             	test   cx,cx
  20ebee:	0f 84 47 fe ff ff    	je     20ea3b <getLineNumberInfo+0x116b>
  20ebf4:	e9 f5 fd ff ff       	jmp    20e9ee <getLineNumberInfo+0x111e>
                if (op_size < 1) return error.InvalidDebugInfo;
  20ebf9:	48 85 ed             	test   rbp,rbp
  20ebfc:	0f 84 d0 08 00 00    	je     20f4d2 <getLineNumberInfo+0x1c02>
            try self.readNoEof(result[0..]);
  20ec02:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20ec07:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20ec0c:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20ec13:	00 00 
            return self.readFn(self, buffer);
  20ec15:	4c 89 e7             	mov    rdi,r12
  20ec18:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20ec1d:	4c 89 ea             	mov    rdx,r13
  20ec20:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20ec24:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20ec29:	66 85 c0             	test   ax,ax
  20ec2c:	0f 85 39 0a 00 00    	jne    20f66b <getLineNumberInfo+0x1d9b>
  20ec32:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  20ec37:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  20ec3c:	0f 82 25 0a 00 00    	jb     20f667 <getLineNumberInfo+0x1d97>
            return result[0];
  20ec42:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
                switch (sub_op) {
  20ec46:	3c 02                	cmp    al,0x2
  20ec48:	0f 84 03 04 00 00    	je     20f051 <getLineNumberInfo+0x1781>
  20ec4e:	3c 03                	cmp    al,0x3
  20ec50:	0f 84 b2 04 00 00    	je     20f108 <getLineNumberInfo+0x1838>
  20ec56:	3c 01                	cmp    al,0x1
  20ec58:	0f 84 2b 0a 00 00    	je     20f689 <getLineNumberInfo+0x1db9>
  20ec5e:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
  20ec62:	0f 88 6a 08 00 00    	js     20f4d2 <getLineNumberInfo+0x1c02>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20ec68:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  20ec6d:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20ec70:	b8 08 00 00 00       	mov    eax,0x8
  20ec75:	ba 01 00 00 00       	mov    edx,0x1
  20ec7a:	48 89 ee             	mov    rsi,rbp
  20ec7d:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20ec7f:	48 89 c1             	mov    rcx,rax
  20ec82:	48 f7 d9             	neg    rcx
  20ec85:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20ec8b:	b8 00 00 00 00       	mov    eax,0x0
  20ec90:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  20ec94:	48 85 c9             	test   rcx,rcx
  20ec97:	0f 84 22 ff ff ff    	je     20ebbf <getLineNumberInfo+0x12ef>
  20ec9d:	e9 6e 0b 00 00       	jmp    20f810 <getLineNumberInfo+0x1f40>
                        if (opcode - 1 >= standard_opcode_lengths.len) return error.InvalidDebugInfo;
  20eca2:	48 39 84 24 98 00 00 	cmp    QWORD PTR [rsp+0x98],rax
  20eca9:	00 
  20ecaa:	0f 86 22 08 00 00    	jbe    20f4d2 <getLineNumberInfo+0x1c02>
                        try in_file.seekForward(len_bytes);
  20ecb0:	48 8b 8c 24 d8 00 00 	mov    rcx,QWORD PTR [rsp+0xd8]
  20ecb7:	00 
  20ecb8:	0f b6 34 01          	movzx  esi,BYTE PTR [rcx+rax*1]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20ecbc:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  20ecc1:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20ecc4:	b8 08 00 00 00       	mov    eax,0x8
  20ecc9:	ba 01 00 00 00       	mov    edx,0x1
  20ecce:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20ecd0:	48 89 c1             	mov    rcx,rax
  20ecd3:	48 f7 d9             	neg    rcx
  20ecd6:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20ecdc:	b8 00 00 00 00       	mov    eax,0x0
  20ece1:	48 0f 46 c8          	cmovbe rcx,rax
  20ece5:	48 85 c9             	test   rcx,rcx
  20ece8:	0f 84 d1 fe ff ff    	je     20ebbf <getLineNumberInfo+0x12ef>
  20ecee:	e9 b6 0a 00 00       	jmp    20f7a9 <getLineNumberInfo+0x1ed9>
            try self.readNoEof(result[0..]);
  20ecf3:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20ecf8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20ecfd:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20ed04:	00 00 
            return self.readFn(self, buffer);
  20ed06:	4c 89 e7             	mov    rdi,r12
  20ed09:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20ed0e:	4c 89 ea             	mov    rdx,r13
  20ed11:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20ed15:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20ed1a:	66 85 c0             	test   ax,ax
  20ed1d:	0f 85 98 08 00 00    	jne    20f5bb <getLineNumberInfo+0x1ceb>
  20ed23:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20ed28:	31 db                	xor    ebx,ebx
  20ed2a:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  20ed2c:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20ed31:	0f 82 68 08 00 00    	jb     20f59f <getLineNumberInfo+0x1ccf>
            return result[0];
  20ed37:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20ed3c:	89 c2                	mov    edx,eax
  20ed3e:	83 e2 7f             	and    edx,0x7f
  20ed41:	89 ee                	mov    esi,ebp
  20ed43:	83 e6 3f             	and    esi,0x3f
  20ed46:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20ed4b:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20ed50:	48 39 d6             	cmp    rsi,rdx
  20ed53:	0f 85 5e 08 00 00    	jne    20f5b7 <getLineNumberInfo+0x1ce7>
        result |= operand;
  20ed59:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  20ed5c:	84 c0                	test   al,al
  20ed5e:	0f 89 16 05 00 00    	jns    20f27a <getLineNumberInfo+0x19aa>
        shift += 7;
  20ed64:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  20ed68:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20ed6d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20ed72:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20ed79:	00 00 
            return self.readFn(self, buffer);
  20ed7b:	4c 89 e7             	mov    rdi,r12
  20ed7e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20ed83:	4c 89 ea             	mov    rdx,r13
  20ed86:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20ed8a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20ed8f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20ed94:	66 85 c0             	test   ax,ax
  20ed97:	74 93                	je     20ed2c <getLineNumberInfo+0x145c>
  20ed99:	e9 1d 08 00 00       	jmp    20f5bb <getLineNumberInfo+0x1ceb>
            try self.readNoEof(result[0..]);
  20ed9e:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20eda3:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20eda8:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20edaf:	00 00 
            return self.readFn(self, buffer);
  20edb1:	4c 89 e7             	mov    rdi,r12
  20edb4:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20edb9:	4c 89 ea             	mov    rdx,r13
  20edbc:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20edc0:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20edc5:	66 85 c0             	test   ax,ax
  20edc8:	0f 85 0f 08 00 00    	jne    20f5dd <getLineNumberInfo+0x1d0d>
  20edce:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20edd3:	bb 07 00 00 00       	mov    ebx,0x7
  20edd8:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  20edda:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20eddf:	0f 82 c0 07 00 00    	jb     20f5a5 <getLineNumberInfo+0x1cd5>
  20ede5:	48 8d 53 f9          	lea    rdx,[rbx-0x7]
            return result[0];
  20ede9:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(i64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20edee:	89 c6                	mov    esi,eax
  20edf0:	83 e6 7f             	and    esi,0x7f
  20edf3:	83 e2 3f             	and    edx,0x3f
  20edf6:	c4 e2 e9 f7 ce       	shlx   rcx,rsi,rdx
  20edfb:	c4 e2 ea f7 d1       	sarx   rdx,rcx,rdx
  20ee00:	48 39 f2             	cmp    rdx,rsi
  20ee03:	0f 85 d0 07 00 00    	jne    20f5d9 <getLineNumberInfo+0x1d09>
        result |= operand;
  20ee09:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) {
  20ee0c:	84 c0                	test   al,al
  20ee0e:	0f 89 77 04 00 00    	jns    20f28b <getLineNumberInfo+0x19bb>
            try self.readNoEof(result[0..]);
  20ee14:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20ee19:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20ee1e:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20ee25:	00 00 
            return self.readFn(self, buffer);
  20ee27:	4c 89 e7             	mov    rdi,r12
  20ee2a:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20ee2f:	4c 89 ea             	mov    rdx,r13
  20ee32:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20ee36:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20ee3b:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20ee40:	48 83 c3 07          	add    rbx,0x7
  20ee44:	66 85 c0             	test   ax,ax
  20ee47:	74 91                	je     20edda <getLineNumberInfo+0x150a>
  20ee49:	e9 8f 07 00 00       	jmp    20f5dd <getLineNumberInfo+0x1d0d>
            try self.readNoEof(result[0..]);
  20ee4e:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20ee53:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20ee58:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20ee5f:	00 00 
            return self.readFn(self, buffer);
  20ee61:	4c 89 e7             	mov    rdi,r12
  20ee64:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20ee69:	4c 89 ea             	mov    rdx,r13
  20ee6c:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20ee70:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20ee75:	66 85 c0             	test   ax,ax
  20ee78:	0f 85 81 07 00 00    	jne    20f5ff <getLineNumberInfo+0x1d2f>
  20ee7e:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20ee83:	31 db                	xor    ebx,ebx
  20ee85:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  20ee87:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20ee8c:	0f 82 19 07 00 00    	jb     20f5ab <getLineNumberInfo+0x1cdb>
            return result[0];
  20ee92:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20ee97:	89 c2                	mov    edx,eax
  20ee99:	83 e2 7f             	and    edx,0x7f
  20ee9c:	89 ee                	mov    esi,ebp
  20ee9e:	83 e6 3f             	and    esi,0x3f
  20eea1:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20eea6:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20eeab:	48 39 d6             	cmp    rsi,rdx
  20eeae:	0f 85 47 07 00 00    	jne    20f5fb <getLineNumberInfo+0x1d2b>
        result |= operand;
  20eeb4:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  20eeb7:	84 c0                	test   al,al
  20eeb9:	0f 89 f2 03 00 00    	jns    20f2b1 <getLineNumberInfo+0x19e1>
        shift += 7;
  20eebf:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  20eec3:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20eec8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20eecd:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20eed4:	00 00 
            return self.readFn(self, buffer);
  20eed6:	4c 89 e7             	mov    rdi,r12
  20eed9:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20eede:	4c 89 ea             	mov    rdx,r13
  20eee1:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20eee5:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20eeea:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20eeef:	66 85 c0             	test   ax,ax
  20eef2:	74 93                	je     20ee87 <getLineNumberInfo+0x15b7>
  20eef4:	e9 06 07 00 00       	jmp    20f5ff <getLineNumberInfo+0x1d2f>
            try self.readNoEof(result[0..]);
  20eef9:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20eefe:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20ef03:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20ef0a:	00 00 
            return self.readFn(self, buffer);
  20ef0c:	4c 89 e7             	mov    rdi,r12
  20ef0f:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20ef14:	4c 89 ea             	mov    rdx,r13
  20ef17:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20ef1b:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20ef20:	66 85 c0             	test   ax,ax
  20ef23:	0f 85 f8 06 00 00    	jne    20f621 <getLineNumberInfo+0x1d51>
  20ef29:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20ef2e:	31 db                	xor    ebx,ebx
  20ef30:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  20ef32:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20ef37:	0f 82 74 06 00 00    	jb     20f5b1 <getLineNumberInfo+0x1ce1>
            return result[0];
  20ef3d:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20ef42:	89 c2                	mov    edx,eax
  20ef44:	83 e2 7f             	and    edx,0x7f
  20ef47:	89 ee                	mov    esi,ebp
  20ef49:	83 e6 3f             	and    esi,0x3f
  20ef4c:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20ef51:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20ef56:	48 39 d6             	cmp    rsi,rdx
  20ef59:	0f 85 be 06 00 00    	jne    20f61d <getLineNumberInfo+0x1d4d>
        result |= operand;
  20ef5f:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  20ef62:	84 c0                	test   al,al
  20ef64:	0f 89 54 03 00 00    	jns    20f2be <getLineNumberInfo+0x19ee>
        shift += 7;
  20ef6a:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  20ef6e:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20ef73:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20ef78:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20ef7f:	00 00 
            return self.readFn(self, buffer);
  20ef81:	4c 89 e7             	mov    rdi,r12
  20ef84:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20ef89:	4c 89 ea             	mov    rdx,r13
  20ef8c:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20ef90:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20ef95:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20ef9a:	66 85 c0             	test   ax,ax
  20ef9d:	74 93                	je     20ef32 <getLineNumberInfo+0x1662>
  20ef9f:	e9 7d 06 00 00       	jmp    20f621 <getLineNumberInfo+0x1d51>
                        prog.is_stmt = !prog.is_stmt;
  20efa4:	8a 84 24 00 01 00 00 	mov    al,BYTE PTR [rsp+0x100]
  20efab:	f6 d0                	not    al
  20efad:	24 01                	and    al,0x1
  20efaf:	88 84 24 00 01 00 00 	mov    BYTE PTR [rsp+0x100],al
  20efb6:	e9 04 fc ff ff       	jmp    20ebbf <getLineNumberInfo+0x12ef>
                        prog.basic_block = true;
  20efbb:	c6 84 24 01 01 00 00 	mov    BYTE PTR [rsp+0x101],0x1
  20efc2:	01 
  20efc3:	e9 f7 fb ff ff       	jmp    20ebbf <getLineNumberInfo+0x12ef>
                        const inc_addr = minimum_instruction_length * ((255 - opcode_base) / line_range);
  20efc8:	0f b6 84 24 a0 00 00 	movzx  eax,BYTE PTR [rsp+0xa0]
  20efcf:	00 
  20efd0:	f6 74 24 5f          	div    BYTE PTR [rsp+0x5f]
  20efd4:	41 f6 e7             	mul    r15b
                        prog.address += inc_addr;
  20efd7:	0f b6 c0             	movzx  eax,al
  20efda:	eb 68                	jmp    20f044 <getLineNumberInfo+0x1774>
                        const arg = try in_stream.readInt(st.elf.endian, u16);
  20efdc:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  20efe1:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  20efe4:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20efe9:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20efee:	48 c7 44 24 10 02 00 	mov    QWORD PTR [rsp+0x10],0x2
  20eff5:	00 00 
            return self.readFn(self, buffer);
  20eff7:	4c 89 e7             	mov    rdi,r12
  20effa:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20efff:	4c 89 ea             	mov    rdx,r13
  20f002:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20f006:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20f00b:	66 85 c0             	test   ax,ax
  20f00e:	0f 85 c0 07 00 00    	jne    20f7d4 <getLineNumberInfo+0x1f04>
  20f014:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  20f019:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  20f01e:	0f 82 ac 07 00 00    	jb     20f7d0 <getLineNumberInfo+0x1f00>
  20f024:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f029:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  20f02e:	89 ca                	mov    edx,ecx
  20f030:	c1 e2 08             	shl    edx,0x8
  20f033:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20f035:	c1 e0 08             	shl    eax,0x8
  20f038:	09 c8                	or     eax,ecx
    switch (endian) {
  20f03a:	f6 c3 01             	test   bl,0x1
  20f03d:	66 0f 45 c2          	cmovne ax,dx
                        prog.address += arg;
  20f041:	0f b7 c0             	movzx  eax,ax
  20f044:	48 01 84 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rax
  20f04b:	00 
  20f04c:	e9 6e fb ff ff       	jmp    20ebbf <getLineNumberInfo+0x12ef>
                        const addr = try in_stream.readInt(st.elf.endian, usize);
  20f051:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  20f056:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  20f059:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20f05e:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20f063:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  20f06a:	00 00 
            return self.readFn(self, buffer);
  20f06c:	4c 89 e7             	mov    rdi,r12
  20f06f:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20f074:	4c 89 ea             	mov    rdx,r13
  20f077:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20f07b:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20f080:	66 85 c0             	test   ax,ax
  20f083:	0f 85 ae 07 00 00    	jne    20f837 <getLineNumberInfo+0x1f67>
  20f089:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  20f08e:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  20f093:	0f 82 9a 07 00 00    	jb     20f833 <getLineNumberInfo+0x1f63>
  20f099:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  20f09e:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  20f0a3:	f6 c3 01             	test   bl,0x1
  20f0a6:	0f 84 72 01 00 00    	je     20f21e <getLineNumberInfo+0x194e>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f0ac:	48 c1 e1 08          	shl    rcx,0x8
  20f0b0:	48 09 c1             	or     rcx,rax
  20f0b3:	0f b6 44 24 4a       	movzx  eax,BYTE PTR [rsp+0x4a]
  20f0b8:	48 c1 e0 10          	shl    rax,0x10
  20f0bc:	48 09 c8             	or     rax,rcx
  20f0bf:	0f b6 4c 24 4b       	movzx  ecx,BYTE PTR [rsp+0x4b]
  20f0c4:	48 c1 e1 18          	shl    rcx,0x18
  20f0c8:	48 09 c1             	or     rcx,rax
  20f0cb:	0f b6 44 24 4c       	movzx  eax,BYTE PTR [rsp+0x4c]
  20f0d0:	48 c1 e0 20          	shl    rax,0x20
  20f0d4:	48 09 c8             	or     rax,rcx
  20f0d7:	0f b6 4c 24 4d       	movzx  ecx,BYTE PTR [rsp+0x4d]
  20f0dc:	48 c1 e1 28          	shl    rcx,0x28
  20f0e0:	48 09 c1             	or     rcx,rax
  20f0e3:	0f b6 54 24 4e       	movzx  edx,BYTE PTR [rsp+0x4e]
  20f0e8:	48 c1 e2 30          	shl    rdx,0x30
  20f0ec:	0f b6 44 24 4f       	movzx  eax,BYTE PTR [rsp+0x4f]
  20f0f1:	48 c1 e0 38          	shl    rax,0x38
  20f0f5:	48 09 d0             	or     rax,rdx
  20f0f8:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  20f0fb:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  20f102:	00 
  20f103:	e9 b7 fa ff ff       	jmp    20ebbf <getLineNumberInfo+0x12ef>
  20f108:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  20f10d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20f112:	48 8d 0d a7 a5 ff ff 	lea    rcx,[rip+0xffffffffffffa5a7]        # 2096c0 <FileInStream_readFn>
  20f119:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20f11e:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  20f125:	4c 89 e7             	mov    rdi,r12
  20f128:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20f12d:	e8 4e e3 ff ff       	call   20d480 <readStringRaw>
  20f132:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20f137:	48 8d 4c 24 22       	lea    rcx,[rsp+0x22]
  20f13c:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  20f140:	c5 f8 29 84 24 b0 01 	vmovaps XMMWORD PTR [rsp+0x1b0],xmm0
  20f147:	00 00 
  20f149:	48 8b 49 0e          	mov    rcx,QWORD PTR [rcx+0xe]
  20f14d:	48 89 8c 24 be 01 00 	mov    QWORD PTR [rsp+0x1be],rcx
  20f154:	00 
                        const file_name = try st.readString();
  20f155:	66 85 c0             	test   ax,ax
  20f158:	0f 85 94 06 00 00    	jne    20f7f2 <getLineNumberInfo+0x1f22>
  20f15e:	48 8d 84 24 b6 01 00 	lea    rax,[rsp+0x1b6]
  20f165:	00 
  20f166:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20f16a:	c5 f9 7f 84 24 d0 01 	vmovdqa XMMWORD PTR [rsp+0x1d0],xmm0
  20f171:	00 00 
            try self.readNoEof(result[0..]);
  20f173:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20f178:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20f17d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f184:	00 00 
            return self.readFn(self, buffer);
  20f186:	4c 89 e7             	mov    rdi,r12
  20f189:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20f18e:	4c 89 ea             	mov    rdx,r13
  20f191:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20f195:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20f19a:	66 85 c0             	test   ax,ax
  20f19d:	0f 85 a6 04 00 00    	jne    20f649 <getLineNumberInfo+0x1d79>
  20f1a3:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20f1a8:	31 ed                	xor    ebp,ebp
  20f1aa:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  20f1ac:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20f1b1:	0f 82 88 04 00 00    	jb     20f63f <getLineNumberInfo+0x1d6f>
            return result[0];
  20f1b7:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20f1bc:	89 c2                	mov    edx,eax
  20f1be:	83 e2 7f             	and    edx,0x7f
  20f1c1:	89 de                	mov    esi,ebx
  20f1c3:	83 e6 3f             	and    esi,0x3f
  20f1c6:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20f1cb:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20f1d0:	48 39 d6             	cmp    rsi,rdx
  20f1d3:	0f 85 6c 04 00 00    	jne    20f645 <getLineNumberInfo+0x1d75>
        result |= operand;
  20f1d9:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  20f1dc:	84 c0                	test   al,al
  20f1de:	0f 89 e7 00 00 00    	jns    20f2cb <getLineNumberInfo+0x19fb>
        shift += 7;
  20f1e4:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  20f1e8:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20f1ed:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20f1f2:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f1f9:	00 00 
            return self.readFn(self, buffer);
  20f1fb:	4c 89 e7             	mov    rdi,r12
  20f1fe:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20f203:	4c 89 ea             	mov    rdx,r13
  20f206:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20f20a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20f20f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20f214:	66 85 c0             	test   ax,ax
  20f217:	74 93                	je     20f1ac <getLineNumberInfo+0x18dc>
  20f219:	e9 2b 04 00 00       	jmp    20f649 <getLineNumberInfo+0x1d79>
                result = (result << 8) | b;
  20f21e:	48 c1 e0 08          	shl    rax,0x8
  20f222:	48 09 c8             	or     rax,rcx
  20f225:	48 c1 e0 08          	shl    rax,0x8
  20f229:	0f b6 4c 24 4a       	movzx  ecx,BYTE PTR [rsp+0x4a]
  20f22e:	48 09 c1             	or     rcx,rax
  20f231:	48 c1 e1 08          	shl    rcx,0x8
  20f235:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  20f23a:	48 09 c8             	or     rax,rcx
  20f23d:	48 c1 e0 08          	shl    rax,0x8
  20f241:	0f b6 4c 24 4c       	movzx  ecx,BYTE PTR [rsp+0x4c]
  20f246:	48 09 c1             	or     rcx,rax
  20f249:	48 c1 e1 08          	shl    rcx,0x8
  20f24d:	0f b6 44 24 4d       	movzx  eax,BYTE PTR [rsp+0x4d]
  20f252:	48 09 c8             	or     rax,rcx
  20f255:	48 c1 e0 08          	shl    rax,0x8
  20f259:	0f b6 4c 24 4e       	movzx  ecx,BYTE PTR [rsp+0x4e]
  20f25e:	48 09 c1             	or     rcx,rax
  20f261:	48 c1 e1 08          	shl    rcx,0x8
  20f265:	0f b6 44 24 4f       	movzx  eax,BYTE PTR [rsp+0x4f]
  20f26a:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  20f26d:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  20f274:	00 
  20f275:	e9 45 f9 ff ff       	jmp    20ebbf <getLineNumberInfo+0x12ef>
                        prog.address += arg * minimum_instruction_length;
  20f27a:	49 0f af df          	imul   rbx,r15
  20f27e:	48 01 9c 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rbx
  20f285:	00 
  20f286:	e9 34 f9 ff ff       	jmp    20ebbf <getLineNumberInfo+0x12ef>
            if (shift < @sizeOf(i64) * 8 and (byte & 0b01000000) != 0) result |= -(i64(1) << @intCast(u6, shift));
  20f28b:	48 83 fb 3f          	cmp    rbx,0x3f
  20f28f:	77 13                	ja     20f2a4 <getLineNumberInfo+0x19d4>
  20f291:	24 40                	and    al,0x40
  20f293:	74 0f                	je     20f2a4 <getLineNumberInfo+0x19d4>
  20f295:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  20f29c:	c4 e2 e1 f7 c0       	shlx   rax,rax,rbx
  20f2a1:	48 09 c5             	or     rbp,rax
                        prog.line += arg;
  20f2a4:	48 01 ac 24 f0 00 00 	add    QWORD PTR [rsp+0xf0],rbp
  20f2ab:	00 
  20f2ac:	e9 0e f9 ff ff       	jmp    20ebbf <getLineNumberInfo+0x12ef>
                        prog.file = arg;
  20f2b1:	48 89 9c 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbx
  20f2b8:	00 
  20f2b9:	e9 01 f9 ff ff       	jmp    20ebbf <getLineNumberInfo+0x12ef>
                        prog.column = arg;
  20f2be:	48 89 9c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rbx
  20f2c5:	00 
  20f2c6:	e9 f4 f8 ff ff       	jmp    20ebbf <getLineNumberInfo+0x12ef>
            try self.readNoEof(result[0..]);
  20f2cb:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20f2d0:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20f2d5:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f2dc:	00 00 
            return self.readFn(self, buffer);
  20f2de:	4c 89 e7             	mov    rdi,r12
  20f2e1:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20f2e6:	4c 89 ea             	mov    rdx,r13
  20f2e9:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20f2ed:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20f2f2:	66 85 c0             	test   ax,ax
  20f2f5:	0f 85 e0 03 00 00    	jne    20f6db <getLineNumberInfo+0x1e0b>
  20f2fb:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20f300:	45 31 f6             	xor    r14d,r14d
  20f303:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  20f305:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20f30a:	0f 82 c1 03 00 00    	jb     20f6d1 <getLineNumberInfo+0x1e01>
            return result[0];
  20f310:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20f315:	89 c2                	mov    edx,eax
  20f317:	83 e2 7f             	and    edx,0x7f
  20f31a:	89 de                	mov    esi,ebx
  20f31c:	83 e6 3f             	and    esi,0x3f
  20f31f:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20f324:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20f329:	48 39 d6             	cmp    rsi,rdx
  20f32c:	0f 85 a5 03 00 00    	jne    20f6d7 <getLineNumberInfo+0x1e07>
        result |= operand;
  20f332:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  20f335:	84 c0                	test   al,al
  20f337:	79 3a                	jns    20f373 <getLineNumberInfo+0x1aa3>
        shift += 7;
  20f339:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  20f33d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20f342:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20f347:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f34e:	00 00 
            return self.readFn(self, buffer);
  20f350:	4c 89 e7             	mov    rdi,r12
  20f353:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20f358:	4c 89 ea             	mov    rdx,r13
  20f35b:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20f35f:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20f364:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20f369:	66 85 c0             	test   ax,ax
  20f36c:	74 97                	je     20f305 <getLineNumberInfo+0x1a35>
  20f36e:	e9 68 03 00 00       	jmp    20f6db <getLineNumberInfo+0x1e0b>
            try self.readNoEof(result[0..]);
  20f373:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20f378:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20f37d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f384:	00 00 
            return self.readFn(self, buffer);
  20f386:	4c 89 e7             	mov    rdi,r12
  20f389:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20f38e:	4c 89 ea             	mov    rdx,r13
  20f391:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20f395:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20f39a:	66 85 c0             	test   ax,ax
  20f39d:	0f 85 bc 04 00 00    	jne    20f85f <getLineNumberInfo+0x1f8f>
  20f3a3:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  20f3a8:	31 c0                	xor    eax,eax
  20f3aa:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  20f3af:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  20f3b1:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  20f3b6:	0f 82 99 04 00 00    	jb     20f855 <getLineNumberInfo+0x1f85>
            return result[0];
  20f3bc:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20f3c1:	89 c2                	mov    edx,eax
  20f3c3:	83 e2 7f             	and    edx,0x7f
  20f3c6:	89 de                	mov    esi,ebx
  20f3c8:	83 e6 3f             	and    esi,0x3f
  20f3cb:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20f3d0:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20f3d5:	48 39 d6             	cmp    rsi,rdx
  20f3d8:	0f 85 7d 04 00 00    	jne    20f85b <getLineNumberInfo+0x1f8b>
        result |= operand;
  20f3de:	48 09 4c 24 68       	or     QWORD PTR [rsp+0x68],rcx
        if ((byte & 0b10000000) == 0) return result;
  20f3e3:	84 c0                	test   al,al
  20f3e5:	79 3a                	jns    20f421 <getLineNumberInfo+0x1b51>
        shift += 7;
  20f3e7:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  20f3eb:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  20f3f0:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20f3f5:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20f3fc:	00 00 
            return self.readFn(self, buffer);
  20f3fe:	4c 89 e7             	mov    rdi,r12
  20f401:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  20f406:	4c 89 ea             	mov    rdx,r13
  20f409:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  20f40d:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20f412:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20f417:	66 85 c0             	test   ax,ax
  20f41a:	74 95                	je     20f3b1 <getLineNumberInfo+0x1ae1>
  20f41c:	e9 3e 04 00 00       	jmp    20f85f <getLineNumberInfo+0x1f8f>
                        try file_entries.append(FileEntry{
  20f421:	c5 f9 6f 84 24 d0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1d0]
  20f428:	00 00 
  20f42a:	c5 f9 7f 84 24 f0 01 	vmovdqa XMMWORD PTR [rsp+0x1f0],xmm0
  20f431:	00 00 
            const new_length = self.len + 1;
  20f433:	48 8b 9c 24 80 00 00 	mov    rbx,QWORD PTR [rsp+0x80]
  20f43a:	00 
            var better_capacity = self.items.len;
  20f43b:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
            if (better_capacity >= new_capacity) return;
  20f440:	48 39 d9             	cmp    rcx,rbx
  20f443:	76 05                	jbe    20f44a <getLineNumberInfo+0x1b7a>
            const result = &self.items[self.len];
  20f445:	48 89 d8             	mov    rax,rbx
  20f448:	eb 4c                	jmp    20f496 <getLineNumberInfo+0x1bc6>
                better_capacity += better_capacity / 2 + 8;
  20f44a:	48 89 c8             	mov    rax,rcx
  20f44d:	48 d1 e8             	shr    rax,1
  20f450:	48 01 c1             	add    rcx,rax
  20f453:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20f457:	48 39 d9             	cmp    rcx,rbx
  20f45a:	76 ee                	jbe    20f44a <getLineNumberInfo+0x1b7a>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20f45c:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  20f463:	00 
  20f464:	4c 89 e7             	mov    rdi,r12
  20f467:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  20f46c:	e8 df 13 00 00       	call   210850 <Allocator_alignedRealloc.62>
  20f471:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  20f476:	66 85 c0             	test   ax,ax
  20f479:	0f 85 5f 04 00 00    	jne    20f8de <getLineNumberInfo+0x200e>
  20f47f:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  20f484:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20f488:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
            const result = &self.items[self.len];
  20f48e:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  20f495:	00 
  20f496:	48 83 c3 01          	add    rbx,0x1
  20f49a:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  20f49f:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  20f4a3:	48 89 9c 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rbx
  20f4aa:	00 
            new_item_ptr.* = item;
  20f4ab:	c5 f9 6f 84 24 f0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1f0]
  20f4b2:	00 00 
  20f4b4:	c5 fa 7f 04 c1       	vmovdqu XMMWORD PTR [rcx+rax*8],xmm0
  20f4b9:	48 89 6c c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],rbp
  20f4be:	4c 89 74 c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],r14
  20f4c3:	48 8b 54 24 68       	mov    rdx,QWORD PTR [rsp+0x68]
  20f4c8:	48 89 54 c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rdx
  20f4cd:	e9 ed f6 ff ff       	jmp    20ebbf <getLineNumberInfo+0x12ef>
  20f4d2:	c5 fc 10 05 1e 1e ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff1e1e]        # 2012f8 <__unnamed_68+0x10>
  20f4d9:	ff 
  20f4da:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  20f4de:	c5 fc 11 40 10       	vmovups YMMWORD PTR [rax+0x10],ymm0
  20f4e3:	c5 fe 6f 05 fd 1d ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff1dfd]        # 2012e8 <__unnamed_68>
  20f4ea:	ff 
  20f4eb:	e9 e7 e6 ff ff       	jmp    20dbd7 <getLineNumberInfo+0x307>
  20f4f0:	66 b8 1e 00          	mov    ax,0x1e
  20f4f4:	eb 22                	jmp    20f518 <getLineNumberInfo+0x1c48>
  20f4f6:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            try file_entries.append(FileEntry{
  20f4fa:	66 89 01             	mov    WORD PTR [rcx],ax
  20f4fd:	c5 fc 10 84 24 d6 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6d6]
  20f504:	00 00 
  20f506:	c5 fc 10 8c 24 e4 06 	vmovups ymm1,YMMWORD PTR [rsp+0x6e4]
  20f50d:	00 00 
  20f50f:	e9 e1 e7 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f514:	66 b8 23 00          	mov    ax,0x23
  20f518:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                const op_size = try readULeb128(in_stream);
  20f51c:	66 89 01             	mov    WORD PTR [rcx],ax
  20f51f:	c5 fe 6f 84 24 4c 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x64c]
  20f526:	00 00 
  20f528:	c5 fc 10 8c 24 5a 06 	vmovups ymm1,YMMWORD PTR [rsp+0x65a]
  20f52f:	00 00 
  20f531:	e9 bf e7 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f536:	66 b9 1e 00          	mov    cx,0x1e
  20f53a:	e9 af f4 ff ff       	jmp    20e9ee <getLineNumberInfo+0x111e>
  20f53f:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                if (try prog.checkLineMatch()) |info| return info;
  20f543:	66 89 01             	mov    WORD PTR [rcx],ax
  20f546:	c5 fc 10 84 24 80 04 	vmovups ymm0,YMMWORD PTR [rsp+0x480]
  20f54d:	00 00 
  20f54f:	c5 fc 10 8c 24 8e 04 	vmovups ymm1,YMMWORD PTR [rsp+0x48e]
  20f556:	00 00 
  20f558:	e9 98 e7 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f55d:	48 8b 84 24 68 02 00 	mov    rax,QWORD PTR [rsp+0x268]
  20f564:	00 
  20f565:	48 89 84 24 08 03 00 	mov    QWORD PTR [rsp+0x308],rax
  20f56c:	00 
  20f56d:	c5 fc 10 84 24 48 02 	vmovups ymm0,YMMWORD PTR [rsp+0x248]
  20f574:	00 00 
  20f576:	c5 fc 11 84 24 e8 02 	vmovups YMMWORD PTR [rsp+0x2e8],ymm0
  20f57d:	00 00 
  20f57f:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  20f583:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  20f588:	c5 fc 10 84 24 e2 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2e2]
  20f58f:	00 00 
  20f591:	c5 fc 10 8c 24 f0 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2f0]
  20f598:	00 00 
  20f59a:	e9 68 f4 ff ff       	jmp    20ea07 <getLineNumberInfo+0x1137>
  20f59f:	66 b8 1e 00          	mov    ax,0x1e
  20f5a3:	eb 16                	jmp    20f5bb <getLineNumberInfo+0x1ceb>
  20f5a5:	66 b8 1e 00          	mov    ax,0x1e
  20f5a9:	eb 32                	jmp    20f5dd <getLineNumberInfo+0x1d0d>
  20f5ab:	66 b8 1e 00          	mov    ax,0x1e
  20f5af:	eb 4e                	jmp    20f5ff <getLineNumberInfo+0x1d2f>
  20f5b1:	66 b8 1e 00          	mov    ax,0x1e
  20f5b5:	eb 6a                	jmp    20f621 <getLineNumberInfo+0x1d51>
  20f5b7:	66 b8 23 00          	mov    ax,0x23
  20f5bb:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  20f5bf:	66 89 01             	mov    WORD PTR [rcx],ax
  20f5c2:	c5 fc 10 84 24 f6 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3f6]
  20f5c9:	00 00 
  20f5cb:	c5 fc 10 8c 24 04 04 	vmovups ymm1,YMMWORD PTR [rsp+0x404]
  20f5d2:	00 00 
  20f5d4:	e9 1c e7 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f5d9:	66 b8 23 00          	mov    ax,0x23
  20f5dd:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readILeb128(in_stream);
  20f5e1:	66 89 01             	mov    WORD PTR [rcx],ax
  20f5e4:	c5 fc 10 84 24 c8 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3c8]
  20f5eb:	00 00 
  20f5ed:	c5 fc 10 8c 24 d6 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3d6]
  20f5f4:	00 00 
  20f5f6:	e9 fa e6 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f5fb:	66 b8 23 00          	mov    ax,0x23
  20f5ff:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  20f603:	66 89 01             	mov    WORD PTR [rcx],ax
  20f606:	c5 fc 10 84 24 9a 03 	vmovups ymm0,YMMWORD PTR [rsp+0x39a]
  20f60d:	00 00 
  20f60f:	c5 fc 10 8c 24 a8 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3a8]
  20f616:	00 00 
  20f618:	e9 d8 e6 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f61d:	66 b8 23 00          	mov    ax,0x23
  20f621:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  20f625:	66 89 01             	mov    WORD PTR [rcx],ax
  20f628:	c5 fc 10 84 24 6c 03 	vmovups ymm0,YMMWORD PTR [rsp+0x36c]
  20f62f:	00 00 
  20f631:	c5 fc 10 8c 24 7a 03 	vmovups ymm1,YMMWORD PTR [rsp+0x37a]
  20f638:	00 00 
  20f63a:	e9 b6 e6 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f63f:	66 b8 1e 00          	mov    ax,0x1e
  20f643:	eb 04                	jmp    20f649 <getLineNumberInfo+0x1d79>
  20f645:	66 b8 23 00          	mov    ax,0x23
  20f649:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const dir_index = try readULeb128(in_stream);
  20f64d:	66 89 01             	mov    WORD PTR [rcx],ax
  20f650:	c5 fc 10 84 24 38 05 	vmovups ymm0,YMMWORD PTR [rsp+0x538]
  20f657:	00 00 
  20f659:	c5 fc 10 8c 24 46 05 	vmovups ymm1,YMMWORD PTR [rsp+0x546]
  20f660:	00 00 
  20f662:	e9 8e e6 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f667:	66 b8 1e 00          	mov    ax,0x1e
  20f66b:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                sub_op = try in_stream.readByte();
  20f66f:	66 89 01             	mov    WORD PTR [rcx],ax
  20f672:	c5 fe 6f 84 24 1e 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x61e]
  20f679:	00 00 
  20f67b:	c5 fc 10 8c 24 2c 06 	vmovups ymm1,YMMWORD PTR [rsp+0x62c]
  20f682:	00 00 
  20f684:	e9 6c e6 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
                        prog.end_sequence = true;
  20f689:	c6 84 24 02 01 00 00 	mov    BYTE PTR [rsp+0x102],0x1
  20f690:	01 
  20f691:	48 8d bc 24 78 02 00 	lea    rdi,[rsp+0x278]
  20f698:	00 
  20f699:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  20f6a0:	00 
                        if (try prog.checkLineMatch()) |info| return info;
  20f6a1:	e8 1a 08 00 00       	call   20fec0 <LineNumberProgram_checkLineMatch>
  20f6a6:	0f b7 84 24 78 02 00 	movzx  eax,WORD PTR [rsp+0x278]
  20f6ad:	00 
  20f6ae:	66 85 c0             	test   ax,ax
  20f6b1:	74 46                	je     20f6f9 <getLineNumberInfo+0x1e29>
  20f6b3:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  20f6b7:	66 89 01             	mov    WORD PTR [rcx],ax
  20f6ba:	c5 fc 10 84 24 c2 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5c2]
  20f6c1:	00 00 
  20f6c3:	c5 fc 10 8c 24 d0 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5d0]
  20f6ca:	00 00 
  20f6cc:	e9 24 e6 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f6d1:	66 b8 1e 00          	mov    ax,0x1e
  20f6d5:	eb 04                	jmp    20f6db <getLineNumberInfo+0x1e0b>
  20f6d7:	66 b8 23 00          	mov    ax,0x23
  20f6db:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const mtime = try readULeb128(in_stream);
  20f6df:	66 89 01             	mov    WORD PTR [rcx],ax
  20f6e2:	c5 fc 10 84 24 0a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x50a]
  20f6e9:	00 00 
  20f6eb:	c5 fc 10 8c 24 18 05 	vmovups ymm1,YMMWORD PTR [rsp+0x518]
  20f6f2:	00 00 
  20f6f4:	e9 fc e5 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
                        if (try prog.checkLineMatch()) |info| return info;
  20f6f9:	80 bc 24 a8 02 00 00 	cmp    BYTE PTR [rsp+0x2a8],0x1
  20f700:	01 
  20f701:	0f 85 b7 e4 ff ff    	jne    20dbbe <getLineNumberInfo+0x2ee>
  20f707:	48 8b 84 24 a0 02 00 	mov    rax,QWORD PTR [rsp+0x2a0]
  20f70e:	00 
  20f70f:	48 89 84 24 36 03 00 	mov    QWORD PTR [rsp+0x336],rax
  20f716:	00 
  20f717:	c5 fc 10 84 24 80 02 	vmovups ymm0,YMMWORD PTR [rsp+0x280]
  20f71e:	00 00 
  20f720:	c5 fc 11 84 24 16 03 	vmovups YMMWORD PTR [rsp+0x316],ymm0
  20f727:	00 00 
  20f729:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  20f72d:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  20f732:	c5 fc 10 84 24 10 03 	vmovups ymm0,YMMWORD PTR [rsp+0x310]
  20f739:	00 00 
  20f73b:	c5 fc 10 8c 24 1e 03 	vmovups ymm1,YMMWORD PTR [rsp+0x31e]
  20f742:	00 00 
  20f744:	e9 be f2 ff ff       	jmp    20ea07 <getLineNumberInfo+0x1137>
  20f749:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        if (try prog.checkLineMatch()) |info| return info;
  20f74d:	66 89 01             	mov    WORD PTR [rcx],ax
  20f750:	c5 fc 10 84 24 24 04 	vmovups ymm0,YMMWORD PTR [rsp+0x424]
  20f757:	00 00 
  20f759:	c5 fc 10 8c 24 32 04 	vmovups ymm1,YMMWORD PTR [rsp+0x432]
  20f760:	00 00 
  20f762:	e9 8e e5 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f767:	48 8b 84 24 30 02 00 	mov    rax,QWORD PTR [rsp+0x230]
  20f76e:	00 
  20f76f:	48 89 84 24 da 02 00 	mov    QWORD PTR [rsp+0x2da],rax
  20f776:	00 
  20f777:	c5 fc 10 84 24 10 02 	vmovups ymm0,YMMWORD PTR [rsp+0x210]
  20f77e:	00 00 
  20f780:	c5 fc 11 84 24 ba 02 	vmovups YMMWORD PTR [rsp+0x2ba],ymm0
  20f787:	00 00 
  20f789:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  20f78d:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  20f792:	c5 fc 10 84 24 b4 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2b4]
  20f799:	00 00 
  20f79b:	c5 fc 10 8c 24 c2 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2c2]
  20f7a2:	00 00 
  20f7a4:	e9 5e f2 ff ff       	jmp    20ea07 <getLineNumberInfo+0x1137>
  20f7a9:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  20f7ad:	48 83 f8 17          	cmp    rax,0x17
  20f7b1:	0f 87 c6 00 00 00    	ja     20f87d <getLineNumberInfo+0x1fad>
  20f7b7:	48 8d 0d a6 14 ff ff 	lea    rcx,[rip+0xffffffffffff14a6]        # 200c64 <__unnamed_128+0xa1c>
  20f7be:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  20f7c2:	48 01 c8             	add    rax,rcx
  20f7c5:	ff e0                	jmp    rax
  20f7c7:	66 b8 1c 00          	mov    ax,0x1c
  20f7cb:	e9 c9 00 00 00       	jmp    20f899 <getLineNumberInfo+0x1fc9>
  20f7d0:	66 b8 1e 00          	mov    ax,0x1e
  20f7d4:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try in_stream.readInt(st.elf.endian, u16);
  20f7d8:	66 89 01             	mov    WORD PTR [rcx],ax
  20f7db:	c5 fc 10 84 24 3e 03 	vmovups ymm0,YMMWORD PTR [rsp+0x33e]
  20f7e2:	00 00 
  20f7e4:	c5 fc 10 8c 24 4c 03 	vmovups ymm1,YMMWORD PTR [rsp+0x34c]
  20f7eb:	00 00 
  20f7ed:	e9 03 e5 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f7f2:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const file_name = try st.readString();
  20f7f6:	66 89 01             	mov    WORD PTR [rcx],ax
  20f7f9:	c5 fc 10 84 24 66 05 	vmovups ymm0,YMMWORD PTR [rsp+0x566]
  20f800:	00 00 
  20f802:	c5 fc 10 8c 24 74 05 	vmovups ymm1,YMMWORD PTR [rsp+0x574]
  20f809:	00 00 
  20f80b:	e9 e5 e4 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f810:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  20f814:	48 83 f8 17          	cmp    rax,0x17
  20f818:	77 6f                	ja     20f889 <getLineNumberInfo+0x1fb9>
  20f81a:	48 8d 0d a3 14 ff ff 	lea    rcx,[rip+0xffffffffffff14a3]        # 200cc4 <__unnamed_128+0xa7c>
  20f821:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  20f825:	48 01 c8             	add    rax,rcx
  20f828:	ff e0                	jmp    rax
  20f82a:	66 b8 20 00          	mov    ax,0x20
  20f82e:	e9 88 00 00 00       	jmp    20f8bb <getLineNumberInfo+0x1feb>
  20f833:	66 b8 1e 00          	mov    ax,0x1e
  20f837:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const addr = try in_stream.readInt(st.elf.endian, usize);
  20f83b:	66 89 01             	mov    WORD PTR [rcx],ax
  20f83e:	c5 fe 6f 84 24 94 05 	vmovdqu ymm0,YMMWORD PTR [rsp+0x594]
  20f845:	00 00 
  20f847:	c5 fc 10 8c 24 a2 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5a2]
  20f84e:	00 00 
  20f850:	e9 a0 e4 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f855:	66 b8 1e 00          	mov    ax,0x1e
  20f859:	eb 04                	jmp    20f85f <getLineNumberInfo+0x1f8f>
  20f85b:	66 b8 23 00          	mov    ax,0x23
  20f85f:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const len_bytes = try readULeb128(in_stream);
  20f863:	66 89 01             	mov    WORD PTR [rcx],ax
  20f866:	c5 fc 10 84 24 dc 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4dc]
  20f86d:	00 00 
  20f86f:	c5 fc 10 8c 24 ea 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4ea]
  20f876:	00 00 
  20f878:	e9 78 e4 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f87d:	48 83 f9 4b          	cmp    rcx,0x4b
  20f881:	75 12                	jne    20f895 <getLineNumberInfo+0x1fc5>
  20f883:	66 b8 20 00          	mov    ax,0x20
  20f887:	eb 10                	jmp    20f899 <getLineNumberInfo+0x1fc9>
  20f889:	48 83 f9 4b          	cmp    rcx,0x4b
  20f88d:	74 9b                	je     20f82a <getLineNumberInfo+0x1f5a>
  20f88f:	66 b8 05 00          	mov    ax,0x5
  20f893:	eb 26                	jmp    20f8bb <getLineNumberInfo+0x1feb>
  20f895:	66 b8 05 00          	mov    ax,0x5
  20f899:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try in_file.seekForward(len_bytes);
  20f89d:	66 89 01             	mov    WORD PTR [rcx],ax
  20f8a0:	c5 fc 10 84 24 52 04 	vmovups ymm0,YMMWORD PTR [rsp+0x452]
  20f8a7:	00 00 
  20f8a9:	c5 fc 10 8c 24 60 04 	vmovups ymm1,YMMWORD PTR [rsp+0x460]
  20f8b0:	00 00 
  20f8b2:	e9 3e e4 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f8b7:	66 b8 1c 00          	mov    ax,0x1c
  20f8bb:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try in_file.seekForward(fwd_amt);
  20f8bf:	66 89 01             	mov    WORD PTR [rcx],ax
  20f8c2:	c5 fc 10 84 24 f0 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5f0]
  20f8c9:	00 00 
  20f8cb:	c5 fc 10 8c 24 fe 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5fe]
  20f8d2:	00 00 
  20f8d4:	e9 1c e4 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
            @panic("assertion failure");
  20f8d9:	e8 f2 38 ff ff       	call   2031d0 <panic>
  20f8de:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try file_entries.append(FileEntry{
  20f8e2:	66 89 01             	mov    WORD PTR [rcx],ax
  20f8e5:	c5 fc 10 84 24 ae 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4ae]
  20f8ec:	00 00 
  20f8ee:	c5 fc 10 8c 24 bc 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4bc]
  20f8f5:	00 00 
  20f8f7:	e9 f9 e3 ff ff       	jmp    20dcf5 <getLineNumberInfo+0x425>
  20f8fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000020f900 <printLineFromFile>:
fn printLineFromFile(allocator: *mem.Allocator, out_stream: var, line_info: *const LineInfo) !void {
  20f900:	55                   	push   rbp
  20f901:	41 57                	push   r15
  20f903:	41 56                	push   r14
  20f905:	41 55                	push   r13
  20f907:	41 54                	push   r12
  20f909:	53                   	push   rbx
  20f90a:	48 81 ec 58 10 00 00 	sub    rsp,0x1058
  20f911:	48 89 d3             	mov    rbx,rdx
  20f914:	49 89 f6             	mov    r14,rsi
  20f917:	48 89 f8             	mov    rax,rdi
    var f = try os.File.openRead(allocator, line_info.file_name);
  20f91a:	48 8d 53 10          	lea    rdx,[rbx+0x10]
  20f91e:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  20f923:	48 89 c6             	mov    rsi,rax
  20f926:	e8 a5 96 ff ff       	call   208fd0 <File_openRead>
  20f92b:	0f b7 6c 24 38       	movzx  ebp,WORD PTR [rsp+0x38]
  20f930:	66 85 ed             	test   bp,bp
  20f933:	74 07                	je     20f93c <printLineFromFile+0x3c>
  20f935:	89 e8                	mov    eax,ebp
  20f937:	e9 8e 02 00 00       	jmp    20fbca <printLineFromFile+0x2ca>
  20f93c:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  20f941:	48 63 5c 24 3c       	movsxd rbx,DWORD PTR [rsp+0x3c]
  20f946:	89 5c 24 08          	mov    DWORD PTR [rsp+0x8],ebx
    var buf: [os.page_size]u8 = undefined;
  20f94a:	48 8d 35 2e 1b ff ff 	lea    rsi,[rip+0xffffffffffff1b2e]        # 20147f <__unnamed_69>
  20f951:	48 8d 6c 24 58       	lea    rbp,[rsp+0x58]
  20f956:	ba 00 10 00 00       	mov    edx,0x1000
  20f95b:	48 89 ef             	mov    rdi,rbp
  20f95e:	e8 cd 20 00 00       	call   211a30 <memcpy>
        const amt_read = try f.read(buf[0..]);
  20f963:	48 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],rbp
  20f968:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  20f96f:	00 00 
  20f971:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  20f976:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20f97b:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  20f980:	e8 2b 9c ff ff       	call   2095b0 <File_read>
  20f985:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  20f98b:	74 40                	je     20f9cd <printLineFromFile+0xcd>
  20f98d:	0f 1f 00             	nop    DWORD PTR [rax]
    return asm volatile ("syscall"
  20f990:	b8 03 00 00 00       	mov    eax,0x3
  20f995:	48 89 df             	mov    rdi,rbx
  20f998:	0f 05                	syscall 
            switch (err) {
  20f99a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20f99e:	74 f0                	je     20f990 <printLineFromFile+0x90>
            const first = list.first orelse return null;
  20f9a0:	48 8b 05 79 56 00 00 	mov    rax,QWORD PTR [rip+0x5679]        # 215020 <emfile_promise_queue>
  20f9a7:	48 85 c0             	test   rax,rax
  20f9aa:	0f 84 15 02 00 00    	je     20fbc5 <printLineFromFile+0x2c5>
            if (node.prev) |prev_node| {
  20f9b0:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20f9b3:	48 85 c9             	test   rcx,rcx
  20f9b6:	0f 84 a5 01 00 00    	je     20fb61 <printLineFromFile+0x261>
                prev_node.next = node.next;
  20f9bc:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20f9c0:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20f9c4:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20f9c8:	e9 9f 01 00 00       	jmp    20fb6c <printLineFromFile+0x26c>
  20f9cd:	41 bc 01 00 00 00    	mov    r12d,0x1
  20f9d3:	4c 89 74 24 40       	mov    QWORD PTR [rsp+0x40],r14
  20f9d8:	4c 8b 6c 24 20       	mov    r13,QWORD PTR [rsp+0x20]
        for (slice) |byte| {
  20f9dd:	4d 85 ed             	test   r13,r13
  20f9e0:	0f 84 3a 01 00 00    	je     20fb20 <printLineFromFile+0x220>
  20f9e6:	45 31 ff             	xor    r15d,r15d
  20f9e9:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  20f9ee:	66 90                	xchg   ax,ax
  20f9f0:	46 0f b6 74 3c 58    	movzx  r14d,BYTE PTR [rsp+r15*1+0x58]
            if (line == line_info.line) {
  20f9f6:	4c 3b 21             	cmp    r12,QWORD PTR [rcx]
  20f9f9:	75 45                	jne    20fa40 <printLineFromFile+0x140>
  20f9fb:	44 88 74 24 07       	mov    BYTE PTR [rsp+0x7],r14b
            const slice = (*[1]u8)(&byte)[0..];
  20fa00:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20fa05:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  20fa0a:	48 c7 44 24 50 01 00 	mov    QWORD PTR [rsp+0x50],0x1
  20fa11:	00 00 
  20fa13:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
            return self.writeFn(self, slice);
  20fa18:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  20fa1d:	ff 17                	call   QWORD PTR [rdi]
  20fa1f:	89 c5                	mov    ebp,eax
                try out_stream.writeByte(byte);
  20fa21:	66 85 ed             	test   bp,bp
  20fa24:	75 7a                	jne    20faa0 <printLineFromFile+0x1a0>
                if (byte == '\n') {
  20fa26:	41 80 fe 0a          	cmp    r14b,0xa
  20fa2a:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  20fa2f:	0f 84 ab 00 00 00    	je     20fae0 <printLineFromFile+0x1e0>
        for (slice) |byte| {
  20fa35:	49 83 c7 01          	add    r15,0x1
  20fa39:	4d 39 ef             	cmp    r15,r13
  20fa3c:	72 b2                	jb     20f9f0 <printLineFromFile+0xf0>
  20fa3e:	eb 15                	jmp    20fa55 <printLineFromFile+0x155>
            if (byte == '\n') {
  20fa40:	31 c0                	xor    eax,eax
  20fa42:	41 80 fe 0a          	cmp    r14b,0xa
  20fa46:	0f 94 c0             	sete   al
  20fa49:	49 01 c4             	add    r12,rax
        for (slice) |byte| {
  20fa4c:	49 83 c7 01          	add    r15,0x1
  20fa50:	4d 39 ef             	cmp    r15,r13
  20fa53:	72 9b                	jb     20f9f0 <printLineFromFile+0xf0>
        if (amt_read < buf.len) return error.EndOfFile;
  20fa55:	49 81 fd ff 0f 00 00 	cmp    r13,0xfff
  20fa5c:	48 8d 44 24 58       	lea    rax,[rsp+0x58]
  20fa61:	0f 86 b9 00 00 00    	jbe    20fb20 <printLineFromFile+0x220>
        const amt_read = try f.read(buf[0..]);
  20fa67:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20fa6c:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  20fa73:	00 00 
  20fa75:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  20fa7a:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  20fa7f:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  20fa84:	e8 27 9b ff ff       	call   2095b0 <File_read>
  20fa89:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  20fa8f:	0f 84 43 ff ff ff    	je     20f9d8 <printLineFromFile+0xd8>
  20fa95:	e9 f6 fe ff ff       	jmp    20f990 <printLineFromFile+0x90>
  20fa9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  20faa0:	b8 03 00 00 00       	mov    eax,0x3
  20faa5:	48 89 df             	mov    rdi,rbx
  20faa8:	0f 05                	syscall 
  20faaa:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20faae:	74 f0                	je     20faa0 <printLineFromFile+0x1a0>
            const first = list.first orelse return null;
  20fab0:	48 8b 05 69 55 00 00 	mov    rax,QWORD PTR [rip+0x5569]        # 215020 <emfile_promise_queue>
  20fab7:	48 85 c0             	test   rax,rax
  20faba:	0f 84 75 fe ff ff    	je     20f935 <printLineFromFile+0x35>
            if (node.prev) |prev_node| {
  20fac0:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20fac3:	48 85 c9             	test   rcx,rcx
  20fac6:	0f 84 10 01 00 00    	je     20fbdc <printLineFromFile+0x2dc>
                prev_node.next = node.next;
  20facc:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20fad0:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20fad4:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20fad8:	e9 0a 01 00 00       	jmp    20fbe7 <printLineFromFile+0x2e7>
  20fadd:	0f 1f 00             	nop    DWORD PTR [rax]
  20fae0:	b8 03 00 00 00       	mov    eax,0x3
  20fae5:	48 89 df             	mov    rdi,rbx
  20fae8:	0f 05                	syscall 
  20faea:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20faee:	74 f0                	je     20fae0 <printLineFromFile+0x1e0>
            const first = list.first orelse return null;
  20faf0:	48 8b 05 29 55 00 00 	mov    rax,QWORD PTR [rip+0x5529]        # 215020 <emfile_promise_queue>
  20faf7:	48 85 c0             	test   rax,rax
  20fafa:	0f 84 b5 01 00 00    	je     20fcb5 <printLineFromFile+0x3b5>
            if (node.prev) |prev_node| {
  20fb00:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20fb03:	48 85 c9             	test   rcx,rcx
  20fb06:	0f 84 42 01 00 00    	je     20fc4e <printLineFromFile+0x34e>
                prev_node.next = node.next;
  20fb0c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20fb10:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20fb14:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20fb18:	e9 3c 01 00 00       	jmp    20fc59 <printLineFromFile+0x359>
  20fb1d:	0f 1f 00             	nop    DWORD PTR [rax]
  20fb20:	b8 03 00 00 00       	mov    eax,0x3
  20fb25:	48 89 df             	mov    rdi,rbx
  20fb28:	0f 05                	syscall 
  20fb2a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20fb2e:	74 f0                	je     20fb20 <printLineFromFile+0x220>
            const first = list.first orelse return null;
  20fb30:	48 8b 05 e9 54 00 00 	mov    rax,QWORD PTR [rip+0x54e9]        # 215020 <emfile_promise_queue>
  20fb37:	66 bd 24 00          	mov    bp,0x24
  20fb3b:	48 85 c0             	test   rax,rax
  20fb3e:	0f 84 f1 fd ff ff    	je     20f935 <printLineFromFile+0x35>
            if (node.prev) |prev_node| {
  20fb44:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20fb47:	48 85 c9             	test   rcx,rcx
  20fb4a:	0f 84 6c 01 00 00    	je     20fcbc <printLineFromFile+0x3bc>
                prev_node.next = node.next;
  20fb50:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20fb54:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20fb58:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20fb5c:	e9 66 01 00 00       	jmp    20fcc7 <printLineFromFile+0x3c7>
                list.first = node.next;
  20fb61:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20fb65:	48 89 0d b4 54 00 00 	mov    QWORD PTR [rip+0x54b4],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  20fb6c:	48 85 c9             	test   rcx,rcx
  20fb6f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20fb72:	48 8d 35 af 54 00 00 	lea    rsi,[rip+0x54af]        # 215028 <emfile_promise_queue+0x8>
  20fb79:	48 0f 45 f1          	cmovne rsi,rcx
  20fb7d:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20fb80:	48 83 05 a8 54 00 00 	add    QWORD PTR [rip+0x54a8],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  20fb87:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20fb88:	74 1e                	je     20fba8 <printLineFromFile+0x2a8>
  20fb8a:	48 83 3d 8e 54 00 00 	cmp    QWORD PTR [rip+0x548e],0x0        # 215020 <emfile_promise_queue>
  20fb91:	00 
  20fb92:	0f 84 8c 01 00 00    	je     20fd24 <printLineFromFile+0x424>
  20fb98:	48 8b 0d 89 54 00 00 	mov    rcx,QWORD PTR [rip+0x5489]        # 215028 <emfile_promise_queue+0x8>
  20fb9f:	48 85 c9             	test   rcx,rcx
  20fba2:	0f 84 7c 01 00 00    	je     20fd24 <printLineFromFile+0x424>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20fba8:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20fbac:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20fbb0:	48 89 c1             	mov    rcx,rax
  20fbb3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20fbb7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20fbbd:	75 f1                	jne    20fbb0 <printLineFromFile+0x2b0>
  20fbbf:	a8 01                	test   al,0x1
  20fbc1:	75 02                	jne    20fbc5 <printLineFromFile+0x2c5>
  20fbc3:	ff 17                	call   QWORD PTR [rdi]
  20fbc5:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  20fbca:	48 81 c4 58 10 00 00 	add    rsp,0x1058
  20fbd1:	5b                   	pop    rbx
  20fbd2:	41 5c                	pop    r12
  20fbd4:	41 5d                	pop    r13
  20fbd6:	41 5e                	pop    r14
  20fbd8:	41 5f                	pop    r15
  20fbda:	5d                   	pop    rbp
  20fbdb:	c3                   	ret    
                list.first = node.next;
  20fbdc:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20fbe0:	48 89 0d 39 54 00 00 	mov    QWORD PTR [rip+0x5439],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  20fbe7:	48 85 c9             	test   rcx,rcx
  20fbea:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20fbed:	48 8d 35 34 54 00 00 	lea    rsi,[rip+0x5434]        # 215028 <emfile_promise_queue+0x8>
  20fbf4:	48 0f 45 f1          	cmovne rsi,rcx
  20fbf8:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20fbfb:	48 83 05 2d 54 00 00 	add    QWORD PTR [rip+0x542d],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  20fc02:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20fc03:	74 1e                	je     20fc23 <printLineFromFile+0x323>
  20fc05:	48 83 3d 13 54 00 00 	cmp    QWORD PTR [rip+0x5413],0x0        # 215020 <emfile_promise_queue>
  20fc0c:	00 
  20fc0d:	0f 84 11 01 00 00    	je     20fd24 <printLineFromFile+0x424>
  20fc13:	48 8b 0d 0e 54 00 00 	mov    rcx,QWORD PTR [rip+0x540e]        # 215028 <emfile_promise_queue+0x8>
  20fc1a:	48 85 c9             	test   rcx,rcx
  20fc1d:	0f 84 01 01 00 00    	je     20fd24 <printLineFromFile+0x424>
  20fc23:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20fc27:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20fc2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20fc30:	48 89 c1             	mov    rcx,rax
  20fc33:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20fc37:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20fc3d:	75 f1                	jne    20fc30 <printLineFromFile+0x330>
  20fc3f:	a8 01                	test   al,0x1
  20fc41:	0f 85 ee fc ff ff    	jne    20f935 <printLineFromFile+0x35>
  20fc47:	ff 17                	call   QWORD PTR [rdi]
  20fc49:	e9 e7 fc ff ff       	jmp    20f935 <printLineFromFile+0x35>
                list.first = node.next;
  20fc4e:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20fc52:	48 89 0d c7 53 00 00 	mov    QWORD PTR [rip+0x53c7],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  20fc59:	48 85 c9             	test   rcx,rcx
  20fc5c:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20fc5f:	48 8d 35 c2 53 00 00 	lea    rsi,[rip+0x53c2]        # 215028 <emfile_promise_queue+0x8>
  20fc66:	48 0f 45 f1          	cmovne rsi,rcx
  20fc6a:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20fc6d:	48 83 05 bb 53 00 00 	add    QWORD PTR [rip+0x53bb],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  20fc74:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20fc75:	74 1e                	je     20fc95 <printLineFromFile+0x395>
  20fc77:	48 83 3d a1 53 00 00 	cmp    QWORD PTR [rip+0x53a1],0x0        # 215020 <emfile_promise_queue>
  20fc7e:	00 
  20fc7f:	0f 84 9f 00 00 00    	je     20fd24 <printLineFromFile+0x424>
  20fc85:	48 8b 0d 9c 53 00 00 	mov    rcx,QWORD PTR [rip+0x539c]        # 215028 <emfile_promise_queue+0x8>
  20fc8c:	48 85 c9             	test   rcx,rcx
  20fc8f:	0f 84 8f 00 00 00    	je     20fd24 <printLineFromFile+0x424>
  20fc95:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20fc99:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20fc9d:	0f 1f 00             	nop    DWORD PTR [rax]
  20fca0:	48 89 c1             	mov    rcx,rax
  20fca3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20fca7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20fcad:	75 f1                	jne    20fca0 <printLineFromFile+0x3a0>
  20fcaf:	a8 01                	test   al,0x1
  20fcb1:	75 02                	jne    20fcb5 <printLineFromFile+0x3b5>
  20fcb3:	ff 17                	call   QWORD PTR [rdi]
  20fcb5:	31 ed                	xor    ebp,ebp
  20fcb7:	e9 79 fc ff ff       	jmp    20f935 <printLineFromFile+0x35>
                list.first = node.next;
  20fcbc:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20fcc0:	48 89 0d 59 53 00 00 	mov    QWORD PTR [rip+0x5359],rcx        # 215020 <emfile_promise_queue>
            if (node.next) |next_node| {
  20fcc7:	48 85 c9             	test   rcx,rcx
  20fcca:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20fccd:	48 8d 35 54 53 00 00 	lea    rsi,[rip+0x5354]        # 215028 <emfile_promise_queue+0x8>
  20fcd4:	48 0f 45 f1          	cmovne rsi,rcx
  20fcd8:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20fcdb:	48 83 05 4d 53 00 00 	add    QWORD PTR [rip+0x534d],0xffffffffffffffff        # 215030 <emfile_promise_queue+0x10>
  20fce2:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20fce3:	74 16                	je     20fcfb <printLineFromFile+0x3fb>
  20fce5:	48 83 3d 33 53 00 00 	cmp    QWORD PTR [rip+0x5333],0x0        # 215020 <emfile_promise_queue>
  20fcec:	00 
  20fced:	74 35                	je     20fd24 <printLineFromFile+0x424>
  20fcef:	48 8b 0d 32 53 00 00 	mov    rcx,QWORD PTR [rip+0x5332]        # 215028 <emfile_promise_queue+0x8>
  20fcf6:	48 85 c9             	test   rcx,rcx
  20fcf9:	74 29                	je     20fd24 <printLineFromFile+0x424>
  20fcfb:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20fcff:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20fd03:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20fd0a:	84 00 00 00 00 00 
  20fd10:	48 89 c1             	mov    rcx,rax
  20fd13:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20fd17:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20fd1d:	75 f1                	jne    20fd10 <printLineFromFile+0x410>
  20fd1f:	e9 1b ff ff ff       	jmp    20fc3f <printLineFromFile+0x33f>
            @panic("assertion failure");
  20fd24:	e8 a7 34 ff ff       	call   2031d0 <panic>
  20fd29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000020fd30 <Allocator_alignedRealloc.54>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  20fd30:	41 56                	push   r14
  20fd32:	53                   	push   rbx
  20fd33:	48 83 ec 78          	sub    rsp,0x78
  20fd37:	49 89 ce             	mov    r14,rcx
  20fd3a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  20fd3d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  20fd41:	48 85 c0             	test   rax,rax
  20fd44:	74 59                	je     20fd9f <Allocator_alignedRealloc.54+0x6f>
        if (n == 0) {
  20fd46:	4d 85 f6             	test   r14,r14
  20fd49:	0f 84 92 00 00 00    	je     20fde1 <Allocator_alignedRealloc.54+0xb1>
        const old_byte_slice = @sliceToBytes(old_mem);
  20fd4f:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  20fd52:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  20fd57:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  20fd5c:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  20fd61:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20fd66:	41 b8 01 00 00 00    	mov    r8d,0x1
  20fd6c:	4c 89 f1             	mov    rcx,r14
  20fd6f:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  20fd72:	0f b7 44 24 48       	movzx  eax,WORD PTR [rsp+0x48]
  20fd77:	66 85 c0             	test   ax,ax
  20fd7a:	0f 84 9e 00 00 00    	je     20fe1e <Allocator_alignedRealloc.54+0xee>
  20fd80:	66 89 03             	mov    WORD PTR [rbx],ax
  20fd83:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  20fd88:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20fd8c:	c5 f8 10 44 24 62    	vmovups xmm0,XMMWORD PTR [rsp+0x62]
  20fd92:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  20fd97:	48 83 c4 78          	add    rsp,0x78
  20fd9b:	5b                   	pop    rbx
  20fd9c:	41 5e                	pop    r14
  20fd9e:	c3                   	ret    
        if (n == 0) {
  20fd9f:	4d 85 f6             	test   r14,r14
  20fda2:	0f 84 a1 00 00 00    	je     20fe49 <Allocator_alignedRealloc.54+0x119>
  20fda8:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20fdad:	b9 01 00 00 00       	mov    ecx,0x1
  20fdb2:	4c 89 f2             	mov    rdx,r14
  20fdb5:	ff 16                	call   QWORD PTR [rsi]
  20fdb7:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  20fdbc:	66 85 c9             	test   cx,cx
  20fdbf:	0f 84 a6 00 00 00    	je     20fe6b <Allocator_alignedRealloc.54+0x13b>
  20fdc5:	0f b7 44 24 1e       	movzx  eax,WORD PTR [rsp+0x1e]
  20fdca:	66 89 44 24 0c       	mov    WORD PTR [rsp+0xc],ax
  20fdcf:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20fdd4:	8b 54 24 1a          	mov    edx,DWORD PTR [rsp+0x1a]
  20fdd8:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
  20fddc:	e9 af 00 00 00       	jmp    20fe90 <Allocator_alignedRealloc.54+0x160>
        const bytes = @sliceToBytes(memory);
  20fde1:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20fde4:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  20fde8:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  20fded:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20fdf2:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  20fdf7:	48 89 f7             	mov    rdi,rsi
  20fdfa:	48 89 c6             	mov    rsi,rax
  20fdfd:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  20fdff:	48 8b 05 da 14 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff14da]        # 2012e0 <__unnamed_70+0x10>
  20fe06:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  20fe0a:	c5 f8 10 05 be 14 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff14be]        # 2012d0 <__unnamed_70>
  20fe11:	ff 
  20fe12:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  20fe16:	48 83 c4 78          	add    rsp,0x78
  20fe1a:	5b                   	pop    rbx
  20fe1b:	41 5e                	pop    r14
  20fe1d:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  20fe1e:	4c 39 74 24 58       	cmp    QWORD PTR [rsp+0x58],r14
    if (!ok) {
  20fe23:	0f 85 87 00 00 00    	jne    20feb0 <Allocator_alignedRealloc.54+0x180>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20fe29:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  20fe2e:	0f b7 44 24 12       	movzx  eax,WORD PTR [rsp+0x12]
  20fe33:	66 89 43 06          	mov    WORD PTR [rbx+0x6],ax
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  20fe37:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20fe3c:	8b 4c 24 0e          	mov    ecx,DWORD PTR [rsp+0xe]
  20fe40:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  20fe43:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  20fe47:	eb 5b                	jmp    20fea4 <Allocator_alignedRealloc.54+0x174>
  20fe49:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            return ([*]align(alignment) T)(undefined)[0..0];
  20fe4e:	0f b7 0d 81 14 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff1481]        # 2012d6 <__unnamed_70+0x6>
  20fe55:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  20fe5a:	8b 0d 72 14 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff1472]        # 2012d2 <__unnamed_70+0x2>
  20fe60:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  20fe64:	31 c9                	xor    ecx,ecx
  20fe66:	45 31 f6             	xor    r14d,r14d
  20fe69:	eb 25                	jmp    20fe90 <Allocator_alignedRealloc.54+0x160>
        assert(byte_slice.len == byte_count);
  20fe6b:	4c 39 74 24 30       	cmp    QWORD PTR [rsp+0x30],r14
  20fe70:	75 3e                	jne    20feb0 <Allocator_alignedRealloc.54+0x180>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20fe72:	48 8b 54 24 28       	mov    rdx,QWORD PTR [rsp+0x28]
  20fe77:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  20fe7c:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  20fe80:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  20fe84:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  20fe89:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  20fe8e:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  20fe90:	66 89 0b             	mov    WORD PTR [rbx],cx
  20fe93:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  20fe97:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  20fe9b:	8b 00                	mov    eax,DWORD PTR [rax]
  20fe9d:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  20fea0:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  20fea4:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  20fea8:	48 83 c4 78          	add    rsp,0x78
  20feac:	5b                   	pop    rbx
  20fead:	41 5e                	pop    r14
  20feaf:	c3                   	ret    
            @panic("assertion failure");
  20feb0:	e8 1b 33 ff ff       	call   2031d0 <panic>
  20feb5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20febc:	00 00 00 00 

000000000020fec0 <LineNumberProgram_checkLineMatch>:
    pub fn checkLineMatch(self: *LineNumberProgram) !?LineInfo {
  20fec0:	55                   	push   rbp
  20fec1:	41 57                	push   r15
  20fec3:	41 56                	push   r14
  20fec5:	41 55                	push   r13
  20fec7:	41 54                	push   r12
  20fec9:	53                   	push   rbx
  20feca:	48 83 ec 78          	sub    rsp,0x78
  20fece:	48 89 f3             	mov    rbx,rsi
  20fed1:	49 89 fe             	mov    r14,rdi
  20fed4:	48 8b 03             	mov    rax,QWORD PTR [rbx]
        if (self.target_address >= self.prev_address and self.target_address < self.address) {
  20fed7:	48 8b 4b 28          	mov    rcx,QWORD PTR [rbx+0x28]
  20fedb:	48 3b 4b 48          	cmp    rcx,QWORD PTR [rbx+0x48]
  20fedf:	0f 82 aa 00 00 00    	jb     20ff8f <LineNumberProgram_checkLineMatch+0xcf>
  20fee5:	48 39 c1             	cmp    rcx,rax
  20fee8:	0f 83 a1 00 00 00    	jae    20ff8f <LineNumberProgram_checkLineMatch+0xcf>
            const file_entry = if (self.prev_file == 0) {
  20feee:	48 8b 4b 50          	mov    rcx,QWORD PTR [rbx+0x50]
  20fef2:	48 85 c9             	test   rcx,rcx
  20fef5:	0f 84 ec 00 00 00    	je     20ffe7 <LineNumberProgram_checkLineMatch+0x127>
            } else if (self.prev_file - 1 >= self.file_entries.len) {
  20fefb:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  20feff:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
  20ff03:	48 3b 48 10          	cmp    rcx,QWORD PTR [rax+0x10]
  20ff07:	0f 83 c2 00 00 00    	jae    20ffcf <LineNumberProgram_checkLineMatch+0x10f>
                &self.file_entries.items[self.prev_file - 1];
  20ff0d:	4c 8b 08             	mov    r9,QWORD PTR [rax]
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  20ff10:	4c 8d 14 89          	lea    r10,[rcx+rcx*4]
  20ff14:	4b 8b 4c d1 10       	mov    rcx,QWORD PTR [r9+r10*8+0x10]
  20ff19:	48 3b 4b 38          	cmp    rcx,QWORD PTR [rbx+0x38]
  20ff1d:	0f 83 ac 00 00 00    	jae    20ffcf <LineNumberProgram_checkLineMatch+0x10f>
                self.include_dirs[file_entry.dir_index];
  20ff23:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  20ff27:	48 c1 e1 04          	shl    rcx,0x4
  20ff2b:	4c 8b 2c 0a          	mov    r13,QWORD PTR [rdx+rcx*1]
  20ff2f:	4c 8b 64 0a 08       	mov    r12,QWORD PTR [rdx+rcx*1+0x8]
  20ff34:	4f 8b 7c d1 08       	mov    r15,QWORD PTR [r9+r10*8+0x8]
    var total_strings_len: usize = strings.len; // 1 sep per string
    {
        comptime var string_i = 0;
        inline while (string_i < strings.len) : (string_i += 1) {
            const arg = ([]const u8)(strings[string_i]);
            total_strings_len += arg.len;
  20ff39:	4d 01 e7             	add    r15,r12
        if (n == 0) {
  20ff3c:	49 83 c7 02          	add    r15,0x2
  20ff40:	0f 84 ce 00 00 00    	je     210014 <LineNumberProgram_checkLineMatch+0x154>
  20ff46:	4c 89 54 24 18       	mov    QWORD PTR [rsp+0x18],r10
  20ff4b:	4c 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],r9
  20ff50:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  20ff54:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20ff59:	b9 01 00 00 00       	mov    ecx,0x1
  20ff5e:	4c 89 fa             	mov    rdx,r15
  20ff61:	ff 16                	call   QWORD PTR [rsi]
  20ff63:	0f b7 44 24 28       	movzx  eax,WORD PTR [rsp+0x28]
  20ff68:	66 85 c0             	test   ax,ax
  20ff6b:	0f 84 b0 00 00 00    	je     210021 <LineNumberProgram_checkLineMatch+0x161>
            const file_name = try os.path.join(self.file_entries.allocator, dir_name, file_entry.file_name);
  20ff71:	66 41 89 06          	mov    WORD PTR [r14],ax
  20ff75:	c5 fc 10 44 24 42    	vmovups ymm0,YMMWORD PTR [rsp+0x42]
  20ff7b:	c5 fc 10 4c 24 58    	vmovups ymm1,YMMWORD PTR [rsp+0x58]
  20ff81:	c4 c1 7c 11 4e 18    	vmovups YMMWORD PTR [r14+0x18],ymm1
  20ff87:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  20ff8d:	eb 73                	jmp    210002 <LineNumberProgram_checkLineMatch+0x142>
        self.prev_address = self.address;
  20ff8f:	48 89 43 48          	mov    QWORD PTR [rbx+0x48],rax
        self.prev_file = self.file;
  20ff93:	c5 f8 10 43 08       	vmovups xmm0,XMMWORD PTR [rbx+0x8]
  20ff98:	c5 f8 11 43 50       	vmovups XMMWORD PTR [rbx+0x50],xmm0
        self.prev_column = self.column;
  20ff9d:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  20ffa1:	48 89 43 60          	mov    QWORD PTR [rbx+0x60],rax
        self.prev_is_stmt = self.is_stmt;
  20ffa5:	8a 43 20             	mov    al,BYTE PTR [rbx+0x20]
  20ffa8:	88 43 68             	mov    BYTE PTR [rbx+0x68],al
        self.prev_basic_block = self.basic_block;
  20ffab:	8a 43 21             	mov    al,BYTE PTR [rbx+0x21]
  20ffae:	88 43 69             	mov    BYTE PTR [rbx+0x69],al
        self.prev_end_sequence = self.end_sequence;
  20ffb1:	8a 43 22             	mov    al,BYTE PTR [rbx+0x22]
  20ffb4:	88 43 6a             	mov    BYTE PTR [rbx+0x6a],al
        return null;
  20ffb7:	c5 fc 10 05 71 14 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff1471]        # 201430 <__unnamed_71+0x18>
  20ffbe:	ff 
  20ffbf:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  20ffc5:	c5 fc 10 05 4b 14 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff144b]        # 201418 <__unnamed_71>
  20ffcc:	ff 
  20ffcd:	eb 2e                	jmp    20fffd <LineNumberProgram_checkLineMatch+0x13d>
  20ffcf:	c5 fc 10 05 21 14 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff1421]        # 2013f8 <__unnamed_72+0x18>
  20ffd6:	ff 
  20ffd7:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  20ffdd:	c5 fc 10 05 fb 13 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff13fb]        # 2013e0 <__unnamed_72>
  20ffe4:	ff 
  20ffe5:	eb 16                	jmp    20fffd <LineNumberProgram_checkLineMatch+0x13d>
                return error.MissingDebugInfo;
  20ffe7:	c5 fc 10 05 d1 13 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff13d1]        # 2013c0 <__unnamed_73+0x18>
  20ffee:	ff 
  20ffef:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  20fff5:	c5 fc 10 05 ab 13 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff13ab]        # 2013a8 <__unnamed_73>
  20fffc:	ff 
  20fffd:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  210002:	48 83 c4 78          	add    rsp,0x78
  210006:	5b                   	pop    rbx
  210007:	41 5c                	pop    r12
  210009:	41 5d                	pop    r13
  21000b:	41 5e                	pop    r14
  21000d:	41 5f                	pop    r15
  21000f:	5d                   	pop    rbp
  210010:	c5 f8 77             	vzeroupper 
  210013:	c3                   	ret    
  210014:	45 31 ff             	xor    r15d,r15d
    assert(dest.len >= source.len);
  210017:	4d 39 e7             	cmp    r15,r12
    if (!ok) {
  21001a:	73 28                	jae    210044 <LineNumberProgram_checkLineMatch+0x184>
  21001c:	e9 c6 05 00 00       	jmp    2105e7 <LineNumberProgram_checkLineMatch+0x727>
        assert(byte_slice.len == byte_count);
  210021:	4c 39 7c 24 38       	cmp    QWORD PTR [rsp+0x38],r15
  210026:	0f 85 bb 05 00 00    	jne    2105e7 <LineNumberProgram_checkLineMatch+0x727>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21002c:	48 8b 6c 24 30       	mov    rbp,QWORD PTR [rsp+0x30]
  210031:	4c 8b 4c 24 20       	mov    r9,QWORD PTR [rsp+0x20]
  210036:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
    assert(dest.len >= source.len);
  21003b:	4d 39 e7             	cmp    r15,r12
  21003e:	0f 82 a3 05 00 00    	jb     2105e7 <LineNumberProgram_checkLineMatch+0x727>
    for (source) |s, i|
  210044:	4d 85 e4             	test   r12,r12
  210047:	0f 84 77 02 00 00    	je     2102c4 <LineNumberProgram_checkLineMatch+0x404>
  21004d:	49 81 fc 80 00 00 00 	cmp    r12,0x80
  210054:	72 1a                	jb     210070 <LineNumberProgram_checkLineMatch+0x1b0>
  210056:	4b 8d 0c 2c          	lea    rcx,[r12+r13*1]
  21005a:	48 39 cd             	cmp    rbp,rcx
  21005d:	0f 83 ab 00 00 00    	jae    21010e <LineNumberProgram_checkLineMatch+0x24e>
  210063:	49 8d 0c 2c          	lea    rcx,[r12+rbp*1]
  210067:	49 39 cd             	cmp    r13,rcx
  21006a:	0f 83 9e 00 00 00    	jae    21010e <LineNumberProgram_checkLineMatch+0x24e>
  210070:	31 c9                	xor    ecx,ecx
  210072:	49 8d 7c 24 ff       	lea    rdi,[r12-0x1]
  210077:	48 29 cf             	sub    rdi,rcx
  21007a:	4c 89 e6             	mov    rsi,r12
  21007d:	48 83 e6 07          	and    rsi,0x7
  210081:	74 21                	je     2100a4 <LineNumberProgram_checkLineMatch+0x1e4>
  210083:	48 f7 de             	neg    rsi
  210086:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21008d:	00 00 00 
  210090:	41 0f b6 54 0d 00    	movzx  edx,BYTE PTR [r13+rcx*1+0x0]
        dest[i] = s;
  210096:	88 54 0d 00          	mov    BYTE PTR [rbp+rcx*1+0x0],dl
    for (source) |s, i|
  21009a:	48 83 c1 01          	add    rcx,0x1
  21009e:	48 83 c6 01          	add    rsi,0x1
  2100a2:	75 ec                	jne    210090 <LineNumberProgram_checkLineMatch+0x1d0>
  2100a4:	48 83 ff 07          	cmp    rdi,0x7
  2100a8:	0f 82 16 02 00 00    	jb     2102c4 <LineNumberProgram_checkLineMatch+0x404>
  2100ae:	66 90                	xchg   ax,ax
  2100b0:	41 0f b6 54 0d 00    	movzx  edx,BYTE PTR [r13+rcx*1+0x0]
        dest[i] = s;
  2100b6:	88 54 0d 00          	mov    BYTE PTR [rbp+rcx*1+0x0],dl
    for (source) |s, i|
  2100ba:	41 0f b6 54 0d 01    	movzx  edx,BYTE PTR [r13+rcx*1+0x1]
        dest[i] = s;
  2100c0:	88 54 0d 01          	mov    BYTE PTR [rbp+rcx*1+0x1],dl
    for (source) |s, i|
  2100c4:	41 0f b6 54 0d 02    	movzx  edx,BYTE PTR [r13+rcx*1+0x2]
        dest[i] = s;
  2100ca:	88 54 0d 02          	mov    BYTE PTR [rbp+rcx*1+0x2],dl
    for (source) |s, i|
  2100ce:	41 0f b6 54 0d 03    	movzx  edx,BYTE PTR [r13+rcx*1+0x3]
        dest[i] = s;
  2100d4:	88 54 0d 03          	mov    BYTE PTR [rbp+rcx*1+0x3],dl
    for (source) |s, i|
  2100d8:	41 0f b6 54 0d 04    	movzx  edx,BYTE PTR [r13+rcx*1+0x4]
        dest[i] = s;
  2100de:	88 54 0d 04          	mov    BYTE PTR [rbp+rcx*1+0x4],dl
    for (source) |s, i|
  2100e2:	41 0f b6 54 0d 05    	movzx  edx,BYTE PTR [r13+rcx*1+0x5]
        dest[i] = s;
  2100e8:	88 54 0d 05          	mov    BYTE PTR [rbp+rcx*1+0x5],dl
    for (source) |s, i|
  2100ec:	41 0f b6 54 0d 06    	movzx  edx,BYTE PTR [r13+rcx*1+0x6]
        dest[i] = s;
  2100f2:	88 54 0d 06          	mov    BYTE PTR [rbp+rcx*1+0x6],dl
    for (source) |s, i|
  2100f6:	41 0f b6 54 0d 07    	movzx  edx,BYTE PTR [r13+rcx*1+0x7]
        dest[i] = s;
  2100fc:	88 54 0d 07          	mov    BYTE PTR [rbp+rcx*1+0x7],dl
    for (source) |s, i|
  210100:	48 83 c1 08          	add    rcx,0x8
  210104:	49 39 cc             	cmp    r12,rcx
  210107:	75 a7                	jne    2100b0 <LineNumberProgram_checkLineMatch+0x1f0>
  210109:	e9 b6 01 00 00       	jmp    2102c4 <LineNumberProgram_checkLineMatch+0x404>
  21010e:	4c 89 e1             	mov    rcx,r12
  210111:	48 83 e1 80          	and    rcx,0xffffffffffffff80
  210115:	48 8d 79 80          	lea    rdi,[rcx-0x80]
  210119:	48 89 fe             	mov    rsi,rdi
  21011c:	48 c1 ee 07          	shr    rsi,0x7
  210120:	8d 56 01             	lea    edx,[rsi+0x1]
  210123:	83 e2 03             	and    edx,0x3
  210126:	48 81 ff 80 01 00 00 	cmp    rdi,0x180
  21012d:	73 10                	jae    21013f <LineNumberProgram_checkLineMatch+0x27f>
  21012f:	31 f6                	xor    esi,esi
  210131:	48 85 d2             	test   rdx,rdx
  210134:	0f 85 3c 01 00 00    	jne    210276 <LineNumberProgram_checkLineMatch+0x3b6>
  21013a:	e9 7c 01 00 00       	jmp    2102bb <LineNumberProgram_checkLineMatch+0x3fb>
  21013f:	48 8d 7a ff          	lea    rdi,[rdx-0x1]
  210143:	48 29 f7             	sub    rdi,rsi
  210146:	31 f6                	xor    esi,esi
  210148:	c4 c1 7c 10 44 35 00 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x0]
  21014f:	c4 c1 7c 10 4c 35 20 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x20]
  210156:	c4 c1 7c 10 54 35 40 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0x40]
  21015d:	c4 c1 7c 10 5c 35 60 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x60]
        dest[i] = s;
  210164:	c5 fc 11 44 35 00    	vmovups YMMWORD PTR [rbp+rsi*1+0x0],ymm0
  21016a:	c5 fc 11 4c 35 20    	vmovups YMMWORD PTR [rbp+rsi*1+0x20],ymm1
  210170:	c5 fc 11 54 35 40    	vmovups YMMWORD PTR [rbp+rsi*1+0x40],ymm2
  210176:	c5 fc 11 5c 35 60    	vmovups YMMWORD PTR [rbp+rsi*1+0x60],ymm3
    for (source) |s, i|
  21017c:	c4 c1 7c 10 84 35 80 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x80]
  210183:	00 00 00 
  210186:	c4 c1 7c 10 8c 35 a0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0xa0]
  21018d:	00 00 00 
  210190:	c4 c1 7c 10 94 35 c0 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0xc0]
  210197:	00 00 00 
  21019a:	c4 c1 7c 10 9c 35 e0 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0xe0]
  2101a1:	00 00 00 
        dest[i] = s;
  2101a4:	c5 fc 11 84 35 80 00 	vmovups YMMWORD PTR [rbp+rsi*1+0x80],ymm0
  2101ab:	00 00 
  2101ad:	c5 fc 11 8c 35 a0 00 	vmovups YMMWORD PTR [rbp+rsi*1+0xa0],ymm1
  2101b4:	00 00 
  2101b6:	c5 fc 11 94 35 c0 00 	vmovups YMMWORD PTR [rbp+rsi*1+0xc0],ymm2
  2101bd:	00 00 
  2101bf:	c5 fc 11 9c 35 e0 00 	vmovups YMMWORD PTR [rbp+rsi*1+0xe0],ymm3
  2101c6:	00 00 
    for (source) |s, i|
  2101c8:	c4 c1 7c 10 84 35 00 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x100]
  2101cf:	01 00 00 
  2101d2:	c4 c1 7c 10 8c 35 20 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x120]
  2101d9:	01 00 00 
  2101dc:	c4 c1 7c 10 94 35 40 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0x140]
  2101e3:	01 00 00 
  2101e6:	c4 c1 7c 10 9c 35 60 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x160]
  2101ed:	01 00 00 
        dest[i] = s;
  2101f0:	c5 fc 11 84 35 00 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x100],ymm0
  2101f7:	00 00 
  2101f9:	c5 fc 11 8c 35 20 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x120],ymm1
  210200:	00 00 
  210202:	c5 fc 11 94 35 40 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x140],ymm2
  210209:	00 00 
  21020b:	c5 fc 11 9c 35 60 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x160],ymm3
  210212:	00 00 
    for (source) |s, i|
  210214:	c4 c1 7c 10 84 35 80 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x180]
  21021b:	01 00 00 
  21021e:	c4 c1 7c 10 8c 35 a0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x1a0]
  210225:	01 00 00 
  210228:	c4 c1 7c 10 94 35 c0 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0x1c0]
  21022f:	01 00 00 
  210232:	c4 c1 7c 10 9c 35 e0 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x1e0]
  210239:	01 00 00 
        dest[i] = s;
  21023c:	c5 fc 11 84 35 80 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x180],ymm0
  210243:	00 00 
  210245:	c5 fc 11 8c 35 a0 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x1a0],ymm1
  21024c:	00 00 
  21024e:	c5 fc 11 94 35 c0 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x1c0],ymm2
  210255:	00 00 
  210257:	c5 fc 11 9c 35 e0 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x1e0],ymm3
  21025e:	00 00 
    for (source) |s, i|
  210260:	48 81 c6 00 02 00 00 	add    rsi,0x200
  210267:	48 83 c7 04          	add    rdi,0x4
  21026b:	0f 85 d7 fe ff ff    	jne    210148 <LineNumberProgram_checkLineMatch+0x288>
  210271:	48 85 d2             	test   rdx,rdx
  210274:	74 45                	je     2102bb <LineNumberProgram_checkLineMatch+0x3fb>
  210276:	48 83 c6 60          	add    rsi,0x60
  21027a:	48 f7 da             	neg    rdx
  21027d:	c4 c1 7c 10 44 35 a0 	vmovups ymm0,YMMWORD PTR [r13+rsi*1-0x60]
  210284:	c4 c1 7c 10 4c 35 c0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1-0x40]
  21028b:	c4 c1 7c 10 54 35 e0 	vmovups ymm2,YMMWORD PTR [r13+rsi*1-0x20]
  210292:	c4 c1 7c 10 5c 35 00 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x0]
        dest[i] = s;
  210299:	c5 fc 11 44 35 a0    	vmovups YMMWORD PTR [rbp+rsi*1-0x60],ymm0
  21029f:	c5 fc 11 4c 35 c0    	vmovups YMMWORD PTR [rbp+rsi*1-0x40],ymm1
  2102a5:	c5 fc 11 54 35 e0    	vmovups YMMWORD PTR [rbp+rsi*1-0x20],ymm2
  2102ab:	c5 fc 11 5c 35 00    	vmovups YMMWORD PTR [rbp+rsi*1+0x0],ymm3
    for (source) |s, i|
  2102b1:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  2102b5:	48 83 c2 01          	add    rdx,0x1
  2102b9:	75 c2                	jne    21027d <LineNumberProgram_checkLineMatch+0x3bd>
  2102bb:	49 39 cc             	cmp    r12,rcx
  2102be:	0f 85 ae fd ff ff    	jne    210072 <LineNumberProgram_checkLineMatch+0x1b2>
  2102c4:	4b 8d 0c d1          	lea    rcx,[r9+r10*8]
  2102c8:	48 83 c1 08          	add    rcx,0x8
        const arg = ([]const u8)(strings[string_i]);
        string_i += 1;
        copy(u8, buf[buf_index..], arg);
        buf_index += arg.len;
        if (string_i >= strings.len) break;
        if (buf[buf_index - 1] != sep) {
  2102cc:	42 80 7c 25 ff 2f    	cmp    BYTE PTR [rbp+r12*1-0x1],0x2f
  2102d2:	74 0a                	je     2102de <LineNumberProgram_checkLineMatch+0x41e>
            buf[buf_index] = sep;
  2102d4:	42 c6 44 25 00 2f    	mov    BYTE PTR [rbp+r12*1+0x0],0x2f
            buf_index += 1;
  2102da:	49 83 c4 01          	add    r12,0x1
        const arg = ([]const u8)(strings[string_i]);
  2102de:	4c 8b 01             	mov    r8,QWORD PTR [rcx]
        copy(u8, buf[buf_index..], arg);
  2102e1:	4d 29 e7             	sub    r15,r12
    assert(dest.len >= source.len);
  2102e4:	4d 39 c7             	cmp    r15,r8
  2102e7:	0f 82 fa 02 00 00    	jb     2105e7 <LineNumberProgram_checkLineMatch+0x727>
    for (source) |s, i|
  2102ed:	4d 85 c0             	test   r8,r8
  2102f0:	0f 84 7a 02 00 00    	je     210570 <LineNumberProgram_checkLineMatch+0x6b0>
  2102f6:	4b 8b 14 d1          	mov    rdx,QWORD PTR [r9+r10*8]
  2102fa:	4d 8d 0c 2c          	lea    r9,[r12+rbp*1]
  2102fe:	49 81 f8 80 00 00 00 	cmp    r8,0x80
  210305:	72 1d                	jb     210324 <LineNumberProgram_checkLineMatch+0x464>
  210307:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  21030b:	49 39 c9             	cmp    r9,rcx
  21030e:	0f 83 b0 00 00 00    	jae    2103c4 <LineNumberProgram_checkLineMatch+0x504>
  210314:	4b 8d 0c 04          	lea    rcx,[r12+r8*1]
  210318:	48 01 e9             	add    rcx,rbp
  21031b:	48 39 ca             	cmp    rdx,rcx
  21031e:	0f 83 a0 00 00 00    	jae    2103c4 <LineNumberProgram_checkLineMatch+0x504>
  210324:	31 f6                	xor    esi,esi
  210326:	49 8d 40 ff          	lea    rax,[r8-0x1]
  21032a:	48 29 f0             	sub    rax,rsi
  21032d:	4c 89 c7             	mov    rdi,r8
  210330:	48 83 e7 07          	and    rdi,0x7
  210334:	74 1c                	je     210352 <LineNumberProgram_checkLineMatch+0x492>
  210336:	48 f7 df             	neg    rdi
  210339:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  210340:	0f b6 0c 32          	movzx  ecx,BYTE PTR [rdx+rsi*1]
        dest[i] = s;
  210344:	41 88 0c 31          	mov    BYTE PTR [r9+rsi*1],cl
    for (source) |s, i|
  210348:	48 83 c6 01          	add    rsi,0x1
  21034c:	48 83 c7 01          	add    rdi,0x1
  210350:	75 ee                	jne    210340 <LineNumberProgram_checkLineMatch+0x480>
  210352:	48 83 f8 07          	cmp    rax,0x7
  210356:	0f 82 14 02 00 00    	jb     210570 <LineNumberProgram_checkLineMatch+0x6b0>
  21035c:	49 8d 0c 2c          	lea    rcx,[r12+rbp*1]
  210360:	48 83 c1 07          	add    rcx,0x7
  210364:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21036b:	00 00 00 00 00 
  210370:	0f b6 04 32          	movzx  eax,BYTE PTR [rdx+rsi*1]
        dest[i] = s;
  210374:	88 44 31 f9          	mov    BYTE PTR [rcx+rsi*1-0x7],al
    for (source) |s, i|
  210378:	0f b6 44 32 01       	movzx  eax,BYTE PTR [rdx+rsi*1+0x1]
        dest[i] = s;
  21037d:	88 44 31 fa          	mov    BYTE PTR [rcx+rsi*1-0x6],al
    for (source) |s, i|
  210381:	0f b6 44 32 02       	movzx  eax,BYTE PTR [rdx+rsi*1+0x2]
        dest[i] = s;
  210386:	88 44 31 fb          	mov    BYTE PTR [rcx+rsi*1-0x5],al
    for (source) |s, i|
  21038a:	0f b6 44 32 03       	movzx  eax,BYTE PTR [rdx+rsi*1+0x3]
        dest[i] = s;
  21038f:	88 44 31 fc          	mov    BYTE PTR [rcx+rsi*1-0x4],al
    for (source) |s, i|
  210393:	0f b6 44 32 04       	movzx  eax,BYTE PTR [rdx+rsi*1+0x4]
        dest[i] = s;
  210398:	88 44 31 fd          	mov    BYTE PTR [rcx+rsi*1-0x3],al
    for (source) |s, i|
  21039c:	0f b6 44 32 05       	movzx  eax,BYTE PTR [rdx+rsi*1+0x5]
        dest[i] = s;
  2103a1:	88 44 31 fe          	mov    BYTE PTR [rcx+rsi*1-0x2],al
    for (source) |s, i|
  2103a5:	0f b6 44 32 06       	movzx  eax,BYTE PTR [rdx+rsi*1+0x6]
        dest[i] = s;
  2103aa:	88 44 31 ff          	mov    BYTE PTR [rcx+rsi*1-0x1],al
    for (source) |s, i|
  2103ae:	0f b6 44 32 07       	movzx  eax,BYTE PTR [rdx+rsi*1+0x7]
        dest[i] = s;
  2103b3:	88 04 31             	mov    BYTE PTR [rcx+rsi*1],al
    for (source) |s, i|
  2103b6:	48 83 c6 08          	add    rsi,0x8
  2103ba:	49 39 f0             	cmp    r8,rsi
  2103bd:	75 b1                	jne    210370 <LineNumberProgram_checkLineMatch+0x4b0>
  2103bf:	e9 ac 01 00 00       	jmp    210570 <LineNumberProgram_checkLineMatch+0x6b0>
  2103c4:	4c 89 c6             	mov    rsi,r8
  2103c7:	48 83 e6 80          	and    rsi,0xffffffffffffff80
  2103cb:	48 8d 7e 80          	lea    rdi,[rsi-0x80]
  2103cf:	48 89 f9             	mov    rcx,rdi
  2103d2:	48 c1 e9 07          	shr    rcx,0x7
  2103d6:	44 8d 51 01          	lea    r10d,[rcx+0x1]
  2103da:	41 83 e2 03          	and    r10d,0x3
  2103de:	48 81 ff 80 01 00 00 	cmp    rdi,0x180
  2103e5:	73 10                	jae    2103f7 <LineNumberProgram_checkLineMatch+0x537>
  2103e7:	31 c9                	xor    ecx,ecx
  2103e9:	4d 85 d2             	test   r10,r10
  2103ec:	0f 85 32 01 00 00    	jne    210524 <LineNumberProgram_checkLineMatch+0x664>
  2103f2:	e9 70 01 00 00       	jmp    210567 <LineNumberProgram_checkLineMatch+0x6a7>
  2103f7:	49 8d 3c 2c          	lea    rdi,[r12+rbp*1]
  2103fb:	48 81 c7 e0 01 00 00 	add    rdi,0x1e0
  210402:	49 8d 42 ff          	lea    rax,[r10-0x1]
  210406:	48 29 c8             	sub    rax,rcx
  210409:	31 c9                	xor    ecx,ecx
  21040b:	c5 fc 10 04 0a       	vmovups ymm0,YMMWORD PTR [rdx+rcx*1]
  210410:	c5 fc 10 4c 0a 20    	vmovups ymm1,YMMWORD PTR [rdx+rcx*1+0x20]
  210416:	c5 fc 10 54 0a 40    	vmovups ymm2,YMMWORD PTR [rdx+rcx*1+0x40]
  21041c:	c5 fc 10 5c 0a 60    	vmovups ymm3,YMMWORD PTR [rdx+rcx*1+0x60]
        dest[i] = s;
  210422:	c5 fc 11 84 0f 20 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x1e0],ymm0
  210429:	ff ff 
  21042b:	c5 fc 11 8c 0f 40 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x1c0],ymm1
  210432:	ff ff 
  210434:	c5 fc 11 94 0f 60 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x1a0],ymm2
  21043b:	ff ff 
  21043d:	c5 fc 11 9c 0f 80 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x180],ymm3
  210444:	ff ff 
    for (source) |s, i|
  210446:	c5 fc 10 84 0a 80 00 	vmovups ymm0,YMMWORD PTR [rdx+rcx*1+0x80]
  21044d:	00 00 
  21044f:	c5 fc 10 8c 0a a0 00 	vmovups ymm1,YMMWORD PTR [rdx+rcx*1+0xa0]
  210456:	00 00 
  210458:	c5 fc 10 94 0a c0 00 	vmovups ymm2,YMMWORD PTR [rdx+rcx*1+0xc0]
  21045f:	00 00 
  210461:	c5 fc 10 9c 0a e0 00 	vmovups ymm3,YMMWORD PTR [rdx+rcx*1+0xe0]
  210468:	00 00 
        dest[i] = s;
  21046a:	c5 fc 11 84 0f a0 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x160],ymm0
  210471:	ff ff 
  210473:	c5 fc 11 8c 0f c0 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x140],ymm1
  21047a:	ff ff 
  21047c:	c5 fc 11 94 0f e0 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x120],ymm2
  210483:	ff ff 
  210485:	c5 fc 11 9c 0f 00 ff 	vmovups YMMWORD PTR [rdi+rcx*1-0x100],ymm3
  21048c:	ff ff 
    for (source) |s, i|
  21048e:	c5 fc 10 84 0a 00 01 	vmovups ymm0,YMMWORD PTR [rdx+rcx*1+0x100]
  210495:	00 00 
  210497:	c5 fc 10 8c 0a 20 01 	vmovups ymm1,YMMWORD PTR [rdx+rcx*1+0x120]
  21049e:	00 00 
  2104a0:	c5 fc 10 94 0a 40 01 	vmovups ymm2,YMMWORD PTR [rdx+rcx*1+0x140]
  2104a7:	00 00 
  2104a9:	c5 fc 10 9c 0a 60 01 	vmovups ymm3,YMMWORD PTR [rdx+rcx*1+0x160]
  2104b0:	00 00 
        dest[i] = s;
  2104b2:	c5 fc 11 84 0f 20 ff 	vmovups YMMWORD PTR [rdi+rcx*1-0xe0],ymm0
  2104b9:	ff ff 
  2104bb:	c5 fc 11 8c 0f 40 ff 	vmovups YMMWORD PTR [rdi+rcx*1-0xc0],ymm1
  2104c2:	ff ff 
  2104c4:	c5 fc 11 94 0f 60 ff 	vmovups YMMWORD PTR [rdi+rcx*1-0xa0],ymm2
  2104cb:	ff ff 
  2104cd:	c5 fc 11 5c 0f 80    	vmovups YMMWORD PTR [rdi+rcx*1-0x80],ymm3
    for (source) |s, i|
  2104d3:	c5 fc 10 84 0a 80 01 	vmovups ymm0,YMMWORD PTR [rdx+rcx*1+0x180]
  2104da:	00 00 
  2104dc:	c5 fc 10 8c 0a a0 01 	vmovups ymm1,YMMWORD PTR [rdx+rcx*1+0x1a0]
  2104e3:	00 00 
  2104e5:	c5 fc 10 94 0a c0 01 	vmovups ymm2,YMMWORD PTR [rdx+rcx*1+0x1c0]
  2104ec:	00 00 
  2104ee:	c5 fc 10 9c 0a e0 01 	vmovups ymm3,YMMWORD PTR [rdx+rcx*1+0x1e0]
  2104f5:	00 00 
        dest[i] = s;
  2104f7:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  2104fd:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  210503:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  210509:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
    for (source) |s, i|
  21050e:	48 81 c1 00 02 00 00 	add    rcx,0x200
  210515:	48 83 c0 04          	add    rax,0x4
  210519:	0f 85 ec fe ff ff    	jne    21040b <LineNumberProgram_checkLineMatch+0x54b>
  21051f:	4d 85 d2             	test   r10,r10
  210522:	74 43                	je     210567 <LineNumberProgram_checkLineMatch+0x6a7>
  210524:	48 83 c1 60          	add    rcx,0x60
  210528:	49 f7 da             	neg    r10
  21052b:	c5 fc 10 44 0a a0    	vmovups ymm0,YMMWORD PTR [rdx+rcx*1-0x60]
  210531:	c5 fc 10 4c 0a c0    	vmovups ymm1,YMMWORD PTR [rdx+rcx*1-0x40]
  210537:	c5 fc 10 54 0a e0    	vmovups ymm2,YMMWORD PTR [rdx+rcx*1-0x20]
  21053d:	c5 fc 10 1c 0a       	vmovups ymm3,YMMWORD PTR [rdx+rcx*1]
        dest[i] = s;
  210542:	c4 c1 7c 11 44 09 a0 	vmovups YMMWORD PTR [r9+rcx*1-0x60],ymm0
  210549:	c4 c1 7c 11 4c 09 c0 	vmovups YMMWORD PTR [r9+rcx*1-0x40],ymm1
  210550:	c4 c1 7c 11 54 09 e0 	vmovups YMMWORD PTR [r9+rcx*1-0x20],ymm2
  210557:	c4 c1 7c 11 1c 09    	vmovups YMMWORD PTR [r9+rcx*1],ymm3
    for (source) |s, i|
  21055d:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  210561:	49 83 c2 01          	add    r10,0x1
  210565:	75 c4                	jne    21052b <LineNumberProgram_checkLineMatch+0x66b>
  210567:	49 39 f0             	cmp    r8,rsi
  21056a:	0f 85 b6 fd ff ff    	jne    210326 <LineNumberProgram_checkLineMatch+0x466>
        buf_index += arg.len;
  210570:	4d 01 e0             	add    r8,r12
                .allocator = self.file_entries.allocator,
  210573:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
                .line = if (self.prev_line >= 0) @intCast(usize, self.prev_line) else 0,
  210577:	48 8b 4b 58          	mov    rcx,QWORD PTR [rbx+0x58]
  21057b:	48 89 ca             	mov    rdx,rcx
  21057e:	48 c1 fa 3f          	sar    rdx,0x3f
  210582:	c4 e2 e8 f2 c9       	andn   rcx,rdx,rcx
                .column = self.prev_column,
  210587:	48 8b 53 60          	mov    rdx,QWORD PTR [rbx+0x60]
                .allocator = self.file_entries.allocator,
  21058b:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
            return LineInfo{
  21058f:	c6 44 24 0a 01       	mov    BYTE PTR [rsp+0xa],0x1
  210594:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  21059a:	0f b7 74 24 16       	movzx  esi,WORD PTR [rsp+0x16]
  21059f:	66 41 89 76 06       	mov    WORD PTR [r14+0x6],si
  2105a4:	8b 74 24 12          	mov    esi,DWORD PTR [rsp+0x12]
  2105a8:	41 89 76 02          	mov    DWORD PTR [r14+0x2],esi
  2105ac:	49 89 4e 08          	mov    QWORD PTR [r14+0x8],rcx
  2105b0:	49 89 56 10          	mov    QWORD PTR [r14+0x10],rdx
  2105b4:	49 89 6e 18          	mov    QWORD PTR [r14+0x18],rbp
  2105b8:	4d 89 46 20          	mov    QWORD PTR [r14+0x20],r8
  2105bc:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
  2105c0:	8a 44 24 0a          	mov    al,BYTE PTR [rsp+0xa]
  2105c4:	41 88 46 30          	mov    BYTE PTR [r14+0x30],al
  2105c8:	8a 44 24 11          	mov    al,BYTE PTR [rsp+0x11]
  2105cc:	41 88 46 37          	mov    BYTE PTR [r14+0x37],al
  2105d0:	0f b7 44 24 0f       	movzx  eax,WORD PTR [rsp+0xf]
  2105d5:	66 41 89 46 35       	mov    WORD PTR [r14+0x35],ax
  2105da:	8b 44 24 0b          	mov    eax,DWORD PTR [rsp+0xb]
  2105de:	41 89 46 31          	mov    DWORD PTR [r14+0x31],eax
  2105e2:	e9 1b fa ff ff       	jmp    210002 <LineNumberProgram_checkLineMatch+0x142>
            @panic("assertion failure");
  2105e7:	c5 f8 77             	vzeroupper 
  2105ea:	e8 e1 2b ff ff       	call   2031d0 <panic>
  2105ef:	90                   	nop

00000000002105f0 <Allocator_alignedRealloc.59>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  2105f0:	41 56                	push   r14
  2105f2:	53                   	push   rbx
  2105f3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  2105fa:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  2105fd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  210601:	48 85 c0             	test   rax,rax
  210604:	74 5e                	je     210664 <Allocator_alignedRealloc.59+0x74>
        if (n == 0) {
  210606:	48 85 c9             	test   rcx,rcx
  210609:	0f 84 a6 00 00 00    	je     2106b5 <Allocator_alignedRealloc.59+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  21060f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  210612:	48 c1 e0 04          	shl    rax,0x4
  210616:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21061b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  210620:	ba 10 00 00 00       	mov    edx,0x10
  210625:	48 89 c8             	mov    rax,rcx
  210628:	48 f7 e2             	mul    rdx
  21062b:	0f 81 ca 00 00 00    	jno    2106fb <Allocator_alignedRealloc.59+0x10b>
  210631:	48 8d 0d 88 1f ff ff 	lea    rcx,[rip+0xffffffffffff1f88]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210638:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21063c:	0f 84 d4 00 00 00    	je     210716 <Allocator_alignedRealloc.59+0x126>
  210642:	48 8b 05 27 0d ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff0d27]        # 201370 <__unnamed_74+0x10>
  210649:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21064d:	c5 f8 10 05 0b 0d ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff0d0b]        # 201360 <__unnamed_74>
  210654:	ff 
  210655:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  210659:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210660:	5b                   	pop    rbx
  210661:	41 5e                	pop    r14
  210663:	c3                   	ret    
        if (n == 0) {
  210664:	48 85 c9             	test   rcx,rcx
  210667:	0f 84 f6 00 00 00    	je     210763 <Allocator_alignedRealloc.59+0x173>
  21066d:	ba 10 00 00 00       	mov    edx,0x10
  210672:	48 89 c8             	mov    rax,rcx
  210675:	48 f7 e2             	mul    rdx
  210678:	0f 81 07 01 00 00    	jno    210785 <Allocator_alignedRealloc.59+0x195>
  21067e:	48 8d 0d 3b 1f ff ff 	lea    rcx,[rip+0xffffffffffff1f3b]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210685:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210689:	0f 84 11 01 00 00    	je     2107a0 <Allocator_alignedRealloc.59+0x1b0>
  21068f:	0f b7 05 d0 0c ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff0cd0]        # 201366 <__unnamed_74+0x6>
  210696:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21069b:	8b 05 c1 0c ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff0cc1]        # 201362 <__unnamed_74+0x2>
  2106a1:	89 04 24             	mov    DWORD PTR [rsp],eax
  2106a4:	48 89 e0             	mov    rax,rsp
  2106a7:	66 b9 0f 00          	mov    cx,0xf
  2106ab:	31 d2                	xor    edx,edx
  2106ad:	45 31 f6             	xor    r14d,r14d
  2106b0:	e9 6f 01 00 00       	jmp    210824 <Allocator_alignedRealloc.59+0x234>
        const bytes = @sliceToBytes(memory);
  2106b5:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  2106b9:	74 1e                	je     2106d9 <Allocator_alignedRealloc.59+0xe9>
        const bytes = @sliceToBytes(memory);
  2106bb:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2106be:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  2106c2:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2106c7:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2106cc:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2106d1:	48 89 f7             	mov    rdi,rsi
  2106d4:	48 89 c6             	mov    rsi,rax
  2106d7:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  2106d9:	48 8b 05 78 0c ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff0c78]        # 201358 <__unnamed_75+0x10>
  2106e0:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2106e4:	c5 f8 10 05 5c 0c ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff0c5c]        # 201348 <__unnamed_75>
  2106eb:	ff 
  2106ec:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2106f0:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2106f7:	5b                   	pop    rbx
  2106f8:	41 5e                	pop    r14
  2106fa:	c3                   	ret    
  2106fb:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  210700:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  210707:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21070c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210710:	0f 85 2c ff ff ff    	jne    210642 <Allocator_alignedRealloc.59+0x52>
  210716:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21071a:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  21071f:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  210724:	41 b8 08 00 00 00    	mov    r8d,0x8
  21072a:	4c 89 f1             	mov    rcx,r14
  21072d:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  210730:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  210735:	66 85 c0             	test   ax,ax
  210738:	0f 84 95 00 00 00    	je     2107d3 <Allocator_alignedRealloc.59+0x1e3>
  21073e:	66 89 03             	mov    WORD PTR [rbx],ax
  210741:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  210748:	00 
  210749:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21074d:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  210753:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  210758:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21075f:	5b                   	pop    rbx
  210760:	41 5e                	pop    r14
  210762:	c3                   	ret    
  210763:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  210766:	0f b7 0d e1 0b ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff0be1]        # 20134e <__unnamed_75+0x6>
  21076d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  210772:	8b 0d d2 0b ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff0bd2]        # 20134a <__unnamed_75+0x2>
  210778:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21077b:	31 c9                	xor    ecx,ecx
  21077d:	45 31 f6             	xor    r14d,r14d
  210780:	e9 9f 00 00 00       	jmp    210824 <Allocator_alignedRealloc.59+0x234>
  210785:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  21078a:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  210791:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210796:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21079a:	0f 85 ef fe ff ff    	jne    21068f <Allocator_alignedRealloc.59+0x9f>
  2107a0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2107a4:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2107a9:	b9 08 00 00 00       	mov    ecx,0x8
  2107ae:	4c 89 f2             	mov    rdx,r14
  2107b1:	ff 16                	call   QWORD PTR [rsi]
  2107b3:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  2107b8:	66 85 c9             	test   cx,cx
  2107bb:	74 41                	je     2107fe <Allocator_alignedRealloc.59+0x20e>
  2107bd:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  2107c2:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2107c7:	48 89 e0             	mov    rax,rsp
  2107ca:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  2107ce:	89 14 24             	mov    DWORD PTR [rsp],edx
  2107d1:	eb 51                	jmp    210824 <Allocator_alignedRealloc.59+0x234>
        assert(byte_slice.len == byte_count);
  2107d3:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  2107d8:	75 6d                	jne    210847 <Allocator_alignedRealloc.59+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2107da:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2107df:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  2107e4:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  2107e9:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2107ed:	49 c1 ee 04          	shr    r14,0x4
  2107f1:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  2107f5:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  2107f8:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  2107fc:	eb 3a                	jmp    210838 <Allocator_alignedRealloc.59+0x248>
        assert(byte_slice.len == byte_count);
  2107fe:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  210803:	75 42                	jne    210847 <Allocator_alignedRealloc.59+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  210805:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21080a:	49 c1 ee 04          	shr    r14,0x4
  21080e:	48 89 e0             	mov    rax,rsp
  210811:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  210815:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  210818:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21081d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  210822:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  210824:	66 89 0b             	mov    WORD PTR [rbx],cx
  210827:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21082b:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21082f:	8b 00                	mov    eax,DWORD PTR [rax]
  210831:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  210834:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  210838:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  21083c:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210843:	5b                   	pop    rbx
  210844:	41 5e                	pop    r14
  210846:	c3                   	ret    
            @panic("assertion failure");
  210847:	e8 84 29 ff ff       	call   2031d0 <panic>
  21084c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000210850 <Allocator_alignedRealloc.62>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  210850:	41 56                	push   r14
  210852:	53                   	push   rbx
  210853:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21085a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21085d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  210861:	48 85 c0             	test   rax,rax
  210864:	74 62                	je     2108c8 <Allocator_alignedRealloc.62+0x78>
        if (n == 0) {
  210866:	48 85 c9             	test   rcx,rcx
  210869:	0f 84 a9 00 00 00    	je     210918 <Allocator_alignedRealloc.62+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  21086f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  210872:	48 c1 e0 03          	shl    rax,0x3
  210876:	48 8d 04 80          	lea    rax,[rax+rax*4]
  21087a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21087f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  210884:	ba 28 00 00 00       	mov    edx,0x28
  210889:	48 89 c8             	mov    rax,rcx
  21088c:	48 f7 e2             	mul    rdx
  21088f:	0f 81 d0 00 00 00    	jno    210965 <Allocator_alignedRealloc.62+0x115>
  210895:	48 8d 0d 24 1d ff ff 	lea    rcx,[rip+0xffffffffffff1d24]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21089c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2108a0:	0f 84 da 00 00 00    	je     210980 <Allocator_alignedRealloc.62+0x130>
  2108a6:	48 8b 05 f3 0a ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff0af3]        # 2013a0 <__unnamed_76+0x10>
  2108ad:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2108b1:	c5 f8 10 05 d7 0a ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff0ad7]        # 201390 <__unnamed_76>
  2108b8:	ff 
  2108b9:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2108bd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2108c4:	5b                   	pop    rbx
  2108c5:	41 5e                	pop    r14
  2108c7:	c3                   	ret    
        if (n == 0) {
  2108c8:	48 85 c9             	test   rcx,rcx
  2108cb:	0f 84 fc 00 00 00    	je     2109cd <Allocator_alignedRealloc.62+0x17d>
  2108d1:	ba 28 00 00 00       	mov    edx,0x28
  2108d6:	48 89 c8             	mov    rax,rcx
  2108d9:	48 f7 e2             	mul    rdx
  2108dc:	0f 81 0c 01 00 00    	jno    2109ee <Allocator_alignedRealloc.62+0x19e>
  2108e2:	48 8d 0d d7 1c ff ff 	lea    rcx,[rip+0xffffffffffff1cd7]        # 2025c0 <__unnamed_48>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2108e9:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2108ed:	0f 84 16 01 00 00    	je     210a09 <Allocator_alignedRealloc.62+0x1b9>
  2108f3:	0f b7 05 9c 0a ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff0a9c]        # 201396 <__unnamed_76+0x6>
  2108fa:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2108ff:	8b 05 8d 0a ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff0a8d]        # 201392 <__unnamed_76+0x2>
  210905:	89 04 24             	mov    DWORD PTR [rsp],eax
  210908:	48 89 e0             	mov    rax,rsp
  21090b:	66 b9 0f 00          	mov    cx,0xf
  21090f:	31 f6                	xor    esi,esi
  210911:	31 d2                	xor    edx,edx
  210913:	e9 9d 01 00 00       	jmp    210ab5 <Allocator_alignedRealloc.62+0x265>
        const bytes = @sliceToBytes(memory);
  210918:	48 c1 e0 03          	shl    rax,0x3
  21091c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  210920:	48 85 c0             	test   rax,rax
  210923:	74 1e                	je     210943 <Allocator_alignedRealloc.62+0xf3>
        const bytes = @sliceToBytes(memory);
  210925:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  210928:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  21092c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  210931:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  210936:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  21093b:	48 89 f7             	mov    rdi,rsi
  21093e:	48 89 c6             	mov    rsi,rax
  210941:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  210943:	48 8b 05 3e 0a ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff0a3e]        # 201388 <__unnamed_77+0x10>
  21094a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21094e:	c5 f8 10 05 22 0a ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff0a22]        # 201378 <__unnamed_77>
  210955:	ff 
  210956:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21095a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210961:	5b                   	pop    rbx
  210962:	41 5e                	pop    r14
  210964:	c3                   	ret    
  210965:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  21096a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  210971:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210976:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21097a:	0f 85 26 ff ff ff    	jne    2108a6 <Allocator_alignedRealloc.62+0x56>
  210980:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  210984:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  210989:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21098e:	41 b8 08 00 00 00    	mov    r8d,0x8
  210994:	4c 89 f1             	mov    rcx,r14
  210997:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21099a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21099f:	66 85 c0             	test   ax,ax
  2109a2:	0f 84 94 00 00 00    	je     210a3c <Allocator_alignedRealloc.62+0x1ec>
  2109a8:	66 89 03             	mov    WORD PTR [rbx],ax
  2109ab:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2109b2:	00 
  2109b3:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2109b7:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  2109bd:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  2109c2:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2109c9:	5b                   	pop    rbx
  2109ca:	41 5e                	pop    r14
  2109cc:	c3                   	ret    
  2109cd:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  2109d0:	0f b7 0d a7 09 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff09a7]        # 20137e <__unnamed_77+0x6>
  2109d7:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2109dc:	8b 0d 98 09 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff0998]        # 20137a <__unnamed_77+0x2>
  2109e2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2109e5:	31 c9                	xor    ecx,ecx
  2109e7:	31 d2                	xor    edx,edx
  2109e9:	e9 c7 00 00 00       	jmp    210ab5 <Allocator_alignedRealloc.62+0x265>
  2109ee:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  2109f3:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  2109fa:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2109ff:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210a03:	0f 85 ea fe ff ff    	jne    2108f3 <Allocator_alignedRealloc.62+0xa3>
  210a09:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  210a0d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  210a12:	b9 08 00 00 00       	mov    ecx,0x8
  210a17:	4c 89 f2             	mov    rdx,r14
  210a1a:	ff 16                	call   QWORD PTR [rsi]
  210a1c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  210a21:	66 85 c9             	test   cx,cx
  210a24:	74 57                	je     210a7d <Allocator_alignedRealloc.62+0x22d>
  210a26:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  210a2b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  210a30:	48 89 e0             	mov    rax,rsp
  210a33:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  210a37:	89 14 24             	mov    DWORD PTR [rsp],edx
  210a3a:	eb 79                	jmp    210ab5 <Allocator_alignedRealloc.62+0x265>
        assert(byte_slice.len == byte_count);
  210a3c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  210a41:	0f 85 91 00 00 00    	jne    210ad8 <Allocator_alignedRealloc.62+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  210a47:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  210a4c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  210a53:	cc cc cc 
  210a56:	4c 89 f2             	mov    rdx,r14
  210a59:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  210a5e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  210a63:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  210a68:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  210a6c:	48 c1 ea 05          	shr    rdx,0x5
  210a70:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  210a74:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  210a77:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  210a7b:	eb 4c                	jmp    210ac9 <Allocator_alignedRealloc.62+0x279>
        assert(byte_slice.len == byte_count);
  210a7d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  210a82:	75 54                	jne    210ad8 <Allocator_alignedRealloc.62+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  210a84:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  210a89:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  210a90:	cc cc cc 
  210a93:	4c 89 f2             	mov    rdx,r14
  210a96:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  210a9b:	48 c1 ea 05          	shr    rdx,0x5
  210a9f:	48 89 e0             	mov    rax,rsp
  210aa2:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  210aa6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  210aa9:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  210aae:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  210ab3:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  210ab5:	66 89 0b             	mov    WORD PTR [rbx],cx
  210ab8:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  210abc:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  210ac0:	8b 00                	mov    eax,DWORD PTR [rax]
  210ac2:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  210ac5:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  210ac9:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  210acd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210ad4:	5b                   	pop    rbx
  210ad5:	41 5e                	pop    r14
  210ad7:	c3                   	ret    
            @panic("assertion failure");
  210ad8:	e8 f3 26 ff ff       	call   2031d0 <panic>
  210add:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000210ae0 <DirectAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  210ae0:	41 57                	push   r15
  210ae2:	41 56                	push   r14
  210ae4:	41 55                	push   r13
  210ae6:	41 54                	push   r12
  210ae8:	53                   	push   rbx
  210ae9:	48 83 ec 10          	sub    rsp,0x10
  210aed:	41 89 cc             	mov    r12d,ecx
  210af0:	49 89 d6             	mov    r14,rdx
  210af3:	49 89 ff             	mov    r15,rdi
  210af6:	45 89 e5             	mov    r13d,r12d
  210af9:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  210b00:	31 c0                	xor    eax,eax
  210b02:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  210b09:	4c 89 eb             	mov    rbx,r13
  210b0c:	48 0f 42 d8          	cmovb  rbx,rax
  210b10:	4a 8d 34 33          	lea    rsi,[rbx+r14*1]
    arg3: usize,
    arg4: usize,
    arg5: usize,
    arg6: usize,
) usize {
    return asm volatile ("syscall"
  210b14:	b8 09 00 00 00       	mov    eax,0x9
  210b19:	bf 00 00 00 00       	mov    edi,0x0
  210b1e:	ba 03 00 00 00       	mov    edx,0x3
  210b23:	41 ba 22 00 00 00    	mov    r10d,0x22
  210b29:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  210b30:	45 31 c9             	xor    r9d,r9d
  210b33:	0f 05                	syscall 
  210b35:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  210b38:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  210b3c:	74 55                	je     210b93 <DirectAllocator_alloc+0xb3>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  210b3e:	48 85 db             	test   rbx,rbx
  210b41:	74 6a                	je     210bad <DirectAllocator_alloc+0xcd>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  210b43:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  210b4a:	41 f7 d4             	not    r12d
  210b4d:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  210b54:	49 21 cc             	and    r12,rcx
  210b57:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  210b5a:	48 89 ce             	mov    rsi,rcx
  210b5d:	48 f7 d6             	not    rsi
  210b60:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  210b63:	b8 0b 00 00 00       	mov    eax,0xb
  210b68:	48 89 cf             	mov    rdi,rcx
  210b6b:	0f 05                	syscall 
  210b6d:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  210b73:	73 69                	jae    210bde <DirectAllocator_alloc+0xfe>
                return @intToPtr([*]u8, aligned_addr)[0..n];
  210b75:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  210b7b:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  210b80:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  210b85:	8b 44 24 04          	mov    eax,DWORD PTR [rsp+0x4]
  210b89:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  210b8d:	4d 89 67 08          	mov    QWORD PTR [r15+0x8],r12
  210b91:	eb 36                	jmp    210bc9 <DirectAllocator_alloc+0xe9>
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  210b93:	48 8b 05 5e 19 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff195e]        # 2024f8 <__unnamed_50+0x10>
  210b9a:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  210b9e:	c5 f8 10 05 42 19 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff1942]        # 2024e8 <__unnamed_50>
  210ba5:	ff 
  210ba6:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  210bab:	eb 20                	jmp    210bcd <DirectAllocator_alloc+0xed>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  210bad:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  210bb3:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  210bb8:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  210bbd:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  210bc1:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  210bc5:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  210bc9:	4d 89 77 10          	mov    QWORD PTR [r15+0x10],r14
  210bcd:	4c 89 f8             	mov    rax,r15
  210bd0:	48 83 c4 10          	add    rsp,0x10
  210bd4:	5b                   	pop    rbx
  210bd5:	41 5c                	pop    r12
  210bd7:	41 5d                	pop    r13
  210bd9:	41 5e                	pop    r14
  210bdb:	41 5f                	pop    r15
  210bdd:	c3                   	ret    
            @panic("assertion failure");
  210bde:	e8 ed 25 ff ff       	call   2031d0 <panic>
  210be3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210bea:	84 00 00 00 00 00 

0000000000210bf0 <DirectAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  210bf0:	55                   	push   rbp
  210bf1:	41 57                	push   r15
  210bf3:	41 56                	push   r14
  210bf5:	41 55                	push   r13
  210bf7:	41 54                	push   r12
  210bf9:	53                   	push   rbx
  210bfa:	48 83 ec 28          	sub    rsp,0x28
  210bfe:	45 89 c4             	mov    r12d,r8d
  210c01:	48 89 cb             	mov    rbx,rcx
  210c04:	49 89 d6             	mov    r14,rdx
  210c07:	49 89 ff             	mov    r15,rdi
                if (new_size <= old_mem.len) {
  210c0a:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  210c0e:	48 39 de             	cmp    rsi,rbx
  210c11:	0f 83 c7 00 00 00    	jae    210cde <DirectAllocator_realloc+0xee>
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  210c17:	45 89 e5             	mov    r13d,r12d
  210c1a:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  210c21:	31 c0                	xor    eax,eax
  210c23:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  210c2a:	4c 89 ed             	mov    rbp,r13
  210c2d:	48 0f 42 e8          	cmovb  rbp,rax
  210c31:	48 8d 74 1d 00       	lea    rsi,[rbp+rbx*1+0x0]
    return asm volatile ("syscall"
  210c36:	b8 09 00 00 00       	mov    eax,0x9
  210c3b:	bf 00 00 00 00       	mov    edi,0x0
  210c40:	ba 03 00 00 00       	mov    edx,0x3
  210c45:	41 ba 22 00 00 00    	mov    r10d,0x22
  210c4b:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  210c52:	45 31 c9             	xor    r9d,r9d
  210c55:	0f 05                	syscall 
  210c57:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  210c5a:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  210c5e:	0f 84 d2 00 00 00    	je     210d36 <DirectAllocator_realloc+0x146>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  210c64:	48 85 ed             	test   rbp,rbp
  210c67:	74 39                	je     210ca2 <DirectAllocator_realloc+0xb2>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  210c69:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  210c70:	41 f7 d4             	not    r12d
  210c73:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  210c7a:	49 21 cc             	and    r12,rcx
  210c7d:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  210c80:	48 89 ce             	mov    rsi,rcx
  210c83:	48 f7 d6             	not    rsi
  210c86:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  210c89:	b8 0b 00 00 00       	mov    eax,0xb
  210c8e:	48 89 cf             	mov    rdi,rcx
  210c91:	0f 05                	syscall 
  210c93:	4c 89 e1             	mov    rcx,r12
  210c96:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  210c9c:	0f 83 74 01 00 00    	jae    210e16 <DirectAllocator_realloc+0x226>
    assert(dest.len >= source.len);
  210ca2:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  210ca6:	48 89 dd             	mov    rbp,rbx
  210ca9:	48 39 de             	cmp    rsi,rbx
  210cac:	0f 87 64 01 00 00    	ja     210e16 <DirectAllocator_realloc+0x226>
    for (source) |s, i|
  210cb2:	48 85 f6             	test   rsi,rsi
  210cb5:	0f 84 29 01 00 00    	je     210de4 <DirectAllocator_realloc+0x1f4>
  210cbb:	48 8d 56 ff          	lea    rdx,[rsi-0x1]
  210cbf:	89 f0                	mov    eax,esi
  210cc1:	83 e0 07             	and    eax,0x7
  210cc4:	48 83 fa 07          	cmp    rdx,0x7
  210cc8:	0f 83 88 00 00 00    	jae    210d56 <DirectAllocator_realloc+0x166>
  210cce:	31 d2                	xor    edx,edx
  210cd0:	48 85 c0             	test   rax,rax
  210cd3:	0f 85 f3 00 00 00    	jne    210dcc <DirectAllocator_realloc+0x1dc>
  210cd9:	e9 06 01 00 00       	jmp    210de4 <DirectAllocator_realloc+0x1f4>
                    const base_addr = @ptrToInt(old_mem.ptr);
  210cde:	49 8b 06             	mov    rax,QWORD PTR [r14]
                    const old_addr_end = base_addr + old_mem.len;
  210ce1:	48 01 c6             	add    rsi,rax
                    const new_addr_end = base_addr + new_size;
  210ce4:	48 8d 0c 18          	lea    rcx,[rax+rbx*1]
                    const rem = @rem(new_addr_end, os.page_size);
  210ce8:	89 ca                	mov    edx,ecx
  210cea:	81 e2 ff 0f 00 00    	and    edx,0xfff
                    const new_addr_end_rounded = new_addr_end + if (rem == 0) 0 else (os.page_size - rem);
  210cf0:	bf 00 10 00 00       	mov    edi,0x1000
  210cf5:	48 29 d7             	sub    rdi,rdx
  210cf8:	48 85 d2             	test   rdx,rdx
  210cfb:	48 0f 44 fa          	cmove  rdi,rdx
  210cff:	48 01 cf             	add    rdi,rcx
                    if (old_addr_end > new_addr_end_rounded) {
  210d02:	48 29 fe             	sub    rsi,rdi
  210d05:	76 0a                	jbe    210d11 <DirectAllocator_realloc+0x121>
  210d07:	b8 0b 00 00 00       	mov    eax,0xb
  210d0c:	0f 05                	syscall 
                    return old_mem[0..new_size];
  210d0e:	49 8b 06             	mov    rax,QWORD PTR [r14]
  210d11:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  210d17:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
  210d1c:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  210d21:	8b 4c 24 0c          	mov    ecx,DWORD PTR [rsp+0xc]
  210d25:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  210d29:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  210d2d:	49 89 5f 10          	mov    QWORD PTR [r15+0x10],rbx
  210d31:	e9 ce 00 00 00       	jmp    210e04 <DirectAllocator_realloc+0x214>
                const result = try alloc(allocator, new_size, alignment);
  210d36:	66 41 c7 07 0f 00    	mov    WORD PTR [r15],0xf
  210d3c:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  210d41:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  210d45:	c5 f8 10 44 24 12    	vmovups xmm0,XMMWORD PTR [rsp+0x12]
  210d4b:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  210d51:	e9 ae 00 00 00       	jmp    210e04 <DirectAllocator_realloc+0x214>
  210d56:	48 29 c6             	sub    rsi,rax
  210d59:	31 d2                	xor    edx,edx
  210d5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  210d60:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  210d63:	0f b6 1c 17          	movzx  ebx,BYTE PTR [rdi+rdx*1]
        dest[i] = s;
  210d67:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  210d6a:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  210d6d:	0f b6 5c 17 01       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x1]
        dest[i] = s;
  210d72:	88 5c 11 01          	mov    BYTE PTR [rcx+rdx*1+0x1],bl
    for (source) |s, i|
  210d76:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  210d79:	0f b6 5c 17 02       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x2]
        dest[i] = s;
  210d7e:	88 5c 11 02          	mov    BYTE PTR [rcx+rdx*1+0x2],bl
    for (source) |s, i|
  210d82:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  210d85:	0f b6 5c 17 03       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x3]
        dest[i] = s;
  210d8a:	88 5c 11 03          	mov    BYTE PTR [rcx+rdx*1+0x3],bl
    for (source) |s, i|
  210d8e:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  210d91:	0f b6 5c 17 04       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x4]
        dest[i] = s;
  210d96:	88 5c 11 04          	mov    BYTE PTR [rcx+rdx*1+0x4],bl
    for (source) |s, i|
  210d9a:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  210d9d:	0f b6 5c 17 05       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x5]
        dest[i] = s;
  210da2:	88 5c 11 05          	mov    BYTE PTR [rcx+rdx*1+0x5],bl
    for (source) |s, i|
  210da6:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  210da9:	0f b6 5c 17 06       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x6]
        dest[i] = s;
  210dae:	88 5c 11 06          	mov    BYTE PTR [rcx+rdx*1+0x6],bl
    for (source) |s, i|
  210db2:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  210db5:	0f b6 5c 17 07       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x7]
        dest[i] = s;
  210dba:	88 5c 11 07          	mov    BYTE PTR [rcx+rdx*1+0x7],bl
    for (source) |s, i|
  210dbe:	48 83 c2 08          	add    rdx,0x8
  210dc2:	48 39 d6             	cmp    rsi,rdx
  210dc5:	75 99                	jne    210d60 <DirectAllocator_realloc+0x170>
  210dc7:	48 85 c0             	test   rax,rax
  210dca:	74 18                	je     210de4 <DirectAllocator_realloc+0x1f4>
  210dcc:	48 f7 d8             	neg    rax
  210dcf:	90                   	nop
  210dd0:	49 8b 36             	mov    rsi,QWORD PTR [r14]
  210dd3:	0f b6 1c 16          	movzx  ebx,BYTE PTR [rsi+rdx*1]
        dest[i] = s;
  210dd7:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  210dda:	48 83 c2 01          	add    rdx,0x1
  210dde:	48 83 c0 01          	add    rax,0x1
  210de2:	75 ec                	jne    210dd0 <DirectAllocator_realloc+0x1e0>
                return result;
  210de4:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  210dea:	0f b7 44 24 0a       	movzx  eax,WORD PTR [rsp+0xa]
  210def:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  210df4:	8b 44 24 06          	mov    eax,DWORD PTR [rsp+0x6]
  210df8:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  210dfc:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  210e00:	49 89 6f 10          	mov    QWORD PTR [r15+0x10],rbp
  210e04:	4c 89 f8             	mov    rax,r15
  210e07:	48 83 c4 28          	add    rsp,0x28
  210e0b:	5b                   	pop    rbx
  210e0c:	41 5c                	pop    r12
  210e0e:	41 5d                	pop    r13
  210e10:	41 5e                	pop    r14
  210e12:	41 5f                	pop    r15
  210e14:	5d                   	pop    rbp
  210e15:	c3                   	ret    
            @panic("assertion failure");
  210e16:	e8 b5 23 ff ff       	call   2031d0 <panic>
  210e1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000210e20 <DirectAllocator_free>:
                _ = os.posix.munmap(@ptrToInt(bytes.ptr), bytes.len);
  210e20:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  210e23:	48 8b 76 08          	mov    rsi,QWORD PTR [rsi+0x8]
  210e27:	b8 0b 00 00 00       	mov    eax,0xb
  210e2c:	0f 05                	syscall 
    fn free(allocator: *Allocator, bytes: []u8) void {
  210e2e:	c3                   	ret    
  210e2f:	90                   	nop

0000000000210e30 <ArenaAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  210e30:	55                   	push   rbp
  210e31:	41 57                	push   r15
  210e33:	41 56                	push   r14
  210e35:	41 55                	push   r13
  210e37:	41 54                	push   r12
  210e39:	53                   	push   rbx
  210e3a:	48 83 ec 58          	sub    rsp,0x58
  210e3e:	89 cb                	mov    ebx,ecx
  210e40:	49 89 d7             	mov    r15,rdx
  210e43:	49 89 f4             	mov    r12,rsi
  210e46:	49 89 fe             	mov    r14,rdi
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  210e49:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  210e4e:	81 e3 ff ff ff 1f    	and    ebx,0x1fffffff
  210e54:	4e 8d 2c 3b          	lea    r13,[rbx+r15*1]
  210e58:	48 85 c0             	test   rax,rax
  210e5b:	74 29                	je     210e86 <ArenaAllocator_alloc+0x56>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  210e5d:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  210e61:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  210e65:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  210e69:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  210e6e:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  210e72:	48 83 c0 20          	add    rax,0x20
  210e76:	48 89 c2             	mov    rdx,rax
  210e79:	48 c1 ea 20          	shr    rdx,0x20
  210e7d:	74 3f                	je     210ebe <ArenaAllocator_alloc+0x8e>
  210e7f:	31 d2                	xor    edx,edx
  210e81:	48 f7 f3             	div    rbx
  210e84:	eb 3c                	jmp    210ec2 <ArenaAllocator_alloc+0x92>
  210e86:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  210e8b:	31 d2                	xor    edx,edx
  210e8d:	4c 89 e6             	mov    rsi,r12
  210e90:	4c 89 e9             	mov    rcx,r13
  210e93:	e8 68 03 00 00       	call   211200 <ArenaAllocator_createNode>
  210e98:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  210e9d:	66 85 c0             	test   ax,ax
  210ea0:	0f 84 fe 00 00 00    	je     210fa4 <ArenaAllocator_alloc+0x174>
  210ea6:	66 41 89 06          	mov    WORD PTR [r14],ax
  210eaa:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  210eaf:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  210eb3:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  210eb9:	e9 ce 00 00 00       	jmp    210f8c <ArenaAllocator_alloc+0x15c>
  210ebe:	31 d2                	xor    edx,edx
  210ec0:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  210ec2:	48 89 d8             	mov    rax,rbx
  210ec5:	48 29 d0             	sub    rax,rdx
  210ec8:	48 85 d2             	test   rdx,rdx
  210ecb:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  210ecf:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  210ed2:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  210ed6:	48 39 ca             	cmp    rdx,rcx
  210ed9:	76 72                	jbe    210f4d <ArenaAllocator_alloc+0x11d>
  210edb:	48 8d 6c 24 08       	lea    rbp,[rsp+0x8]
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  210ee0:	48 89 ef             	mov    rdi,rbp
  210ee3:	4c 89 e6             	mov    rsi,r12
  210ee6:	48 89 ca             	mov    rdx,rcx
  210ee9:	4c 89 e9             	mov    rcx,r13
  210eec:	e8 0f 03 00 00       	call   211200 <ArenaAllocator_createNode>
  210ef1:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  210ef6:	66 85 c0             	test   ax,ax
  210ef9:	75 7e                	jne    210f79 <ArenaAllocator_alloc+0x149>
  210efb:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  210f00:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  210f04:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  210f08:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  210f0c:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  210f11:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  210f15:	48 83 c0 20          	add    rax,0x20
  210f19:	48 89 c2             	mov    rdx,rax
  210f1c:	48 c1 ea 20          	shr    rdx,0x20
  210f20:	74 0e                	je     210f30 <ArenaAllocator_alloc+0x100>
  210f22:	31 d2                	xor    edx,edx
  210f24:	48 f7 f3             	div    rbx
  210f27:	eb 0b                	jmp    210f34 <ArenaAllocator_alloc+0x104>
  210f29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  210f30:	31 d2                	xor    edx,edx
  210f32:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  210f34:	48 89 d8             	mov    rax,rbx
  210f37:	48 29 d0             	sub    rax,rdx
  210f3a:	48 85 d2             	test   rdx,rdx
  210f3d:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  210f41:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  210f44:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  210f48:	48 39 ca             	cmp    rdx,rcx
  210f4b:	77 93                	ja     210ee0 <ArenaAllocator_alloc+0xb0>
            self.end_index = new_end_index;
  210f4d:	49 89 54 24 38       	mov    QWORD PTR [r12+0x38],rdx
            return result;
  210f52:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  210f58:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  210f5d:	66 41 89 4e 06       	mov    WORD PTR [r14+0x6],cx
            const result = cur_buf[adjusted_index..new_end_index];
  210f62:	48 8d 44 06 20       	lea    rax,[rsi+rax*1+0x20]
            return result;
  210f67:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  210f6b:	41 89 4e 02          	mov    DWORD PTR [r14+0x2],ecx
  210f6f:	49 89 46 08          	mov    QWORD PTR [r14+0x8],rax
  210f73:	4d 89 7e 10          	mov    QWORD PTR [r14+0x10],r15
  210f77:	eb 19                	jmp    210f92 <ArenaAllocator_alloc+0x162>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  210f79:	66 41 89 06          	mov    WORD PTR [r14],ax
  210f7d:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  210f82:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  210f86:	c5 f8 10 44 24 2c    	vmovups xmm0,XMMWORD PTR [rsp+0x2c]
  210f8c:	c4 c1 78 11 46 02    	vmovups XMMWORD PTR [r14+0x2],xmm0
  210f92:	4c 89 f0             	mov    rax,r14
  210f95:	48 83 c4 58          	add    rsp,0x58
  210f99:	5b                   	pop    rbx
  210f9a:	41 5c                	pop    r12
  210f9c:	41 5d                	pop    r13
  210f9e:	41 5e                	pop    r14
  210fa0:	41 5f                	pop    r15
  210fa2:	5d                   	pop    rbp
  210fa3:	c3                   	ret    
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  210fa4:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  210fa9:	e9 af fe ff ff       	jmp    210e5d <ArenaAllocator_alloc+0x2d>
  210fae:	66 90                	xchg   ax,ax

0000000000210fb0 <ArenaAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  210fb0:	55                   	push   rbp
  210fb1:	41 57                	push   r15
  210fb3:	41 56                	push   r14
  210fb5:	41 55                	push   r13
  210fb7:	41 54                	push   r12
  210fb9:	53                   	push   rbx
  210fba:	48 83 ec 58          	sub    rsp,0x58
  210fbe:	45 89 c5             	mov    r13d,r8d
  210fc1:	49 89 cf             	mov    r15,rcx
  210fc4:	48 89 d3             	mov    rbx,rdx
  210fc7:	49 89 f4             	mov    r12,rsi
  210fca:	48 89 fd             	mov    rbp,rdi
        if (new_size <= old_mem.len) {
  210fcd:	4c 39 7b 08          	cmp    QWORD PTR [rbx+0x8],r15
  210fd1:	73 43                	jae    211016 <ArenaAllocator_realloc+0x66>
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  210fd3:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  210fd8:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  210fdf:	4f 8d 34 2f          	lea    r14,[r15+r13*1]
  210fe3:	48 85 c0             	test   rax,rax
  210fe6:	74 54                	je     21103c <ArenaAllocator_realloc+0x8c>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  210fe8:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  210fec:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  210ff0:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  210ff4:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  210ff9:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  210ffd:	48 83 c0 20          	add    rax,0x20
  211001:	48 89 c2             	mov    rdx,rax
  211004:	48 c1 ea 20          	shr    rdx,0x20
  211008:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  21100d:	75 77                	jne    211086 <ArenaAllocator_realloc+0xd6>
  21100f:	31 d2                	xor    edx,edx
  211011:	41 f7 f5             	div    r13d
  211014:	eb 75                	jmp    21108b <ArenaAllocator_realloc+0xdb>
            return old_mem[0..new_size];
  211016:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  211019:	66 c7 45 00 00 00    	mov    WORD PTR [rbp+0x0],0x0
  21101f:	0f b7 4c 24 1e       	movzx  ecx,WORD PTR [rsp+0x1e]
  211024:	66 89 4d 06          	mov    WORD PTR [rbp+0x6],cx
  211028:	8b 4c 24 1a          	mov    ecx,DWORD PTR [rsp+0x1a]
  21102c:	89 4d 02             	mov    DWORD PTR [rbp+0x2],ecx
  21102f:	48 89 45 08          	mov    QWORD PTR [rbp+0x8],rax
  211033:	4c 89 7d 10          	mov    QWORD PTR [rbp+0x10],r15
  211037:	e9 a2 00 00 00       	jmp    2110de <ArenaAllocator_realloc+0x12e>
  21103c:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  211041:	31 d2                	xor    edx,edx
  211043:	4c 89 e6             	mov    rsi,r12
  211046:	4c 89 f1             	mov    rcx,r14
  211049:	e8 b2 01 00 00       	call   211200 <ArenaAllocator_createNode>
  21104e:	0f b7 44 24 30       	movzx  eax,WORD PTR [rsp+0x30]
  211053:	66 85 c0             	test   ax,ax
  211056:	75 6e                	jne    2110c6 <ArenaAllocator_realloc+0x116>
  211058:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  21105d:	eb 89                	jmp    210fe8 <ArenaAllocator_realloc+0x38>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  21105f:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  211064:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  211068:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  21106c:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  211070:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  211075:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  211079:	48 83 c0 20          	add    rax,0x20
  21107d:	48 89 c2             	mov    rdx,rax
  211080:	48 c1 ea 20          	shr    rdx,0x20
  211084:	74 89                	je     21100f <ArenaAllocator_realloc+0x5f>
  211086:	31 d2                	xor    edx,edx
  211088:	49 f7 f5             	div    r13
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  21108b:	4c 89 ed             	mov    rbp,r13
  21108e:	48 29 d5             	sub    rbp,rdx
  211091:	48 85 d2             	test   rdx,rdx
  211094:	48 0f 44 ea          	cmove  rbp,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  211098:	48 01 fd             	add    rbp,rdi
            const new_end_index = adjusted_index + n;
  21109b:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
            if (new_end_index > cur_buf.len) {
  21109f:	48 39 c8             	cmp    rax,rcx
  2110a2:	76 42                	jbe    2110e6 <ArenaAllocator_realloc+0x136>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  2110a4:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2110a9:	4c 89 e6             	mov    rsi,r12
  2110ac:	48 89 ca             	mov    rdx,rcx
  2110af:	4c 89 f1             	mov    rcx,r14
  2110b2:	e8 49 01 00 00       	call   211200 <ArenaAllocator_createNode>
  2110b7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2110bc:	66 85 c0             	test   ax,ax
  2110bf:	74 9e                	je     21105f <ArenaAllocator_realloc+0xaf>
  2110c1:	48 8b 6c 24 08       	mov    rbp,QWORD PTR [rsp+0x8]
            const result = try alloc(allocator, new_size, alignment);
  2110c6:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  2110ca:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  2110cf:	48 89 45 10          	mov    QWORD PTR [rbp+0x10],rax
  2110d3:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  2110d9:	c5 f8 11 45 02       	vmovups XMMWORD PTR [rbp+0x2],xmm0
  2110de:	48 89 e8             	mov    rax,rbp
  2110e1:	e9 f1 00 00 00       	jmp    2111d7 <ArenaAllocator_realloc+0x227>
            self.end_index = new_end_index;
  2110e6:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
    assert(dest.len >= source.len);
  2110eb:	48 8b 7b 08          	mov    rdi,QWORD PTR [rbx+0x8]
  2110ef:	4c 39 ff             	cmp    rdi,r15
    if (!ok) {
  2110f2:	0f 87 ee 00 00 00    	ja     2111e6 <ArenaAllocator_realloc+0x236>
  2110f8:	4c 8d 04 2e          	lea    r8,[rsi+rbp*1]
  2110fc:	49 83 c0 20          	add    r8,0x20
    for (source) |s, i|
  211100:	48 85 ff             	test   rdi,rdi
  211103:	0f 84 ac 00 00 00    	je     2111b5 <ArenaAllocator_realloc+0x205>
  211109:	48 8d 57 ff          	lea    rdx,[rdi-0x1]
  21110d:	89 f9                	mov    ecx,edi
  21110f:	83 e1 07             	and    ecx,0x7
  211112:	48 83 fa 07          	cmp    rdx,0x7
  211116:	73 0c                	jae    211124 <ArenaAllocator_realloc+0x174>
  211118:	31 d2                	xor    edx,edx
  21111a:	48 85 c9             	test   rcx,rcx
  21111d:	75 7e                	jne    21119d <ArenaAllocator_realloc+0x1ed>
  21111f:	e9 91 00 00 00       	jmp    2111b5 <ArenaAllocator_realloc+0x205>
  211124:	48 29 cf             	sub    rdi,rcx
  211127:	48 01 ee             	add    rsi,rbp
  21112a:	48 83 c6 27          	add    rsi,0x27
  21112e:	31 d2                	xor    edx,edx
  211130:	48 8b 2b             	mov    rbp,QWORD PTR [rbx]
  211133:	0f b6 44 15 00       	movzx  eax,BYTE PTR [rbp+rdx*1+0x0]
        dest[i] = s;
  211138:	88 44 16 f9          	mov    BYTE PTR [rsi+rdx*1-0x7],al
    for (source) |s, i|
  21113c:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  21113f:	0f b6 44 10 01       	movzx  eax,BYTE PTR [rax+rdx*1+0x1]
        dest[i] = s;
  211144:	88 44 16 fa          	mov    BYTE PTR [rsi+rdx*1-0x6],al
    for (source) |s, i|
  211148:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  21114b:	0f b6 44 10 02       	movzx  eax,BYTE PTR [rax+rdx*1+0x2]
        dest[i] = s;
  211150:	88 44 16 fb          	mov    BYTE PTR [rsi+rdx*1-0x5],al
    for (source) |s, i|
  211154:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  211157:	0f b6 44 10 03       	movzx  eax,BYTE PTR [rax+rdx*1+0x3]
        dest[i] = s;
  21115c:	88 44 16 fc          	mov    BYTE PTR [rsi+rdx*1-0x4],al
    for (source) |s, i|
  211160:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  211163:	0f b6 44 10 04       	movzx  eax,BYTE PTR [rax+rdx*1+0x4]
        dest[i] = s;
  211168:	88 44 16 fd          	mov    BYTE PTR [rsi+rdx*1-0x3],al
    for (source) |s, i|
  21116c:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  21116f:	0f b6 44 10 05       	movzx  eax,BYTE PTR [rax+rdx*1+0x5]
        dest[i] = s;
  211174:	88 44 16 fe          	mov    BYTE PTR [rsi+rdx*1-0x2],al
    for (source) |s, i|
  211178:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  21117b:	0f b6 44 10 06       	movzx  eax,BYTE PTR [rax+rdx*1+0x6]
        dest[i] = s;
  211180:	88 44 16 ff          	mov    BYTE PTR [rsi+rdx*1-0x1],al
    for (source) |s, i|
  211184:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  211187:	0f b6 44 10 07       	movzx  eax,BYTE PTR [rax+rdx*1+0x7]
        dest[i] = s;
  21118c:	88 04 16             	mov    BYTE PTR [rsi+rdx*1],al
    for (source) |s, i|
  21118f:	48 83 c2 08          	add    rdx,0x8
  211193:	48 39 d7             	cmp    rdi,rdx
  211196:	75 98                	jne    211130 <ArenaAllocator_realloc+0x180>
  211198:	48 85 c9             	test   rcx,rcx
  21119b:	74 18                	je     2111b5 <ArenaAllocator_realloc+0x205>
  21119d:	48 f7 d9             	neg    rcx
  2111a0:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  2111a3:	0f b6 04 10          	movzx  eax,BYTE PTR [rax+rdx*1]
        dest[i] = s;
  2111a7:	41 88 04 10          	mov    BYTE PTR [r8+rdx*1],al
    for (source) |s, i|
  2111ab:	48 83 c2 01          	add    rdx,0x1
  2111af:	48 83 c1 01          	add    rcx,0x1
  2111b3:	75 eb                	jne    2111a0 <ArenaAllocator_realloc+0x1f0>
  2111b5:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
            return result;
  2111ba:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  2111bf:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  2111c4:	66 89 48 06          	mov    WORD PTR [rax+0x6],cx
  2111c8:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  2111cc:	89 48 02             	mov    DWORD PTR [rax+0x2],ecx
  2111cf:	4c 89 40 08          	mov    QWORD PTR [rax+0x8],r8
  2111d3:	4c 89 78 10          	mov    QWORD PTR [rax+0x10],r15
  2111d7:	48 83 c4 58          	add    rsp,0x58
  2111db:	5b                   	pop    rbx
  2111dc:	41 5c                	pop    r12
  2111de:	41 5d                	pop    r13
  2111e0:	41 5e                	pop    r14
  2111e2:	41 5f                	pop    r15
  2111e4:	5d                   	pop    rbp
  2111e5:	c3                   	ret    
            @panic("assertion failure");
  2111e6:	e8 e5 1f ff ff       	call   2031d0 <panic>
  2111eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000002111f0 <ArenaAllocator_free>:
    fn free(allocator: *Allocator, bytes: []u8) void {}
  2111f0:	c3                   	ret    
  2111f1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2111f8:	0f 1f 84 00 00 00 00 
  2111ff:	00 

0000000000211200 <ArenaAllocator_createNode>:
    fn createNode(self: *ArenaAllocator, prev_len: usize, minimum_size: usize) !*BufNode {
  211200:	41 57                	push   r15
  211202:	41 56                	push   r14
  211204:	53                   	push   rbx
  211205:	48 83 ec 30          	sub    rsp,0x30
  211209:	48 89 d3             	mov    rbx,rdx
  21120c:	49 89 f6             	mov    r14,rsi
  21120f:	49 89 ff             	mov    r15,rdi
        const actual_min_size = minimum_size + @sizeOf(BufNode);
  211212:	48 83 c1 20          	add    rcx,0x20
  211216:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21121d:	00 00 00 
            len += len / 2;
  211220:	48 89 d8             	mov    rax,rbx
  211223:	48 d1 e8             	shr    rax,1
  211226:	48 01 d8             	add    rax,rbx
            len += os.page_size - @rem(len, os.page_size);
  211229:	89 c2                	mov    edx,eax
  21122b:	81 e2 ff 0f 00 00    	and    edx,0xfff
  211231:	bb 00 10 00 00       	mov    ebx,0x1000
  211236:	48 29 d3             	sub    rbx,rdx
  211239:	48 01 c3             	add    rbx,rax
            if (len >= actual_min_size) break;
  21123c:	48 39 cb             	cmp    rbx,rcx
  21123f:	72 df                	jb     211220 <ArenaAllocator_createNode+0x20>
        if (n == 0) {
  211241:	48 85 db             	test   rbx,rbx
  211244:	74 38                	je     21127e <ArenaAllocator_createNode+0x7e>
  211246:	49 8b 76 18          	mov    rsi,QWORD PTR [r14+0x18]
  21124a:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21124f:	b9 08 00 00 00       	mov    ecx,0x8
  211254:	48 89 da             	mov    rdx,rbx
  211257:	ff 16                	call   QWORD PTR [rsi]
  211259:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  21125e:	66 85 c0             	test   ax,ax
  211261:	74 1f                	je     211282 <ArenaAllocator_createNode+0x82>
        const buf = try self.child_allocator.alignedAlloc(u8, @alignOf(BufNode), len);
  211263:	66 41 89 07          	mov    WORD PTR [r15],ax
  211267:	48 8b 44 24 22       	mov    rax,QWORD PTR [rsp+0x22]
  21126c:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  211271:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  211275:	49 89 47 02          	mov    QWORD PTR [r15+0x2],rax
  211279:	e9 c6 00 00 00       	jmp    211344 <ArenaAllocator_createNode+0x144>
  21127e:	31 db                	xor    ebx,ebx
  211280:	eb 10                	jmp    211292 <ArenaAllocator_createNode+0x92>
        assert(byte_slice.len == byte_count);
  211282:	48 39 5c 24 18       	cmp    QWORD PTR [rsp+0x18],rbx
    if (!ok) {
  211287:	0f 85 c1 00 00 00    	jne    21134e <ArenaAllocator_createNode+0x14e>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21128d:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
        buf_node.* = BufNode{
  211292:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  211296:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  21129a:	48 89 40 10          	mov    QWORD PTR [rax+0x10],rax
  21129e:	48 89 58 18          	mov    QWORD PTR [rax+0x18],rbx
            if (list.last) |last| {
  2112a2:	49 8b 4e 28          	mov    rcx,QWORD PTR [r14+0x28]
  2112a6:	48 85 c9             	test   rcx,rcx
  2112a9:	74 12                	je     2112bd <ArenaAllocator_createNode+0xbd>
            new_node.prev = node;
  2112ab:	48 89 08             	mov    QWORD PTR [rax],rcx
            if (node.next) |next_node| {
  2112ae:	48 8b 51 08          	mov    rdx,QWORD PTR [rcx+0x8]
  2112b2:	48 85 d2             	test   rdx,rdx
  2112b5:	74 24                	je     2112db <ArenaAllocator_createNode+0xdb>
                new_node.next = next_node;
  2112b7:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  2112bb:	eb 2a                	jmp    2112e7 <ArenaAllocator_createNode+0xe7>
            if (list.first) |first| {
  2112bd:	49 8b 4e 20          	mov    rcx,QWORD PTR [r14+0x20]
  2112c1:	48 85 c9             	test   rcx,rcx
  2112c4:	74 2a                	je     2112f0 <ArenaAllocator_createNode+0xf0>
            new_node.next = node;
  2112c6:	48 89 48 08          	mov    QWORD PTR [rax+0x8],rcx
            if (node.prev) |prev_node| {
  2112ca:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  2112cd:	48 85 d2             	test   rdx,rdx
  2112d0:	74 38                	je     21130a <ArenaAllocator_createNode+0x10a>
                new_node.prev = prev_node;
  2112d2:	48 89 10             	mov    QWORD PTR [rax],rdx
                prev_node.next = new_node;
  2112d5:	48 83 c2 08          	add    rdx,0x8
  2112d9:	eb 3a                	jmp    211315 <ArenaAllocator_createNode+0x115>
  2112db:	49 8d 56 28          	lea    rdx,[r14+0x28]
                new_node.next = null;
  2112df:	48 c7 40 08 00 00 00 	mov    QWORD PTR [rax+0x8],0x0
  2112e6:	00 
  2112e7:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.next = new_node;
  2112ea:	48 89 41 08          	mov    QWORD PTR [rcx+0x8],rax
  2112ee:	eb 2b                	jmp    21131b <ArenaAllocator_createNode+0x11b>
                list.first = new_node;
  2112f0:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
                list.last = new_node;
  2112f4:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
                new_node.next = null;
  2112f8:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2112fc:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
                list.len = 1;
  211300:	49 c7 46 30 01 00 00 	mov    QWORD PTR [r14+0x30],0x1
  211307:	00 
  211308:	eb 16                	jmp    211320 <ArenaAllocator_createNode+0x120>
  21130a:	49 8d 56 20          	lea    rdx,[r14+0x20]
                new_node.prev = null;
  21130e:	48 c7 00 00 00 00 00 	mov    QWORD PTR [rax],0x0
  211315:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.prev = new_node;
  211318:	48 89 01             	mov    QWORD PTR [rcx],rax
  21131b:	49 83 46 30 01       	add    QWORD PTR [r14+0x30],0x1
        self.end_index = 0;
  211320:	49 c7 46 38 00 00 00 	mov    QWORD PTR [r14+0x38],0x0
  211327:	00 
        return buf_node;
  211328:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  21132e:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  211333:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  211338:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  21133c:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  211340:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  211344:	48 83 c4 30          	add    rsp,0x30
  211348:	5b                   	pop    rbx
  211349:	41 5e                	pop    r14
  21134b:	41 5f                	pop    r15
  21134d:	c3                   	ret    
            @panic("assertion failure");
  21134e:	e8 7d 1e ff ff       	call   2031d0 <panic>
  211353:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21135a:	84 00 00 00 00 00 

0000000000211360 <_start>:
}

nakedcc fn _start() noreturn {
    switch (builtin.arch) {
        builtin.Arch.x86_64 => {
            argc_ptr = asm ("lea (%%rsp), %[argc]"
  211360:	48 8d 04 24          	lea    rax,[rsp]
  211364:	48 89 05 25 1d 00 00 	mov    QWORD PTR [rip+0x1d25],rax        # 213090 <argc_ptr>
        },
        else => @compileError("unsupported arch"),
    }
    // If LLVM inlines stack variables into _start, they will overwrite
    // the command line argument data.
    @noInlineCall(posixCallMainAndExit);
  21136b:	e8 00 00 00 00       	call   211370 <posixCallMainAndExit>

0000000000211370 <posixCallMainAndExit>:
    std.os.windows.ExitProcess(callMain());
}

// TODO https://github.com/ziglang/zig/issues/265
fn posixCallMainAndExit() noreturn {
    const argc = argc_ptr[0];
  211370:	41 56                	push   r14
  211372:	53                   	push   rbx
  211373:	48 83 ec 18          	sub    rsp,0x18
  211377:	48 8b 15 12 1d 00 00 	mov    rdx,QWORD PTR [rip+0x1d12]        # 213090 <argc_ptr>
  21137e:	48 8b 1a             	mov    rbx,QWORD PTR [rdx]
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);

    const envp_optional = @ptrCast([*]?[*]u8, argv + argc + 1);
  211381:	48 8d 0c da          	lea    rcx,[rdx+rbx*8]
  211385:	48 83 c1 10          	add    rcx,0x10
    var envp_count: usize = 0;
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  211389:	48 8d 04 da          	lea    rax,[rdx+rbx*8]
  21138d:	48 83 c0 20          	add    rax,0x20
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);
  211391:	4c 8d 72 08          	lea    r14,[rdx+0x8]
  211395:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  21139c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  2113a0:	48 83 c2 01          	add    rdx,0x1
  2113a4:	48 83 78 f0 00       	cmp    QWORD PTR [rax-0x10],0x0
  2113a9:	48 8d 40 08          	lea    rax,[rax+0x8]
  2113ad:	75 f1                	jne    2113a0 <posixCallMainAndExit+0x30>
    const envp = @ptrCast([*][*]u8, envp_optional)[0..envp_count];
  2113af:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2113b4:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
    if (builtin.os == builtin.Os.linux) {
        const auxv = @ptrCast([*]usize, envp.ptr + envp_count + 1);
        var i: usize = 0;
        while (auxv[i] != 0) : (i += 2) {
  2113b9:	48 8b 48 f0          	mov    rcx,QWORD PTR [rax-0x10]
  2113bd:	48 85 c9             	test   rcx,rcx
  2113c0:	74 28                	je     2113ea <posixCallMainAndExit+0x7a>
  2113c2:	48 8d 15 6f 3c 00 00 	lea    rdx,[rip+0x3c6f]        # 215038 <linux_aux_raw>
  2113c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
            if (auxv[i] < std.os.linux_aux_raw.len) std.os.linux_aux_raw[auxv[i]] = auxv[i + 1];
  2113d0:	48 83 f9 25          	cmp    rcx,0x25
  2113d4:	77 08                	ja     2113de <posixCallMainAndExit+0x6e>
  2113d6:	48 8b 70 f8          	mov    rsi,QWORD PTR [rax-0x8]
  2113da:	48 89 34 ca          	mov    QWORD PTR [rdx+rcx*8],rsi
        while (auxv[i] != 0) : (i += 2) {
  2113de:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2113e1:	48 83 c0 10          	add    rax,0x10
  2113e5:	48 85 c9             	test   rcx,rcx
  2113e8:	75 e6                	jne    2113d0 <posixCallMainAndExit+0x60>
        }
        std.debug.assert(std.os.linux_aux_raw[std.elf.AT_PAGESZ] == std.os.page_size);
  2113ea:	31 ff                	xor    edi,edi
  2113ec:	48 81 3d 71 3c 00 00 	cmp    QWORD PTR [rip+0x3c71],0x1000        # 215068 <linux_aux_raw+0x30>
  2113f3:	00 10 00 00 
  2113f7:	40 0f 94 c7          	sete   dil
  2113fb:	e8 00 1c ff ff       	call   203000 <assert>
  211400:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
    }

    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
  211405:	48 89 df             	mov    rdi,rbx
  211408:	4c 89 f6             	mov    rsi,r14
  21140b:	e8 10 00 00 00       	call   211420 <callMainWithArgs>
    _ = syscall1(SYS_exit, @bitCast(usize, isize(status)));
  211410:	0f b6 f8             	movzx  edi,al
    return asm volatile ("syscall"
  211413:	b8 3c 00 00 00       	mov    eax,0x3c
  211418:	0f 05                	syscall 
  21141a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000211420 <callMainWithArgs>:
}

fn callMainWithArgs(argc: usize, argv: [*][*]u8, envp: [][*]u8) u8 {
    std.os.ArgIteratorPosix.raw = argv[0..argc];
  211420:	55                   	push   rbp
  211421:	41 57                	push   r15
  211423:	41 56                	push   r14
  211425:	53                   	push   rbx
  211426:	48 83 ec 58          	sub    rsp,0x58
  21142a:	48 89 35 67 1c 00 00 	mov    QWORD PTR [rip+0x1c67],rsi        # 213098 <raw>
  211431:	48 89 3d 68 1c 00 00 	mov    QWORD PTR [rip+0x1c68],rdi        # 2130a0 <raw+0x8>
    std.os.posix_environ_raw = envp;
  211438:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  21143c:	c5 f8 11 05 3c 1c 00 	vmovups XMMWORD PTR [rip+0x1c3c],xmm0        # 213080 <posix_environ_raw>
  211443:	00 
    if (stderr_stream) |st| {
  211444:	48 8b 1d bd 3b 00 00 	mov    rbx,QWORD PTR [rip+0x3bbd]        # 215008 <stderr_stream>
  21144b:	48 85 db             	test   rbx,rbx
  21144e:	74 09                	je     211459 <callMainWithArgs+0x39>
            return std.fmt.format(self, Error, self.writeFn, format, args);
  211450:	48 8b 2d b9 1b 00 00 	mov    rbp,QWORD PTR [rip+0x1bb9]        # 213010 <stderr_file_out_stream+0x8>
  211457:	eb 34                	jmp    21148d <callMainWithArgs+0x6d>
        stderr_file = try io.getStdErr();
  211459:	48 8d 05 a0 1b 00 00 	lea    rax,[rip+0x1ba0]        # 213000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211460:	48 89 05 a1 1b 00 00 	mov    QWORD PTR [rip+0x1ba1],rax        # 213008 <stderr_file_out_stream>
  211467:	48 8d 2d 32 36 ff ff 	lea    rbp,[rip+0xffffffffffff3632]        # 204aa0 <FileOutStream_writeFn>
  21146e:	48 89 2d 9b 1b 00 00 	mov    QWORD PTR [rip+0x1b9b],rbp        # 213010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  211475:	c7 05 81 1b 00 00 02 	mov    DWORD PTR [rip+0x1b81],0x2        # 213000 <stderr_file>
  21147c:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21147f:	48 8d 1d 8a 1b 00 00 	lea    rbx,[rip+0x1b8a]        # 213010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  211486:	48 89 1d 7b 3b 00 00 	mov    QWORD PTR [rip+0x3b7b],rbx        # 215008 <stderr_stream>
  21148d:	4c 8d 74 24 4f       	lea    r14,[rsp+0x4f]
                        try output(context, fmt[start_index..i]);
  211492:	48 8d 35 5f 30 00 00 	lea    rsi,[rip+0x305f]        # 2144f8 <__unnamed_78>
  211499:	48 89 df             	mov    rdi,rbx
  21149c:	ff d5                	call   rbp
  21149e:	66 85 c0             	test   ax,ax
  2114a1:	0f 85 cb 00 00 00    	jne    211572 <callMainWithArgs+0x152>
    var buf: [max_int_digits - 1]u8 = undefined;
  2114a7:	c5 fc 10 05 70 10 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff1070]        # 20251f <__unnamed_2+0x1f>
  2114ae:	ff 
  2114af:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  2114b5:	c5 fc 10 05 43 10 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff1043]        # 202500 <__unnamed_2>
  2114bc:	ff 
  2114bd:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2114c3:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  2114c8:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  2114cc:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  2114d3:	00 00 
  2114d5:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  2114d8:	48 89 df             	mov    rdi,rbx
  2114db:	c5 f8 77             	vzeroupper 
  2114de:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2114e0:	66 85 c0             	test   ax,ax
  2114e3:	0f 85 89 00 00 00    	jne    211572 <callMainWithArgs+0x152>
                        try output(context, fmt[start_index..i]);
  2114e9:	48 8d 35 18 30 00 00 	lea    rsi,[rip+0x3018]        # 214508 <__unnamed_79>
  2114f0:	48 89 df             	mov    rdi,rbx
  2114f3:	ff d5                	call   rbp
  2114f5:	66 85 c0             	test   ax,ax
  2114f8:	75 78                	jne    211572 <callMainWithArgs+0x152>
    var buf: [max_int_digits - 1]u8 = undefined;
  2114fa:	c5 fc 10 05 1d 10 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff101d]        # 20251f <__unnamed_2+0x1f>
  211501:	ff 
  211502:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  211508:	c5 fc 10 05 f0 0f ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff0ff0]        # 202500 <__unnamed_2>
  21150f:	ff 
  211510:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  211516:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  21151b:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  21151f:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  211526:	00 00 
  211528:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  21152b:	48 89 df             	mov    rdi,rbx
  21152e:	c5 f8 77             	vzeroupper 
  211531:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  211533:	66 85 c0             	test   ax,ax
  211536:	75 3a                	jne    211572 <callMainWithArgs+0x152>
                        try output(context, fmt[start_index..i]);
  211538:	48 8d 35 d9 2f 00 00 	lea    rsi,[rip+0x2fd9]        # 214518 <__unnamed_80>
  21153f:	48 89 df             	mov    rdi,rbx
  211542:	ff d5                	call   rbp
  211544:	66 85 c0             	test   ax,ax
  211547:	75 29                	jne    211572 <callMainWithArgs+0x152>
                const casted_value = ([]const u8)(value);
  211549:	c5 f8 10 05 1f 2d 00 	vmovups xmm0,XMMWORD PTR [rip+0x2d1f]        # 214270 <__unnamed_81>
  211550:	00 
  211551:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  211557:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  21155c:	48 89 df             	mov    rdi,rbx
  21155f:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  211561:	66 85 c0             	test   ax,ax
  211564:	75 0c                	jne    211572 <callMainWithArgs+0x152>
        try output(context, fmt[start_index..]);
  211566:	48 8d 35 bb 2f 00 00 	lea    rsi,[rip+0x2fbb]        # 214528 <__unnamed_82>
  21156d:	48 89 df             	mov    rdi,rbx
  211570:	ff d5                	call   rbp
    var ok_count: usize = 0;
    var skip_count: usize = 0;
    for (test_fn_list) |test_fn, i| {
        warn("Test {}/{} {}...", i + 1, test_fn_list.len, test_fn.name);

        if (test_fn.func()) |_| {
  211572:	e8 99 1a ff ff       	call   203010 <loop_opt>
  211577:	89 c5                	mov    ebp,eax
  211579:	0f b7 c5             	movzx  eax,bp
  21157c:	83 f8 26             	cmp    eax,0x26
  21157f:	74 1a                	je     21159b <callMainWithArgs+0x17b>
  211581:	66 85 ed             	test   bp,bp
  211584:	75 31                	jne    2115b7 <callMainWithArgs+0x197>
    if (stderr_stream) |st| {
  211586:	48 8b 3d 7b 3a 00 00 	mov    rdi,QWORD PTR [rip+0x3a7b]        # 215008 <stderr_stream>
  21158d:	48 85 ff             	test   rdi,rdi
  211590:	74 41                	je     2115d3 <callMainWithArgs+0x1b3>
  211592:	48 8b 0d 77 1a 00 00 	mov    rcx,QWORD PTR [rip+0x1a77]        # 213010 <stderr_file_out_stream+0x8>
  211599:	eb 6c                	jmp    211607 <callMainWithArgs+0x1e7>
  21159b:	48 8b 3d 66 3a 00 00 	mov    rdi,QWORD PTR [rip+0x3a66]        # 215008 <stderr_stream>
  2115a2:	48 85 ff             	test   rdi,rdi
  2115a5:	0f 84 81 00 00 00    	je     21162c <callMainWithArgs+0x20c>
  2115ab:	48 8b 05 5e 1a 00 00 	mov    rax,QWORD PTR [rip+0x1a5e]        # 213010 <stderr_file_out_stream+0x8>
  2115b2:	e9 a9 00 00 00       	jmp    211660 <callMainWithArgs+0x240>
  2115b7:	4c 8b 35 4a 3a 00 00 	mov    r14,QWORD PTR [rip+0x3a4a]        # 215008 <stderr_stream>
  2115be:	4d 85 f6             	test   r14,r14
  2115c1:	0f 84 be 00 00 00    	je     211685 <callMainWithArgs+0x265>
  2115c7:	4c 8b 3d 42 1a 00 00 	mov    r15,QWORD PTR [rip+0x1a42]        # 213010 <stderr_file_out_stream+0x8>
  2115ce:	e9 e6 00 00 00       	jmp    2116b9 <callMainWithArgs+0x299>
        stderr_file = try io.getStdErr();
  2115d3:	48 8d 05 26 1a 00 00 	lea    rax,[rip+0x1a26]        # 213000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2115da:	48 89 05 27 1a 00 00 	mov    QWORD PTR [rip+0x1a27],rax        # 213008 <stderr_file_out_stream>
  2115e1:	48 8d 0d b8 34 ff ff 	lea    rcx,[rip+0xffffffffffff34b8]        # 204aa0 <FileOutStream_writeFn>
  2115e8:	48 89 0d 21 1a 00 00 	mov    QWORD PTR [rip+0x1a21],rcx        # 213010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2115ef:	c7 05 07 1a 00 00 02 	mov    DWORD PTR [rip+0x1a07],0x2        # 213000 <stderr_file>
  2115f6:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2115f9:	48 8d 3d 10 1a 00 00 	lea    rdi,[rip+0x1a10]        # 213010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  211600:	48 89 3d 01 3a 00 00 	mov    QWORD PTR [rip+0x3a01],rdi        # 215008 <stderr_stream>
  211607:	48 8d 35 2a 2f 00 00 	lea    rsi,[rip+0x2f2a]        # 214538 <__unnamed_83>
  21160e:	ff d1                	call   rcx
    if (stderr_stream) |st| {
  211610:	48 8b 3d f1 39 00 00 	mov    rdi,QWORD PTR [rip+0x39f1]        # 215008 <stderr_stream>
  211617:	48 85 ff             	test   rdi,rdi
  21161a:	0f 84 f3 00 00 00    	je     211713 <callMainWithArgs+0x2f3>
  211620:	48 8b 0d e9 19 00 00 	mov    rcx,QWORD PTR [rip+0x19e9]        # 213010 <stderr_file_out_stream+0x8>
  211627:	e9 1b 01 00 00       	jmp    211747 <callMainWithArgs+0x327>
        stderr_file = try io.getStdErr();
  21162c:	48 8d 05 cd 19 00 00 	lea    rax,[rip+0x19cd]        # 213000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211633:	48 89 05 ce 19 00 00 	mov    QWORD PTR [rip+0x19ce],rax        # 213008 <stderr_file_out_stream>
  21163a:	48 8d 05 5f 34 ff ff 	lea    rax,[rip+0xffffffffffff345f]        # 204aa0 <FileOutStream_writeFn>
  211641:	48 89 05 c8 19 00 00 	mov    QWORD PTR [rip+0x19c8],rax        # 213010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  211648:	c7 05 ae 19 00 00 02 	mov    DWORD PTR [rip+0x19ae],0x2        # 213000 <stderr_file>
  21164f:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211652:	48 8d 3d b7 19 00 00 	lea    rdi,[rip+0x19b7]        # 213010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  211659:	48 89 3d a8 39 00 00 	mov    QWORD PTR [rip+0x39a8],rdi        # 215008 <stderr_stream>
  211660:	48 8d 35 e1 2e 00 00 	lea    rsi,[rip+0x2ee1]        # 214548 <__unnamed_84>
  211667:	ff d0                	call   rax
    if (stderr_stream) |st| {
  211669:	48 8b 1d 98 39 00 00 	mov    rbx,QWORD PTR [rip+0x3998]        # 215008 <stderr_stream>
  211670:	48 85 db             	test   rbx,rbx
  211673:	0f 84 dc 00 00 00    	je     211755 <callMainWithArgs+0x335>
  211679:	48 8b 2d 90 19 00 00 	mov    rbp,QWORD PTR [rip+0x1990]        # 213010 <stderr_file_out_stream+0x8>
  211680:	e9 04 01 00 00       	jmp    211789 <callMainWithArgs+0x369>
        stderr_file = try io.getStdErr();
  211685:	48 8d 05 74 19 00 00 	lea    rax,[rip+0x1974]        # 213000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21168c:	48 89 05 75 19 00 00 	mov    QWORD PTR [rip+0x1975],rax        # 213008 <stderr_file_out_stream>
  211693:	4c 8d 3d 06 34 ff ff 	lea    r15,[rip+0xffffffffffff3406]        # 204aa0 <FileOutStream_writeFn>
  21169a:	4c 89 3d 6f 19 00 00 	mov    QWORD PTR [rip+0x196f],r15        # 213010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  2116a1:	c7 05 55 19 00 00 02 	mov    DWORD PTR [rip+0x1955],0x2        # 213000 <stderr_file>
  2116a8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2116ab:	4c 8d 35 5e 19 00 00 	lea    r14,[rip+0x195e]        # 213010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  2116b2:	4c 89 35 4f 39 00 00 	mov    QWORD PTR [rip+0x394f],r14        # 215008 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  2116b9:	48 8d 35 c8 2e 00 00 	lea    rsi,[rip+0x2ec8]        # 214588 <__unnamed_85>
  2116c0:	4c 89 f7             	mov    rdi,r14
  2116c3:	41 ff d7             	call   r15
  2116c6:	b3 01                	mov    bl,0x1
  2116c8:	66 85 c0             	test   ax,ax
  2116cb:	0f 85 53 01 00 00    	jne    211824 <callMainWithArgs+0x404>
  2116d1:	48 0f bf c5          	movsx  rax,bp
  2116d5:	48 c1 e0 04          	shl    rax,0x4
  2116d9:	48 8d 0d 20 29 00 00 	lea    rcx,[rip+0x2920]        # 214000 <raw+0xf68>
  2116e0:	48 01 c1             	add    rcx,rax
                const casted_value = ([]const u8)(value);
  2116e3:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2116e7:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  2116ed:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  2116f2:	4c 89 f7             	mov    rdi,r14
  2116f5:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2116f8:	66 85 c0             	test   ax,ax
  2116fb:	0f 85 23 01 00 00    	jne    211824 <callMainWithArgs+0x404>
        try output(context, fmt[start_index..]);
  211701:	48 8d 35 90 2e 00 00 	lea    rsi,[rip+0x2e90]        # 214598 <__unnamed_86>
  211708:	4c 89 f7             	mov    rdi,r14
  21170b:	41 ff d7             	call   r15
  21170e:	e9 11 01 00 00       	jmp    211824 <callMainWithArgs+0x404>
        stderr_file = try io.getStdErr();
  211713:	48 8d 05 e6 18 00 00 	lea    rax,[rip+0x18e6]        # 213000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21171a:	48 89 05 e7 18 00 00 	mov    QWORD PTR [rip+0x18e7],rax        # 213008 <stderr_file_out_stream>
  211721:	48 8d 0d 78 33 ff ff 	lea    rcx,[rip+0xffffffffffff3378]        # 204aa0 <FileOutStream_writeFn>
  211728:	48 89 0d e1 18 00 00 	mov    QWORD PTR [rip+0x18e1],rcx        # 213010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  21172f:	c7 05 c7 18 00 00 02 	mov    DWORD PTR [rip+0x18c7],0x2        # 213000 <stderr_file>
  211736:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  211739:	48 8d 3d d0 18 00 00 	lea    rdi,[rip+0x18d0]        # 213010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  211740:	48 89 3d c1 38 00 00 	mov    QWORD PTR [rip+0x38c1],rdi        # 215008 <stderr_stream>
  211747:	48 8d 35 0a 2e 00 00 	lea    rsi,[rip+0x2e0a]        # 214558 <__unnamed_87>
  21174e:	ff d1                	call   rcx
  211750:	e9 cd 00 00 00       	jmp    211822 <callMainWithArgs+0x402>
        stderr_file = try io.getStdErr();
  211755:	48 8d 05 a4 18 00 00 	lea    rax,[rip+0x18a4]        # 213000 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21175c:	48 89 05 a5 18 00 00 	mov    QWORD PTR [rip+0x18a5],rax        # 213008 <stderr_file_out_stream>
  211763:	48 8d 2d 36 33 ff ff 	lea    rbp,[rip+0xffffffffffff3336]        # 204aa0 <FileOutStream_writeFn>
  21176a:	48 89 2d 9f 18 00 00 	mov    QWORD PTR [rip+0x189f],rbp        # 213010 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  211771:	c7 05 85 18 00 00 02 	mov    DWORD PTR [rip+0x1885],0x2        # 213000 <stderr_file>
  211778:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  21177b:	48 8d 1d 8e 18 00 00 	lea    rbx,[rip+0x188e]        # 213010 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  211782:	48 89 1d 7f 38 00 00 	mov    QWORD PTR [rip+0x387f],rbx        # 215008 <stderr_stream>
    var buf: [max_int_digits - 1]u8 = undefined;
  211789:	c5 fc 10 05 8e 0d ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff0d8e]        # 20251f <__unnamed_2+0x1f>
  211790:	ff 
  211791:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  211797:	c5 fc 10 05 61 0d ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff0d61]        # 202500 <__unnamed_2>
  21179e:	ff 
  21179f:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2117a5:	c6 44 24 4f 30       	mov    BYTE PTR [rsp+0x4f],0x30
        const padded_buf = buf[index - padding ..];
  2117aa:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  2117ae:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  2117b5:	00 00 
  2117b7:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  2117ba:	48 89 df             	mov    rdi,rbx
  2117bd:	c5 f8 77             	vzeroupper 
  2117c0:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  2117c2:	66 85 c0             	test   ax,ax
  2117c5:	75 5b                	jne    211822 <callMainWithArgs+0x402>
                        try output(context, fmt[start_index..i]);
  2117c7:	48 8d 35 9a 2d 00 00 	lea    rsi,[rip+0x2d9a]        # 214568 <__unnamed_88>
  2117ce:	48 89 df             	mov    rdi,rbx
  2117d1:	ff d5                	call   rbp
  2117d3:	66 85 c0             	test   ax,ax
  2117d6:	75 4a                	jne    211822 <callMainWithArgs+0x402>
    var buf: [max_int_digits - 1]u8 = undefined;
  2117d8:	c5 fc 10 05 3f 0d ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff0d3f]        # 20251f <__unnamed_2+0x1f>
  2117df:	ff 
  2117e0:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  2117e6:	c5 fc 10 05 12 0d ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff0d12]        # 202500 <__unnamed_2>
  2117ed:	ff 
  2117ee:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  2117f4:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  2117f9:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  2117fd:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  211804:	00 00 
  211806:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  211809:	48 89 df             	mov    rdi,rbx
  21180c:	c5 f8 77             	vzeroupper 
  21180f:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  211811:	66 85 c0             	test   ax,ax
  211814:	75 0c                	jne    211822 <callMainWithArgs+0x402>
        try output(context, fmt[start_index..]);
  211816:	48 8d 35 5b 2d 00 00 	lea    rsi,[rip+0x2d5b]        # 214578 <__unnamed_89>
  21181d:	48 89 df             	mov    rdi,rbx
  211820:	ff d5                	call   rbp
  211822:	31 db                	xor    ebx,ebx
    return callMain();
  211824:	89 d8                	mov    eax,ebx
  211826:	48 83 c4 58          	add    rsp,0x58
  21182a:	5b                   	pop    rbx
  21182b:	41 5e                	pop    r14
  21182d:	41 5f                	pop    r15
  21182f:	5d                   	pop    rbp
  211830:	c3                   	ret    
  211831:	cc                   	int3   
  211832:	cc                   	int3   
  211833:	cc                   	int3   
  211834:	cc                   	int3   
  211835:	cc                   	int3   
  211836:	cc                   	int3   
  211837:	cc                   	int3   
  211838:	cc                   	int3   
  211839:	cc                   	int3   
  21183a:	cc                   	int3   
  21183b:	cc                   	int3   
  21183c:	cc                   	int3   
  21183d:	cc                   	int3   
  21183e:	cc                   	int3   
  21183f:	cc                   	int3   

0000000000211840 <memset>:

export fn memset(dest: ?[*]u8, c: u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  211840:	48 85 d2             	test   rdx,rdx
  211843:	0f 84 d4 01 00 00    	je     211a1d <memset+0x1dd>
  211849:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  211850:	73 08                	jae    21185a <memset+0x1a>
  211852:	45 31 c0             	xor    r8d,r8d
  211855:	e9 a8 01 00 00       	jmp    211a02 <memset+0x1c2>
  21185a:	49 89 d0             	mov    r8,rdx
  21185d:	49 83 e0 80          	and    r8,0xffffffffffffff80
  211861:	c5 f9 6e c6          	vmovd  xmm0,esi
  211865:	c4 e2 7d 78 c0       	vpbroadcastb ymm0,xmm0
  21186a:	49 8d 48 80          	lea    rcx,[r8-0x80]
  21186e:	48 89 c8             	mov    rax,rcx
  211871:	48 c1 e8 07          	shr    rax,0x7
  211875:	44 8d 48 01          	lea    r9d,[rax+0x1]
  211879:	41 83 e1 07          	and    r9d,0x7
  21187d:	48 81 f9 80 03 00 00 	cmp    rcx,0x380
  211884:	73 10                	jae    211896 <memset+0x56>
  211886:	31 c0                	xor    eax,eax
  211888:	4d 85 c9             	test   r9,r9
  21188b:	0f 85 44 01 00 00    	jne    2119d5 <memset+0x195>
  211891:	e9 67 01 00 00       	jmp    2119fd <memset+0x1bd>
  211896:	48 8d 8f e0 03 00 00 	lea    rcx,[rdi+0x3e0]
  21189d:	4d 8d 51 ff          	lea    r10,[r9-0x1]
  2118a1:	49 29 c2             	sub    r10,rax
  2118a4:	31 c0                	xor    eax,eax
  2118a6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2118ad:	00 00 00 
        dest.?[index] = c;
  2118b0:	c5 fe 7f 84 01 20 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3e0],ymm0
  2118b7:	ff ff 
  2118b9:	c5 fe 7f 84 01 40 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3c0],ymm0
  2118c0:	ff ff 
  2118c2:	c5 fe 7f 84 01 60 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3a0],ymm0
  2118c9:	ff ff 
  2118cb:	c5 fe 7f 84 01 80 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x380],ymm0
  2118d2:	ff ff 
  2118d4:	c5 fe 7f 84 01 a0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x360],ymm0
  2118db:	ff ff 
  2118dd:	c5 fe 7f 84 01 c0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x340],ymm0
  2118e4:	ff ff 
  2118e6:	c5 fe 7f 84 01 e0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x320],ymm0
  2118ed:	ff ff 
  2118ef:	c5 fe 7f 84 01 00 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x300],ymm0
  2118f6:	ff ff 
  2118f8:	c5 fe 7f 84 01 20 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2e0],ymm0
  2118ff:	ff ff 
  211901:	c5 fe 7f 84 01 40 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2c0],ymm0
  211908:	ff ff 
  21190a:	c5 fe 7f 84 01 60 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2a0],ymm0
  211911:	ff ff 
  211913:	c5 fe 7f 84 01 80 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x280],ymm0
  21191a:	ff ff 
  21191c:	c5 fe 7f 84 01 a0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x260],ymm0
  211923:	ff ff 
  211925:	c5 fe 7f 84 01 c0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x240],ymm0
  21192c:	ff ff 
  21192e:	c5 fe 7f 84 01 e0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x220],ymm0
  211935:	ff ff 
  211937:	c5 fe 7f 84 01 00 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x200],ymm0
  21193e:	ff ff 
  211940:	c5 fe 7f 84 01 20 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  211947:	ff ff 
  211949:	c5 fe 7f 84 01 40 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1c0],ymm0
  211950:	ff ff 
  211952:	c5 fe 7f 84 01 60 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1a0],ymm0
  211959:	ff ff 
  21195b:	c5 fe 7f 84 01 80 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x180],ymm0
  211962:	ff ff 
  211964:	c5 fe 7f 84 01 a0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x160],ymm0
  21196b:	ff ff 
  21196d:	c5 fe 7f 84 01 c0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x140],ymm0
  211974:	ff ff 
  211976:	c5 fe 7f 84 01 e0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x120],ymm0
  21197d:	ff ff 
  21197f:	c5 fe 7f 84 01 00 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0x100],ymm0
  211986:	ff ff 
  211988:	c5 fe 7f 84 01 20 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  21198f:	ff ff 
  211991:	c5 fe 7f 84 01 40 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xc0],ymm0
  211998:	ff ff 
  21199a:	c5 fe 7f 84 01 60 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xa0],ymm0
  2119a1:	ff ff 
  2119a3:	c5 fe 7f 44 01 80    	vmovdqu YMMWORD PTR [rcx+rax*1-0x80],ymm0
  2119a9:	c5 fe 7f 44 01 a0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x60],ymm0
  2119af:	c5 fe 7f 44 01 c0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x40],ymm0
  2119b5:	c5 fe 7f 44 01 e0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x20],ymm0
  2119bb:	c5 fe 7f 04 01       	vmovdqu YMMWORD PTR [rcx+rax*1],ymm0
    while (index != n) : (index += 1)
  2119c0:	48 05 00 04 00 00    	add    rax,0x400
  2119c6:	49 83 c2 08          	add    r10,0x8
  2119ca:	0f 85 e0 fe ff ff    	jne    2118b0 <memset+0x70>
  2119d0:	4d 85 c9             	test   r9,r9
  2119d3:	74 28                	je     2119fd <memset+0x1bd>
  2119d5:	48 01 f8             	add    rax,rdi
  2119d8:	48 83 c0 60          	add    rax,0x60
  2119dc:	49 f7 d9             	neg    r9
  2119df:	90                   	nop
        dest.?[index] = c;
  2119e0:	c5 fe 7f 40 a0       	vmovdqu YMMWORD PTR [rax-0x60],ymm0
  2119e5:	c5 fe 7f 40 c0       	vmovdqu YMMWORD PTR [rax-0x40],ymm0
  2119ea:	c5 fe 7f 40 e0       	vmovdqu YMMWORD PTR [rax-0x20],ymm0
  2119ef:	c5 fe 7f 00          	vmovdqu YMMWORD PTR [rax],ymm0
    while (index != n) : (index += 1)
  2119f3:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  2119f7:	49 83 c1 01          	add    r9,0x1
  2119fb:	75 e3                	jne    2119e0 <memset+0x1a0>
  2119fd:	49 39 d0             	cmp    r8,rdx
  211a00:	74 1b                	je     211a1d <memset+0x1dd>
        dest.?[index] = c;
  211a02:	4a 8d 04 07          	lea    rax,[rdi+r8*1]
  211a06:	4c 29 c2             	sub    rdx,r8
  211a09:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  211a10:	40 88 30             	mov    BYTE PTR [rax],sil
    while (index != n) : (index += 1)
  211a13:	48 83 c0 01          	add    rax,0x1
  211a17:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  211a1b:	75 f3                	jne    211a10 <memset+0x1d0>

    return dest;
  211a1d:	48 89 f8             	mov    rax,rdi
  211a20:	c5 f8 77             	vzeroupper 
  211a23:	c3                   	ret    
  211a24:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211a2b:	00 00 00 00 00 

0000000000211a30 <memcpy>:

export fn memcpy(noalias dest: ?[*]u8, noalias src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  211a30:	48 85 d2             	test   rdx,rdx
  211a33:	0f 84 d7 01 00 00    	je     211c10 <memcpy+0x1e0>
  211a39:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  211a40:	73 07                	jae    211a49 <memcpy+0x19>
  211a42:	31 c0                	xor    eax,eax
  211a44:	e9 b7 01 00 00       	jmp    211c00 <memcpy+0x1d0>
  211a49:	48 89 d0             	mov    rax,rdx
  211a4c:	48 83 e0 80          	and    rax,0xffffffffffffff80
  211a50:	4c 8d 48 80          	lea    r9,[rax-0x80]
  211a54:	4c 89 c9             	mov    rcx,r9
  211a57:	48 c1 e9 07          	shr    rcx,0x7
  211a5b:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  211a5f:	41 83 e0 03          	and    r8d,0x3
  211a63:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  211a6a:	73 10                	jae    211a7c <memcpy+0x4c>
  211a6c:	31 c9                	xor    ecx,ecx
  211a6e:	4d 85 c0             	test   r8,r8
  211a71:	0f 85 35 01 00 00    	jne    211bac <memcpy+0x17c>
  211a77:	e9 7c 01 00 00       	jmp    211bf8 <memcpy+0x1c8>
  211a7c:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  211a80:	49 29 c9             	sub    r9,rcx
  211a83:	31 c9                	xor    ecx,ecx
  211a85:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211a8c:	00 00 00 00 
        dest.?[index] = src.?[index];
  211a90:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  211a95:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  211a9b:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  211aa1:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  211aa7:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  211aac:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  211ab2:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  211ab8:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  211abe:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  211ac5:	00 00 
  211ac7:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  211ace:	00 00 
  211ad0:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  211ad7:	00 00 
  211ad9:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  211ae0:	00 00 
  211ae2:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  211ae9:	00 00 
  211aeb:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  211af2:	00 00 
  211af4:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  211afb:	00 00 
  211afd:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  211b04:	00 00 
  211b06:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  211b0d:	00 00 
  211b0f:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  211b16:	00 00 
  211b18:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  211b1f:	00 00 
  211b21:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  211b28:	00 00 
  211b2a:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  211b31:	00 00 
  211b33:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  211b3a:	00 00 
  211b3c:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  211b43:	00 00 
  211b45:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  211b4c:	00 00 
  211b4e:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  211b55:	00 00 
  211b57:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  211b5e:	00 00 
  211b60:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  211b67:	00 00 
  211b69:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  211b70:	00 00 
  211b72:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  211b79:	00 00 
  211b7b:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  211b82:	00 00 
  211b84:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  211b8b:	00 00 
  211b8d:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  211b94:	00 00 
    while (index != n) : (index += 1)
  211b96:	48 81 c1 00 02 00 00 	add    rcx,0x200
  211b9d:	49 83 c1 04          	add    r9,0x4
  211ba1:	0f 85 e9 fe ff ff    	jne    211a90 <memcpy+0x60>
  211ba7:	4d 85 c0             	test   r8,r8
  211baa:	74 4c                	je     211bf8 <memcpy+0x1c8>
  211bac:	48 83 c1 60          	add    rcx,0x60
  211bb0:	49 f7 d8             	neg    r8
  211bb3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211bba:	84 00 00 00 00 00 
        dest.?[index] = src.?[index];
  211bc0:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  211bc6:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  211bcc:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  211bd2:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  211bd7:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  211bdd:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  211be3:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  211be9:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
    while (index != n) : (index += 1)
  211bee:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  211bf2:	49 83 c0 01          	add    r8,0x1
  211bf6:	75 c8                	jne    211bc0 <memcpy+0x190>
  211bf8:	48 39 d0             	cmp    rax,rdx
  211bfb:	74 13                	je     211c10 <memcpy+0x1e0>
  211bfd:	0f 1f 00             	nop    DWORD PTR [rax]
        dest.?[index] = src.?[index];
  211c00:	0f b6 0c 06          	movzx  ecx,BYTE PTR [rsi+rax*1]
  211c04:	88 0c 07             	mov    BYTE PTR [rdi+rax*1],cl
    while (index != n) : (index += 1)
  211c07:	48 83 c0 01          	add    rax,0x1
  211c0b:	48 39 c2             	cmp    rdx,rax
  211c0e:	75 f0                	jne    211c00 <memcpy+0x1d0>

    return dest;
  211c10:	48 89 f8             	mov    rax,rdi
  211c13:	c5 f8 77             	vzeroupper 
  211c16:	c3                   	ret    
  211c17:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  211c1e:	00 00 

0000000000211c20 <memmove>:
}

export fn memmove(dest: ?[*]u8, src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    if (@ptrToInt(dest) < @ptrToInt(src)) {
  211c20:	48 39 f7             	cmp    rdi,rsi
  211c23:	0f 83 cb 00 00 00    	jae    211cf4 <memmove+0xd4>
  211c29:	48 85 d2             	test   rdx,rdx
        var index: usize = 0;
        while (index != n) : (index += 1) {
  211c2c:	0f 84 0f 05 00 00    	je     212141 <memmove+0x521>
  211c32:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  211c39:	72 1a                	jb     211c55 <memmove+0x35>
  211c3b:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  211c3f:	48 39 f8             	cmp    rax,rdi
  211c42:	0f 86 0b 01 00 00    	jbe    211d53 <memmove+0x133>
  211c48:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  211c4c:	48 39 f0             	cmp    rax,rsi
  211c4f:	0f 86 fe 00 00 00    	jbe    211d53 <memmove+0x133>
  211c55:	45 31 d2             	xor    r10d,r10d
            dest.?[index] = src.?[index];
  211c58:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  211c5c:	4d 29 d0             	sub    r8,r10
  211c5f:	48 89 d1             	mov    rcx,rdx
  211c62:	48 83 e1 07          	and    rcx,0x7
  211c66:	74 1b                	je     211c83 <memmove+0x63>
  211c68:	48 f7 d9             	neg    rcx
  211c6b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  211c70:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  211c75:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
        while (index != n) : (index += 1) {
  211c79:	49 83 c2 01          	add    r10,0x1
  211c7d:	48 83 c1 01          	add    rcx,0x1
  211c81:	75 ed                	jne    211c70 <memmove+0x50>
            dest.?[index] = src.?[index];
  211c83:	49 83 f8 07          	cmp    r8,0x7
  211c87:	0f 82 b4 04 00 00    	jb     212141 <memmove+0x521>
  211c8d:	0f 1f 00             	nop    DWORD PTR [rax]
  211c90:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  211c95:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
  211c99:	42 0f b6 44 16 01    	movzx  eax,BYTE PTR [rsi+r10*1+0x1]
  211c9f:	42 88 44 17 01       	mov    BYTE PTR [rdi+r10*1+0x1],al
  211ca4:	42 0f b6 44 16 02    	movzx  eax,BYTE PTR [rsi+r10*1+0x2]
  211caa:	42 88 44 17 02       	mov    BYTE PTR [rdi+r10*1+0x2],al
  211caf:	42 0f b6 44 16 03    	movzx  eax,BYTE PTR [rsi+r10*1+0x3]
  211cb5:	42 88 44 17 03       	mov    BYTE PTR [rdi+r10*1+0x3],al
  211cba:	42 0f b6 44 16 04    	movzx  eax,BYTE PTR [rsi+r10*1+0x4]
  211cc0:	42 88 44 17 04       	mov    BYTE PTR [rdi+r10*1+0x4],al
  211cc5:	42 0f b6 44 16 05    	movzx  eax,BYTE PTR [rsi+r10*1+0x5]
  211ccb:	42 88 44 17 05       	mov    BYTE PTR [rdi+r10*1+0x5],al
  211cd0:	42 0f b6 44 16 06    	movzx  eax,BYTE PTR [rsi+r10*1+0x6]
  211cd6:	42 88 44 17 06       	mov    BYTE PTR [rdi+r10*1+0x6],al
  211cdb:	42 0f b6 44 16 07    	movzx  eax,BYTE PTR [rsi+r10*1+0x7]
  211ce1:	42 88 44 17 07       	mov    BYTE PTR [rdi+r10*1+0x7],al
        while (index != n) : (index += 1) {
  211ce6:	49 83 c2 08          	add    r10,0x8
  211cea:	4c 39 d2             	cmp    rdx,r10
  211ced:	75 a1                	jne    211c90 <memmove+0x70>
  211cef:	e9 4d 04 00 00       	jmp    212141 <memmove+0x521>
  211cf4:	48 85 d2             	test   rdx,rdx
        }
    } else {
        var index = n;
        while (index != 0) {
  211cf7:	0f 84 44 04 00 00    	je     212141 <memmove+0x521>
  211cfd:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  211d04:	0f 82 2a 02 00 00    	jb     211f34 <memmove+0x314>
  211d0a:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  211d0e:	48 39 f8             	cmp    rax,rdi
  211d11:	76 0d                	jbe    211d20 <memmove+0x100>
  211d13:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  211d17:	48 39 f0             	cmp    rax,rsi
  211d1a:	0f 87 14 02 00 00    	ja     211f34 <memmove+0x314>
  211d20:	49 89 d0             	mov    r8,rdx
  211d23:	49 83 e0 80          	and    r8,0xffffffffffffff80
  211d27:	49 8d 48 80          	lea    rcx,[r8-0x80]
  211d2b:	48 89 c8             	mov    rax,rcx
  211d2e:	48 c1 e8 07          	shr    rax,0x7
  211d32:	44 8d 48 01          	lea    r9d,[rax+0x1]
  211d36:	41 83 e1 03          	and    r9d,0x3
  211d3a:	48 81 f9 80 01 00 00 	cmp    rcx,0x180
  211d41:	73 47                	jae    211d8a <memmove+0x16a>
  211d43:	31 c0                	xor    eax,eax
  211d45:	4d 85 c9             	test   r9,r9
  211d48:	0f 85 8a 01 00 00    	jne    211ed8 <memmove+0x2b8>
  211d4e:	e9 d5 01 00 00       	jmp    211f28 <memmove+0x308>
        while (index != n) : (index += 1) {
  211d53:	49 89 d2             	mov    r10,rdx
  211d56:	49 83 e2 80          	and    r10,0xffffffffffffff80
  211d5a:	4d 8d 4a 80          	lea    r9,[r10-0x80]
  211d5e:	4c 89 c9             	mov    rcx,r9
  211d61:	48 c1 e9 07          	shr    rcx,0x7
  211d65:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  211d69:	41 83 e0 03          	and    r8d,0x3
  211d6d:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  211d74:	0f 83 4c 02 00 00    	jae    211fc6 <memmove+0x3a6>
  211d7a:	31 c9                	xor    ecx,ecx
  211d7c:	4d 85 c0             	test   r8,r8
  211d7f:	0f 85 67 03 00 00    	jne    2120ec <memmove+0x4cc>
  211d85:	e9 ae 03 00 00       	jmp    212138 <memmove+0x518>
        while (index != 0) {
  211d8a:	4c 8d 14 16          	lea    r10,[rsi+rdx*1]
  211d8e:	49 83 c2 e0          	add    r10,0xffffffffffffffe0
  211d92:	48 8d 0c 17          	lea    rcx,[rdi+rdx*1]
  211d96:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  211d9a:	4d 8d 59 ff          	lea    r11,[r9-0x1]
  211d9e:	49 29 c3             	sub    r11,rax
  211da1:	31 c0                	xor    eax,eax
  211da3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211daa:	84 00 00 00 00 00 
            index -= 1;
            dest.?[index] = src.?[index];
  211db0:	c4 c1 7c 10 44 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x60]
  211db7:	c4 c1 7c 10 4c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x40]
  211dbe:	c4 c1 7c 10 54 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x20]
  211dc5:	c4 c1 7c 10 1c 02    	vmovups ymm3,YMMWORD PTR [r10+rax*1]
  211dcb:	c5 fc 11 1c 01       	vmovups YMMWORD PTR [rcx+rax*1],ymm3
  211dd0:	c5 fc 11 54 01 e0    	vmovups YMMWORD PTR [rcx+rax*1-0x20],ymm2
  211dd6:	c5 fc 11 4c 01 c0    	vmovups YMMWORD PTR [rcx+rax*1-0x40],ymm1
  211ddc:	c5 fc 11 44 01 a0    	vmovups YMMWORD PTR [rcx+rax*1-0x60],ymm0
  211de2:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0xe0]
  211de9:	ff ff ff 
  211dec:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0xc0]
  211df3:	ff ff ff 
  211df6:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0xa0]
  211dfd:	ff ff ff 
  211e00:	c4 c1 7c 10 5c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x80]
  211e07:	c5 fc 11 5c 01 80    	vmovups YMMWORD PTR [rcx+rax*1-0x80],ymm3
  211e0d:	c5 fc 11 94 01 60 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xa0],ymm2
  211e14:	ff ff 
  211e16:	c5 fc 11 8c 01 40 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xc0],ymm1
  211e1d:	ff ff 
  211e1f:	c5 fc 11 84 01 20 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  211e26:	ff ff 
  211e28:	c4 c1 7c 10 84 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x160]
  211e2f:	fe ff ff 
  211e32:	c4 c1 7c 10 8c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x140]
  211e39:	fe ff ff 
  211e3c:	c4 c1 7c 10 94 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x120]
  211e43:	fe ff ff 
  211e46:	c4 c1 7c 10 9c 02 00 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x100]
  211e4d:	ff ff ff 
  211e50:	c5 fc 11 9c 01 00 ff 	vmovups YMMWORD PTR [rcx+rax*1-0x100],ymm3
  211e57:	ff ff 
  211e59:	c5 fc 11 94 01 e0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x120],ymm2
  211e60:	ff ff 
  211e62:	c5 fc 11 8c 01 c0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x140],ymm1
  211e69:	ff ff 
  211e6b:	c5 fc 11 84 01 a0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x160],ymm0
  211e72:	ff ff 
  211e74:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x1e0]
  211e7b:	fe ff ff 
  211e7e:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x1c0]
  211e85:	fe ff ff 
  211e88:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x1a0]
  211e8f:	fe ff ff 
  211e92:	c4 c1 7c 10 9c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x180]
  211e99:	fe ff ff 
  211e9c:	c5 fc 11 9c 01 80 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x180],ymm3
  211ea3:	ff ff 
  211ea5:	c5 fc 11 94 01 60 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1a0],ymm2
  211eac:	ff ff 
  211eae:	c5 fc 11 8c 01 40 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1c0],ymm1
  211eb5:	ff ff 
  211eb7:	c5 fc 11 84 01 20 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  211ebe:	ff ff 
  211ec0:	48 05 00 fe ff ff    	add    rax,0xfffffffffffffe00
  211ec6:	49 83 c3 04          	add    r11,0x4
  211eca:	0f 85 e0 fe ff ff    	jne    211db0 <memmove+0x190>
  211ed0:	48 f7 d8             	neg    rax
  211ed3:	4d 85 c9             	test   r9,r9
  211ed6:	74 50                	je     211f28 <memmove+0x308>
  211ed8:	48 8d 4a e0          	lea    rcx,[rdx-0x20]
  211edc:	48 29 c1             	sub    rcx,rax
  211edf:	49 f7 d9             	neg    r9
  211ee2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211ee9:	1f 84 00 00 00 00 00 
  211ef0:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  211ef6:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  211efc:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  211f02:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  211f07:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
  211f0c:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  211f12:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  211f18:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  211f1e:	48 83 c1 80          	add    rcx,0xffffffffffffff80
  211f22:	49 83 c1 01          	add    r9,0x1
  211f26:	75 c8                	jne    211ef0 <memmove+0x2d0>
  211f28:	49 39 d0             	cmp    r8,rdx
        while (index != 0) {
  211f2b:	0f 84 10 02 00 00    	je     212141 <memmove+0x521>
  211f31:	4c 29 c2             	sub    rdx,r8
            index -= 1;
  211f34:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  211f38:	48 89 d1             	mov    rcx,rdx
  211f3b:	48 83 e1 07          	and    rcx,0x7
  211f3f:	74 22                	je     211f63 <memmove+0x343>
  211f41:	48 f7 d9             	neg    rcx
  211f44:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  211f4b:	00 00 00 00 00 
            dest.?[index] = src.?[index];
  211f50:	0f b6 44 16 ff       	movzx  eax,BYTE PTR [rsi+rdx*1-0x1]
  211f55:	88 44 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],al
            index -= 1;
  211f59:	48 8d 52 ff          	lea    rdx,[rdx-0x1]
        while (index != 0) {
  211f5d:	48 83 c1 01          	add    rcx,0x1
  211f61:	75 ed                	jne    211f50 <memmove+0x330>
            index -= 1;
  211f63:	49 83 f8 07          	cmp    r8,0x7
  211f67:	0f 82 d4 01 00 00    	jb     212141 <memmove+0x521>
        while (index != 0) {
  211f6d:	48 89 d0             	mov    rax,rdx
            dest.?[index] = src.?[index];
  211f70:	0f b6 4c 16 ff       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x1]
  211f75:	88 4c 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],cl
  211f79:	0f b6 4c 16 fe       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x2]
  211f7e:	88 4c 17 fe          	mov    BYTE PTR [rdi+rdx*1-0x2],cl
  211f82:	0f b6 4c 16 fd       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x3]
  211f87:	88 4c 17 fd          	mov    BYTE PTR [rdi+rdx*1-0x3],cl
  211f8b:	0f b6 4c 16 fc       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x4]
  211f90:	88 4c 17 fc          	mov    BYTE PTR [rdi+rdx*1-0x4],cl
  211f94:	0f b6 4c 16 fb       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x5]
  211f99:	88 4c 17 fb          	mov    BYTE PTR [rdi+rdx*1-0x5],cl
  211f9d:	0f b6 4c 16 fa       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x6]
  211fa2:	88 4c 17 fa          	mov    BYTE PTR [rdi+rdx*1-0x6],cl
  211fa6:	0f b6 4c 16 f9       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x7]
  211fab:	88 4c 17 f9          	mov    BYTE PTR [rdi+rdx*1-0x7],cl
  211faf:	0f b6 4c 16 f8       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x8]
  211fb4:	88 4c 17 f8          	mov    BYTE PTR [rdi+rdx*1-0x8],cl
        while (index != 0) {
  211fb8:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
  211fbc:	48 89 c2             	mov    rdx,rax
  211fbf:	75 af                	jne    211f70 <memmove+0x350>
  211fc1:	e9 7b 01 00 00       	jmp    212141 <memmove+0x521>
        while (index != n) : (index += 1) {
  211fc6:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  211fca:	49 29 c9             	sub    r9,rcx
  211fcd:	31 c9                	xor    ecx,ecx
  211fcf:	90                   	nop
            dest.?[index] = src.?[index];
  211fd0:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  211fd5:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  211fdb:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  211fe1:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  211fe7:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  211fec:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  211ff2:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  211ff8:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  211ffe:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  212005:	00 00 
  212007:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  21200e:	00 00 
  212010:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  212017:	00 00 
  212019:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  212020:	00 00 
  212022:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  212029:	00 00 
  21202b:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  212032:	00 00 
  212034:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  21203b:	00 00 
  21203d:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  212044:	00 00 
  212046:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  21204d:	00 00 
  21204f:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  212056:	00 00 
  212058:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  21205f:	00 00 
  212061:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  212068:	00 00 
  21206a:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  212071:	00 00 
  212073:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  21207a:	00 00 
  21207c:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  212083:	00 00 
  212085:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  21208c:	00 00 
  21208e:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  212095:	00 00 
  212097:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  21209e:	00 00 
  2120a0:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  2120a7:	00 00 
  2120a9:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  2120b0:	00 00 
  2120b2:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  2120b9:	00 00 
  2120bb:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  2120c2:	00 00 
  2120c4:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  2120cb:	00 00 
  2120cd:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  2120d4:	00 00 
        while (index != n) : (index += 1) {
  2120d6:	48 81 c1 00 02 00 00 	add    rcx,0x200
  2120dd:	49 83 c1 04          	add    r9,0x4
  2120e1:	0f 85 e9 fe ff ff    	jne    211fd0 <memmove+0x3b0>
  2120e7:	4d 85 c0             	test   r8,r8
  2120ea:	74 4c                	je     212138 <memmove+0x518>
  2120ec:	48 83 c1 60          	add    rcx,0x60
  2120f0:	49 f7 d8             	neg    r8
  2120f3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2120fa:	84 00 00 00 00 00 
            dest.?[index] = src.?[index];
  212100:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  212106:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  21210c:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  212112:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  212117:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  21211d:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  212123:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  212129:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
        while (index != n) : (index += 1) {
  21212e:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  212132:	49 83 c0 01          	add    r8,0x1
  212136:	75 c8                	jne    212100 <memmove+0x4e0>
  212138:	49 39 d2             	cmp    r10,rdx
  21213b:	0f 85 17 fb ff ff    	jne    211c58 <memmove+0x38>
        }
    }

    return dest;
  212141:	48 89 f8             	mov    rax,rdi
  212144:	c5 f8 77             	vzeroupper 
  212147:	c3                   	ret    
  212148:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21214f:	00 

0000000000212150 <clone>:

// TODO we should be able to put this directly in std/linux/x86_64.zig but
// it causes a segfault in release mode. this is a workaround of calling it
// across .o file boundaries. fix comptime @ptrCast of nakedcc functions.
nakedcc fn clone() void {
    asm volatile (
  212150:	31 c0                	xor    eax,eax
  212152:	b0 38                	mov    al,0x38
  212154:	49 89 fb             	mov    r11,rdi
  212157:	48 89 d7             	mov    rdi,rdx
  21215a:	4c 89 c2             	mov    rdx,r8
  21215d:	4d 89 c8             	mov    r8,r9
  212160:	4c 8b 54 24 08       	mov    r10,QWORD PTR [rsp+0x8]
  212165:	4d 89 d9             	mov    r9,r11
  212168:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  21216c:	48 83 ee 08          	sub    rsi,0x8
  212170:	48 89 0e             	mov    QWORD PTR [rsi],rcx
  212173:	0f 05                	syscall 
  212175:	85 c0                	test   eax,eax
  212177:	75 0f                	jne    212188 <clone+0x38>
  212179:	31 ed                	xor    ebp,ebp
  21217b:	5f                   	pop    rdi
  21217c:	41 ff d1             	call   r9
  21217f:	89 c7                	mov    edi,eax
  212181:	31 c0                	xor    eax,eax
  212183:	b0 3c                	mov    al,0x3c
  212185:	0f 05                	syscall 
  212187:	f4                   	hlt    
  212188:	c3                   	ret    
nakedcc fn clone() void {
  212189:	c3                   	ret    
  21218a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000212190 <fmodf>:
    );
}

const math = @import("../math/index.zig");

export fn fmodf(x: f32, y: f32) f32 {
  212190:	c5 f9 6f d0          	vmovdqa xmm2,xmm0
    const digits = if (T == f32) 23 else 52;
    const exp_bits = if (T == f32) 9 else 12;
    const bits_minus_1 = T.bit_count - 1;
    const mask = if (T == f32) 0xff else 0x7ff;
    var ux = @bitCast(uint, x);
    var uy = @bitCast(uint, y);
  212194:	c4 c1 79 7e c9       	vmovd  r9d,xmm1
    var ex = @intCast(i32, (ux >> digits) & mask);
    var ey = @intCast(i32, (uy >> digits) & mask);
    const sx = if (T == f32) @intCast(u32, ux & 0x80000000) else @intCast(i32, ux >> bits_minus_1);
    var i: uint = undefined;

    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  212199:	44 89 c8             	mov    eax,r9d
  21219c:	c5 fa 10 05 8c 04 ff 	vmovss xmm0,DWORD PTR [rip+0xffffffffffff048c]        # 202630 <__unnamed_53+0x20>
  2121a3:	ff 
  2121a4:	01 c0                	add    eax,eax
  2121a6:	0f 84 4a 01 00 00    	je     2122f6 <fmodf+0x166>

fn isNan(comptime T: type, bits: T) bool {
    if (T == u16) {
        return (bits & 0x7fff) > 0x7c00;
    } else if (T == u32) {
        return (bits & 0x7fffffff) > 0x7f800000;
  2121ac:	44 89 c9             	mov    ecx,r9d
  2121af:	81 e1 ff ff ff 7f    	and    ecx,0x7fffffff
  2121b5:	81 f9 00 00 80 7f    	cmp    ecx,0x7f800000
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  2121bb:	0f 87 35 01 00 00    	ja     2122f6 <fmodf+0x166>
  2121c1:	c4 c1 79 7e d0       	vmovd  r8d,xmm2
  2121c6:	ba 17 08 00 00       	mov    edx,0x817
  2121cb:	c4 c2 68 f7 c8       	bextr  ecx,r8d,edx
  2121d0:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  2121d6:	0f 84 1a 01 00 00    	je     2122f6 <fmodf+0x166>
    if (ux << 1 <= uy << 1) {
  2121dc:	43 8d 34 00          	lea    esi,[r8+r8*1]
  2121e0:	39 c6                	cmp    esi,eax
  2121e2:	76 2a                	jbe    21220e <fmodf+0x7e>
  2121e4:	c4 c2 68 f7 f9       	bextr  edi,r9d,edx
        ux &= @maxValue(uint) >> exp_bits;
  2121e9:	44 89 c0             	mov    eax,r8d
    if (ex == 0) {
  2121ec:	85 c9                	test   ecx,ecx
  2121ee:	74 2d                	je     21221d <fmodf+0x8d>
        ux &= @maxValue(uint) >> exp_bits;
  2121f0:	25 ff ff 7f 00       	and    eax,0x7fffff
        ux |= 1 << digits;
  2121f5:	0d 00 00 80 00       	or     eax,0x800000
    if (ey == 0) {
  2121fa:	85 ff                	test   edi,edi
  2121fc:	74 49                	je     212247 <fmodf+0xb7>
        uy &= @maxValue(uint) >> exp_bits;
  2121fe:	41 81 e1 ff ff 7f 00 	and    r9d,0x7fffff
        uy |= 1 << digits;
  212205:	41 81 c9 00 00 80 00 	or     r9d,0x800000
  21220c:	eb 77                	jmp    212285 <fmodf+0xf5>
  21220e:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  212212:	0f 84 de 00 00 00    	je     2122f6 <fmodf+0x166>
  212218:	c5 f9 6f c2          	vmovdqa xmm0,xmm2
    return generic_fmod(f32, x, y);
  21221c:	c3                   	ret    
  21221d:	31 c9                	xor    ecx,ecx
        i = ux << exp_bits;
  21221f:	c1 e0 09             	shl    eax,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  212222:	78 13                	js     212237 <fmodf+0xa7>
  212224:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21222b:	00 00 00 00 00 
            ex -= 1;
  212230:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  212233:	01 c0                	add    eax,eax
        while (i >> bits_minus_1 == 0) : (b: {
  212235:	79 f9                	jns    212230 <fmodf+0xa0>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  212237:	b8 01 00 00 00       	mov    eax,0x1
  21223c:	29 c8                	sub    eax,ecx
  21223e:	c4 c2 79 f7 c0       	shlx   eax,r8d,eax
    if (ey == 0) {
  212243:	85 ff                	test   edi,edi
  212245:	75 b7                	jne    2121fe <fmodf+0x6e>
        i = uy << exp_bits;
  212247:	44 89 ca             	mov    edx,r9d
  21224a:	31 ff                	xor    edi,edi
  21224c:	c1 e2 09             	shl    edx,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  21224f:	78 16                	js     212267 <fmodf+0xd7>
  212251:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212258:	0f 1f 84 00 00 00 00 
  21225f:	00 
            ey -= 1;
  212260:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  212263:	01 d2                	add    edx,edx
        while (i >> bits_minus_1 == 0) : (b: {
  212265:	79 f9                	jns    212260 <fmodf+0xd0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  212267:	ba 01 00 00 00       	mov    edx,0x1
  21226c:	29 fa                	sub    edx,edi
  21226e:	c4 42 69 f7 c9       	shlx   r9d,r9d,edx
  212273:	eb 10                	jmp    212285 <fmodf+0xf5>
  212275:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21227c:	00 00 00 00 
        ux <<= 1;
  212280:	01 c0                	add    eax,eax
    while (ex > ey) : (ex -= 1) {
  212282:	83 c1 ff             	add    ecx,0xffffffff
  212285:	89 c6                	mov    esi,eax
  212287:	44 29 ce             	sub    esi,r9d
  21228a:	0f 99 c2             	setns  dl
  21228d:	39 f9                	cmp    ecx,edi
  21228f:	7e 10                	jle    2122a1 <fmodf+0x111>
        if (i >> bits_minus_1 == 0) {
  212291:	f6 c2 01             	test   dl,0x1
  212294:	74 ea                	je     212280 <fmodf+0xf0>
  212296:	89 f0                	mov    eax,esi
            if (i == 0)
  212298:	85 f6                	test   esi,esi
  21229a:	75 e4                	jne    212280 <fmodf+0xf0>
  21229c:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
    return generic_fmod(f32, x, y);
  2122a0:	c3                   	ret    
    if (i >> bits_minus_1 == 0) {
  2122a1:	84 d2                	test   dl,dl
  2122a3:	74 06                	je     2122ab <fmodf+0x11b>
  2122a5:	89 f0                	mov    eax,esi
        if (i == 0)
  2122a7:	85 f6                	test   esi,esi
  2122a9:	74 4c                	je     2122f7 <fmodf+0x167>
    while (ux >> digits == 0) : (b: {
  2122ab:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  2122b0:	77 1a                	ja     2122cc <fmodf+0x13c>
  2122b2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2122b9:	1f 84 00 00 00 00 00 
        ux <<= 1;
  2122c0:	01 c0                	add    eax,eax
        ex -= 1;
  2122c2:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  2122c5:	3d 00 00 80 00       	cmp    eax,0x800000
  2122ca:	72 f4                	jb     2122c0 <fmodf+0x130>
  2122cc:	41 81 e0 00 00 00 80 	and    r8d,0x80000000
    if (ex > 0) {
  2122d3:	85 c9                	test   ecx,ecx
  2122d5:	7e 0c                	jle    2122e3 <fmodf+0x153>
        ux -%= 1 << digits;
  2122d7:	05 00 00 80 ff       	add    eax,0xff800000
        ux |= uint(@bitCast(u32, ex)) << digits;
  2122dc:	c1 e1 17             	shl    ecx,0x17
  2122df:	09 c1                	or     ecx,eax
  2122e1:	eb 0c                	jmp    2122ef <fmodf+0x15f>
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  2122e3:	ba 01 00 00 00       	mov    edx,0x1
  2122e8:	29 ca                	sub    edx,ecx
  2122ea:	c4 e2 6b f7 c8       	shrx   ecx,eax,edx
        ux |= sx;
  2122ef:	44 09 c1             	or     ecx,r8d
    return @bitCast(T, ux);
  2122f2:	c5 f9 6e c1          	vmovd  xmm0,ecx
    return generic_fmod(f32, x, y);
  2122f6:	c3                   	ret    
  2122f7:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2122fb:	c3                   	ret    
  2122fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000212300 <fmod>:
export fn fmod(x: f64, y: f64) f64 {
  212300:	c5 f9 6f d0          	vmovdqa xmm2,xmm0
    var uy = @bitCast(uint, y);
  212304:	c4 c1 f9 7e cb       	vmovq  r11,xmm1
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  212309:	4c 89 d8             	mov    rax,r11
  21230c:	c5 fb 10 05 dc de fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffededc]        # 2001f0 <app_mask-0x30>
  212313:	ff 
  212314:	48 01 c0             	add    rax,rax
  212317:	0f 84 6f 01 00 00    	je     21248c <fmod+0x18c>
  21231d:	49 b9 ff ff ff ff ff 	movabs r9,0x7fffffffffffffff
  212324:	ff ff 7f 
    } else if (T == u64) {
        return (bits & (@maxValue(u64) >> 1)) > (u64(0x7ff) << 52);
  212327:	4c 89 d9             	mov    rcx,r11
  21232a:	4c 21 c9             	and    rcx,r9
  21232d:	48 ba 00 00 00 00 00 	movabs rdx,0x7ff0000000000000
  212334:	00 f0 7f 
  212337:	48 39 d1             	cmp    rcx,rdx
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  21233a:	0f 87 4c 01 00 00    	ja     21248c <fmod+0x18c>
  212340:	c4 c1 f9 7e d2       	vmovq  r10,xmm2
  212345:	4c 89 d1             	mov    rcx,r10
  212348:	48 c1 e9 34          	shr    rcx,0x34
  21234c:	81 e1 ff 07 00 00    	and    ecx,0x7ff
  212352:	81 f9 ff 07 00 00    	cmp    ecx,0x7ff
  212358:	0f 84 2e 01 00 00    	je     21248c <fmod+0x18c>
    if (ux << 1 <= uy << 1) {
  21235e:	4b 8d 14 12          	lea    rdx,[r10+r10*1]
  212362:	48 39 c2             	cmp    rdx,rax
  212365:	76 35                	jbe    21239c <fmod+0x9c>
  212367:	4c 89 df             	mov    rdi,r11
  21236a:	48 c1 ef 34          	shr    rdi,0x34
  21236e:	81 e7 ff 07 00 00    	and    edi,0x7ff
  212374:	49 b8 00 00 00 00 00 	movabs r8,0x10000000000000
  21237b:	00 10 00 
    if (ex == 0) {
  21237e:	85 c9                	test   ecx,ecx
  212380:	74 29                	je     2123ab <fmod+0xab>
        ux &= @maxValue(uint) >> exp_bits;
  212382:	49 8d 40 ff          	lea    rax,[r8-0x1]
  212386:	4c 21 d0             	and    rax,r10
        ux |= 1 << digits;
  212389:	4c 09 c0             	or     rax,r8
    if (ey == 0) {
  21238c:	85 ff                	test   edi,edi
  21238e:	74 48                	je     2123d8 <fmod+0xd8>
        uy &= @maxValue(uint) >> exp_bits;
  212390:	49 8d 50 ff          	lea    rdx,[r8-0x1]
  212394:	49 21 d3             	and    r11,rdx
        uy |= 1 << digits;
  212397:	4d 09 c3             	or     r11,r8
  21239a:	eb 7a                	jmp    212416 <fmod+0x116>
  21239c:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2123a0:	0f 84 e6 00 00 00    	je     21248c <fmod+0x18c>
  2123a6:	c5 f9 6f c2          	vmovdqa xmm0,xmm2
    return generic_fmod(f64, x, y);
  2123aa:	c3                   	ret    
        i = ux << exp_bits;
  2123ab:	4c 89 d0             	mov    rax,r10
  2123ae:	31 c9                	xor    ecx,ecx
  2123b0:	48 c1 e0 0c          	shl    rax,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  2123b4:	78 12                	js     2123c8 <fmod+0xc8>
  2123b6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2123bd:	00 00 00 
            ex -= 1;
  2123c0:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  2123c3:	48 01 c0             	add    rax,rax
        while (i >> bits_minus_1 == 0) : (b: {
  2123c6:	79 f8                	jns    2123c0 <fmod+0xc0>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  2123c8:	b8 01 00 00 00       	mov    eax,0x1
  2123cd:	29 c8                	sub    eax,ecx
  2123cf:	c4 c2 f9 f7 c2       	shlx   rax,r10,rax
    if (ey == 0) {
  2123d4:	85 ff                	test   edi,edi
  2123d6:	75 b8                	jne    212390 <fmod+0x90>
        i = uy << exp_bits;
  2123d8:	4c 89 da             	mov    rdx,r11
  2123db:	31 ff                	xor    edi,edi
  2123dd:	48 c1 e2 0c          	shl    rdx,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  2123e1:	78 15                	js     2123f8 <fmod+0xf8>
  2123e3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2123ea:	84 00 00 00 00 00 
            ey -= 1;
  2123f0:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  2123f3:	48 01 d2             	add    rdx,rdx
        while (i >> bits_minus_1 == 0) : (b: {
  2123f6:	79 f8                	jns    2123f0 <fmod+0xf0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  2123f8:	ba 01 00 00 00       	mov    edx,0x1
  2123fd:	29 fa                	sub    edx,edi
  2123ff:	c4 42 e9 f7 db       	shlx   r11,r11,rdx
  212404:	eb 10                	jmp    212416 <fmod+0x116>
  212406:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21240d:	00 00 00 
        ux <<= 1;
  212410:	48 01 c0             	add    rax,rax
    while (ex > ey) : (ex -= 1) {
  212413:	83 c1 ff             	add    ecx,0xffffffff
  212416:	48 89 c6             	mov    rsi,rax
  212419:	4c 29 de             	sub    rsi,r11
  21241c:	0f 99 c2             	setns  dl
  21241f:	39 f9                	cmp    ecx,edi
  212421:	7e 12                	jle    212435 <fmod+0x135>
        if (i >> bits_minus_1 == 0) {
  212423:	f6 c2 01             	test   dl,0x1
  212426:	74 e8                	je     212410 <fmod+0x110>
  212428:	48 89 f0             	mov    rax,rsi
            if (i == 0)
  21242b:	48 85 f6             	test   rsi,rsi
  21242e:	75 e0                	jne    212410 <fmod+0x110>
  212430:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
    return generic_fmod(f64, x, y);
  212434:	c3                   	ret    
    if (i >> bits_minus_1 == 0) {
  212435:	84 d2                	test   dl,dl
  212437:	74 08                	je     212441 <fmod+0x141>
  212439:	48 89 f0             	mov    rax,rsi
        if (i == 0)
  21243c:	48 85 f6             	test   rsi,rsi
  21243f:	74 4c                	je     21248d <fmod+0x18d>
  212441:	49 83 c1 01          	add    r9,0x1
    while (ux >> digits == 0) : (b: {
  212445:	4c 39 c0             	cmp    rax,r8
  212448:	73 11                	jae    21245b <fmod+0x15b>
  21244a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        ux <<= 1;
  212450:	48 01 c0             	add    rax,rax
        ex -= 1;
  212453:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  212456:	4c 39 c0             	cmp    rax,r8
  212459:	72 f5                	jb     212450 <fmod+0x150>
  21245b:	4d 21 ca             	and    r10,r9
    if (ex > 0) {
  21245e:	85 c9                	test   ecx,ecx
  212460:	7e 16                	jle    212478 <fmod+0x178>
        ux -%= 1 << digits;
  212462:	48 ba 00 00 00 00 00 	movabs rdx,0xfff0000000000000
  212469:	00 f0 ff 
  21246c:	48 01 d0             	add    rax,rdx
        ux |= uint(@bitCast(u32, ex)) << digits;
  21246f:	48 c1 e1 34          	shl    rcx,0x34
  212473:	48 09 c1             	or     rcx,rax
  212476:	eb 0c                	jmp    212484 <fmod+0x184>
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  212478:	ba 01 00 00 00       	mov    edx,0x1
  21247d:	29 ca                	sub    edx,ecx
  21247f:	c4 e2 eb f7 c8       	shrx   rcx,rax,rdx
        ux |= @intCast(uint, sx) << bits_minus_1;
  212484:	4c 09 d1             	or     rcx,r10
    return @bitCast(T, ux);
  212487:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    return generic_fmod(f64, x, y);
  21248c:	c3                   	ret    
  21248d:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  212491:	c3                   	ret    
  212492:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212499:	1f 84 00 00 00 00 00 

00000000002124a0 <floorf>:
    var u = @bitCast(u32, x);
    const e = @intCast(i32, (u >> 23) & 0xFF) - 0x7F;
    var m: u32 = undefined;

    // TODO: Shouldn't need this explicit check.
    if (x == 0.0) {
  2124a0:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  2124a4:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  2124a8:	75 02                	jne    2124ac <floorf+0xc>
  2124aa:	7b 57                	jnp    212503 <floorf+0x63>
  2124ac:	c5 f9 7e c1          	vmovd  ecx,xmm0
  2124b0:	89 c8                	mov    eax,ecx
  2124b2:	c1 e8 17             	shr    eax,0x17
  2124b5:	0f b6 d0             	movzx  edx,al
  2124b8:	81 fa 95 00 00 00    	cmp    edx,0x95
  2124be:	77 43                	ja     212503 <floorf+0x63>

    if (e >= 23) {
        return x;
    }

    if (e >= 0) {
  2124c0:	83 fa 7f             	cmp    edx,0x7f
  2124c3:	72 2e                	jb     2124f3 <floorf+0x53>
  2124c5:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  2124c8:	83 e0 1f             	and    eax,0x1f
  2124cb:	ba ff ff 7f 00       	mov    edx,0x7fffff
  2124d0:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  2124d5:	85 ca                	test   edx,ecx
  2124d7:	74 2a                	je     212503 <floorf+0x63>
            return x;
        }
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 != 0) {
  2124d9:	89 ce                	mov    esi,ecx
  2124db:	c1 fe 1f             	sar    esi,0x1f
  2124de:	21 d6                	and    esi,edx
  2124e0:	01 ce                	add    esi,ecx
            u += m;
        }
        return @bitCast(f32, u & ~m);
  2124e2:	b9 00 00 80 ff       	mov    ecx,0xff800000
  2124e7:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  2124ec:	21 f0                	and    eax,esi
  2124ee:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.floor(x);
  2124f2:	c3                   	ret    
    } else {
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 == 0) {
  2124f3:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2124f7:	85 c9                	test   ecx,ecx
  2124f9:	79 08                	jns    212503 <floorf+0x63>
  2124fb:	c5 f9 6e 05 31 01 ff 	vmovd  xmm0,DWORD PTR [rip+0xffffffffffff0131]        # 202634 <__unnamed_53+0x24>
  212502:	ff 
  212503:	c3                   	ret    
  212504:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21250b:	00 00 00 00 00 

0000000000212510 <ceilf>:
    var u = @bitCast(u32, x);
    var e = @intCast(i32, (u >> 23) & 0xFF) - 0x7F;
    var m: u32 = undefined;

    // TODO: Shouldn't need this explicit check.
    if (x == 0.0) {
  212510:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  212514:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  212518:	75 02                	jne    21251c <ceilf+0xc>
  21251a:	7b 5a                	jnp    212576 <ceilf+0x66>
  21251c:	c5 f9 7e c1          	vmovd  ecx,xmm0
  212520:	89 c8                	mov    eax,ecx
  212522:	c1 e8 17             	shr    eax,0x17
  212525:	0f b6 d0             	movzx  edx,al
  212528:	81 fa 95 00 00 00    	cmp    edx,0x95
  21252e:	77 46                	ja     212576 <ceilf+0x66>
        return x;
    }

    if (e >= 23) {
        return x;
    } else if (e >= 0) {
  212530:	83 fa 7f             	cmp    edx,0x7f
  212533:	72 31                	jb     212566 <ceilf+0x56>
  212535:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  212538:	83 e0 1f             	and    eax,0x1f
  21253b:	ba ff ff 7f 00       	mov    edx,0x7fffff
  212540:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  212545:	85 ca                	test   edx,ecx
  212547:	74 2d                	je     212576 <ceilf+0x66>
            return x;
        }
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 == 0) {
  212549:	89 ce                	mov    esi,ecx
  21254b:	c1 fe 1f             	sar    esi,0x1f
  21254e:	c4 e2 48 f2 d2       	andn   edx,esi,edx
  212553:	01 ca                	add    edx,ecx
            u += m;
        }
        u &= ~m;
  212555:	b9 00 00 80 ff       	mov    ecx,0xff800000
  21255a:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  21255f:	21 d0                	and    eax,edx
        return @bitCast(f32, u);
  212561:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.ceil(x);
  212565:	c3                   	ret    
    } else {
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 != 0) {
  212566:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21256a:	85 c9                	test   ecx,ecx
  21256c:	78 08                	js     212576 <ceilf+0x66>
  21256e:	c5 f9 6e 05 ba 00 ff 	vmovd  xmm0,DWORD PTR [rip+0xffffffffffff00ba]        # 202630 <__unnamed_53+0x20>
  212575:	ff 
  212576:	c3                   	ret    
  212577:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21257e:	00 00 

0000000000212580 <floor>:
fn floor64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  212580:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  212584:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  212588:	75 02                	jne    21258c <floor+0xc>
  21258a:	7b 54                	jnp    2125e0 <floor+0x60>
  21258c:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  212591:	b9 34 0b 00 00       	mov    ecx,0xb34
  212596:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  21259b:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  2125a2:	77 3c                	ja     2125e0 <floor+0x60>
        return x;
    }

    if (u >> 63 != 0) {
        @setFloatMode(this, builtin.FloatMode.Strict);
        y = x - math.f64_toint + math.f64_toint - x;
  2125a4:	c5 fb 10 0d 4c dc fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffedc4c]        # 2001f8 <app_mask-0x28>
  2125ab:	ff 
  2125ac:	c5 fb 10 15 64 dc fe 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffedc64]        # 200218 <app_mask-0x8>
  2125b3:	ff 
    if (u >> 63 != 0) {
  2125b4:	48 85 c0             	test   rax,rax
  2125b7:	78 28                	js     2125e1 <floor+0x61>
  2125b9:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  2125bd:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    } else {
        @setFloatMode(this, builtin.FloatMode.Strict);
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  2125c1:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  2125c8:	76 28                	jbe    2125f2 <floor+0x72>
  2125ca:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
        if (u >> 63 != 0) {
            return -1.0;
        } else {
            return 0.0;
        }
    } else if (y > 0) {
  2125ce:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  2125d2:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  2125d6:	76 24                	jbe    2125fc <floor+0x7c>
        return x + y - 1;
  2125d8:	c5 f3 58 05 20 dc fe 	vaddsd xmm0,xmm1,QWORD PTR [rip+0xfffffffffffedc20]        # 200200 <app_mask-0x20>
  2125df:	ff 
    return math.floor(x);
  2125e0:	c3                   	ret    
  2125e1:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  2125e5:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  2125e9:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  2125f0:	77 d8                	ja     2125ca <floor+0x4a>
    if (u >> 63 != 0) {
  2125f2:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  2125f5:	78 0a                	js     212601 <floor+0x81>
  2125f7:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  2125fb:	c3                   	ret    
  2125fc:	c5 f9 28 c1          	vmovapd xmm0,xmm1
  212600:	c3                   	ret    
  212601:	c5 fb 10 05 f7 db fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffedbf7]        # 200200 <app_mask-0x20>
  212608:	ff 
  212609:	c3                   	ret    
  21260a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000212610 <ceil>:
fn ceil64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  212610:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  212614:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  212618:	75 02                	jne    21261c <ceil+0xc>
  21261a:	7b 79                	jnp    212695 <ceil+0x85>
  21261c:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  212621:	b9 34 0b 00 00       	mov    ecx,0xb34
  212626:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  21262b:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  212632:	77 61                	ja     212695 <ceil+0x85>
        return x;
    }

    if (u >> 63 != 0) {
        @setFloatMode(this, builtin.FloatMode.Strict);
        y = x - math.f64_toint + math.f64_toint - x;
  212634:	c5 fb 10 0d bc db fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffedbbc]        # 2001f8 <app_mask-0x28>
  21263b:	ff 
  21263c:	c5 fb 10 15 d4 db fe 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffedbd4]        # 200218 <app_mask-0x8>
  212643:	ff 
    if (u >> 63 != 0) {
  212644:	48 85 c0             	test   rax,rax
  212647:	78 29                	js     212672 <ceil+0x62>
  212649:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  21264d:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    } else {
        @setFloatMode(this, builtin.FloatMode.Strict);
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  212651:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  212658:	76 29                	jbe    212683 <ceil+0x73>
  21265a:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
        if (u >> 63 != 0) {
            return -0.0;
        } else {
            return 1.0;
        }
    } else if (y < 0) {
  21265e:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  212662:	c5 f9 2e d0          	vucomisd xmm2,xmm0
  212666:	76 2e                	jbe    212696 <ceil+0x86>
        return x + y + 1;
  212668:	c5 f3 58 05 80 db fe 	vaddsd xmm0,xmm1,QWORD PTR [rip+0xfffffffffffedb80]        # 2001f0 <app_mask-0x30>
  21266f:	ff 
  212670:	eb 23                	jmp    212695 <ceil+0x85>
  212672:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  212676:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  21267a:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  212681:	77 d7                	ja     21265a <ceil+0x4a>
        if (u >> 63 != 0) {
  212683:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
    if (u >> 63 != 0) {
  212687:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  21268a:	78 09                	js     212695 <ceil+0x85>
  21268c:	c5 fb 10 05 5c db fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffedb5c]        # 2001f0 <app_mask-0x30>
  212693:	ff 
    return math.ceil(x);
  212694:	c3                   	ret    
  212695:	c3                   	ret    
  212696:	c5 f9 28 c1          	vmovapd xmm0,xmm1
  21269a:	c3                   	ret    
  21269b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000002126a0 <sqrt>:
// behaviour. Most intermediate i32 values are changed to u32 where appropriate but there are
// potentially some edge cases remaining that are not handled in the same way.
export fn sqrt(x: f64) f64 {
    const tiny: f64 = 1.0e-300;
    const sign: u32 = 0x80000000;
    const u = @bitCast(u64, x);
  2126a0:	c4 e1 f9 7e c0       	vmovq  rax,xmm0

    var ix0 = @intCast(u32, u >> 32);
  2126a5:	48 89 c7             	mov    rdi,rax
  2126a8:	48 c1 ef 20          	shr    rdi,0x20
    var ix1 = @intCast(u32, u & 0xFFFFFFFF);

    // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = nan
    if (ix0 & 0x7FF00000 == 0x7FF00000) {
  2126ac:	b9 00 00 f0 7f       	mov    ecx,0x7ff00000
  2126b1:	c4 e2 40 f2 c9       	andn   ecx,edi,ecx
  2126b6:	75 06                	jne    2126be <sqrt+0x1e>
        return x * x + x;
  2126b8:	c4 e2 f9 a9 c0       	vfmadd213sd xmm0,xmm0,xmm0
  2126bd:	c3                   	ret    
    }

    // sqrt(+-0) = +-0
    if (x == 0.0) {
  2126be:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  2126c2:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  2126c6:	75 03                	jne    2126cb <sqrt+0x2b>
  2126c8:	7a 01                	jp     2126cb <sqrt+0x2b>
        return x;
  2126ca:	c3                   	ret    
    }
    // sqrt(-ve) = snan
    if (ix0 & sign != 0) {
  2126cb:	85 ff                	test   edi,edi
  2126cd:	0f 88 d2 00 00 00    	js     2127a5 <sqrt+0x105>
        return math.snan(f64);
    }

    // normalize x
    var m = @intCast(i32, ix0 >> 20);
  2126d3:	49 89 c0             	mov    r8,rax
  2126d6:	49 c1 e8 34          	shr    r8,0x34
    if (m == 0) {
  2126da:	45 85 c0             	test   r8d,r8d
  2126dd:	75 5e                	jne    21273d <sqrt+0x9d>
  2126df:	31 d2                	xor    edx,edx
  2126e1:	31 c9                	xor    ecx,ecx
        // subnormal
        while (ix0 == 0) {
  2126e3:	85 ff                	test   edi,edi
  2126e5:	75 18                	jne    2126ff <sqrt+0x5f>
  2126e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2126ee:	00 00 
            m -= 21;
  2126f0:	83 c1 eb             	add    ecx,0xffffffeb
            ix0 |= ix1 >> 11;
  2126f3:	89 c7                	mov    edi,eax
  2126f5:	c1 ef 0b             	shr    edi,0xb
            ix1 <<= 21;
  2126f8:	c1 e0 15             	shl    eax,0x15
        while (ix0 == 0) {
  2126fb:	85 ff                	test   edi,edi
  2126fd:	74 f1                	je     2126f0 <sqrt+0x50>
  2126ff:	31 f6                	xor    esi,esi
        }

        // subnormal
        var i: u32 = 0;
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  212701:	0f ba e7 14          	bt     edi,0x14
  212705:	72 20                	jb     212727 <sqrt+0x87>
  212707:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21270e:	00 00 
  212710:	89 fa                	mov    edx,edi
            ix0 <<= 1;
  212712:	8d 3c 12             	lea    edi,[rdx+rdx*1]
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  212715:	83 c6 ff             	add    esi,0xffffffff
  212718:	f7 c2 00 00 08 00    	test   edx,0x80000
  21271e:	74 f0                	je     212710 <sqrt+0x70>
  212720:	89 f2                	mov    edx,esi
  212722:	f7 da                	neg    edx
  212724:	83 e2 1f             	and    edx,0x1f
        }
        m -= @intCast(i32, i) - 1;
  212727:	44 8d 04 31          	lea    r8d,[rcx+rsi*1]
  21272b:	41 83 c0 01          	add    r8d,0x1
        ix0 |= ix1 >> @intCast(u5, 32 - i);
  21272f:	c4 e2 4b f7 c8       	shrx   ecx,eax,esi
  212734:	09 f9                	or     ecx,edi
        ix1 <<= @intCast(u5, i);
  212736:	c4 e2 69 f7 c0       	shlx   eax,eax,edx
  21273b:	89 cf                	mov    edi,ecx
    }

    // unbias exponent
    m -= 1023;
  21273d:	41 81 c0 01 fc ff ff 	add    r8d,0xfffffc01
    ix0 = (ix0 & 0x000FFFFF) | 0x00100000;
  212744:	81 e7 ff ff 0f 00    	and    edi,0xfffff
  21274a:	81 cf 00 00 10 00    	or     edi,0x100000
    if (m & 1 != 0) {
  212750:	41 f6 c0 01          	test   r8b,0x1
  212754:	74 06                	je     21275c <sqrt+0xbc>
        ix0 += ix0 + (ix1 >> 31);
  212756:	0f a4 c7 01          	shld   edi,eax,0x1
        ix1 = ix1 +% ix1;
  21275a:	01 c0                	add    eax,eax
    }
    m >>= 1;

    // sqrt(x) bit by bit
    ix0 += ix0 + (ix1 >> 31);
  21275c:	0f a4 c7 01          	shld   edi,eax,0x1
    var t: u32 = undefined;
    var t1: u32 = undefined;

    while (r != 0) {
        t = s0 +% r;
        if (t <= ix0) {
  212760:	31 f6                	xor    esi,esi
  212762:	81 ff ff ff 1f 00    	cmp    edi,0x1fffff
  212768:	40 0f 97 c6          	seta   sil
  21276c:	41 89 f1             	mov    r9d,esi
  21276f:	41 c1 e1 15          	shl    r9d,0x15
  212773:	c1 e6 16             	shl    esi,0x16
            s0 = t + r;
            ix0 -= t;
            q += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212776:	8d 0c 3f             	lea    ecx,[rdi+rdi*1]
        if (t <= ix0) {
  212779:	81 ff 00 00 20 00    	cmp    edi,0x200000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21277f:	8d bc 3f 00 00 c0 ff 	lea    edi,[rdi+rdi*1-0x400000]
  212786:	0f 42 f9             	cmovb  edi,ecx
  212789:	b9 1e 01 00 00       	mov    ecx,0x11e
  21278e:	c4 e2 70 f7 d0       	bextr  edx,eax,ecx
  212793:	09 fa                	or     edx,edi
        t = s0 +% r;
  212795:	8d be 00 00 10 00    	lea    edi,[rsi+0x100000]
        if (t <= ix0) {
  21279b:	89 d1                	mov    ecx,edx
  21279d:	29 f9                	sub    ecx,edi
  21279f:	73 0d                	jae    2127ae <sqrt+0x10e>
  2127a1:	89 d1                	mov    ecx,edx
  2127a3:	eb 18                	jmp    2127bd <sqrt+0x11d>
  2127a5:	c5 fb 10 05 83 da fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffeda83]        # 200230 <app_mask+0x10>
  2127ac:	ff 
        return x;
  2127ad:	c3                   	ret    
            s0 = t + r;
  2127ae:	81 c7 00 00 10 00    	add    edi,0x100000
            q += r;
  2127b4:	41 81 c9 00 00 10 00 	or     r9d,0x100000
  2127bb:	89 fe                	mov    esi,edi
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2127bd:	ba 1d 01 00 00       	mov    edx,0x11d
  2127c2:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2127c7:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2127ca:	8d be 00 00 08 00    	lea    edi,[rsi+0x80000]
        if (t <= ix0) {
  2127d0:	89 d1                	mov    ecx,edx
  2127d2:	29 f9                	sub    ecx,edi
  2127d4:	73 04                	jae    2127da <sqrt+0x13a>
  2127d6:	89 d1                	mov    ecx,edx
  2127d8:	eb 0d                	jmp    2127e7 <sqrt+0x147>
            s0 = t + r;
  2127da:	81 c6 00 00 10 00    	add    esi,0x100000
            q += r;
  2127e0:	41 81 c1 00 00 08 00 	add    r9d,0x80000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2127e7:	ba 1c 01 00 00       	mov    edx,0x11c
  2127ec:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2127f1:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2127f4:	8d be 00 00 04 00    	lea    edi,[rsi+0x40000]
        if (t <= ix0) {
  2127fa:	89 d1                	mov    ecx,edx
  2127fc:	29 f9                	sub    ecx,edi
  2127fe:	73 04                	jae    212804 <sqrt+0x164>
  212800:	89 d1                	mov    ecx,edx
  212802:	eb 0d                	jmp    212811 <sqrt+0x171>
            s0 = t + r;
  212804:	81 c6 00 00 08 00    	add    esi,0x80000
            q += r;
  21280a:	41 81 c1 00 00 04 00 	add    r9d,0x40000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212811:	ba 1b 01 00 00       	mov    edx,0x11b
  212816:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21281b:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21281e:	8d be 00 00 02 00    	lea    edi,[rsi+0x20000]
        if (t <= ix0) {
  212824:	89 d1                	mov    ecx,edx
  212826:	29 f9                	sub    ecx,edi
  212828:	73 04                	jae    21282e <sqrt+0x18e>
  21282a:	89 d1                	mov    ecx,edx
  21282c:	eb 0d                	jmp    21283b <sqrt+0x19b>
            s0 = t + r;
  21282e:	81 c6 00 00 04 00    	add    esi,0x40000
            q += r;
  212834:	41 81 c1 00 00 02 00 	add    r9d,0x20000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21283b:	ba 1a 01 00 00       	mov    edx,0x11a
  212840:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  212845:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  212848:	8d be 00 00 01 00    	lea    edi,[rsi+0x10000]
        if (t <= ix0) {
  21284e:	89 d1                	mov    ecx,edx
  212850:	29 f9                	sub    ecx,edi
  212852:	73 04                	jae    212858 <sqrt+0x1b8>
  212854:	89 d1                	mov    ecx,edx
  212856:	eb 0d                	jmp    212865 <sqrt+0x1c5>
            s0 = t + r;
  212858:	81 c6 00 00 02 00    	add    esi,0x20000
            q += r;
  21285e:	41 81 c1 00 00 01 00 	add    r9d,0x10000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212865:	ba 19 01 00 00       	mov    edx,0x119
  21286a:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21286f:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  212872:	8d be 00 80 00 00    	lea    edi,[rsi+0x8000]
        if (t <= ix0) {
  212878:	89 d1                	mov    ecx,edx
  21287a:	29 f9                	sub    ecx,edi
  21287c:	73 04                	jae    212882 <sqrt+0x1e2>
  21287e:	89 d1                	mov    ecx,edx
  212880:	eb 0d                	jmp    21288f <sqrt+0x1ef>
            s0 = t + r;
  212882:	81 c6 00 00 01 00    	add    esi,0x10000
            q += r;
  212888:	41 81 c1 00 80 00 00 	add    r9d,0x8000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21288f:	ba 18 01 00 00       	mov    edx,0x118
  212894:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  212899:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21289c:	8d be 00 40 00 00    	lea    edi,[rsi+0x4000]
        if (t <= ix0) {
  2128a2:	89 d1                	mov    ecx,edx
  2128a4:	29 f9                	sub    ecx,edi
  2128a6:	73 04                	jae    2128ac <sqrt+0x20c>
  2128a8:	89 d1                	mov    ecx,edx
  2128aa:	eb 0d                	jmp    2128b9 <sqrt+0x219>
            s0 = t + r;
  2128ac:	81 c6 00 80 00 00    	add    esi,0x8000
            q += r;
  2128b2:	41 81 c1 00 40 00 00 	add    r9d,0x4000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2128b9:	ba 17 01 00 00       	mov    edx,0x117
  2128be:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2128c3:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2128c6:	8d be 00 20 00 00    	lea    edi,[rsi+0x2000]
        if (t <= ix0) {
  2128cc:	89 d1                	mov    ecx,edx
  2128ce:	29 f9                	sub    ecx,edi
  2128d0:	73 04                	jae    2128d6 <sqrt+0x236>
  2128d2:	89 d1                	mov    ecx,edx
  2128d4:	eb 0d                	jmp    2128e3 <sqrt+0x243>
            s0 = t + r;
  2128d6:	81 c6 00 40 00 00    	add    esi,0x4000
            q += r;
  2128dc:	41 81 c1 00 20 00 00 	add    r9d,0x2000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2128e3:	ba 16 01 00 00       	mov    edx,0x116
  2128e8:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2128ed:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2128f0:	8d be 00 10 00 00    	lea    edi,[rsi+0x1000]
        if (t <= ix0) {
  2128f6:	89 d1                	mov    ecx,edx
  2128f8:	29 f9                	sub    ecx,edi
  2128fa:	73 04                	jae    212900 <sqrt+0x260>
  2128fc:	89 d1                	mov    ecx,edx
  2128fe:	eb 0d                	jmp    21290d <sqrt+0x26d>
            s0 = t + r;
  212900:	81 c6 00 20 00 00    	add    esi,0x2000
            q += r;
  212906:	41 81 c1 00 10 00 00 	add    r9d,0x1000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21290d:	ba 15 01 00 00       	mov    edx,0x115
  212912:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  212917:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21291a:	8d be 00 08 00 00    	lea    edi,[rsi+0x800]
        if (t <= ix0) {
  212920:	89 d1                	mov    ecx,edx
  212922:	29 f9                	sub    ecx,edi
  212924:	73 04                	jae    21292a <sqrt+0x28a>
  212926:	89 d1                	mov    ecx,edx
  212928:	eb 0d                	jmp    212937 <sqrt+0x297>
            s0 = t + r;
  21292a:	81 c6 00 10 00 00    	add    esi,0x1000
            q += r;
  212930:	41 81 c1 00 08 00 00 	add    r9d,0x800
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212937:	ba 14 01 00 00       	mov    edx,0x114
  21293c:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  212941:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  212944:	8d be 00 04 00 00    	lea    edi,[rsi+0x400]
        if (t <= ix0) {
  21294a:	89 d1                	mov    ecx,edx
  21294c:	29 f9                	sub    ecx,edi
  21294e:	73 04                	jae    212954 <sqrt+0x2b4>
  212950:	89 d1                	mov    ecx,edx
  212952:	eb 0d                	jmp    212961 <sqrt+0x2c1>
            s0 = t + r;
  212954:	81 c6 00 08 00 00    	add    esi,0x800
            q += r;
  21295a:	41 81 c1 00 04 00 00 	add    r9d,0x400
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212961:	ba 13 01 00 00       	mov    edx,0x113
  212966:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21296b:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21296e:	8d be 00 02 00 00    	lea    edi,[rsi+0x200]
        if (t <= ix0) {
  212974:	89 d1                	mov    ecx,edx
  212976:	29 f9                	sub    ecx,edi
  212978:	73 04                	jae    21297e <sqrt+0x2de>
  21297a:	89 d1                	mov    ecx,edx
  21297c:	eb 0d                	jmp    21298b <sqrt+0x2eb>
            s0 = t + r;
  21297e:	81 c6 00 04 00 00    	add    esi,0x400
            q += r;
  212984:	41 81 c1 00 02 00 00 	add    r9d,0x200
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21298b:	ba 12 01 00 00       	mov    edx,0x112
  212990:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  212995:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  212998:	8d be 00 01 00 00    	lea    edi,[rsi+0x100]
        if (t <= ix0) {
  21299e:	89 d1                	mov    ecx,edx
  2129a0:	29 f9                	sub    ecx,edi
  2129a2:	73 04                	jae    2129a8 <sqrt+0x308>
  2129a4:	89 d1                	mov    ecx,edx
  2129a6:	eb 0d                	jmp    2129b5 <sqrt+0x315>
            s0 = t + r;
  2129a8:	81 c6 00 02 00 00    	add    esi,0x200
            q += r;
  2129ae:	41 81 c1 00 01 00 00 	add    r9d,0x100
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2129b5:	ba 11 01 00 00       	mov    edx,0x111
  2129ba:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2129bf:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2129c2:	89 f7                	mov    edi,esi
  2129c4:	83 ef 80             	sub    edi,0xffffff80
        if (t <= ix0) {
  2129c7:	89 d1                	mov    ecx,edx
  2129c9:	29 f9                	sub    ecx,edi
  2129cb:	73 04                	jae    2129d1 <sqrt+0x331>
  2129cd:	89 d1                	mov    ecx,edx
  2129cf:	eb 0a                	jmp    2129db <sqrt+0x33b>
            s0 = t + r;
  2129d1:	81 c6 00 01 00 00    	add    esi,0x100
            q += r;
  2129d7:	41 83 e9 80          	sub    r9d,0xffffff80
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2129db:	ba 10 01 00 00       	mov    edx,0x110
  2129e0:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  2129e5:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  2129e8:	8d 7e 40             	lea    edi,[rsi+0x40]
        if (t <= ix0) {
  2129eb:	89 d1                	mov    ecx,edx
  2129ed:	29 f9                	sub    ecx,edi
  2129ef:	73 04                	jae    2129f5 <sqrt+0x355>
  2129f1:	89 d1                	mov    ecx,edx
  2129f3:	eb 07                	jmp    2129fc <sqrt+0x35c>
            s0 = t + r;
  2129f5:	83 ee 80             	sub    esi,0xffffff80
            q += r;
  2129f8:	41 83 c1 40          	add    r9d,0x40
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  2129fc:	ba 0f 01 00 00       	mov    edx,0x10f
  212a01:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  212a06:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  212a09:	8d 7e 20             	lea    edi,[rsi+0x20]
        if (t <= ix0) {
  212a0c:	89 d1                	mov    ecx,edx
  212a0e:	29 f9                	sub    ecx,edi
  212a10:	73 04                	jae    212a16 <sqrt+0x376>
  212a12:	89 d1                	mov    ecx,edx
  212a14:	eb 07                	jmp    212a1d <sqrt+0x37d>
            s0 = t + r;
  212a16:	83 c6 40             	add    esi,0x40
            q += r;
  212a19:	41 83 c1 20          	add    r9d,0x20
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212a1d:	ba 0e 01 00 00       	mov    edx,0x10e
  212a22:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  212a27:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  212a2a:	8d 7e 10             	lea    edi,[rsi+0x10]
        if (t <= ix0) {
  212a2d:	89 d1                	mov    ecx,edx
  212a2f:	29 f9                	sub    ecx,edi
  212a31:	73 04                	jae    212a37 <sqrt+0x397>
  212a33:	89 d1                	mov    ecx,edx
  212a35:	eb 07                	jmp    212a3e <sqrt+0x39e>
            s0 = t + r;
  212a37:	83 c6 20             	add    esi,0x20
            q += r;
  212a3a:	41 83 c1 10          	add    r9d,0x10
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212a3e:	ba 0d 01 00 00       	mov    edx,0x10d
  212a43:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  212a48:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  212a4b:	8d 7e 08             	lea    edi,[rsi+0x8]
        if (t <= ix0) {
  212a4e:	89 d1                	mov    ecx,edx
  212a50:	29 f9                	sub    ecx,edi
  212a52:	73 04                	jae    212a58 <sqrt+0x3b8>
  212a54:	89 d1                	mov    ecx,edx
  212a56:	eb 07                	jmp    212a5f <sqrt+0x3bf>
            s0 = t + r;
  212a58:	83 c6 10             	add    esi,0x10
            q += r;
  212a5b:	41 83 c1 08          	add    r9d,0x8
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212a5f:	ba 0c 01 00 00       	mov    edx,0x10c
  212a64:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  212a69:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  212a6c:	8d 7e 04             	lea    edi,[rsi+0x4]
        if (t <= ix0) {
  212a6f:	89 d1                	mov    ecx,edx
  212a71:	29 f9                	sub    ecx,edi
  212a73:	73 04                	jae    212a79 <sqrt+0x3d9>
  212a75:	89 d1                	mov    ecx,edx
  212a77:	eb 07                	jmp    212a80 <sqrt+0x3e0>
            s0 = t + r;
  212a79:	83 c6 08             	add    esi,0x8
            q += r;
  212a7c:	41 83 c1 04          	add    r9d,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212a80:	ba 0b 01 00 00       	mov    edx,0x10b
  212a85:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  212a8a:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  212a8d:	8d 7e 02             	lea    edi,[rsi+0x2]
        if (t <= ix0) {
  212a90:	89 d1                	mov    ecx,edx
  212a92:	29 f9                	sub    ecx,edi
  212a94:	73 04                	jae    212a9a <sqrt+0x3fa>
  212a96:	89 d1                	mov    ecx,edx
  212a98:	eb 07                	jmp    212aa1 <sqrt+0x401>
            s0 = t + r;
  212a9a:	83 c6 04             	add    esi,0x4
            q += r;
  212a9d:	41 83 c1 02          	add    r9d,0x2
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212aa1:	ba 0a 01 00 00       	mov    edx,0x10a
  212aa6:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  212aab:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  212aae:	8d 7e 01             	lea    edi,[rsi+0x1]
        if (t <= ix0) {
  212ab1:	89 d1                	mov    ecx,edx
  212ab3:	29 f9                	sub    ecx,edi
  212ab5:	73 04                	jae    212abb <sqrt+0x41b>
  212ab7:	89 d1                	mov    ecx,edx
  212ab9:	eb 07                	jmp    212ac2 <sqrt+0x422>
            s0 = t + r;
  212abb:	83 c6 02             	add    esi,0x2
            q += r;
  212abe:	41 83 c1 01          	add    r9d,0x1
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212ac2:	55                   	push   rbp
  212ac3:	41 56                	push   r14
  212ac5:	53                   	push   rbx
  212ac6:	ba 09 01 00 00       	mov    edx,0x109
  212acb:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  212ad0:	c1 e0 17             	shl    eax,0x17
  212ad3:	8d 1c 4a             	lea    ebx,[rdx+rcx*2]
    m >>= 1;
  212ad6:	41 d1 e8             	shr    r8d,1
  212ad9:	31 d2                	xor    edx,edx
  212adb:	bf 00 00 00 80       	mov    edi,0x80000000
  212ae0:	41 ba 1e 01 00 00    	mov    r10d,0x11e
  212ae6:	41 bb 1d 01 00 00    	mov    r11d,0x11d
  212aec:	41 be 1c 01 00 00    	mov    r14d,0x11c
  212af2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212af9:	1f 84 00 00 00 00 00 

    r = sign;
    while (r != 0) {
        t = s1 +% r;
        t = s0;
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  212b00:	89 fd                	mov    ebp,edi
  212b02:	89 f1                	mov    ecx,esi
  212b04:	39 f3                	cmp    ebx,esi
  212b06:	73 04                	jae    212b0c <sqrt+0x46c>
  212b08:	31 ed                	xor    ebp,ebp
  212b0a:	31 c9                	xor    ecx,ecx
  212b0c:	01 d5                	add    ebp,edx
  212b0e:	29 cb                	sub    ebx,ecx
                ix0 -= 1;
            }
            ix1 = ix1 -% t1;
            q1 += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212b10:	0f a4 c3 01          	shld   ebx,eax,0x1
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  212b14:	39 f3                	cmp    ebx,esi
  212b16:	73 08                	jae    212b20 <sqrt+0x480>
  212b18:	31 d2                	xor    edx,edx
  212b1a:	31 c9                	xor    ecx,ecx
  212b1c:	eb 08                	jmp    212b26 <sqrt+0x486>
  212b1e:	66 90                	xchg   ax,ax
  212b20:	89 fa                	mov    edx,edi
  212b22:	d1 ea                	shr    edx,1
  212b24:	89 f1                	mov    ecx,esi
  212b26:	01 ea                	add    edx,ebp
  212b28:	29 cb                	sub    ebx,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212b2a:	c4 e2 28 f7 c8       	bextr  ecx,eax,r10d
  212b2f:	8d 2c 59             	lea    ebp,[rcx+rbx*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  212b32:	39 f5                	cmp    ebp,esi
  212b34:	73 0a                	jae    212b40 <sqrt+0x4a0>
  212b36:	31 db                	xor    ebx,ebx
  212b38:	31 c9                	xor    ecx,ecx
  212b3a:	eb 0b                	jmp    212b47 <sqrt+0x4a7>
  212b3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  212b40:	89 fb                	mov    ebx,edi
  212b42:	c1 eb 02             	shr    ebx,0x2
  212b45:	89 f1                	mov    ecx,esi
  212b47:	01 d3                	add    ebx,edx
  212b49:	29 cd                	sub    ebp,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212b4b:	c4 e2 20 f7 c8       	bextr  ecx,eax,r11d
  212b50:	8d 2c 69             	lea    ebp,[rcx+rbp*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  212b53:	39 f5                	cmp    ebp,esi
  212b55:	73 09                	jae    212b60 <sqrt+0x4c0>
  212b57:	31 d2                	xor    edx,edx
  212b59:	31 c9                	xor    ecx,ecx
  212b5b:	eb 0a                	jmp    212b67 <sqrt+0x4c7>
  212b5d:	0f 1f 00             	nop    DWORD PTR [rax]
  212b60:	89 fa                	mov    edx,edi
  212b62:	c1 ea 03             	shr    edx,0x3
  212b65:	89 f1                	mov    ecx,esi
  212b67:	01 da                	add    edx,ebx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212b69:	c4 e2 08 f7 d8       	bextr  ebx,eax,r14d
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  212b6e:	29 cd                	sub    ebp,ecx
  212b70:	c1 e0 04             	shl    eax,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  212b73:	8d 1c 6b             	lea    ebx,[rbx+rbp*2]
        ix1 = ix1 +% ix1;
        r >>= 1;
  212b76:	c1 ef 04             	shr    edi,0x4
    while (r != 0) {
  212b79:	75 85                	jne    212b00 <sqrt+0x460>
    }

    // rounding direction
    if (ix0 | ix1 != 0) {
  212b7b:	09 c3                	or     ebx,eax
  212b7d:	5b                   	pop    rbx
  212b7e:	41 5e                	pop    r14
  212b80:	5d                   	pop    rbp
  212b81:	74 16                	je     212b99 <sqrt+0x4f9>
        var z = 1.0 - tiny; // raise inexact
        if (z >= 1.0) {
            z = 1.0 + tiny;
            if (q1 == 0xFFFFFFFF) {
  212b83:	83 fa ff             	cmp    edx,0xffffffff
  212b86:	74 0b                	je     212b93 <sqrt+0x4f3>
                if (q1 == 0xFFFFFFFE) {
                    q += 1;
                }
                q1 += 2;
            } else {
                q1 += q1 & 1;
  212b88:	89 d0                	mov    eax,edx
  212b8a:	83 e0 01             	and    eax,0x1
  212b8d:	01 d0                	add    eax,edx
  212b8f:	89 c2                	mov    edx,eax
  212b91:	eb 06                	jmp    212b99 <sqrt+0x4f9>
                q += 1;
  212b93:	41 83 c1 01          	add    r9d,0x1
  212b97:	31 d2                	xor    edx,edx
            }
        }
    }

    ix0 = (q >> 1) + 0x3FE00000;
  212b99:	44 89 c8             	mov    eax,r9d
  212b9c:	d1 e8                	shr    eax,1
    ix1 = q1 >> 1;
    if (q & 1 != 0) {
  212b9e:	44 0f ac ca 01       	shrd   edx,r9d,0x1
    }

    // NOTE: musl here appears to rely on signed twos-complement wraparound. +% has the same
    // behaviour at least.
    var iix0 = @intCast(i32, ix0);
    iix0 = iix0 +% (m << 20);
  212ba3:	41 c1 e0 14          	shl    r8d,0x14
  212ba7:	41 8d 04 00          	lea    eax,[r8+rax*1]
  212bab:	05 00 00 e0 3f       	add    eax,0x3fe00000

    const uz = (@intCast(u64, iix0) << 32) | ix1;
  212bb0:	48 c1 e0 20          	shl    rax,0x20
  212bb4:	48 09 c2             	or     rdx,rax
    return @bitCast(f64, uz);
  212bb7:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  212bbc:	c3                   	ret    
  212bbd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000212bc0 <sqrtf>:
}

export fn sqrtf(x: f32) f32 {
    const tiny: f32 = 1.0e-30;
    const sign: i32 = @bitCast(i32, u32(0x80000000));
    var ix: i32 = @bitCast(i32, x);
  212bc0:	c5 f9 7e c1          	vmovd  ecx,xmm0

    if ((ix & 0x7F800000) == 0x7F800000) {
  212bc4:	b8 00 00 80 7f       	mov    eax,0x7f800000
  212bc9:	c4 e2 70 f2 c0       	andn   eax,ecx,eax
  212bce:	75 06                	jne    212bd6 <sqrtf+0x16>
        return x * x + x; // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = snan
  212bd0:	c4 e2 79 a9 c0       	vfmadd213ss xmm0,xmm0,xmm0
  212bd5:	c3                   	ret    
    }

    // zero
    if (ix <= 0) {
  212bd6:	85 c9                	test   ecx,ecx
  212bd8:	7e 15                	jle    212bef <sqrtf+0x2f>
  212bda:	41 89 c8             	mov    r8d,ecx
  212bdd:	41 c1 e8 17          	shr    r8d,0x17
        }
    }

    // normalize
    var m = ix >> 23;
    if (m == 0) {
  212be1:	75 48                	jne    212c2b <sqrtf+0x6b>
  212be3:	31 d2                	xor    edx,edx
        // subnormal
        var i: i32 = 0;
        while (ix & 0x00800000 == 0) : (i += 1) {
  212be5:	0f ba e1 17          	bt     ecx,0x17
  212be9:	73 18                	jae    212c03 <sqrtf+0x43>
  212beb:	89 ce                	mov    esi,ecx
  212bed:	eb 31                	jmp    212c20 <sqrtf+0x60>
        if (ix & ~sign == 0) {
  212bef:	f7 c1 ff ff ff 7f    	test   ecx,0x7fffffff
  212bf5:	0f 84 29 03 00 00    	je     212f24 <sqrtf+0x364>
        if (ix < 0) {
  212bfb:	85 c9                	test   ecx,ecx
  212bfd:	0f 88 19 03 00 00    	js     212f1c <sqrtf+0x35c>
  212c03:	31 d2                	xor    edx,edx
  212c05:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  212c0c:	00 00 00 00 
            ix <<= 1;
  212c10:	8d 34 09             	lea    esi,[rcx+rcx*1]
        while (ix & 0x00800000 == 0) : (i += 1) {
  212c13:	83 c2 01             	add    edx,0x1
  212c16:	f7 c1 00 00 40 00    	test   ecx,0x400000
  212c1c:	89 f1                	mov    ecx,esi
  212c1e:	74 f0                	je     212c10 <sqrtf+0x50>
        }
        m -= i - 1;
  212c20:	41 b8 01 00 00 00    	mov    r8d,0x1
  212c26:	41 29 d0             	sub    r8d,edx
  212c29:	89 f1                	mov    ecx,esi
    }

    m -= 127; // unbias exponent
  212c2b:	41 83 c0 81          	add    r8d,0xffffff81
    ix = (ix & 0x007FFFFF) | 0x00800000;
  212c2f:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  212c35:	81 c9 00 00 80 00    	or     ecx,0x800000

    if (m & 1 != 0) { // odd m, double x to even
  212c3b:	44 89 c0             	mov    eax,r8d
  212c3e:	24 01                	and    al,0x1
  212c40:	c4 e2 79 f7 c1       	shlx   eax,ecx,eax
  212c45:	8d 34 85 00 00 00 00 	lea    esi,[rax*4+0x0]
    var s: i32 = 0;
    var r: i32 = 0x01000000; // r = moving bit right -> left

    while (r != 0) {
        const t = s + r;
        if (t <= ix) {
  212c4c:	31 d2                	xor    edx,edx
  212c4e:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  212c53:	0f 9f c2             	setg   dl
  212c56:	89 d1                	mov    ecx,edx
  212c58:	c1 e1 18             	shl    ecx,0x18
  212c5b:	c1 e2 19             	shl    edx,0x19
  212c5e:	3d 00 00 80 00       	cmp    eax,0x800000
  212c63:	8d 3c 85 00 00 00 fe 	lea    edi,[rax*4-0x2000000]
  212c6a:	0f 4c fe             	cmovl  edi,esi
        const t = s + r;
  212c6d:	8d 82 00 00 80 00    	lea    eax,[rdx+0x800000]
        if (t <= ix) {
  212c73:	89 fe                	mov    esi,edi
  212c75:	29 c6                	sub    esi,eax
  212c77:	7d 04                	jge    212c7d <sqrtf+0xbd>
  212c79:	89 fe                	mov    esi,edi
  212c7b:	eb 0d                	jmp    212c8a <sqrtf+0xca>
            s = t + r;
  212c7d:	05 00 00 80 00       	add    eax,0x800000
            ix -= t;
            q += r;
  212c82:	81 c9 00 00 80 00    	or     ecx,0x800000
  212c88:	89 c2                	mov    edx,eax
  212c8a:	01 f6                	add    esi,esi
        const t = s + r;
  212c8c:	8d 82 00 00 40 00    	lea    eax,[rdx+0x400000]
        if (t <= ix) {
  212c92:	89 f7                	mov    edi,esi
  212c94:	29 c7                	sub    edi,eax
  212c96:	7d 04                	jge    212c9c <sqrtf+0xdc>
  212c98:	89 f7                	mov    edi,esi
  212c9a:	eb 0c                	jmp    212ca8 <sqrtf+0xe8>
            s = t + r;
  212c9c:	81 c2 00 00 80 00    	add    edx,0x800000
            q += r;
  212ca2:	81 c1 00 00 40 00    	add    ecx,0x400000
  212ca8:	01 ff                	add    edi,edi
        const t = s + r;
  212caa:	8d 82 00 00 20 00    	lea    eax,[rdx+0x200000]
        if (t <= ix) {
  212cb0:	89 fe                	mov    esi,edi
  212cb2:	29 c6                	sub    esi,eax
  212cb4:	7d 04                	jge    212cba <sqrtf+0xfa>
  212cb6:	89 fe                	mov    esi,edi
  212cb8:	eb 0c                	jmp    212cc6 <sqrtf+0x106>
            s = t + r;
  212cba:	81 c2 00 00 40 00    	add    edx,0x400000
            q += r;
  212cc0:	81 c1 00 00 20 00    	add    ecx,0x200000
  212cc6:	01 f6                	add    esi,esi
        const t = s + r;
  212cc8:	8d 82 00 00 10 00    	lea    eax,[rdx+0x100000]
        if (t <= ix) {
  212cce:	89 f7                	mov    edi,esi
  212cd0:	29 c7                	sub    edi,eax
  212cd2:	7d 04                	jge    212cd8 <sqrtf+0x118>
  212cd4:	89 f7                	mov    edi,esi
  212cd6:	eb 0c                	jmp    212ce4 <sqrtf+0x124>
            s = t + r;
  212cd8:	81 c2 00 00 20 00    	add    edx,0x200000
            q += r;
  212cde:	81 c1 00 00 10 00    	add    ecx,0x100000
  212ce4:	01 ff                	add    edi,edi
        const t = s + r;
  212ce6:	8d 82 00 00 08 00    	lea    eax,[rdx+0x80000]
        if (t <= ix) {
  212cec:	89 fe                	mov    esi,edi
  212cee:	29 c6                	sub    esi,eax
  212cf0:	7d 04                	jge    212cf6 <sqrtf+0x136>
  212cf2:	89 fe                	mov    esi,edi
  212cf4:	eb 0c                	jmp    212d02 <sqrtf+0x142>
            s = t + r;
  212cf6:	81 c2 00 00 10 00    	add    edx,0x100000
            q += r;
  212cfc:	81 c1 00 00 08 00    	add    ecx,0x80000
  212d02:	01 f6                	add    esi,esi
        const t = s + r;
  212d04:	8d 82 00 00 04 00    	lea    eax,[rdx+0x40000]
        if (t <= ix) {
  212d0a:	89 f7                	mov    edi,esi
  212d0c:	29 c7                	sub    edi,eax
  212d0e:	7d 04                	jge    212d14 <sqrtf+0x154>
  212d10:	89 f7                	mov    edi,esi
  212d12:	eb 0c                	jmp    212d20 <sqrtf+0x160>
            s = t + r;
  212d14:	81 c2 00 00 08 00    	add    edx,0x80000
            q += r;
  212d1a:	81 c1 00 00 04 00    	add    ecx,0x40000
  212d20:	01 ff                	add    edi,edi
        const t = s + r;
  212d22:	8d 82 00 00 02 00    	lea    eax,[rdx+0x20000]
        if (t <= ix) {
  212d28:	89 fe                	mov    esi,edi
  212d2a:	29 c6                	sub    esi,eax
  212d2c:	7d 04                	jge    212d32 <sqrtf+0x172>
  212d2e:	89 fe                	mov    esi,edi
  212d30:	eb 0c                	jmp    212d3e <sqrtf+0x17e>
            s = t + r;
  212d32:	81 c2 00 00 04 00    	add    edx,0x40000
            q += r;
  212d38:	81 c1 00 00 02 00    	add    ecx,0x20000
  212d3e:	01 f6                	add    esi,esi
        const t = s + r;
  212d40:	8d 82 00 00 01 00    	lea    eax,[rdx+0x10000]
        if (t <= ix) {
  212d46:	89 f7                	mov    edi,esi
  212d48:	29 c7                	sub    edi,eax
  212d4a:	7d 04                	jge    212d50 <sqrtf+0x190>
  212d4c:	89 f7                	mov    edi,esi
  212d4e:	eb 0c                	jmp    212d5c <sqrtf+0x19c>
            s = t + r;
  212d50:	81 c2 00 00 02 00    	add    edx,0x20000
            q += r;
  212d56:	81 c1 00 00 01 00    	add    ecx,0x10000
  212d5c:	01 ff                	add    edi,edi
        const t = s + r;
  212d5e:	8d 82 00 80 00 00    	lea    eax,[rdx+0x8000]
        if (t <= ix) {
  212d64:	89 fe                	mov    esi,edi
  212d66:	29 c6                	sub    esi,eax
  212d68:	7d 04                	jge    212d6e <sqrtf+0x1ae>
  212d6a:	89 fe                	mov    esi,edi
  212d6c:	eb 0c                	jmp    212d7a <sqrtf+0x1ba>
            s = t + r;
  212d6e:	81 c2 00 00 01 00    	add    edx,0x10000
            q += r;
  212d74:	81 c1 00 80 00 00    	add    ecx,0x8000
  212d7a:	01 f6                	add    esi,esi
        const t = s + r;
  212d7c:	8d 82 00 40 00 00    	lea    eax,[rdx+0x4000]
        if (t <= ix) {
  212d82:	89 f7                	mov    edi,esi
  212d84:	29 c7                	sub    edi,eax
  212d86:	7d 04                	jge    212d8c <sqrtf+0x1cc>
  212d88:	89 f7                	mov    edi,esi
  212d8a:	eb 0c                	jmp    212d98 <sqrtf+0x1d8>
            s = t + r;
  212d8c:	81 c2 00 80 00 00    	add    edx,0x8000
            q += r;
  212d92:	81 c1 00 40 00 00    	add    ecx,0x4000
  212d98:	01 ff                	add    edi,edi
        const t = s + r;
  212d9a:	8d 82 00 20 00 00    	lea    eax,[rdx+0x2000]
        if (t <= ix) {
  212da0:	89 fe                	mov    esi,edi
  212da2:	29 c6                	sub    esi,eax
  212da4:	7d 04                	jge    212daa <sqrtf+0x1ea>
  212da6:	89 fe                	mov    esi,edi
  212da8:	eb 0c                	jmp    212db6 <sqrtf+0x1f6>
            s = t + r;
  212daa:	81 c2 00 40 00 00    	add    edx,0x4000
            q += r;
  212db0:	81 c1 00 20 00 00    	add    ecx,0x2000
  212db6:	01 f6                	add    esi,esi
        const t = s + r;
  212db8:	8d 82 00 10 00 00    	lea    eax,[rdx+0x1000]
        if (t <= ix) {
  212dbe:	89 f7                	mov    edi,esi
  212dc0:	29 c7                	sub    edi,eax
  212dc2:	7d 04                	jge    212dc8 <sqrtf+0x208>
  212dc4:	89 f7                	mov    edi,esi
  212dc6:	eb 0c                	jmp    212dd4 <sqrtf+0x214>
            s = t + r;
  212dc8:	81 c2 00 20 00 00    	add    edx,0x2000
            q += r;
  212dce:	81 c1 00 10 00 00    	add    ecx,0x1000
  212dd4:	01 ff                	add    edi,edi
        const t = s + r;
  212dd6:	8d 82 00 08 00 00    	lea    eax,[rdx+0x800]
        if (t <= ix) {
  212ddc:	89 fe                	mov    esi,edi
  212dde:	29 c6                	sub    esi,eax
  212de0:	7d 04                	jge    212de6 <sqrtf+0x226>
  212de2:	89 fe                	mov    esi,edi
  212de4:	eb 0c                	jmp    212df2 <sqrtf+0x232>
            s = t + r;
  212de6:	81 c2 00 10 00 00    	add    edx,0x1000
            q += r;
  212dec:	81 c1 00 08 00 00    	add    ecx,0x800
  212df2:	01 f6                	add    esi,esi
        const t = s + r;
  212df4:	8d 82 00 04 00 00    	lea    eax,[rdx+0x400]
        if (t <= ix) {
  212dfa:	89 f7                	mov    edi,esi
  212dfc:	29 c7                	sub    edi,eax
  212dfe:	7d 04                	jge    212e04 <sqrtf+0x244>
  212e00:	89 f7                	mov    edi,esi
  212e02:	eb 0c                	jmp    212e10 <sqrtf+0x250>
            s = t + r;
  212e04:	81 c2 00 08 00 00    	add    edx,0x800
            q += r;
  212e0a:	81 c1 00 04 00 00    	add    ecx,0x400
  212e10:	01 ff                	add    edi,edi
        const t = s + r;
  212e12:	8d 82 00 02 00 00    	lea    eax,[rdx+0x200]
        if (t <= ix) {
  212e18:	89 fe                	mov    esi,edi
  212e1a:	29 c6                	sub    esi,eax
  212e1c:	7d 04                	jge    212e22 <sqrtf+0x262>
  212e1e:	89 fe                	mov    esi,edi
  212e20:	eb 0c                	jmp    212e2e <sqrtf+0x26e>
            s = t + r;
  212e22:	81 c2 00 04 00 00    	add    edx,0x400
            q += r;
  212e28:	81 c1 00 02 00 00    	add    ecx,0x200
  212e2e:	01 f6                	add    esi,esi
        const t = s + r;
  212e30:	8d 82 00 01 00 00    	lea    eax,[rdx+0x100]
        if (t <= ix) {
  212e36:	89 f7                	mov    edi,esi
  212e38:	29 c7                	sub    edi,eax
  212e3a:	7d 04                	jge    212e40 <sqrtf+0x280>
  212e3c:	89 f7                	mov    edi,esi
  212e3e:	eb 0c                	jmp    212e4c <sqrtf+0x28c>
            s = t + r;
  212e40:	81 c2 00 02 00 00    	add    edx,0x200
            q += r;
  212e46:	81 c1 00 01 00 00    	add    ecx,0x100
  212e4c:	01 ff                	add    edi,edi
        const t = s + r;
  212e4e:	89 d0                	mov    eax,edx
  212e50:	83 e8 80             	sub    eax,0xffffff80
        if (t <= ix) {
  212e53:	89 fe                	mov    esi,edi
  212e55:	29 c6                	sub    esi,eax
  212e57:	7d 04                	jge    212e5d <sqrtf+0x29d>
  212e59:	89 fe                	mov    esi,edi
  212e5b:	eb 09                	jmp    212e66 <sqrtf+0x2a6>
            s = t + r;
  212e5d:	81 c2 00 01 00 00    	add    edx,0x100
            q += r;
  212e63:	83 e9 80             	sub    ecx,0xffffff80
  212e66:	01 f6                	add    esi,esi
        const t = s + r;
  212e68:	8d 42 40             	lea    eax,[rdx+0x40]
        if (t <= ix) {
  212e6b:	89 f7                	mov    edi,esi
  212e6d:	29 c7                	sub    edi,eax
  212e6f:	7d 04                	jge    212e75 <sqrtf+0x2b5>
  212e71:	89 f7                	mov    edi,esi
  212e73:	eb 06                	jmp    212e7b <sqrtf+0x2bb>
            s = t + r;
  212e75:	83 ea 80             	sub    edx,0xffffff80
            q += r;
  212e78:	83 c1 40             	add    ecx,0x40
  212e7b:	01 ff                	add    edi,edi
        const t = s + r;
  212e7d:	8d 42 20             	lea    eax,[rdx+0x20]
        if (t <= ix) {
  212e80:	89 fe                	mov    esi,edi
  212e82:	29 c6                	sub    esi,eax
  212e84:	7d 04                	jge    212e8a <sqrtf+0x2ca>
  212e86:	89 fe                	mov    esi,edi
  212e88:	eb 06                	jmp    212e90 <sqrtf+0x2d0>
            s = t + r;
  212e8a:	83 c2 40             	add    edx,0x40
            q += r;
  212e8d:	83 c1 20             	add    ecx,0x20
  212e90:	01 f6                	add    esi,esi
        const t = s + r;
  212e92:	8d 42 10             	lea    eax,[rdx+0x10]
        if (t <= ix) {
  212e95:	89 f7                	mov    edi,esi
  212e97:	29 c7                	sub    edi,eax
  212e99:	7d 04                	jge    212e9f <sqrtf+0x2df>
  212e9b:	89 f7                	mov    edi,esi
  212e9d:	eb 06                	jmp    212ea5 <sqrtf+0x2e5>
            s = t + r;
  212e9f:	83 c2 20             	add    edx,0x20
            q += r;
  212ea2:	83 c1 10             	add    ecx,0x10
  212ea5:	01 ff                	add    edi,edi
        const t = s + r;
  212ea7:	8d 42 08             	lea    eax,[rdx+0x8]
        if (t <= ix) {
  212eaa:	89 fe                	mov    esi,edi
  212eac:	29 c6                	sub    esi,eax
  212eae:	7d 04                	jge    212eb4 <sqrtf+0x2f4>
  212eb0:	89 fe                	mov    esi,edi
  212eb2:	eb 06                	jmp    212eba <sqrtf+0x2fa>
            s = t + r;
  212eb4:	83 c2 10             	add    edx,0x10
            q += r;
  212eb7:	83 c1 08             	add    ecx,0x8
  212eba:	01 f6                	add    esi,esi
        const t = s + r;
  212ebc:	8d 42 04             	lea    eax,[rdx+0x4]
        if (t <= ix) {
  212ebf:	89 f7                	mov    edi,esi
  212ec1:	29 c7                	sub    edi,eax
  212ec3:	7d 04                	jge    212ec9 <sqrtf+0x309>
  212ec5:	89 f7                	mov    edi,esi
  212ec7:	eb 06                	jmp    212ecf <sqrtf+0x30f>
            s = t + r;
  212ec9:	83 c2 08             	add    edx,0x8
            q += r;
  212ecc:	83 c1 04             	add    ecx,0x4
  212ecf:	01 ff                	add    edi,edi
        const t = s + r;
  212ed1:	8d 42 02             	lea    eax,[rdx+0x2]
        if (t <= ix) {
  212ed4:	89 fe                	mov    esi,edi
  212ed6:	29 c6                	sub    esi,eax
  212ed8:	7d 0a                	jge    212ee4 <sqrtf+0x324>
  212eda:	89 fe                	mov    esi,edi
  212edc:	01 f6                	add    esi,esi
  212ede:	39 d6                	cmp    esi,edx
  212ee0:	7f 0e                	jg     212ef0 <sqrtf+0x330>
  212ee2:	eb 14                	jmp    212ef8 <sqrtf+0x338>
            s = t + r;
  212ee4:	83 c2 04             	add    edx,0x4
            q += r;
  212ee7:	83 c1 02             	add    ecx,0x2
  212eea:	01 f6                	add    esi,esi
        if (t <= ix) {
  212eec:	39 d6                	cmp    esi,edx
  212eee:	7e 08                	jle    212ef8 <sqrtf+0x338>
        const t = s + r;
  212ef0:	83 c2 01             	add    edx,0x1
            ix -= t;
  212ef3:	29 d6                	sub    esi,edx
            q += r;
  212ef5:	83 c1 01             	add    ecx,0x1
    m >>= 1; // m = [m / 2]
  212ef8:	41 83 e0 fe          	and    r8d,0xfffffffe
  212efc:	41 c1 e0 16          	shl    r8d,0x16
        ix += ix;
        r >>= 1;
    }

    // floating add to find rounding direction
    if (ix != 0) {
  212f00:	85 f6                	test   esi,esi
  212f02:	0f 95 c0             	setne  al
  212f05:	20 c8                	and    al,cl
  212f07:	0f b6 c0             	movzx  eax,al
  212f0a:	01 c8                	add    eax,ecx
                }
            }
        }
    }

    ix = (q >> 1) + 0x3f000000;
  212f0c:	d1 f8                	sar    eax,1
    ix += m << 23;
  212f0e:	41 8d 04 00          	lea    eax,[r8+rax*1]
  212f12:	05 00 00 00 3f       	add    eax,0x3f000000
    return @bitCast(f32, ix);
  212f17:	c5 f9 6e c0          	vmovd  xmm0,eax
  212f1b:	c3                   	ret    
  212f1c:	c5 f9 6e 05 14 f7 fe 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffef714]        # 202638 <__unnamed_53+0x28>
  212f23:	ff 
            return x; // sqrt (+-0) = +-0
  212f24:	c3                   	ret    
