
./zig-cache/test:     file format elf64-x86-64


Disassembly of section .text:

0000000000208000 <assert>:
/// In Debug and ReleaseSafe modes, calls to this function are always
/// generated, and the `unreachable` statement triggers a panic.
/// In ReleaseFast and ReleaseSmall modes, calls to this function can be
/// optimized away.
pub fn assert(ok: bool) void {
    if (!ok) {
  208000:	40 f6 c7 01          	test   dil,0x1
  208004:	74 01                	je     208007 <assert+0x7>
pub fn assert(ok: bool) void {
  208006:	c3                   	ret    
        // In ReleaseFast test mode, we still want assert(false) to crash, so
        // we insert an explicit call to @panic instead of unreachable.
        // TODO we should use `assertOrPanic` in tests and remove this logic.
        if (builtin.is_test) {
            @panic("assertion failure");
  208007:	50                   	push   rax
  208008:	e8 a3 1c 00 00       	call   209cb0 <panic>
  20800d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000208010 <init_vdso_clock_gettime>:
const linux = std.os.linux;
const cstr = std.cstr;
const mem = std.mem;

pub fn lookup(vername: []const u8, name: []const u8) usize {
    const vdso_addr = std.os.linux_aux_raw[std.elf.AT_SYSINFO_EHDR];
  208010:	55                   	push   rbp
  208011:	41 57                	push   r15
  208013:	41 56                	push   r14
  208015:	41 55                	push   r13
  208017:	41 54                	push   r12
  208019:	53                   	push   rbx
  20801a:	4c 8b 0d 4f 91 01 00 	mov    r9,QWORD PTR [rip+0x1914f]        # 221170 <linux_aux_raw+0x108>
    if (vdso_addr == 0) return 0;
  208021:	4d 85 c9             	test   r9,r9
  208024:	0f 84 53 05 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>

    var maybe_dynv: ?[*]usize = null;
    var base: usize = @maxValue(usize);
    {
        var i: usize = 0;
        while (i < eh.e_phnum) : ({
  20802a:	41 0f b7 51 38       	movzx  edx,WORD PTR [r9+0x38]
  20802f:	48 85 d2             	test   rdx,rdx
  208032:	0f 84 45 05 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  208038:	49 8b 59 20          	mov    rbx,QWORD PTR [r9+0x20]
    var ph_addr: usize = vdso_addr + eh.e_phoff;
  20803c:	4c 01 cb             	add    rbx,r9
  20803f:	41 0f b7 49 36       	movzx  ecx,WORD PTR [r9+0x36]
        while (i < eh.e_phnum) : ({
  208044:	48 8d 42 ff          	lea    rax,[rdx-0x1]
  208048:	89 d5                	mov    ebp,edx
  20804a:	83 e5 03             	and    ebp,0x3
  20804d:	48 83 f8 03          	cmp    rax,0x3
  208051:	73 18                	jae    20806b <init_vdso_clock_gettime+0x5b>
  208053:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  20805a:	45 31 f6             	xor    r14d,r14d
            i += 1;
            ph_addr += eh.e_phentsize;
        }) {
            const this_ph = @intToPtr(*elf.Phdr, ph_addr);
            switch (this_ph.p_type) {
  20805d:	48 85 ed             	test   rbp,rbp
  208060:	0f 85 ec 00 00 00    	jne    208152 <init_vdso_clock_gettime+0x142>
  208066:	e9 29 01 00 00       	jmp    208194 <init_vdso_clock_gettime+0x184>
        while (i < eh.e_phnum) : ({
  20806b:	48 89 e8             	mov    rax,rbp
  20806e:	48 29 d0             	sub    rax,rdx
  208071:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  208078:	45 31 f6             	xor    r14d,r14d
  20807b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  208080:	48 89 da             	mov    rdx,rbx
            switch (this_ph.p_type) {
  208083:	8b 1a                	mov    ebx,DWORD PTR [rdx]
  208085:	83 fb 02             	cmp    ebx,0x2
  208088:	74 66                	je     2080f0 <init_vdso_clock_gettime+0xe0>
  20808a:	83 fb 01             	cmp    ebx,0x1
  20808d:	75 0b                	jne    20809a <init_vdso_clock_gettime+0x8a>
  20808f:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  208093:	4d 01 c8             	add    r8,r9
  208096:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20809a:	8b 1c 0a             	mov    ebx,DWORD PTR [rdx+rcx*1]
            ph_addr += eh.e_phentsize;
  20809d:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  2080a0:	83 fb 01             	cmp    ebx,0x1
  2080a3:	74 5d                	je     208102 <init_vdso_clock_gettime+0xf2>
  2080a5:	83 fb 02             	cmp    ebx,0x2
  2080a8:	75 07                	jne    2080b1 <init_vdso_clock_gettime+0xa1>
  2080aa:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  2080ae:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  2080b1:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  2080b4:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  2080b7:	83 fb 01             	cmp    ebx,0x1
  2080ba:	74 5c                	je     208118 <init_vdso_clock_gettime+0x108>
  2080bc:	83 fb 02             	cmp    ebx,0x2
  2080bf:	75 07                	jne    2080c8 <init_vdso_clock_gettime+0xb8>
  2080c1:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  2080c5:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  2080c8:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  2080cb:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  2080ce:	83 fb 01             	cmp    ebx,0x1
  2080d1:	74 5b                	je     20812e <init_vdso_clock_gettime+0x11e>
  2080d3:	83 fb 02             	cmp    ebx,0x2
  2080d6:	75 07                	jne    2080df <init_vdso_clock_gettime+0xcf>
  2080d8:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  2080dc:	4d 01 ce             	add    r14,r9
        while (i < eh.e_phnum) : ({
  2080df:	48 8d 1c 0a          	lea    rbx,[rdx+rcx*1]
  2080e3:	48 83 c0 04          	add    rax,0x4
  2080e7:	75 97                	jne    208080 <init_vdso_clock_gettime+0x70>
  2080e9:	eb 5c                	jmp    208147 <init_vdso_clock_gettime+0x137>
  2080eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  2080f0:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  2080f4:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  2080f7:	8b 1c 0a             	mov    ebx,DWORD PTR [rdx+rcx*1]
            ph_addr += eh.e_phentsize;
  2080fa:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  2080fd:	83 fb 01             	cmp    ebx,0x1
  208100:	75 a3                	jne    2080a5 <init_vdso_clock_gettime+0x95>
  208102:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  208106:	4d 01 c8             	add    r8,r9
  208109:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20810d:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  208110:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  208113:	83 fb 01             	cmp    ebx,0x1
  208116:	75 a4                	jne    2080bc <init_vdso_clock_gettime+0xac>
  208118:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20811c:	4d 01 c8             	add    r8,r9
  20811f:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  208123:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  208126:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  208129:	83 fb 01             	cmp    ebx,0x1
  20812c:	75 a5                	jne    2080d3 <init_vdso_clock_gettime+0xc3>
  20812e:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  208132:	4d 01 c8             	add    r8,r9
  208135:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
        while (i < eh.e_phnum) : ({
  208139:	48 8d 1c 0a          	lea    rbx,[rdx+rcx*1]
  20813d:	48 83 c0 04          	add    rax,0x4
  208141:	0f 85 39 ff ff ff    	jne    208080 <init_vdso_clock_gettime+0x70>
  208147:	48 01 ca             	add    rdx,rcx
  20814a:	48 89 d3             	mov    rbx,rdx
            switch (this_ph.p_type) {
  20814d:	48 85 ed             	test   rbp,rbp
  208150:	74 42                	je     208194 <init_vdso_clock_gettime+0x184>
  208152:	48 f7 dd             	neg    rbp
  208155:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20815c:	00 00 00 00 
  208160:	8b 03                	mov    eax,DWORD PTR [rbx]
  208162:	83 f8 01             	cmp    eax,0x1
  208165:	74 19                	je     208180 <init_vdso_clock_gettime+0x170>
  208167:	83 f8 02             	cmp    eax,0x2
  20816a:	75 07                	jne    208173 <init_vdso_clock_gettime+0x163>
  20816c:	4c 8b 73 08          	mov    r14,QWORD PTR [rbx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  208170:	4d 01 ce             	add    r14,r9
            ph_addr += eh.e_phentsize;
  208173:	48 01 cb             	add    rbx,rcx
        while (i < eh.e_phnum) : ({
  208176:	48 83 c5 01          	add    rbp,0x1
  20817a:	75 e4                	jne    208160 <init_vdso_clock_gettime+0x150>
  20817c:	eb 16                	jmp    208194 <init_vdso_clock_gettime+0x184>
  20817e:	66 90                	xchg   ax,ax
  208180:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  208184:	4d 01 c8             	add    r8,r9
  208187:	4c 2b 43 10          	sub    r8,QWORD PTR [rbx+0x10]
            ph_addr += eh.e_phentsize;
  20818b:	48 01 cb             	add    rbx,rcx
        while (i < eh.e_phnum) : ({
  20818e:	48 83 c5 01          	add    rbp,0x1
  208192:	75 cc                	jne    208160 <init_vdso_clock_gettime+0x150>
                else => {},
            }
        }
    }
    const dynv = maybe_dynv orelse return 0;
    if (base == @maxValue(usize)) return 0;
  208194:	49 83 f8 ff          	cmp    r8,0xffffffffffffffff
    const dynv = maybe_dynv orelse return 0;
  208198:	0f 84 df 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  20819e:	4d 85 f6             	test   r14,r14
  2081a1:	0f 84 d6 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
    var maybe_versym: ?[*]u16 = null;
    var maybe_verdef: ?*elf.Verdef = null;

    {
        var i: usize = 0;
        while (dynv[i] != 0) : (i += 2) {
  2081a7:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  2081aa:	48 85 d2             	test   rdx,rdx
  2081ad:	0f 84 ca 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
            const p = base + dynv[i + 1];
  2081b3:	49 83 c6 10          	add    r14,0x10
  2081b7:	45 31 ff             	xor    r15d,r15d
  2081ba:	45 31 db             	xor    r11d,r11d
  2081bd:	45 31 d2             	xor    r10d,r10d
  2081c0:	31 ed                	xor    ebp,ebp
  2081c2:	45 31 ed             	xor    r13d,r13d
  2081c5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2081cc:	00 00 00 00 
  2081d0:	49 8b 4e f8          	mov    rcx,QWORD PTR [r14-0x8]
  2081d4:	4c 01 c1             	add    rcx,r8
            switch (dynv[i]) {
  2081d7:	48 83 fa 05          	cmp    rdx,0x5
  2081db:	7e 33                	jle    208210 <init_vdso_clock_gettime+0x200>
  2081dd:	48 83 fa 06          	cmp    rdx,0x6
  2081e1:	74 4b                	je     20822e <init_vdso_clock_gettime+0x21e>
  2081e3:	48 81 fa f0 ff ff 6f 	cmp    rdx,0x6ffffff0
  2081ea:	74 53                	je     20823f <init_vdso_clock_gettime+0x22f>
  2081ec:	48 81 fa fc ff ff 6f 	cmp    rdx,0x6ffffffc
  2081f3:	75 2b                	jne    208220 <init_vdso_clock_gettime+0x210>
  2081f5:	49 89 cb             	mov    r11,rcx
        while (dynv[i] != 0) : (i += 2) {
  2081f8:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  2081fb:	49 83 c6 10          	add    r14,0x10
  2081ff:	48 85 d2             	test   rdx,rdx
  208202:	75 cc                	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
  208204:	eb 5d                	jmp    208263 <init_vdso_clock_gettime+0x253>
  208206:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20820d:	00 00 00 
            switch (dynv[i]) {
  208210:	48 83 fa 04          	cmp    rdx,0x4
  208214:	74 3a                	je     208250 <init_vdso_clock_gettime+0x240>
  208216:	48 83 fa 05          	cmp    rdx,0x5
  20821a:	75 04                	jne    208220 <init_vdso_clock_gettime+0x210>
  20821c:	49 89 cf             	mov    r15,rcx
  20821f:	90                   	nop
        while (dynv[i] != 0) : (i += 2) {
  208220:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  208223:	49 83 c6 10          	add    r14,0x10
  208227:	48 85 d2             	test   rdx,rdx
  20822a:	75 a4                	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
  20822c:	eb 35                	jmp    208263 <init_vdso_clock_gettime+0x253>
  20822e:	49 89 cd             	mov    r13,rcx
  208231:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  208234:	49 83 c6 10          	add    r14,0x10
  208238:	48 85 d2             	test   rdx,rdx
  20823b:	75 93                	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
  20823d:	eb 24                	jmp    208263 <init_vdso_clock_gettime+0x253>
  20823f:	49 89 ca             	mov    r10,rcx
  208242:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  208245:	49 83 c6 10          	add    r14,0x10
  208249:	48 85 d2             	test   rdx,rdx
  20824c:	75 82                	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
  20824e:	eb 13                	jmp    208263 <init_vdso_clock_gettime+0x253>
  208250:	48 89 cd             	mov    rbp,rcx
  208253:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  208256:	49 83 c6 10          	add    r14,0x10
  20825a:	48 85 d2             	test   rdx,rdx
  20825d:	0f 85 6d ff ff ff    	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
        }
    }

    const strings = maybe_strings orelse return 0;
    const syms = maybe_syms orelse return 0;
    const hashtab = maybe_hashtab orelse return 0;
  208263:	48 85 ed             	test   rbp,rbp
    const strings = maybe_strings orelse return 0;
  208266:	0f 84 11 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  20826c:	4d 85 ed             	test   r13,r13
  20826f:	0f 84 08 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  208275:	4d 85 ff             	test   r15,r15
  208278:	0f 84 ff 02 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
    if (maybe_verdef == null) maybe_versym = null;
  20827e:	4d 85 db             	test   r11,r11
  208281:	4d 0f 44 d3          	cmove  r10,r11

    const OK_TYPES = (1 << elf.STT_NOTYPE | 1 << elf.STT_OBJECT | 1 << elf.STT_FUNC | 1 << elf.STT_COMMON);
    const OK_BINDS = (1 << elf.STB_GLOBAL | 1 << elf.STB_WEAK | 1 << elf.STB_GNU_UNIQUE);

    var i: usize = 0;
    while (i < hashtab[1]) : (i += 1) {
  208285:	44 8b 4d 04          	mov    r9d,DWORD PTR [rbp+0x4]
  208289:	4d 85 c9             	test   r9,r9
  20828c:	0f 84 eb 02 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  208292:	31 d2                	xor    edx,edx
  208294:	4d 85 d2             	test   r10,r10
  208297:	0f 84 e5 01 00 00    	je     208482 <init_vdso_clock_gettime+0x472>
  20829d:	41 bc 27 00 00 00    	mov    r12d,0x27
  2082a3:	41 be 06 04 00 00    	mov    r14d,0x406
  2082a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info & 0xf) & OK_TYPES)) continue;
  2082b0:	48 8d 0c 52          	lea    rcx,[rdx+rdx*2]
  2082b4:	41 8a 5c cd 04       	mov    bl,BYTE PTR [r13+rcx*8+0x4]
  2082b9:	89 d8                	mov    eax,ebx
  2082bb:	24 0f                	and    al,0xf
  2082bd:	0f b6 c0             	movzx  eax,al
  2082c0:	41 0f a3 c4          	bt     r12d,eax
  2082c4:	0f 83 a6 01 00 00    	jae    208470 <init_vdso_clock_gettime+0x460>
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info >> 4) & OK_BINDS)) continue;
  2082ca:	c0 eb 04             	shr    bl,0x4
  2082cd:	0f b6 c3             	movzx  eax,bl
  2082d0:	41 0f a3 c6          	bt     r14d,eax
  2082d4:	0f 83 96 01 00 00    	jae    208470 <init_vdso_clock_gettime+0x460>
        if (0 == syms[i].st_shndx) continue;
  2082da:	66 41 83 7c cd 06 00 	cmp    WORD PTR [r13+rcx*8+0x6],0x0
  2082e1:	0f 84 89 01 00 00    	je     208470 <init_vdso_clock_gettime+0x460>
        if (!mem.eql(u8, name, cstr.toSliceConst(strings + syms[i].st_name))) continue;
  2082e7:	41 8b 6c cd 00       	mov    ebp,DWORD PTR [r13+rcx*8+0x0]
  2082ec:	4c 01 fd             	add    rbp,r15
  2082ef:	48 c7 c1 eb ff ff ff 	mov    rcx,0xffffffffffffffeb
  2082f6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2082fd:	00 00 00 
    else => "\n",
};

pub fn len(ptr: [*]const u8) usize {
    var count: usize = 0;
    while (ptr[count] != 0) : (count += 1) {}
  208300:	80 7c 0d 15 00       	cmp    BYTE PTR [rbp+rcx*1+0x15],0x0
  208305:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  208309:	75 f5                	jne    208300 <init_vdso_clock_gettime+0x2f0>
    assert(lessThan(u8, "", "a"));
}

/// Compares two slices and returns whether they are equal.
pub fn eql(comptime T: type, a: []const T, b: []const T) bool {
    if (a.len != b.len) return false;
  20830b:	48 85 c9             	test   rcx,rcx
  20830e:	0f 85 5c 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
    for (a) |item, index| {
        if (b[index] != item) return false;
  208314:	80 7d 00 5f          	cmp    BYTE PTR [rbp+0x0],0x5f
  208318:	0f 85 52 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20831e:	80 7d 01 5f          	cmp    BYTE PTR [rbp+0x1],0x5f
  208322:	0f 85 48 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208328:	80 7d 02 76          	cmp    BYTE PTR [rbp+0x2],0x76
  20832c:	0f 85 3e 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208332:	80 7d 03 64          	cmp    BYTE PTR [rbp+0x3],0x64
  208336:	0f 85 34 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20833c:	80 7d 04 73          	cmp    BYTE PTR [rbp+0x4],0x73
  208340:	0f 85 2a 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208346:	80 7d 05 6f          	cmp    BYTE PTR [rbp+0x5],0x6f
  20834a:	0f 85 20 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208350:	80 7d 06 5f          	cmp    BYTE PTR [rbp+0x6],0x5f
  208354:	0f 85 16 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20835a:	80 7d 07 63          	cmp    BYTE PTR [rbp+0x7],0x63
  20835e:	0f 85 0c 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208364:	80 7d 08 6c          	cmp    BYTE PTR [rbp+0x8],0x6c
  208368:	0f 85 02 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20836e:	80 7d 09 6f          	cmp    BYTE PTR [rbp+0x9],0x6f
  208372:	0f 85 f8 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208378:	80 7d 0a 63          	cmp    BYTE PTR [rbp+0xa],0x63
  20837c:	0f 85 ee 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208382:	80 7d 0b 6b          	cmp    BYTE PTR [rbp+0xb],0x6b
  208386:	0f 85 e4 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20838c:	80 7d 0c 5f          	cmp    BYTE PTR [rbp+0xc],0x5f
  208390:	0f 85 da 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208396:	80 7d 0d 67          	cmp    BYTE PTR [rbp+0xd],0x67
  20839a:	0f 85 d0 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083a0:	80 7d 0e 65          	cmp    BYTE PTR [rbp+0xe],0x65
  2083a4:	0f 85 c6 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083aa:	80 7d 0f 74          	cmp    BYTE PTR [rbp+0xf],0x74
  2083ae:	0f 85 bc 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083b4:	80 7d 10 74          	cmp    BYTE PTR [rbp+0x10],0x74
  2083b8:	0f 85 b2 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083be:	80 7d 11 69          	cmp    BYTE PTR [rbp+0x11],0x69
  2083c2:	0f 85 a8 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083c8:	80 7d 12 6d          	cmp    BYTE PTR [rbp+0x12],0x6d
  2083cc:	0f 85 9e 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083d2:	80 7d 13 65          	cmp    BYTE PTR [rbp+0x13],0x65
  2083d6:	0f 85 94 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
        if (maybe_versym) |versym| {
            if (!checkver(maybe_verdef.?, versym[i], vername, strings))
  2083dc:	41 0f b7 2c 52       	movzx  ebp,WORD PTR [r10+rdx*2]
  2083e1:	4c 89 d9             	mov    rcx,r11

fn checkver(def_arg: *elf.Verdef, vsym_arg: i32, vername: []const u8, strings: [*]u8) bool {
    var def = def_arg;
    const vsym = @bitCast(u32, vsym_arg) & 0x7fff;
    while (true) {
        if (0 == (def.vd_flags & elf.VER_FLG_BASE) and (def.vd_ndx & 0x7fff) == vsym)
  2083e4:	f6 41 02 01          	test   BYTE PTR [rcx+0x2],0x1
  2083e8:	75 1c                	jne    208406 <init_vdso_clock_gettime+0x3f6>
  2083ea:	eb 09                	jmp    2083f5 <init_vdso_clock_gettime+0x3e5>
            break;
        if (def.vd_next == 0)
            return false;
        def = @intToPtr(*elf.Verdef, @ptrToInt(def) + def.vd_next);
  2083ec:	48 01 d9             	add    rcx,rbx
        if (0 == (def.vd_flags & elf.VER_FLG_BASE) and (def.vd_ndx & 0x7fff) == vsym)
  2083ef:	f6 41 02 01          	test   BYTE PTR [rcx+0x2],0x1
  2083f3:	75 11                	jne    208406 <init_vdso_clock_gettime+0x3f6>
  2083f5:	0f b7 41 04          	movzx  eax,WORD PTR [rcx+0x4]
  2083f9:	66 31 e8             	xor    ax,bp
  2083fc:	25 ff 7f 00 00       	and    eax,0x7fff
  208401:	66 85 c0             	test   ax,ax
  208404:	74 0a                	je     208410 <init_vdso_clock_gettime+0x400>
        if (def.vd_next == 0)
  208406:	8b 59 10             	mov    ebx,DWORD PTR [rcx+0x10]
  208409:	48 85 db             	test   rbx,rbx
  20840c:	75 de                	jne    2083ec <init_vdso_clock_gettime+0x3dc>
  20840e:	eb 60                	jmp    208470 <init_vdso_clock_gettime+0x460>
    }
    const aux = @intToPtr(*elf.Verdaux, @ptrToInt(def) + def.vd_aux);
  208410:	8b 41 0c             	mov    eax,DWORD PTR [rcx+0xc]
    return mem.eql(u8, vername, cstr.toSliceConst(strings + aux.vda_name));
  208413:	8b 2c 08             	mov    ebp,DWORD PTR [rax+rcx*1]
  208416:	4c 01 fd             	add    rbp,r15
  208419:	48 c7 c1 f6 ff ff ff 	mov    rcx,0xfffffffffffffff6
  208420:	80 7c 0d 0a 00       	cmp    BYTE PTR [rbp+rcx*1+0xa],0x0
  208425:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  208429:	75 f5                	jne    208420 <init_vdso_clock_gettime+0x410>
    if (a.len != b.len) return false;
  20842b:	48 85 c9             	test   rcx,rcx
  20842e:	75 40                	jne    208470 <init_vdso_clock_gettime+0x460>
        if (b[index] != item) return false;
  208430:	80 7d 00 4c          	cmp    BYTE PTR [rbp+0x0],0x4c
  208434:	75 3a                	jne    208470 <init_vdso_clock_gettime+0x460>
  208436:	80 7d 01 49          	cmp    BYTE PTR [rbp+0x1],0x49
  20843a:	75 34                	jne    208470 <init_vdso_clock_gettime+0x460>
  20843c:	80 7d 02 4e          	cmp    BYTE PTR [rbp+0x2],0x4e
  208440:	75 2e                	jne    208470 <init_vdso_clock_gettime+0x460>
  208442:	80 7d 03 55          	cmp    BYTE PTR [rbp+0x3],0x55
  208446:	75 28                	jne    208470 <init_vdso_clock_gettime+0x460>
  208448:	80 7d 04 58          	cmp    BYTE PTR [rbp+0x4],0x58
  20844c:	75 22                	jne    208470 <init_vdso_clock_gettime+0x460>
  20844e:	80 7d 05 5f          	cmp    BYTE PTR [rbp+0x5],0x5f
  208452:	75 1c                	jne    208470 <init_vdso_clock_gettime+0x460>
  208454:	80 7d 06 32          	cmp    BYTE PTR [rbp+0x6],0x32
  208458:	75 16                	jne    208470 <init_vdso_clock_gettime+0x460>
  20845a:	80 7d 07 2e          	cmp    BYTE PTR [rbp+0x7],0x2e
  20845e:	75 10                	jne    208470 <init_vdso_clock_gettime+0x460>
  208460:	80 7d 08 36          	cmp    BYTE PTR [rbp+0x8],0x36
            if (!checkver(maybe_verdef.?, versym[i], vername, strings))
  208464:	0f 84 37 01 00 00    	je     2085a1 <init_vdso_clock_gettime+0x591>
  20846a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    while (i < hashtab[1]) : (i += 1) {
  208470:	48 83 c2 01          	add    rdx,0x1
  208474:	4c 39 ca             	cmp    rdx,r9
  208477:	0f 82 33 fe ff ff    	jb     2082b0 <init_vdso_clock_gettime+0x2a0>
  20847d:	e9 fb 00 00 00       	jmp    20857d <init_vdso_clock_gettime+0x56d>
  208482:	bd 27 00 00 00       	mov    ebp,0x27
  208487:	41 ba 06 04 00 00    	mov    r10d,0x406
  20848d:	0f 1f 00             	nop    DWORD PTR [rax]
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info & 0xf) & OK_TYPES)) continue;
  208490:	48 8d 0c 52          	lea    rcx,[rdx+rdx*2]
  208494:	41 8a 44 cd 04       	mov    al,BYTE PTR [r13+rcx*8+0x4]
  208499:	89 c3                	mov    ebx,eax
  20849b:	80 e3 0f             	and    bl,0xf
  20849e:	0f b6 db             	movzx  ebx,bl
  2084a1:	0f a3 dd             	bt     ebp,ebx
  2084a4:	0f 83 c6 00 00 00    	jae    208570 <init_vdso_clock_gettime+0x560>
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info >> 4) & OK_BINDS)) continue;
  2084aa:	c0 e8 04             	shr    al,0x4
  2084ad:	0f b6 c0             	movzx  eax,al
  2084b0:	41 0f a3 c2          	bt     r10d,eax
  2084b4:	0f 83 b6 00 00 00    	jae    208570 <init_vdso_clock_gettime+0x560>
        if (0 == syms[i].st_shndx) continue;
  2084ba:	66 41 83 7c cd 06 00 	cmp    WORD PTR [r13+rcx*8+0x6],0x0
  2084c1:	0f 84 a9 00 00 00    	je     208570 <init_vdso_clock_gettime+0x560>
        if (!mem.eql(u8, name, cstr.toSliceConst(strings + syms[i].st_name))) continue;
  2084c7:	41 8b 5c cd 00       	mov    ebx,DWORD PTR [r13+rcx*8+0x0]
  2084cc:	4c 01 fb             	add    rbx,r15
  2084cf:	48 c7 c1 eb ff ff ff 	mov    rcx,0xffffffffffffffeb
  2084d6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2084dd:	00 00 00 
  2084e0:	80 7c 0b 15 00       	cmp    BYTE PTR [rbx+rcx*1+0x15],0x0
  2084e5:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  2084e9:	75 f5                	jne    2084e0 <init_vdso_clock_gettime+0x4d0>
    if (a.len != b.len) return false;
  2084eb:	48 85 c9             	test   rcx,rcx
  2084ee:	0f 85 7c 00 00 00    	jne    208570 <init_vdso_clock_gettime+0x560>
        if (b[index] != item) return false;
  2084f4:	80 3b 5f             	cmp    BYTE PTR [rbx],0x5f
  2084f7:	75 77                	jne    208570 <init_vdso_clock_gettime+0x560>
  2084f9:	80 7b 01 5f          	cmp    BYTE PTR [rbx+0x1],0x5f
  2084fd:	75 71                	jne    208570 <init_vdso_clock_gettime+0x560>
  2084ff:	80 7b 02 76          	cmp    BYTE PTR [rbx+0x2],0x76
  208503:	75 6b                	jne    208570 <init_vdso_clock_gettime+0x560>
  208505:	80 7b 03 64          	cmp    BYTE PTR [rbx+0x3],0x64
  208509:	75 65                	jne    208570 <init_vdso_clock_gettime+0x560>
  20850b:	80 7b 04 73          	cmp    BYTE PTR [rbx+0x4],0x73
  20850f:	75 5f                	jne    208570 <init_vdso_clock_gettime+0x560>
  208511:	80 7b 05 6f          	cmp    BYTE PTR [rbx+0x5],0x6f
  208515:	75 59                	jne    208570 <init_vdso_clock_gettime+0x560>
  208517:	80 7b 06 5f          	cmp    BYTE PTR [rbx+0x6],0x5f
  20851b:	75 53                	jne    208570 <init_vdso_clock_gettime+0x560>
  20851d:	80 7b 07 63          	cmp    BYTE PTR [rbx+0x7],0x63
  208521:	75 4d                	jne    208570 <init_vdso_clock_gettime+0x560>
  208523:	80 7b 08 6c          	cmp    BYTE PTR [rbx+0x8],0x6c
  208527:	75 47                	jne    208570 <init_vdso_clock_gettime+0x560>
  208529:	80 7b 09 6f          	cmp    BYTE PTR [rbx+0x9],0x6f
  20852d:	75 41                	jne    208570 <init_vdso_clock_gettime+0x560>
  20852f:	80 7b 0a 63          	cmp    BYTE PTR [rbx+0xa],0x63
  208533:	75 3b                	jne    208570 <init_vdso_clock_gettime+0x560>
  208535:	80 7b 0b 6b          	cmp    BYTE PTR [rbx+0xb],0x6b
  208539:	75 35                	jne    208570 <init_vdso_clock_gettime+0x560>
  20853b:	80 7b 0c 5f          	cmp    BYTE PTR [rbx+0xc],0x5f
  20853f:	75 2f                	jne    208570 <init_vdso_clock_gettime+0x560>
  208541:	80 7b 0d 67          	cmp    BYTE PTR [rbx+0xd],0x67
  208545:	75 29                	jne    208570 <init_vdso_clock_gettime+0x560>
  208547:	80 7b 0e 65          	cmp    BYTE PTR [rbx+0xe],0x65
  20854b:	75 23                	jne    208570 <init_vdso_clock_gettime+0x560>
  20854d:	80 7b 0f 74          	cmp    BYTE PTR [rbx+0xf],0x74
  208551:	75 1d                	jne    208570 <init_vdso_clock_gettime+0x560>
  208553:	80 7b 10 74          	cmp    BYTE PTR [rbx+0x10],0x74
  208557:	75 17                	jne    208570 <init_vdso_clock_gettime+0x560>
  208559:	80 7b 11 69          	cmp    BYTE PTR [rbx+0x11],0x69
  20855d:	75 11                	jne    208570 <init_vdso_clock_gettime+0x560>
  20855f:	80 7b 12 6d          	cmp    BYTE PTR [rbx+0x12],0x6d
  208563:	75 0b                	jne    208570 <init_vdso_clock_gettime+0x560>
  208565:	80 7b 13 65          	cmp    BYTE PTR [rbx+0x13],0x65
  208569:	74 36                	je     2085a1 <init_vdso_clock_gettime+0x591>
  20856b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    while (i < hashtab[1]) : (i += 1) {
  208570:	48 83 c2 01          	add    rdx,0x1
  208574:	4c 39 ca             	cmp    rdx,r9
  208577:	0f 82 13 ff ff ff    	jb     208490 <init_vdso_clock_gettime+0x480>
}
var vdso_clock_gettime = init_vdso_clock_gettime;
extern fn init_vdso_clock_gettime(clk: i32, ts: *timespec) usize {
    const addr = vdso.lookup(VDSO_CGT_VER, VDSO_CGT_SYM);
    var f = @intToPtr(@typeOf(init_vdso_clock_gettime), addr);
    _ = @cmpxchgStrong(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, init_vdso_clock_gettime, f, builtin.AtomicOrder.Monotonic, builtin.AtomicOrder.Monotonic);
  20857d:	48 8d 05 8c fa ff ff 	lea    rax,[rip+0xfffffffffffffa8c]        # 208010 <init_vdso_clock_gettime>
  208584:	31 c9                	xor    ecx,ecx
  208586:	f0 48 0f b1 0d a9 4a 	lock cmpxchg QWORD PTR [rip+0x14aa9],rcx        # 21d038 <vdso_clock_gettime>
  20858d:	01 00 
    if (@ptrToInt(f) == 0) return @bitCast(usize, isize(-ENOSYS));
  20858f:	48 c7 c0 da ff ff ff 	mov    rax,0xffffffffffffffda
  208596:	5b                   	pop    rbx
  208597:	41 5c                	pop    r12
  208599:	41 5d                	pop    r13
  20859b:	41 5e                	pop    r14
  20859d:	41 5f                	pop    r15
  20859f:	5d                   	pop    rbp
  2085a0:	c3                   	ret    
        return base + syms[i].st_value;
  2085a1:	48 8d 04 52          	lea    rax,[rdx+rdx*2]
  2085a5:	4d 03 44 c5 08       	add    r8,QWORD PTR [r13+rax*8+0x8]
    _ = @cmpxchgStrong(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, init_vdso_clock_gettime, f, builtin.AtomicOrder.Monotonic, builtin.AtomicOrder.Monotonic);
  2085aa:	48 8d 05 5f fa ff ff 	lea    rax,[rip+0xfffffffffffffa5f]        # 208010 <init_vdso_clock_gettime>
  2085b1:	f0 4c 0f b1 05 7e 4a 	lock cmpxchg QWORD PTR [rip+0x14a7e],r8        # 21d038 <vdso_clock_gettime>
  2085b8:	01 00 
    if (@ptrToInt(f) == 0) return @bitCast(usize, isize(-ENOSYS));
  2085ba:	4d 85 c0             	test   r8,r8
  2085bd:	74 d0                	je     20858f <init_vdso_clock_gettime+0x57f>
    return f(clk, ts);
  2085bf:	5b                   	pop    rbx
  2085c0:	41 5c                	pop    r12
  2085c2:	41 5d                	pop    r13
  2085c4:	41 5e                	pop    r14
  2085c6:	41 5f                	pop    r15
  2085c8:	5d                   	pop    rbp
  2085c9:	41 ff e0             	jmp    r8
  2085cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000002085d0 <Futex>:
    if (stderr_stream) |st| {
  2085d0:	55                   	push   rbp
  2085d1:	41 57                	push   r15
  2085d3:	41 56                	push   r14
  2085d5:	41 55                	push   r13
  2085d7:	41 54                	push   r12
  2085d9:	53                   	push   rbx
  2085da:	48 81 ec d8 00 00 00 	sub    rsp,0xd8
  2085e1:	48 8b 3d 48 8a 01 00 	mov    rdi,QWORD PTR [rip+0x18a48]        # 221030 <stderr_stream>
  2085e8:	48 85 ff             	test   rdi,rdi
  2085eb:	74 09                	je     2085f6 <Futex+0x26>
        pub const Error = WriteError;

        writeFn: fn (self: *Self, bytes: []const u8) Error!void,

        pub fn print(self: *Self, comptime format: []const u8, args: ...) !void {
            return std.fmt.format(self, Error, self.writeFn, format, args);
  2085ed:	48 8b 05 3c 4a 01 00 	mov    rax,QWORD PTR [rip+0x14a3c]        # 21d030 <stderr_file_out_stream+0x8>
  2085f4:	eb 34                	jmp    20862a <Futex+0x5a>
        stderr_file = try io.getStdErr();
  2085f6:	48 8d 05 23 4a 01 00 	lea    rax,[rip+0x14a23]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2085fd:	48 89 05 24 4a 01 00 	mov    QWORD PTR [rip+0x14a24],rax        # 21d028 <stderr_file_out_stream>
  208604:	48 8d 05 35 33 00 00 	lea    rax,[rip+0x3335]        # 20b940 <FileOutStream_writeFn>
  20860b:	48 89 05 1e 4a 01 00 	mov    QWORD PTR [rip+0x14a1e],rax        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  208612:	c7 05 04 4a 01 00 02 	mov    DWORD PTR [rip+0x14a04],0x2        # 21d020 <stderr_file>
  208619:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20861c:	48 8d 3d 0d 4a 01 00 	lea    rdi,[rip+0x14a0d]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  208623:	48 89 3d 06 8a 01 00 	mov    QWORD PTR [rip+0x18a06],rdi        # 221030 <stderr_stream>
        if (state != State.Start) {
            @compileError("Incomplete format string: " ++ fmt);
        }
    }
    if (start_index < fmt.len) {
        try output(context, fmt[start_index..]);
  20862a:	48 8d 35 27 85 01 00 	lea    rsi,[rip+0x18527]        # 220b58 <__unnamed_1>
  208631:	ff d0                	call   rax
    const Self = this;

    counter: u128,

    pub fn init(pSelf: *Self) void {
        pSelf.counter = 0;
  208633:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  208637:	c5 f8 11 05 c1 49 01 	vmovups XMMWORD PTR [rip+0x149c1],xmm0        # 21d000 <gProducer_context>
  20863e:	00 
  20863f:	c5 f8 11 05 c9 49 01 	vmovups XMMWORD PTR [rip+0x149c9],xmm0        # 21d010 <gConsumer_context>
  208646:	00 
                //On Linux, seccomp can do arbitrary things to our ability to call
                //  syscalls, including return any errno value it wants and
                //  inconsistently throwing errors. Since we can't account for
                //  abuses of seccomp in a reasonable way, we'll assume that if
                //  seccomp is going to block us it will at least do so consistently
                var ts: posix.timespec = undefined;
  208647:	c5 f9 10 05 51 7c ff 	vmovupd xmm0,XMMWORD PTR [rip+0xffffffffffff7c51]        # 2002a0 <__unnamed_2>
  20864e:	ff 
  20864f:	c5 f9 29 44 24 30    	vmovapd XMMWORD PTR [rsp+0x30],xmm0
  208655:	4c 8d 7c 24 30       	lea    r15,[rsp+0x30]
        : "rcx", "r11"
    );
}

pub fn syscall2(number: usize, arg1: usize, arg2: usize) usize {
    return asm volatile ("syscall"
  20865a:	b8 e5 00 00 00       	mov    eax,0xe5
  20865f:	bf 01 00 00 00       	mov    edi,0x1
  208664:	4c 89 fe             	mov    rsi,r15
  208667:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  208669:	48 89 c2             	mov    rdx,rax
  20866c:	48 f7 da             	neg    rdx
  20866f:	31 c9                	xor    ecx,ecx
  208671:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  208677:	48 0f 47 ca          	cmova  rcx,rdx
                var result = posix.clock_getres(monotonic_clock_id, &ts);
                var errno = posix.getErrno(result);
                switch (errno) {
  20867b:	48 85 c9             	test   rcx,rcx
  20867e:	74 13                	je     208693 <Futex+0xc3>
  208680:	48 83 f9 16          	cmp    rcx,0x16
  208684:	0f 85 7b 01 00 00    	jne    208805 <Futex+0x235>
  20868a:	66 bb 01 00          	mov    bx,0x1
  20868e:	e9 76 01 00 00       	jmp    208809 <Futex+0x239>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  208693:	48 8b 05 9e 49 01 00 	mov    rax,QWORD PTR [rip+0x1499e]        # 21d038 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20869a:	48 85 c0             	test   rax,rax
  20869d:	74 23                	je     2086c2 <Futex+0xf2>
  20869f:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
            const rc = f(clk_id, tp);
  2086a4:	bf 01 00 00 00       	mov    edi,0x1
  2086a9:	ff d0                	call   rax
            switch (rc) {
  2086ab:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  2086af:	0f 84 89 01 00 00    	je     20883e <Futex+0x26e>
  2086b5:	48 85 c0             	test   rax,rax
  2086b8:	c5 f9 10 05 e0 7b ff 	vmovupd xmm0,XMMWORD PTR [rip+0xffffffffffff7be0]        # 2002a0 <__unnamed_2>
  2086bf:	ff 
  2086c0:	74 11                	je     2086d3 <Futex+0x103>
  2086c2:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2086c7:	b8 e4 00 00 00       	mov    eax,0xe4
  2086cc:	bf 01 00 00 00       	mov    edi,0x1
  2086d1:	0f 05                	syscall 
  2086d3:	66 bb 02 00          	mov    bx,0x2
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2086d7:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                }
                self.resolution = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);

                result = posix.clock_gettime(monotonic_clock_id, &ts);
                errno = posix.getErrno(result);
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  2086dd:	0f 83 26 01 00 00    	jae    208809 <Futex+0x239>
    fn clockDarwin() u64 {
        return darwin.mach_absolute_time();
    }

    fn clockLinux() u64 {
        var ts: posix.timespec = undefined;
  2086e3:	c5 f9 29 44 24 30    	vmovapd XMMWORD PTR [rsp+0x30],xmm0
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  2086e9:	48 8b 05 48 49 01 00 	mov    rax,QWORD PTR [rip+0x14948]        # 21d038 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  2086f0:	48 85 c0             	test   rax,rax
  2086f3:	74 17                	je     20870c <Futex+0x13c>
  2086f5:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
            const rc = f(clk_id, tp);
  2086fa:	bf 01 00 00 00       	mov    edi,0x1
  2086ff:	ff d0                	call   rax
            switch (rc) {
  208701:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  208705:	74 16                	je     20871d <Futex+0x14d>
  208707:	48 85 c0             	test   rax,rax
  20870a:	74 11                	je     20871d <Futex+0x14d>
  20870c:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  208711:	b8 e4 00 00 00       	mov    eax,0xe4
  208716:	bf 01 00 00 00       	mov    edi,0x1
  20871b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20871d:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  208723:	0f 83 89 0f 00 00    	jae    2096b2 <Futex+0x10e2>
    arg3: usize,
    arg4: usize,
    arg5: usize,
    arg6: usize,
) usize {
    return asm volatile ("syscall"
  208729:	b8 09 00 00 00       	mov    eax,0x9
  20872e:	31 ff                	xor    edi,edi
  208730:	be 00 00 80 00       	mov    esi,0x800000
  208735:	ba 03 00 00 00       	mov    edx,0x3
  20873a:	41 ba 22 01 00 00    	mov    r10d,0x122
  208740:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  208747:	45 31 c9             	xor    r9d,r9d
  20874a:	0f 05                	syscall 
  20874c:	48 89 c3             	mov    rbx,rax

    const MAP_GROWSDOWN = if (builtin.os == builtin.Os.linux) linux.MAP_GROWSDOWN else 0;

    const mmap_len = default_stack_size;
    const stack_addr = posix.mmap(null, mmap_len, posix.PROT_READ | posix.PROT_WRITE, posix.MAP_PRIVATE | posix.MAP_ANONYMOUS | MAP_GROWSDOWN, -1, 0);
    if (stack_addr == posix.MAP_FAILED) return error.OutOfMemory;
  20874f:	48 83 fb ff          	cmp    rbx,0xffffffffffffffff
  208753:	0f 84 ad 02 00 00    	je     208a06 <Futex+0x436>
    errdefer assert(posix.munmap(stack_addr, mmap_len) == 0);

    var stack_end: usize = stack_addr + mmap_len;
    var arg: usize = undefined;
    if (@sizeOf(Context) != 0) {
        stack_end -= @sizeOf(Context);
  208759:	48 8d 8b f8 ff 7f 00 	lea    rcx,[rbx+0x7ffff8]
        stack_end -= stack_end % @alignOf(Context);
  208760:	48 83 e1 f8          	and    rcx,0xfffffffffffffff8
        assert(stack_end >= stack_addr);
  208764:	48 39 d9             	cmp    rcx,rbx
  208767:	0f 82 45 0f 00 00    	jb     2096b2 <Futex+0x10e2>
  20876d:	4c 8b 6c 24 30       	mov    r13,QWORD PTR [rsp+0x30]
  208772:	4c 8b 64 24 38       	mov    r12,QWORD PTR [rsp+0x38]
        const context_ptr = @alignCast(@alignOf(Context), @intToPtr(*Context, stack_end));
        context_ptr.* = context;
  208777:	48 8d 05 82 48 01 00 	lea    rax,[rip+0x14882]        # 21d000 <gProducer_context>
  20877e:	48 89 01             	mov    QWORD PTR [rcx],rax
        arg = stack_end;
    }

    stack_end -= @sizeOf(Thread);
  208781:	48 8d 69 e8          	lea    rbp,[rcx-0x18]
    stack_end -= stack_end % @alignOf(Thread);
    assert(stack_end >= stack_addr);
  208785:	48 39 dd             	cmp    rbp,rbx
  208788:	0f 82 24 0f 00 00    	jb     2096b2 <Futex+0x10e2>
    const thread_ptr = @alignCast(@alignOf(Thread), @intToPtr(*Thread, stack_end));

    thread_ptr.data.stack_addr = stack_addr;
  20878e:	48 89 59 f0          	mov    QWORD PTR [rcx-0x10],rbx
    thread_ptr.data.stack_len = mmap_len;
  208792:	48 c7 41 f8 00 00 80 	mov    QWORD PTR [rcx-0x8],0x800000
  208799:	00 
        }
    } else if (builtin.os == builtin.Os.linux) {
        // use linux API directly.  TODO use posix.CLONE_SETTLS and initialize thread local storage correctly
        const flags = posix.CLONE_VM | posix.CLONE_FS | posix.CLONE_FILES | posix.CLONE_SIGHAND | posix.CLONE_THREAD | posix.CLONE_SYSVSEM | posix.CLONE_PARENT_SETTID | posix.CLONE_CHILD_CLEARTID | posix.CLONE_DETACHED;
        const newtls: usize = 0;
        const rc = posix.clone(MainFuncs.linuxThreadMain, stack_end, flags, arg, &thread_ptr.data.handle, newtls, &thread_ptr.data.handle);
  20879a:	48 89 2c 24          	mov    QWORD PTR [rsp],rbp
  20879e:	48 8d 3d 2b 30 00 00 	lea    rdi,[rip+0x302b]        # 20b7d0 <MainFuncs_linuxThreadMain>
  2087a5:	45 31 f6             	xor    r14d,r14d
  2087a8:	ba 00 0f 75 00       	mov    edx,0x750f00
  2087ad:	45 31 c9             	xor    r9d,r9d
  2087b0:	48 89 ee             	mov    rsi,rbp
  2087b3:	49 89 e8             	mov    r8,rbp
  2087b6:	e8 d5 0f 01 00       	call   219790 <clone>
  2087bb:	48 89 c1             	mov    rcx,rax
  2087be:	48 f7 d9             	neg    rcx
  2087c1:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2087c7:	49 0f 46 ce          	cmovbe rcx,r14
        const err = posix.getErrno(rc);
        switch (err) {
  2087cb:	48 85 c9             	test   rcx,rcx
  2087ce:	0f 84 84 00 00 00    	je     208858 <Futex+0x288>
    return asm volatile ("syscall"
  2087d4:	b8 0b 00 00 00       	mov    eax,0xb
  2087d9:	be 00 00 80 00       	mov    esi,0x800000
  2087de:	48 89 df             	mov    rdi,rbx
  2087e1:	48 83 f9 0b          	cmp    rcx,0xb
  2087e5:	0f 84 24 02 00 00    	je     208a0f <Futex+0x43f>
  2087eb:	48 83 f9 0c          	cmp    rcx,0xc
  2087ef:	0f 85 2e 02 00 00    	jne    208a23 <Futex+0x453>
  2087f5:	0f 05                	syscall 
  2087f7:	66 bb 04 00          	mov    bx,0x4
  2087fb:	48 85 c0             	test   rax,rax
  2087fe:	74 09                	je     208809 <Futex+0x239>
  208800:	e9 ad 0e 00 00       	jmp    2096b2 <Futex+0x10e2>
  208805:	66 bb 02 00          	mov    bx,0x2
  208809:	48 8b 3d f8 87 01 00 	mov    rdi,QWORD PTR [rip+0x187f8]        # 221008 <gConsumer_wait_count>
  208810:	48 03 3d e9 87 01 00 	add    rdi,QWORD PTR [rip+0x187e9]        # 221000 <gProducer_wait_count>
  208817:	48 8b 35 fa 87 01 00 	mov    rsi,QWORD PTR [rip+0x187fa]        # 221018 <gConsumer_wake_count>
  20881e:	48 03 35 eb 87 01 00 	add    rsi,QWORD PTR [rip+0x187eb]        # 221010 <gProducer_wake_count>
  208825:	e8 46 15 00 00       	call   209d70 <warn.16>
  20882a:	89 d8                	mov    eax,ebx
  20882c:	48 81 c4 d8 00 00 00 	add    rsp,0xd8
  208833:	5b                   	pop    rbx
  208834:	41 5c                	pop    r12
  208836:	41 5d                	pop    r13
  208838:	41 5e                	pop    r14
  20883a:	41 5f                	pop    r15
  20883c:	5d                   	pop    rbp
  20883d:	c3                   	ret    
  20883e:	c5 f9 10 05 5a 7a ff 	vmovupd xmm0,XMMWORD PTR [rip+0xffffffffffff7a5a]        # 2002a0 <__unnamed_2>
  208845:	ff 
  208846:	66 bb 02 00          	mov    bx,0x2
  20884a:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  208850:	0f 82 8d fe ff ff    	jb     2086e3 <Futex+0x113>
  208856:	eb b1                	jmp    208809 <Futex+0x239>
    return asm volatile ("syscall"
  208858:	b8 09 00 00 00       	mov    eax,0x9
  20885d:	31 ff                	xor    edi,edi
  20885f:	be 00 00 80 00       	mov    esi,0x800000
  208864:	ba 03 00 00 00       	mov    edx,0x3
  208869:	41 ba 22 01 00 00    	mov    r10d,0x122
  20886f:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  208876:	45 31 c9             	xor    r9d,r9d
  208879:	0f 05                	syscall 
  20887b:	48 89 c3             	mov    rbx,rax
    if (stack_addr == posix.MAP_FAILED) return error.OutOfMemory;
  20887e:	48 83 fb ff          	cmp    rbx,0xffffffffffffffff
  208882:	0f 84 7e 01 00 00    	je     208a06 <Futex+0x436>
        stack_end -= @sizeOf(Context);
  208888:	48 8d 8b f8 ff 7f 00 	lea    rcx,[rbx+0x7ffff8]
        stack_end -= stack_end % @alignOf(Context);
  20888f:	48 83 e1 f8          	and    rcx,0xfffffffffffffff8
        assert(stack_end >= stack_addr);
  208893:	48 39 d9             	cmp    rcx,rbx
  208896:	0f 82 16 0e 00 00    	jb     2096b2 <Futex+0x10e2>
  20889c:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
        context_ptr.* = context;
  2088a1:	48 8d 05 68 47 01 00 	lea    rax,[rip+0x14768]        # 21d010 <gConsumer_context>
  2088a8:	48 89 01             	mov    QWORD PTR [rcx],rax
    stack_end -= @sizeOf(Thread);
  2088ab:	4c 8d 71 e8          	lea    r14,[rcx-0x18]
    assert(stack_end >= stack_addr);
  2088af:	49 39 de             	cmp    r14,rbx
  2088b2:	0f 82 fa 0d 00 00    	jb     2096b2 <Futex+0x10e2>
    thread_ptr.data.stack_addr = stack_addr;
  2088b8:	48 89 59 f0          	mov    QWORD PTR [rcx-0x10],rbx
    thread_ptr.data.stack_len = mmap_len;
  2088bc:	48 c7 41 f8 00 00 80 	mov    QWORD PTR [rcx-0x8],0x800000
  2088c3:	00 
        const rc = posix.clone(MainFuncs.linuxThreadMain, stack_end, flags, arg, &thread_ptr.data.handle, newtls, &thread_ptr.data.handle);
  2088c4:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  2088c8:	48 8d 3d b1 2f 00 00 	lea    rdi,[rip+0x2fb1]        # 20b880 <MainFuncs_linuxThreadMain.21>
  2088cf:	45 31 e4             	xor    r12d,r12d
  2088d2:	ba 00 0f 75 00       	mov    edx,0x750f00
  2088d7:	45 31 c9             	xor    r9d,r9d
  2088da:	4c 89 f6             	mov    rsi,r14
  2088dd:	4d 89 f0             	mov    r8,r14
  2088e0:	e8 ab 0e 01 00       	call   219790 <clone>
  2088e5:	48 89 c1             	mov    rcx,rax
  2088e8:	48 f7 d9             	neg    rcx
  2088eb:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2088f1:	49 0f 46 cc          	cmovbe rcx,r12
        switch (err) {
  2088f5:	48 85 c9             	test   rcx,rcx
  2088f8:	74 49                	je     208943 <Futex+0x373>
    return asm volatile ("syscall"
  2088fa:	b8 0b 00 00 00       	mov    eax,0xb
  2088ff:	be 00 00 80 00       	mov    esi,0x800000
  208904:	48 89 df             	mov    rdi,rbx
  208907:	48 83 f9 0b          	cmp    rcx,0xb
  20890b:	0f 84 26 01 00 00    	je     208a37 <Futex+0x467>
  208911:	48 83 f9 0c          	cmp    rcx,0xc
  208915:	0f 85 30 01 00 00    	jne    208a4b <Futex+0x47b>
  20891b:	0f 05                	syscall 
  20891d:	66 bb 04 00          	mov    bx,0x4
  208921:	48 85 c0             	test   rax,rax
  208924:	0f 84 df fe ff ff    	je     208809 <Futex+0x239>
  20892a:	e9 83 0d 00 00       	jmp    2096b2 <Futex+0x10e2>
    return syscall4(SYS_futex, uaddr, futex_op, @bitCast(u32, val), @ptrToInt(timeout));
  20892f:	89 c2                	mov    edx,eax
    return asm volatile ("syscall"
  208931:	b8 ca 00 00 00       	mov    eax,0xca
  208936:	be 00 00 00 00       	mov    esi,0x0
  20893b:	45 31 d2             	xor    r10d,r10d
  20893e:	48 89 ef             	mov    rdi,rbp
  208941:	0f 05                	syscall 
                    const pid_value = @atomicLoad(i32, &self.data.handle, builtin.AtomicOrder.SeqCst);
  208943:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
                    if (pid_value == 0) break;
  208946:	85 c0                	test   eax,eax
  208948:	75 e5                	jne    20892f <Futex+0x35f>
                assert(posix.munmap(self.data.stack_addr, self.data.stack_len) == 0);
  20894a:	48 8b 7d 08          	mov    rdi,QWORD PTR [rbp+0x8]
  20894e:	48 8b 75 10          	mov    rsi,QWORD PTR [rbp+0x10]
    return asm volatile ("syscall"
  208952:	b8 0b 00 00 00       	mov    eax,0xb
  208957:	0f 05                	syscall 
  208959:	48 85 c0             	test   rax,rax
  20895c:	c5 f9 10 05 3c 79 ff 	vmovupd xmm0,XMMWORD PTR [rip+0xffffffffffff793c]        # 2002a0 <__unnamed_2>
  208963:	ff 
  208964:	74 19                	je     20897f <Futex+0x3af>
  208966:	e9 47 0d 00 00       	jmp    2096b2 <Futex+0x10e2>
  20896b:	89 c2                	mov    edx,eax
    return asm volatile ("syscall"
  20896d:	b8 ca 00 00 00       	mov    eax,0xca
  208972:	be 00 00 00 00       	mov    esi,0x0
  208977:	45 31 d2             	xor    r10d,r10d
  20897a:	4c 89 f7             	mov    rdi,r14
  20897d:	0f 05                	syscall 
                    const pid_value = @atomicLoad(i32, &self.data.handle, builtin.AtomicOrder.SeqCst);
  20897f:	41 8b 06             	mov    eax,DWORD PTR [r14]
                    if (pid_value == 0) break;
  208982:	85 c0                	test   eax,eax
  208984:	75 e5                	jne    20896b <Futex+0x39b>
                assert(posix.munmap(self.data.stack_addr, self.data.stack_len) == 0);
  208986:	49 8b 7e 08          	mov    rdi,QWORD PTR [r14+0x8]
  20898a:	49 8b 76 10          	mov    rsi,QWORD PTR [r14+0x10]
    return asm volatile ("syscall"
  20898e:	b8 0b 00 00 00       	mov    eax,0xb
  208993:	0f 05                	syscall 
  208995:	48 85 c0             	test   rax,rax
  208998:	0f 85 14 0d 00 00    	jne    2096b2 <Futex+0x10e2>
        var ts: posix.timespec = undefined;
  20899e:	c5 f9 29 44 24 30    	vmovapd XMMWORD PTR [rsp+0x30],xmm0
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  2089a4:	48 8b 05 8d 46 01 00 	mov    rax,QWORD PTR [rip+0x1468d]        # 21d038 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  2089ab:	48 85 c0             	test   rax,rax
  2089ae:	74 17                	je     2089c7 <Futex+0x3f7>
  2089b0:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
            const rc = f(clk_id, tp);
  2089b5:	bf 01 00 00 00       	mov    edi,0x1
  2089ba:	ff d0                	call   rax
            switch (rc) {
  2089bc:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  2089c0:	74 16                	je     2089d8 <Futex+0x408>
  2089c2:	48 85 c0             	test   rax,rax
  2089c5:	74 11                	je     2089d8 <Futex+0x408>
  2089c7:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2089cc:	b8 e4 00 00 00       	mov    eax,0xe4
  2089d1:	bf 01 00 00 00       	mov    edi,0x1
  2089d6:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2089d8:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  2089de:	0f 83 ce 0c 00 00    	jae    2096b2 <Futex+0x10e2>
        var result = posix.clock_gettime(monotonic_clock_id, &ts);
        debug.assert(posix.getErrno(result) == 0);
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  2089e4:	48 8b 6c 24 30       	mov    rbp,QWORD PTR [rsp+0x30]
  2089e9:	48 8b 5c 24 38       	mov    rbx,QWORD PTR [rsp+0x38]
    if (stderr_stream) |st| {
  2089ee:	4c 8b 35 3b 86 01 00 	mov    r14,QWORD PTR [rip+0x1863b]        # 221030 <stderr_stream>
  2089f5:	4d 85 f6             	test   r14,r14
  2089f8:	74 65                	je     208a5f <Futex+0x48f>
  2089fa:	4c 8b 25 2f 46 01 00 	mov    r12,QWORD PTR [rip+0x1462f]        # 21d030 <stderr_file_out_stream+0x8>
  208a01:	e9 8d 00 00 00       	jmp    208a93 <Futex+0x4c3>
  208a06:	66 bb 05 00          	mov    bx,0x5
  208a0a:	e9 fa fd ff ff       	jmp    208809 <Futex+0x239>
  208a0f:	0f 05                	syscall 
  208a11:	66 bb 03 00          	mov    bx,0x3
  208a15:	48 85 c0             	test   rax,rax
    if (!ok) {
  208a18:	0f 84 eb fd ff ff    	je     208809 <Futex+0x239>
  208a1e:	e9 8f 0c 00 00       	jmp    2096b2 <Futex+0x10e2>
  208a23:	0f 05                	syscall 
  208a25:	66 bb 02 00          	mov    bx,0x2
  208a29:	48 85 c0             	test   rax,rax
  208a2c:	0f 84 d7 fd ff ff    	je     208809 <Futex+0x239>
  208a32:	e9 7b 0c 00 00       	jmp    2096b2 <Futex+0x10e2>
  208a37:	0f 05                	syscall 
  208a39:	66 bb 03 00          	mov    bx,0x3
  208a3d:	48 85 c0             	test   rax,rax
  208a40:	0f 84 c3 fd ff ff    	je     208809 <Futex+0x239>
  208a46:	e9 67 0c 00 00       	jmp    2096b2 <Futex+0x10e2>
  208a4b:	0f 05                	syscall 
  208a4d:	66 bb 02 00          	mov    bx,0x2
  208a51:	48 85 c0             	test   rax,rax
  208a54:	0f 84 af fd ff ff    	je     208809 <Futex+0x239>
  208a5a:	e9 53 0c 00 00       	jmp    2096b2 <Futex+0x10e2>
        stderr_file = try io.getStdErr();
  208a5f:	48 8d 05 ba 45 01 00 	lea    rax,[rip+0x145ba]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  208a66:	48 89 05 bb 45 01 00 	mov    QWORD PTR [rip+0x145bb],rax        # 21d028 <stderr_file_out_stream>
  208a6d:	4c 8d 25 cc 2e 00 00 	lea    r12,[rip+0x2ecc]        # 20b940 <FileOutStream_writeFn>
  208a74:	4c 89 25 b5 45 01 00 	mov    QWORD PTR [rip+0x145b5],r12        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  208a7b:	c7 05 9b 45 01 00 02 	mov    DWORD PTR [rip+0x1459b],0x2        # 21d020 <stderr_file>
  208a82:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  208a85:	4c 8d 35 a4 45 01 00 	lea    r14,[rip+0x145a4]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  208a8c:	4c 89 35 9d 85 01 00 	mov    QWORD PTR [rip+0x1859d],r14        # 221030 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  208a93:	48 8d 35 fe 80 01 00 	lea    rsi,[rip+0x180fe]        # 220b98 <__unnamed_3>
  208a9a:	4c 89 f7             	mov    rdi,r14
  208a9d:	41 ff d4             	call   r12
  208aa0:	66 85 c0             	test   ax,ax
  208aa3:	74 39                	je     208ade <Futex+0x50e>

    var end_time = timer.read();
    var duration = end_time - start_time;
    warn("test Futex: time={.6}\n", @intToFloat(f64, end_time - start_time) / @intToFloat(f64, std.os.time.ns_per_s));

    assert(gCounter == max_counter * 2);
  208aa5:	48 81 3d 70 85 01 00 	cmp    QWORD PTR [rip+0x18570],0x1312d00        # 221020 <gCounter>
  208aac:	00 2d 31 01 
    if (!ok) {
  208ab0:	0f 85 fc 0b 00 00    	jne    2096b2 <Futex+0x10e2>
        gProducer_wait_count + gConsumer_wait_count, gProducer_wake_count + gConsumer_wake_count);
  208ab6:	48 8b 3d 4b 85 01 00 	mov    rdi,QWORD PTR [rip+0x1854b]        # 221008 <gConsumer_wait_count>
  208abd:	48 03 3d 3c 85 01 00 	add    rdi,QWORD PTR [rip+0x1853c]        # 221000 <gProducer_wait_count>
  208ac4:	48 8b 35 4d 85 01 00 	mov    rsi,QWORD PTR [rip+0x1854d]        # 221018 <gConsumer_wake_count>
  208acb:	48 03 35 3e 85 01 00 	add    rsi,QWORD PTR [rip+0x1853e]        # 221010 <gProducer_wake_count>
    defer warn("test Futex:- futex_wait counts={} futex_wake counts={}\n",
  208ad2:	e8 99 12 00 00       	call   209d70 <warn.16>
test "Futex" {
  208ad7:	31 c0                	xor    eax,eax
  208ad9:	e9 4e fd ff ff       	jmp    20882c <Futex+0x25c>
  208ade:	4c 29 ed             	sub    rbp,r13
  208ae1:	48 69 c5 00 ca 9a 3b 	imul   rax,rbp,0x3b9aca00
  208ae8:	48 2b 5c 24 10       	sub    rbx,QWORD PTR [rsp+0x10]
  208aed:	48 01 c3             	add    rbx,rax
  208af0:	c4 e1 f9 6e c3       	vmovq  xmm0,rbx
  208af5:	c5 f9 62 05 a3 76 ff 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff76a3]        # 2001a0 <__unnamed_156-0x10>
  208afc:	ff 
  208afd:	c5 f9 5c 05 cb 7b ff 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff7bcb]        # 2006d0 <__unnamed_62+0x10>
  208b04:	ff 
  208b05:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  208b09:	c5 fb 59 0d b7 80 ff 	vmulsd xmm1,xmm0,QWORD PTR [rip+0xffffffffffff80b7]        # 200bc8 <__unnamed_441+0x28>
  208b10:	ff 
    const bits = @bitCast(u32, x);
    return bits >> 31 != 0;
}

fn signbit64(x: f64) bool {
    const bits = @bitCast(u64, x);
  208b11:	c4 e1 f9 7e c8       	vmovq  rax,xmm1
    return bits >> 63 != 0;
  208b16:	48 85 c0             	test   rax,rax
    output: fn (@typeOf(context), []const u8) Errors!void,
) Errors!void {
    var x = f64(value);

    // Errol doesn't handle these special cases.
    if (math.signbit(x)) {
  208b19:	78 44                	js     208b5f <Futex+0x58f>
  208b1b:	48 b8 00 00 00 00 00 	movabs rax,0x7ff0000000000000
  208b22:	00 f0 7f 
        f32 => {
            const bits = @bitCast(u32, x);
            return bits & 0x7FFFFFFF > 0x7F800000;
        },
        f64 => {
            const bits = @bitCast(u64, x);
  208b25:	c4 e1 f9 7e cd       	vmovq  rbp,xmm1
            return (bits & (@maxValue(u64) >> 1)) > (u64(0x7FF) << 52);
  208b2a:	b1 3f                	mov    cl,0x3f
  208b2c:	c4 e2 f0 f5 cd       	bzhi   rcx,rbp,rcx
  208b31:	48 39 c1             	cmp    rcx,rax
        try output(context, "-");
        x = -x;
    }

    if (math.isNan(x)) {
  208b34:	76 09                	jbe    208b3f <Futex+0x56f>
        return output(context, "nan");
  208b36:	48 8d 35 bb 82 01 00 	lea    rsi,[rip+0x182bb]        # 220df8 <__unnamed_4>
  208b3d:	eb 0c                	jmp    208b4b <Futex+0x57b>
        },
        f32 => {
            return @bitCast(u32, x) == 0x7F800000;
        },
        f64 => {
            return @bitCast(u64, x) == 0x7FF << 52;
  208b3f:	48 39 c5             	cmp    rbp,rax
    }
    if (math.isPositiveInf(x)) {
  208b42:	75 51                	jne    208b95 <Futex+0x5c5>
        return output(context, "inf");
  208b44:	48 8d 35 bd 82 01 00 	lea    rsi,[rip+0x182bd]        # 220e08 <__unnamed_5>
  208b4b:	4c 89 f7             	mov    rdi,r14
  208b4e:	41 ff d4             	call   r12
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  208b51:	66 85 c0             	test   ax,ax
  208b54:	0f 85 4b ff ff ff    	jne    208aa5 <Futex+0x4d5>
  208b5a:	e9 35 0b 00 00       	jmp    209694 <Futex+0x10c4>
  208b5f:	c5 f8 29 4c 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm1
        try output(context, "-");
  208b65:	48 8d 35 7c 82 01 00 	lea    rsi,[rip+0x1827c]        # 220de8 <__unnamed_6>
  208b6c:	4c 89 f7             	mov    rdi,r14
  208b6f:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  208b74:	41 ff d4             	call   r12
  208b77:	66 85 c0             	test   ax,ax
  208b7a:	0f 85 06 0b 00 00    	jne    209686 <Futex+0x10b6>
  208b80:	c5 f9 28 4c 24 10    	vmovapd xmm1,XMMWORD PTR [rsp+0x10]
        x = -x;
  208b86:	c5 f1 57 0d 62 7b ff 	vxorpd xmm1,xmm1,XMMWORD PTR [rip+0xffffffffffff7b62]        # 2006f0 <__unnamed_540+0x10>
  208b8d:	ff 
  208b8e:	4c 8b 64 24 08       	mov    r12,QWORD PTR [rsp+0x8]
  208b93:	eb 86                	jmp    208b1b <Futex+0x54b>
    }
    if (x == 0.0) {
  208b95:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  208b99:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  208b9d:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  208ba2:	0f 85 b2 00 00 00    	jne    208c5a <Futex+0x68a>
  208ba8:	0f 8a ac 00 00 00    	jp     208c5a <Futex+0x68a>
        try output(context, "0");
  208bae:	48 8d 35 73 82 01 00 	lea    rsi,[rip+0x18273]        # 220e28 <__unnamed_7>
  208bb5:	4c 89 f7             	mov    rdi,r14
  208bb8:	41 ff d4             	call   r12
  208bbb:	66 85 c0             	test   ax,ax
  208bbe:	0f 85 c2 0a 00 00    	jne    209686 <Futex+0x10b6>

        if (maybe_precision) |precision| {
            if (precision != 0) {
                try output(context, ".");
  208bc4:	48 8d 35 4d 82 01 00 	lea    rsi,[rip+0x1824d]        # 220e18 <__unnamed_8>
  208bcb:	4c 89 f7             	mov    rdi,r14
  208bce:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  208bd2:	66 85 c0             	test   ax,ax
  208bd5:	0f 85 ab 0a 00 00    	jne    209686 <Futex+0x10b6>
                var i: usize = 0;
                while (i < precision) : (i += 1) {
                    try output(context, "0");
  208bdb:	48 8d 35 46 82 01 00 	lea    rsi,[rip+0x18246]        # 220e28 <__unnamed_7>
  208be2:	4c 89 f7             	mov    rdi,r14
  208be5:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  208be9:	66 85 c0             	test   ax,ax
  208bec:	0f 85 94 0a 00 00    	jne    209686 <Futex+0x10b6>
  208bf2:	48 8d 35 2f 82 01 00 	lea    rsi,[rip+0x1822f]        # 220e28 <__unnamed_7>
  208bf9:	4c 89 f7             	mov    rdi,r14
  208bfc:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  208c00:	66 85 c0             	test   ax,ax
  208c03:	0f 85 7d 0a 00 00    	jne    209686 <Futex+0x10b6>
  208c09:	48 8d 35 18 82 01 00 	lea    rsi,[rip+0x18218]        # 220e28 <__unnamed_7>
  208c10:	4c 89 f7             	mov    rdi,r14
  208c13:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  208c17:	66 85 c0             	test   ax,ax
  208c1a:	0f 85 66 0a 00 00    	jne    209686 <Futex+0x10b6>
  208c20:	48 8d 35 01 82 01 00 	lea    rsi,[rip+0x18201]        # 220e28 <__unnamed_7>
  208c27:	4c 89 f7             	mov    rdi,r14
  208c2a:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  208c2e:	66 85 c0             	test   ax,ax
  208c31:	0f 85 4f 0a 00 00    	jne    209686 <Futex+0x10b6>
  208c37:	48 8d 35 ea 81 01 00 	lea    rsi,[rip+0x181ea]        # 220e28 <__unnamed_7>
  208c3e:	4c 89 f7             	mov    rdi,r14
  208c41:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  208c45:	66 85 c0             	test   ax,ax
  208c48:	0f 85 38 0a 00 00    	jne    209686 <Futex+0x10b6>
  208c4e:	48 8d 35 d3 81 01 00 	lea    rsi,[rip+0x181d3]        # 220e28 <__unnamed_7>
  208c55:	e9 a2 0a 00 00       	jmp    2096fc <Futex+0x112c>
  208c5a:	c5 f8 29 4c 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm1

        return;
    }

    // non-special case, use errol3
    var buffer: [32]u8 = undefined;
  208c60:	c5 fd 10 05 78 80 ff 	vmovupd ymm0,YMMWORD PTR [rip+0xffffffffffff8078]        # 200ce0 <__unnamed_9>
  208c67:	ff 
  208c68:	c5 fd 11 44 24 30    	vmovupd YMMWORD PTR [rsp+0x30],ymm0
    var float_decimal = errol.errol3(x, buffer[0..]);
  208c6e:	4c 89 7c 24 20       	mov    QWORD PTR [rsp+0x20],r15
  208c73:	48 c7 44 24 28 20 00 	mov    QWORD PTR [rsp+0x28],0x20
  208c7a:	00 00 
  208c7c:	b8 b0 01 00 00       	mov    eax,0x1b0
  208c81:	31 d2                	xor    edx,edx
  208c83:	48 8d 0d d6 8c ff ff 	lea    rcx,[rip+0xffffffffffff8cd6]        # 201960 <enum3.12>
fn tableLowerBound(k: u64) usize {
    var i = enum3.len;
    var j: usize = 0;

    while (j < enum3.len) {
        if (enum3[j] < k) {
  208c8a:	48 39 2c d1          	cmp    QWORD PTR [rcx+rdx*8],rbp
  208c8e:	72 15                	jb     208ca5 <Futex+0x6d5>
  208c90:	48 89 d0             	mov    rax,rdx
  208c93:	48 01 d2             	add    rdx,rdx
  208c96:	48 83 c2 01          	add    rdx,0x1
    while (j < enum3.len) {
  208c9a:	48 81 fa b0 01 00 00 	cmp    rdx,0x1b0
  208ca1:	72 e7                	jb     208c8a <Futex+0x6ba>
  208ca3:	eb 10                	jmp    208cb5 <Futex+0x6e5>
  208ca5:	48 01 d2             	add    rdx,rdx
  208ca8:	48 83 c2 02          	add    rdx,0x2
  208cac:	48 81 fa b0 01 00 00 	cmp    rdx,0x1b0
  208cb3:	72 d5                	jb     208c8a <Futex+0x6ba>
    if (i < enum3.len and enum3[i] == bits) {
  208cb5:	48 3d af 01 00 00    	cmp    rax,0x1af
  208cbb:	77 48                	ja     208d05 <Futex+0x735>
  208cbd:	48 39 2c c1          	cmp    QWORD PTR [rcx+rax*8],rbp
  208cc1:	75 42                	jne    208d05 <Futex+0x735>
        const data = enum3_data[i];
  208cc3:	48 8d 04 40          	lea    rax,[rax+rax*2]
  208cc7:	48 8d 0d d2 55 01 00 	lea    rcx,[rip+0x155d2]        # 21e2a0 <enum3_data.13>
  208cce:	48 8b 14 c1          	mov    rdx,QWORD PTR [rcx+rax*8]
  208cd2:	4c 8b 7c c1 08       	mov    r15,QWORD PTR [rcx+rax*8+0x8]
    for (source) |s, i|
  208cd7:	49 8d 7f ff          	lea    rdi,[r15-0x1]
  208cdb:	44 89 fe             	mov    esi,r15d
  208cde:	83 e6 07             	and    esi,0x7
  208ce1:	48 83 ff 07          	cmp    rdi,0x7
  208ce5:	0f 83 6a 04 00 00    	jae    209155 <Futex+0xb85>
  208ceb:	31 ff                	xor    edi,edi
  208ced:	48 8d 6c 24 31       	lea    rbp,[rsp+0x31]
  208cf2:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  208cf7:	48 85 f6             	test   rsi,rsi
  208cfa:	0f 85 bc 04 00 00    	jne    2091bc <Futex+0xbec>
  208d00:	e9 d5 04 00 00       	jmp    2091da <Futex+0xc0a>
  208d05:	c5 f9 28 44 24 10    	vmovapd xmm0,XMMWORD PTR [rsp+0x10]
    if (val > 9.007199254740992e15 and val < 3.40282366920938e+38) {
  208d0b:	c5 f9 2e 05 75 7f ff 	vucomisd xmm0,QWORD PTR [rip+0xffffffffffff7f75]        # 200c88 <app_mask+0x50>
  208d12:	ff 
  208d13:	0f 86 44 02 00 00    	jbe    208f5d <Futex+0x98d>
  208d19:	c5 fb 10 0d 27 7f ff 	vmovsd xmm1,QWORD PTR [rip+0xffffffffffff7f27]        # 200c48 <app_mask+0x10>
  208d20:	ff 
  208d21:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  208d25:	0f 86 32 02 00 00    	jbe    208f5d <Futex+0x98d>
fn errolInt(val: f64, buffer: []u8) FloatDecimal {
    const pow19 = u128(1e19);

    assert((val > 9.007199254740992e15) and val < (3.40282366920938e38));

    var mid = @floatToInt(u128, val);
  208d2b:	c5 f8 77             	vzeroupper 
  208d2e:	e8 2d 2e 01 00       	call   21bb60 <__fixunsdfti>
  208d33:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  208d38:	48 89 54 24 60       	mov    QWORD PTR [rsp+0x60],rdx
        .exp = exp,
    };
}

fn fpnext(val: f64) f64 {
    return @bitCast(f64, @bitCast(u64, val) +% 1);
  208d3d:	48 8d 45 01          	lea    rax,[rbp+0x1]
  208d41:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
    var low: u128 = mid - fpeint((fpnext(val) - val) / 2.0);
  208d46:	c5 fb 5c 44 24 10    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x10]
  208d4c:	c5 fb 59 05 b4 7e ff 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xffffffffffff7eb4]        # 200c08 <__unnamed_441+0x68>
  208d53:	ff 

    return buf_index;
}

fn fpeint(from: f64) u128 {
    const bits = @bitCast(u64, from);
  208d54:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    assert((bits & ((1 << 52) - 1)) == 0);
  208d59:	48 89 c8             	mov    rax,rcx
  208d5c:	48 c1 e0 0c          	shl    rax,0xc
  208d60:	0f 85 4c 09 00 00    	jne    2096b2 <Futex+0x10e2>
  208d66:	48 ba ff ff ff ff ff 	movabs rdx,0xfffffffffffff
  208d6d:	ff 0f 00 
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  208d70:	48 8d 45 ff          	lea    rax,[rbp-0x1]
  208d74:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
    var high: u128 = mid + fpeint((val - fpprev(val)) / 2.0);
  208d79:	c5 f9 28 4c 24 10    	vmovapd xmm1,XMMWORD PTR [rsp+0x10]
  208d7f:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
  208d83:	c5 fb 59 05 7d 7e ff 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xffffffffffff7e7d]        # 200c08 <__unnamed_441+0x68>
  208d8a:	ff 
    const bits = @bitCast(u64, from);
  208d8b:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
    assert((bits & ((1 << 52) - 1)) == 0);
  208d90:	48 85 d0             	test   rax,rdx
  208d93:	0f 85 19 09 00 00    	jne    2096b2 <Futex+0x10e2>

    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  208d99:	48 c1 e9 34          	shr    rcx,0x34
  208d9d:	83 c1 01             	add    ecx,0x1
  208da0:	83 e1 7f             	and    ecx,0x7f
  208da3:	41 b8 01 00 00 00    	mov    r8d,0x1
  208da9:	31 ff                	xor    edi,edi
  208dab:	4c 0f a5 c7          	shld   rdi,r8,cl

    var i: i32 = 0;
    var a_copy = a;
    var b_copy = b;

    if (af != bf) {
  208daf:	31 d2                	xor    edx,edx
    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  208db1:	c4 c2 f1 f7 f0       	shlx   rsi,r8,rcx
  208db6:	f6 c1 40             	test   cl,0x40
  208db9:	48 0f 45 fe          	cmovne rdi,rsi
  208dbd:	48 0f 45 f2          	cmovne rsi,rdx
    if (af != bf) {
  208dc1:	45 31 d2             	xor    r10d,r10d
  208dc4:	4c 8b 7c 24 50       	mov    r15,QWORD PTR [rsp+0x50]
    var low: u128 = mid - fpeint((fpnext(val) - val) / 2.0);
  208dc9:	4c 89 fb             	mov    rbx,r15
  208dcc:	48 29 f3             	sub    rbx,rsi
  208dcf:	4c 8b 4c 24 60       	mov    r9,QWORD PTR [rsp+0x60]
  208dd4:	4c 89 ce             	mov    rsi,r9
  208dd7:	48 19 fe             	sbb    rsi,rdi
    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  208dda:	48 c1 e8 34          	shr    rax,0x34
  208dde:	83 c0 01             	add    eax,0x1
  208de1:	83 e0 7f             	and    eax,0x7f
  208de4:	31 ff                	xor    edi,edi
  208de6:	89 c1                	mov    ecx,eax
  208de8:	4c 0f a5 c7          	shld   rdi,r8,cl
  208dec:	c4 c2 f9 f7 c8       	shlx   rcx,r8,rax
  208df1:	a8 40                	test   al,0x40
  208df3:	48 0f 45 f9          	cmovne rdi,rcx
  208df7:	49 0f 45 ca          	cmovne rcx,r10
    if (@bitCast(u64, val) & 0x1 != 0) {
  208dfb:	83 e5 01             	and    ebp,0x1
  208dfe:	31 c0                	xor    eax,eax
  208e00:	48 85 ed             	test   rbp,rbp
  208e03:	0f 94 c0             	sete   al
    var high: u128 = mid + fpeint((val - fpprev(val)) / 2.0);
  208e06:	49 29 ef             	sub    r15,rbp
  208e09:	4c 89 cd             	mov    rbp,r9
  208e0c:	48 83 dd 00          	sbb    rbp,0x0
    if (@bitCast(u64, val) & 0x1 != 0) {
  208e10:	49 01 cf             	add    r15,rcx
  208e13:	48 11 fd             	adc    rbp,rdi
  208e16:	48 29 c3             	sub    rbx,rax
  208e19:	48 83 de 00          	sbb    rsi,0x0
  208e1d:	49 bc 00 00 e8 89 04 	movabs r12,0x8ac7230489e80000
  208e24:	23 c7 8a 
    const lf = @intCast(u64, (low / pow19) % pow19);
  208e27:	31 c9                	xor    ecx,ecx
  208e29:	48 89 df             	mov    rdi,rbx
  208e2c:	4c 89 e2             	mov    rdx,r12
  208e2f:	e8 2c 38 01 00       	call   21c660 <__udivti3>
  208e34:	48 89 c1             	mov    rcx,rax
  208e37:	49 0f af cc          	imul   rcx,r12
  208e3b:	48 29 cb             	sub    rbx,rcx
  208e3e:	31 c9                	xor    ecx,ecx
  208e40:	48 89 c7             	mov    rdi,rax
  208e43:	48 89 d6             	mov    rsi,rdx
  208e46:	4c 89 e2             	mov    rdx,r12
  208e49:	e8 32 38 01 00       	call   21c680 <__umodti3>
  208e4e:	49 89 c5             	mov    r13,rax
    const hf = @intCast(u64, (high / pow19) % pow19);
  208e51:	31 c9                	xor    ecx,ecx
  208e53:	4c 89 ff             	mov    rdi,r15
  208e56:	48 89 ee             	mov    rsi,rbp
  208e59:	4c 89 e2             	mov    rdx,r12
  208e5c:	e8 ff 37 01 00       	call   21c660 <__udivti3>
  208e61:	48 89 c1             	mov    rcx,rax
  208e64:	49 0f af cc          	imul   rcx,r12
  208e68:	49 29 cf             	sub    r15,rcx
  208e6b:	31 c9                	xor    ecx,ecx
  208e6d:	48 89 c7             	mov    rdi,rax
  208e70:	48 89 d6             	mov    rsi,rdx
  208e73:	4c 89 e2             	mov    rdx,r12
  208e76:	e8 05 38 01 00       	call   21c680 <__umodti3>
    if (lf != hf) {
  208e7b:	49 39 c5             	cmp    r13,rax
  208e7e:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  208e83:	49 0f 45 dd          	cmovne rbx,r13
  208e87:	49 89 c5             	mov    r13,rax
  208e8a:	4c 0f 45 f8          	cmovne r15,rax
  208e8e:	48 b9 bf d5 ed bd ce 	movabs rcx,0xdbe6fecebdedd5bf
  208e95:	fe e6 db 
    const af = a / pow10;
  208e98:	48 89 da             	mov    rdx,rbx
  208e9b:	c4 e2 eb f6 c1       	mulx   rax,rdx,rcx
  208ea0:	48 c1 e8 21          	shr    rax,0x21
    const bf = b / pow10;
  208ea4:	4c 89 fa             	mov    rdx,r15
  208ea7:	c4 e2 eb f6 c9       	mulx   rcx,rdx,rcx
  208eac:	48 c1 e9 21          	shr    rcx,0x21
    if (af != bf) {
  208eb0:	48 39 c8             	cmp    rax,rcx
  208eb3:	bd 0a 00 00 00       	mov    ebp,0xa
  208eb8:	ba 00 00 00 00       	mov    edx,0x0
  208ebd:	0f 44 ea             	cmove  ebp,edx
  208ec0:	48 0f 44 c3          	cmove  rax,rbx
  208ec4:	49 0f 44 cf          	cmove  rcx,r15
  208ec8:	bb 01 00 00 00       	mov    ebx,0x1
        i = 10;
        a_copy = af;
        b_copy = bf;
    }

    while (true) : (i += 1) {
  208ecd:	29 eb                	sub    ebx,ebp
  208ecf:	83 c5 12             	add    ebp,0x12
  208ed2:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  208ed9:	cc cc cc 
        a_copy /= 10;
  208edc:	48 89 c2             	mov    rdx,rax
  208edf:	c4 e2 eb f6 c6       	mulx   rax,rdx,rsi
  208ee4:	48 c1 e8 03          	shr    rax,0x3
        b_copy /= 10;
  208ee8:	48 89 ca             	mov    rdx,rcx
  208eeb:	c4 e2 eb f6 ce       	mulx   rcx,rdx,rsi
  208ef0:	48 c1 e9 03          	shr    rcx,0x3

        if (a_copy == b_copy) return i;
  208ef4:	83 c3 ff             	add    ebx,0xffffffff
  208ef7:	83 c5 01             	add    ebp,0x1
  208efa:	48 39 c8             	cmp    rax,rcx
  208efd:	75 dd                	jne    208edc <Futex+0x90c>
    if (lf != hf) {
  208eff:	4c 39 6c 24 10       	cmp    QWORD PTR [rsp+0x10],r13
  208f04:	74 25                	je     208f2b <Futex+0x95b>
        mid = mid / (pow19 / 10);
  208f06:	48 ba 00 00 64 a7 b3 	movabs rdx,0xde0b6b3a7640000
  208f0d:	b6 e0 0d 
  208f10:	31 c9                	xor    ecx,ecx
  208f12:	48 8b 7c 24 50       	mov    rdi,QWORD PTR [rsp+0x50]
  208f17:	48 8b 74 24 60       	mov    rsi,QWORD PTR [rsp+0x60]
  208f1c:	e8 3f 37 01 00       	call   21c660 <__udivti3>
  208f21:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  208f26:	48 89 54 24 60       	mov    QWORD PTR [rsp+0x60],rdx
        var i: i32 = @boolToInt(lf == hf);
  208f2b:	31 c0                	xor    eax,eax
  208f2d:	4c 39 6c 24 10       	cmp    QWORD PTR [rsp+0x10],r13
  208f32:	0f 94 c0             	sete   al
        while (i < mi) : (i += 1) {
  208f35:	41 89 dc             	mov    r12d,ebx
  208f38:	41 f7 dc             	neg    r12d
  208f3b:	41 39 c4             	cmp    r12d,eax
  208f3e:	0f 86 6f 01 00 00    	jbe    2090b3 <Futex+0xae3>
  208f44:	89 c1                	mov    ecx,eax
  208f46:	f7 d9                	neg    ecx
  208f48:	29 d9                	sub    ecx,ebx
  208f4a:	83 f9 10             	cmp    ecx,0x10
  208f4d:	0f 83 c7 02 00 00    	jae    20921a <Futex+0xc4a>
  208f53:	ba 01 00 00 00       	mov    edx,0x1
  208f58:	e9 68 05 00 00       	jmp    2094c5 <Futex+0xef5>
    } else if (val >= 16.0 and val < 9.007199254740992e15) {
  208f5d:	c5 f9 2e 05 8b 7c ff 	vucomisd xmm0,QWORD PTR [rip+0xffffffffffff7c8b]        # 200bf0 <__unnamed_441+0x50>
  208f64:	ff 
  208f65:	0f 82 54 01 00 00    	jb     2090bf <Futex+0xaef>
  208f6b:	c5 fb 10 0d 15 7d ff 	vmovsd xmm1,QWORD PTR [rip+0xffffffffffff7d15]        # 200c88 <app_mask+0x50>
  208f72:	ff 
  208f73:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  208f77:	0f 86 42 01 00 00    	jbe    2090bf <Futex+0xaef>
    const u = @floatToInt(u64, val);
  208f7d:	c5 fb 10 15 d3 7c ff 	vmovsd xmm2,QWORD PTR [rip+0xffffffffffff7cd3]        # 200c58 <app_mask+0x20>
  208f84:	ff 
  208f85:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  208f89:	c4 e1 fb 2c c1       	vcvttsd2si rax,xmm1
  208f8e:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  208f95:	00 00 80 
  208f98:	48 31 c1             	xor    rcx,rax
  208f9b:	c4 e1 fb 2c f8       	vcvttsd2si rdi,xmm0
  208fa0:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  208fa4:	48 0f 43 f9          	cmovae rdi,rcx
    const n = @intToFloat(f64, u);
  208fa8:	c4 e1 f9 6e cf       	vmovq  xmm1,rdi
  208fad:	c5 f1 62 0d eb 71 ff 	vpunpckldq xmm1,xmm1,XMMWORD PTR [rip+0xffffffffffff71eb]        # 2001a0 <__unnamed_156-0x10>
  208fb4:	ff 
  208fb5:	c5 f1 5c 0d 13 77 ff 	vsubpd xmm1,xmm1,XMMWORD PTR [rip+0xffffffffffff7713]        # 2006d0 <__unnamed_62+0x10>
  208fbc:	ff 
  208fbd:	c5 f1 7c c9          	vhaddpd xmm1,xmm1,xmm1
  208fc1:	c5 f9 29 4c 24 60    	vmovapd XMMWORD PTR [rsp+0x60],xmm1
    var mid = val - n;
  208fc7:	c5 fb 5c c1          	vsubsd xmm0,xmm0,xmm1
    var buf_index = u64toa(u, buffer);
  208fcb:	c5 f9 29 44 24 50    	vmovapd XMMWORD PTR [rsp+0x50],xmm0
  208fd1:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  208fd6:	c5 f8 77             	vzeroupper 
  208fd9:	e8 22 f2 00 00       	call   218200 <u64toa>
  208fde:	49 89 c4             	mov    r12,rax
    buffer[j] = 0;
  208fe1:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  208fe6:	42 c6 04 20 00       	mov    BYTE PTR [rax+r12*1],0x0
    if (mid != 0.0) {
  208feb:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  208fef:	c5 f9 28 4c 24 50    	vmovapd xmm1,XMMWORD PTR [rsp+0x50]
  208ff5:	c5 f9 28 d9          	vmovapd xmm3,xmm1
  208ff9:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  208ffd:	0f 84 55 02 00 00    	je     209258 <Futex+0xc88>
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  209003:	c4 e2 79 59 4c 24 10 	vpbroadcastq xmm1,QWORD PTR [rsp+0x10]
  20900a:	c5 f1 d4 0d 7e 78 ff 	vpaddq xmm1,xmm1,XMMWORD PTR [rip+0xffffffffffff787e]        # 200890 <__unnamed_54+0x10>
  209011:	ff 
    var lo = ((fpprev(val) - n) + mid) / 2.0;
  209012:	c5 fb 12 54 24 60    	vmovddup xmm2,QWORD PTR [rsp+0x60]
  209018:	c5 f1 5c ca          	vsubpd xmm1,xmm1,xmm2
  20901c:	c5 f9 28 eb          	vmovapd xmm5,xmm3
  209020:	c5 fb 12 d5          	vmovddup xmm2,xmm5
  209024:	c5 f1 58 ca          	vaddpd xmm1,xmm1,xmm2
  209028:	c5 f1 59 1d 30 74 ff 	vmulpd xmm3,xmm1,XMMWORD PTR [rip+0xffffffffffff7430]        # 200460 <__unnamed_447+0x10>
  20902f:	ff 
  209030:	c5 f9 28 0d 78 72 ff 	vmovapd xmm1,XMMWORD PTR [rip+0xffffffffffff7278]        # 2002b0 <__unnamed_2+0x10>
  209037:	ff 
  209038:	c5 fb 10 15 80 7b ff 	vmovsd xmm2,QWORD PTR [rip+0xffffffffffff7b80]        # 200bc0 <__unnamed_441+0x20>
  20903f:	ff 
  209040:	4c 89 e1             	mov    rcx,r12
  209043:	48 89 c8             	mov    rax,rcx
            mid *= 10.0;
  209046:	c5 d3 59 e2          	vmulsd xmm4,xmm5,xmm2
            const mdig = @floatToInt(i32, mid);
  20904a:	c5 fb 2c cc          	vcvttsd2si ecx,xmm4
            mid -= @intToFloat(f64, mdig);
  20904e:	c5 cb 2a e9          	vcvtsi2sd xmm5,xmm6,ecx
  209052:	c5 db 5c ed          	vsubsd xmm5,xmm4,xmm5
            buffer[j] = @intCast(u8, mdig + '0');
  209056:	48 8b 54 24 20       	mov    rdx,QWORD PTR [rsp+0x20]
  20905b:	80 c1 30             	add    cl,0x30
  20905e:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            if (hdig != ldig or j > 50) break;
  209061:	48 83 f8 31          	cmp    rax,0x31
  209065:	77 2c                	ja     209093 <Futex+0xac3>
  209067:	c5 e1 59 d9          	vmulpd xmm3,xmm3,xmm1
  20906b:	c5 fb 2c cb          	vcvttsd2si ecx,xmm3
  20906f:	c4 e3 79 05 e3 01    	vpermilpd xmm4,xmm3,0x1
  209075:	c5 fb 2c d4          	vcvttsd2si edx,xmm4
  209079:	39 ca                	cmp    edx,ecx
  20907b:	75 16                	jne    209093 <Futex+0xac3>
            hi -= @intToFloat(f64, hdig);
  20907d:	c5 cb 2a e1          	vcvtsi2sd xmm4,xmm6,ecx
  209081:	48 8d 48 01          	lea    rcx,[rax+0x1]
            lo -= @intToFloat(f64, ldig);
  209085:	c5 fb 12 e4          	vmovddup xmm4,xmm4
  209089:	c5 e1 5c dc          	vsubpd xmm3,xmm3,xmm4
        while (mid != 0.0) {
  20908d:	c5 f9 2e e8          	vucomisd xmm5,xmm0
  209091:	75 b0                	jne    209043 <Futex+0xa73>
        if (mid > 0.5) {
  209093:	4c 8d 78 01          	lea    r15,[rax+0x1]
  209097:	c5 f9 2e 2d 69 7b ff 	vucomisd xmm5,QWORD PTR [rip+0xffffffffffff7b69]        # 200c08 <__unnamed_441+0x68>
  20909e:	ff 
  20909f:	0f 86 f8 01 00 00    	jbe    20929d <Futex+0xccd>
            buffer[j - 1] += 1;
  2090a5:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  2090aa:	80 04 01 01          	add    BYTE PTR [rcx+rax*1],0x1
  2090ae:	e9 30 07 00 00       	jmp    2097e3 <Futex+0x1213>
  2090b3:	31 c9                	xor    ecx,ecx
  2090b5:	ba 01 00 00 00       	mov    edx,0x1
  2090ba:	e9 18 04 00 00       	jmp    2094d7 <Futex+0xf07>
  2090bf:	48 8d bc 24 a8 00 00 	lea    rdi,[rsp+0xa8]
  2090c6:	00 

pub fn frexp(x: var) frexp_result(@typeOf(x)) {
    const T = @typeOf(x);
    return switch (T) {
        f32 => frexp32(x),
        f64 => frexp64(x),
  2090c7:	c5 f8 77             	vzeroupper 
  2090ca:	e8 21 f8 00 00       	call   2188f0 <frexp64>
    var exp = @floatToInt(i16, math.floor(307 + @intToFloat(f64, e) * 0.30103));
  2090cf:	c5 eb 2a 8c 24 b0 00 	vcvtsi2sd xmm1,xmm2,DWORD PTR [rsp+0xb0]
  2090d6:	00 00 
  2090d8:	c5 fb 10 05 18 7b ff 	vmovsd xmm0,QWORD PTR [rip+0xffffffffffff7b18]        # 200bf8 <__unnamed_441+0x58>
  2090df:	ff 
  2090e0:	c4 e2 f1 a9 05 2f 7b 	vfmadd213sd xmm0,xmm1,QWORD PTR [rip+0xffffffffffff7b2f]        # 200c18 <__unnamed_441+0x78>
  2090e7:	ff ff 
fn floor64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  2090e9:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  2090ed:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  2090f1:	75 06                	jne    2090f9 <Futex+0xb29>
  2090f3:	0f 8b 1a 07 00 00    	jnp    209813 <Futex+0x1243>
  2090f9:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  2090fe:	b9 34 0b 00 00       	mov    ecx,0xb34
  209103:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  209108:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  20910f:	0f 87 fe 06 00 00    	ja     209813 <Futex+0x1243>
        return x;
    }

    if (u >> 63 != 0) {
        @setFloatMode(this, builtin.FloatMode.Strict);
        y = x - math.f64_toint + math.f64_toint - x;
  209115:	c5 fb 10 15 cb 7a ff 	vmovsd xmm2,QWORD PTR [rip+0xffffffffffff7acb]        # 200be8 <__unnamed_441+0x48>
  20911c:	ff 
  20911d:	c5 fb 10 1d fb 7a ff 	vmovsd xmm3,QWORD PTR [rip+0xffffffffffff7afb]        # 200c20 <__unnamed_441+0x80>
  209124:	ff 
    if (u >> 63 != 0) {
  209125:	48 85 c0             	test   rax,rax
  209128:	0f 88 97 01 00 00    	js     2092c5 <Futex+0xcf5>
  20912e:	c5 fb 58 db          	vaddsd xmm3,xmm0,xmm3
  209132:	c5 e3 58 d2          	vaddsd xmm2,xmm3,xmm2
    } else {
        @setFloatMode(this, builtin.FloatMode.Strict);
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  209136:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  20913d:	0f 87 97 01 00 00    	ja     2092da <Futex+0xd0a>
    if (u >> 63 != 0) {
  209143:	48 85 c0             	test   rax,rax
        math.forceEval(y);
        if (u >> 63 != 0) {
  209146:	0f 88 b9 06 00 00    	js     209805 <Futex+0x1235>
  20914c:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  209150:	e9 be 06 00 00       	jmp    209813 <Futex+0x1243>
  209155:	4c 89 fd             	mov    rbp,r15
  209158:	48 29 f5             	sub    rbp,rsi
  20915b:	31 ff                	xor    edi,edi
  20915d:	0f b6 1c 3a          	movzx  ebx,BYTE PTR [rdx+rdi*1]
        dest[i] = s;
  209161:	88 5c 3c 31          	mov    BYTE PTR [rsp+rdi*1+0x31],bl
    for (source) |s, i|
  209165:	0f b6 5c 3a 01       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x1]
        dest[i] = s;
  20916a:	88 5c 3c 32          	mov    BYTE PTR [rsp+rdi*1+0x32],bl
    for (source) |s, i|
  20916e:	0f b6 5c 3a 02       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x2]
        dest[i] = s;
  209173:	88 5c 3c 33          	mov    BYTE PTR [rsp+rdi*1+0x33],bl
    for (source) |s, i|
  209177:	0f b6 5c 3a 03       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x3]
        dest[i] = s;
  20917c:	88 5c 3c 34          	mov    BYTE PTR [rsp+rdi*1+0x34],bl
    for (source) |s, i|
  209180:	0f b6 5c 3a 04       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x4]
        dest[i] = s;
  209185:	88 5c 3c 35          	mov    BYTE PTR [rsp+rdi*1+0x35],bl
    for (source) |s, i|
  209189:	0f b6 5c 3a 05       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x5]
        dest[i] = s;
  20918e:	88 5c 3c 36          	mov    BYTE PTR [rsp+rdi*1+0x36],bl
    for (source) |s, i|
  209192:	0f b6 5c 3a 06       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x6]
        dest[i] = s;
  209197:	88 5c 3c 37          	mov    BYTE PTR [rsp+rdi*1+0x37],bl
    for (source) |s, i|
  20919b:	0f b6 5c 3a 07       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x7]
        dest[i] = s;
  2091a0:	88 5c 3c 38          	mov    BYTE PTR [rsp+rdi*1+0x38],bl
    for (source) |s, i|
  2091a4:	48 83 c7 08          	add    rdi,0x8
  2091a8:	48 39 fd             	cmp    rbp,rdi
  2091ab:	75 b0                	jne    20915d <Futex+0xb8d>
  2091ad:	48 8d 6c 24 31       	lea    rbp,[rsp+0x31]
  2091b2:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  2091b7:	48 85 f6             	test   rsi,rsi
  2091ba:	74 1e                	je     2091da <Futex+0xc0a>
  2091bc:	48 8d 2c 3c          	lea    rbp,[rsp+rdi*1]
  2091c0:	48 83 c5 31          	add    rbp,0x31
  2091c4:	48 01 fa             	add    rdx,rdi
  2091c7:	31 ff                	xor    edi,edi
  2091c9:	0f b6 1c 3a          	movzx  ebx,BYTE PTR [rdx+rdi*1]
        dest[i] = s;
  2091cd:	88 5c 3d 00          	mov    BYTE PTR [rbp+rdi*1+0x0],bl
    for (source) |s, i|
  2091d1:	48 83 c7 01          	add    rdi,0x1
  2091d5:	48 39 fe             	cmp    rsi,rdi
  2091d8:	75 ef                	jne    2091c9 <Futex+0xbf9>
  2091da:	44 8b 64 c1 10       	mov    r12d,DWORD PTR [rcx+rax*8+0x10]
            if (float_decimal.exp >= 0) {
  2091df:	45 85 e4             	test   r12d,r12d
  2091e2:	0f 89 52 03 00 00    	jns    20953a <Futex+0xf6a>
                const min_exp_required = @intCast(usize, -float_decimal.exp);
  2091e8:	44 89 e0             	mov    eax,r12d
  2091eb:	f7 d8                	neg    eax
                if (precision > min_exp_required) {
  2091ed:	83 f8 05             	cmp    eax,0x5
  2091f0:	77 18                	ja     20920a <Futex+0xc3a>
                const min_exp_required = @intCast(usize, -float_decimal.exp);
  2091f2:	48 98                	cdqe   
                    round_digit = precision - min_exp_required;
  2091f4:	b9 06 00 00 00       	mov    ecx,0x6
  2091f9:	48 29 c1             	sub    rcx,rax
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  2091fc:	4c 39 f9             	cmp    rcx,r15
  2091ff:	0f 82 45 03 00 00    	jb     20954a <Futex+0xf7a>
  209205:	e9 db 03 00 00       	jmp    2095e5 <Futex+0x1015>
  20920a:	31 c9                	xor    ecx,ecx
  20920c:	4c 39 f9             	cmp    rcx,r15
  20920f:	0f 83 d0 03 00 00    	jae    2095e5 <Futex+0x1015>
  209215:	e9 30 03 00 00       	jmp    20954a <Futex+0xf7a>
        while (i < mi) : (i += 1) {
  20921a:	89 ce                	mov    esi,ecx
  20921c:	83 e6 f0             	and    esi,0xfffffff0
  20921f:	8d 7e f0             	lea    edi,[rsi-0x10]
  209222:	89 fa                	mov    edx,edi
  209224:	c1 ea 04             	shr    edx,0x4
  209227:	44 8d 42 01          	lea    r8d,[rdx+0x1]
  20922b:	83 ff 70             	cmp    edi,0x70
  20922e:	0f 83 c5 00 00 00    	jae    2092f9 <Futex+0xd29>
  209234:	c4 e2 7d 59 0d 03 7a 	vpbroadcastq ymm1,QWORD PTR [rip+0xffffffffffff7a03]        # 200c40 <app_mask+0x8>
  20923b:	ff ff 
  20923d:	c5 fd 6f d9          	vmovdqa ymm3,ymm1
  209241:	c5 fd 6f d1          	vmovdqa ymm2,ymm1
  209245:	c5 fd 6f c1          	vmovdqa ymm0,ymm1
  209249:	41 f6 c0 07          	test   r8b,0x7
  20924d:	0f 85 32 01 00 00    	jne    209385 <Futex+0xdb5>
  209253:	e9 a6 01 00 00       	jmp    2093fe <Futex+0xe2e>
        while (buffer[j - 1] == '0') {
  209258:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  20925d:	42 80 7c 21 ff 30    	cmp    BYTE PTR [rcx+r12*1-0x1],0x30
  209263:	0f 85 77 05 00 00    	jne    2097e0 <Futex+0x1210>
  209269:	49 8d 44 24 ff       	lea    rax,[r12-0x1]
  20926e:	4c 01 e1             	add    rcx,r12
  209271:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  209275:	4d 89 e7             	mov    r15,r12
            buffer[j - 1] = 0;
  209278:	c6 01 00             	mov    BYTE PTR [rcx],0x0
        while (buffer[j - 1] == '0') {
  20927b:	48 8b 54 24 20       	mov    rdx,QWORD PTR [rsp+0x20]
  209280:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  209284:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  209288:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20928c:	42 80 7c 3a fe 30    	cmp    BYTE PTR [rdx+r15*1-0x2],0x30
  209292:	4d 8d 7f ff          	lea    r15,[r15-0x1]
  209296:	74 e0                	je     209278 <Futex+0xca8>
  209298:	e9 46 05 00 00       	jmp    2097e3 <Futex+0x1213>
        } else if ((mid == 0.5) and (buffer[j - 1] & 0x1) != 0) {
  20929d:	0f 85 40 05 00 00    	jne    2097e3 <Futex+0x1213>
  2092a3:	0f 8a 3a 05 00 00    	jp     2097e3 <Futex+0x1213>
  2092a9:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  2092ae:	8a 14 01             	mov    dl,BYTE PTR [rcx+rax*1]
  2092b1:	f6 c2 01             	test   dl,0x1
  2092b4:	0f 84 29 05 00 00    	je     2097e3 <Futex+0x1213>
            buffer[j - 1] += 1;
  2092ba:	80 c2 01             	add    dl,0x1
  2092bd:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
  2092c0:	e9 1e 05 00 00       	jmp    2097e3 <Futex+0x1213>
  2092c5:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  2092c9:	c5 eb 58 d3          	vaddsd xmm2,xmm2,xmm3
    if (e <= 0x3FF - 1) {
  2092cd:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  2092d4:	0f 86 69 fe ff ff    	jbe    209143 <Futex+0xb73>
  2092da:	c5 eb 5c c0          	vsubsd xmm0,xmm2,xmm0
            return -1.0;
        } else {
            return 0.0;
        }
    } else if (y > 0) {
  2092de:	c5 e1 57 db          	vxorpd xmm3,xmm3,xmm3
  2092e2:	c5 f9 2e c3          	vucomisd xmm0,xmm3
  2092e6:	0f 86 23 05 00 00    	jbe    20980f <Futex+0x123f>
        return x + y - 1;
  2092ec:	c5 eb 58 05 0c 79 ff 	vaddsd xmm0,xmm2,QWORD PTR [rip+0xffffffffffff790c]        # 200c00 <__unnamed_441+0x60>
  2092f3:	ff 
  2092f4:	e9 1a 05 00 00       	jmp    209813 <Futex+0x1243>
        while (i < mi) : (i += 1) {
  2092f9:	44 89 c7             	mov    edi,r8d
  2092fc:	83 e7 07             	and    edi,0x7
  2092ff:	83 c7 ff             	add    edi,0xffffffff
  209302:	29 d7                	sub    edi,edx
  209304:	c4 e2 7d 59 0d 33 79 	vpbroadcastq ymm1,QWORD PTR [rip+0xffffffffffff7933]        # 200c40 <app_mask+0x8>
  20930b:	ff ff 
  20930d:	c4 e2 7d 59 25 ca 78 	vpbroadcastq ymm4,QWORD PTR [rip+0xffffffffffff78ca]        # 200be0 <__unnamed_441+0x40>
  209314:	ff ff 
  209316:	c5 fd 6f d9          	vmovdqa ymm3,ymm1
  20931a:	c5 fd 6f d1          	vmovdqa ymm2,ymm1
  20931e:	c5 fd 6f c1          	vmovdqa ymm0,ymm1
            x *= 10;
  209322:	c5 f5 f4 ec          	vpmuludq ymm5,ymm1,ymm4
  209326:	c5 f5 73 d1 20       	vpsrlq ymm1,ymm1,0x20
  20932b:	c5 f5 f4 cc          	vpmuludq ymm1,ymm1,ymm4
  20932f:	c5 f5 73 f1 20       	vpsllq ymm1,ymm1,0x20
  209334:	c5 d5 d4 c9          	vpaddq ymm1,ymm5,ymm1
  209338:	c5 e5 f4 ec          	vpmuludq ymm5,ymm3,ymm4
  20933c:	c5 e5 73 d3 20       	vpsrlq ymm3,ymm3,0x20
  209341:	c5 e5 f4 dc          	vpmuludq ymm3,ymm3,ymm4
  209345:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  20934a:	c5 d5 d4 db          	vpaddq ymm3,ymm5,ymm3
  20934e:	c5 ed f4 ec          	vpmuludq ymm5,ymm2,ymm4
  209352:	c5 ed 73 d2 20       	vpsrlq ymm2,ymm2,0x20
  209357:	c5 ed f4 d4          	vpmuludq ymm2,ymm2,ymm4
  20935b:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  209360:	c5 d5 d4 d2          	vpaddq ymm2,ymm5,ymm2
  209364:	c5 fd f4 ec          	vpmuludq ymm5,ymm0,ymm4
  209368:	c5 fd 73 d0 20       	vpsrlq ymm0,ymm0,0x20
  20936d:	c5 fd f4 c4          	vpmuludq ymm0,ymm0,ymm4
  209371:	c5 fd 73 f0 20       	vpsllq ymm0,ymm0,0x20
  209376:	c5 d5 d4 c0          	vpaddq ymm0,ymm5,ymm0
  20937a:	83 c7 08             	add    edi,0x8
  20937d:	75 a3                	jne    209322 <Futex+0xd52>
  20937f:	41 f6 c0 07          	test   r8b,0x7
  209383:	74 79                	je     2093fe <Futex+0xe2e>
  209385:	89 ca                	mov    edx,ecx
  209387:	83 e2 70             	and    edx,0x70
  20938a:	83 c2 f0             	add    edx,0xfffffff0
  20938d:	c1 ea 04             	shr    edx,0x4
  209390:	83 c2 01             	add    edx,0x1
  209393:	83 e2 07             	and    edx,0x7
  209396:	f7 da                	neg    edx
  209398:	c4 e2 7d 59 25 2f 78 	vpbroadcastq ymm4,QWORD PTR [rip+0xffffffffffff782f]        # 200bd0 <__unnamed_441+0x30>
  20939f:	ff ff 
  2093a1:	c5 f5 f4 ec          	vpmuludq ymm5,ymm1,ymm4
  2093a5:	c5 f5 73 d1 20       	vpsrlq ymm1,ymm1,0x20
  2093aa:	c5 f5 f4 cc          	vpmuludq ymm1,ymm1,ymm4
  2093ae:	c5 f5 73 f1 20       	vpsllq ymm1,ymm1,0x20
  2093b3:	c5 d5 d4 c9          	vpaddq ymm1,ymm5,ymm1
  2093b7:	c5 e5 f4 ec          	vpmuludq ymm5,ymm3,ymm4
  2093bb:	c5 e5 73 d3 20       	vpsrlq ymm3,ymm3,0x20
  2093c0:	c5 e5 f4 dc          	vpmuludq ymm3,ymm3,ymm4
  2093c4:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  2093c9:	c5 d5 d4 db          	vpaddq ymm3,ymm5,ymm3
  2093cd:	c5 ed f4 ec          	vpmuludq ymm5,ymm2,ymm4
  2093d1:	c5 ed 73 d2 20       	vpsrlq ymm2,ymm2,0x20
  2093d6:	c5 ed f4 d4          	vpmuludq ymm2,ymm2,ymm4
  2093da:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  2093df:	c5 d5 d4 d2          	vpaddq ymm2,ymm5,ymm2
  2093e3:	c5 fd f4 ec          	vpmuludq ymm5,ymm0,ymm4
  2093e7:	c5 fd 73 d0 20       	vpsrlq ymm0,ymm0,0x20
  2093ec:	c5 fd f4 c4          	vpmuludq ymm0,ymm0,ymm4
  2093f0:	c5 fd 73 f0 20       	vpsllq ymm0,ymm0,0x20
  2093f5:	c5 d5 d4 c0          	vpaddq ymm0,ymm5,ymm0
  2093f9:	83 c2 01             	add    edx,0x1
  2093fc:	75 a3                	jne    2093a1 <Futex+0xdd1>
  2093fe:	c5 dd 73 d3 20       	vpsrlq ymm4,ymm3,0x20
  209403:	c5 dd f4 e1          	vpmuludq ymm4,ymm4,ymm1
  209407:	c5 d5 73 d1 20       	vpsrlq ymm5,ymm1,0x20
  20940c:	c5 e5 f4 ed          	vpmuludq ymm5,ymm3,ymm5
  209410:	c5 d5 d4 e4          	vpaddq ymm4,ymm5,ymm4
  209414:	c5 dd 73 f4 20       	vpsllq ymm4,ymm4,0x20
  209419:	c5 e5 f4 c9          	vpmuludq ymm1,ymm3,ymm1
  20941d:	c5 f5 d4 cc          	vpaddq ymm1,ymm1,ymm4
  209421:	c5 e5 73 d2 20       	vpsrlq ymm3,ymm2,0x20
  209426:	c5 e5 f4 d9          	vpmuludq ymm3,ymm3,ymm1
  20942a:	c5 dd 73 d1 20       	vpsrlq ymm4,ymm1,0x20
  20942f:	c5 ed f4 e4          	vpmuludq ymm4,ymm2,ymm4
  209433:	c5 dd d4 db          	vpaddq ymm3,ymm4,ymm3
  209437:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  20943c:	c5 ed f4 c9          	vpmuludq ymm1,ymm2,ymm1
  209440:	c5 f5 d4 cb          	vpaddq ymm1,ymm1,ymm3
  209444:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  209449:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  20944d:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  209452:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  209456:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  20945a:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  20945f:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  209463:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  209467:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  20946d:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  209472:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  209476:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  20947b:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  20947f:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  209483:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  209488:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  20948c:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  209490:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  209495:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  20949a:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  20949e:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  2094a3:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  2094a7:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  2094ab:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  2094b0:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  2094b4:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  2094b8:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  2094bd:	39 f1                	cmp    ecx,esi
        while (i < mi) : (i += 1) {
  2094bf:	74 14                	je     2094d5 <Futex+0xf05>
  2094c1:	09 c6                	or     esi,eax
  2094c3:	89 f0                	mov    eax,esi
            x *= 10;
  2094c5:	f7 d8                	neg    eax
  2094c7:	29 d8                	sub    eax,ebx
  2094c9:	48 01 d2             	add    rdx,rdx
  2094cc:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
        while (i < mi) : (i += 1) {
  2094d0:	83 c0 ff             	add    eax,0xffffffff
  2094d3:	75 f4                	jne    2094c9 <Futex+0xef9>
    const m64 = @truncate(u64, @divTrunc(mid, x));
  2094d5:	31 c9                	xor    ecx,ecx
  2094d7:	48 8b 7c 24 50       	mov    rdi,QWORD PTR [rsp+0x50]
  2094dc:	48 8b 74 24 60       	mov    rsi,QWORD PTR [rsp+0x60]
  2094e1:	c5 f8 77             	vzeroupper 
  2094e4:	e8 77 31 01 00       	call   21c660 <__udivti3>
    if (lf != hf) {
  2094e9:	4c 39 6c 24 10       	cmp    QWORD PTR [rsp+0x10],r13
    if (lf != hf) mi += 19;
  2094ee:	44 0f 45 e5          	cmovne r12d,ebp
  2094f2:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
    var buf_index = u64toa(m64, buffer) - 1;
  2094f7:	48 89 c7             	mov    rdi,rax
  2094fa:	e8 01 ed 00 00       	call   218200 <u64toa>
  2094ff:	49 89 c7             	mov    r15,rax
    if (mi != 0) {
  209502:	45 85 e4             	test   r12d,r12d
  209505:	74 1d                	je     209524 <Futex+0xf54>
  209507:	4c 89 f8             	mov    rax,r15
  20950a:	48 83 c0 ff          	add    rax,0xffffffffffffffff
        buffer[buf_index - 1] += @boolToInt(buffer[buf_index] >= '5');
  20950e:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  209513:	42 80 7c 39 ff 34    	cmp    BYTE PTR [rcx+r15*1-0x1],0x34
  209519:	0f 97 c2             	seta   dl
  20951c:	42 00 54 39 fe       	add    BYTE PTR [rcx+r15*1-0x2],dl
  209521:	49 89 c7             	mov    r15,rax
        .digits = buffer[0..buf_index],
  209524:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        .exp = @intCast(i32, buf_index) + mi,
  209529:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20952e:	45 01 fc             	add    r12d,r15d
            if (float_decimal.exp >= 0) {
  209531:	45 85 e4             	test   r12d,r12d
  209534:	0f 88 ae fc ff ff    	js     2091e8 <Futex+0xc18>
                round_digit = precision + @intCast(usize, float_decimal.exp);
  20953a:	49 63 cc             	movsxd rcx,r12d
  20953d:	48 83 c1 06          	add    rcx,0x6
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  209541:	4c 39 f9             	cmp    rcx,r15
  209544:	0f 83 9b 00 00 00    	jae    2095e5 <Futex+0x1015>
  20954a:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  20954f:	8a 04 08             	mov    al,BYTE PTR [rax+rcx*1]
  209552:	04 d0                	add    al,0xd0
  209554:	3c 05                	cmp    al,0x5
  209556:	0f 82 89 00 00 00    	jb     2095e5 <Futex+0x1015>
            if (i == 0) {
  20955c:	48 85 c9             	test   rcx,rcx
  20955f:	74 6a                	je     2095cb <Futex+0xffb>
  209561:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  209566:	8a 44 0f ff          	mov    al,BYTE PTR [rdi+rcx*1-0x1]
  20956a:	04 d1                	add    al,0xd1
  20956c:	0f b6 f0             	movzx  esi,al
  20956f:	69 c6 cd 00 00 00    	imul   eax,esi,0xcd
  209575:	ba 0b 05 00 00       	mov    edx,0x50b
  20957a:	c4 e2 68 f7 c0       	bextr  eax,eax,edx
  20957f:	b3 0a                	mov    bl,0xa
  209581:	f6 e3                	mul    bl
  209583:	40 28 c6             	sub    sil,al
            float_decimal.digits[i] = new_value + '0';
  209586:	89 f0                	mov    eax,esi
  209588:	0c 30                	or     al,0x30
  20958a:	88 44 0f ff          	mov    BYTE PTR [rdi+rcx*1-0x1],al
            if (new_value != 0) {
  20958e:	40 84 f6             	test   sil,sil
  209591:	75 52                	jne    2095e5 <Futex+0x1015>
  209593:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
            if (i == 0) {
  209598:	48 83 f9 01          	cmp    rcx,0x1
  20959c:	74 2d                	je     2095cb <Futex+0xffb>
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  20959e:	0f b6 44 0f fe       	movzx  eax,BYTE PTR [rdi+rcx*1-0x2]
  2095a3:	04 d1                	add    al,0xd1
  2095a5:	0f b6 f0             	movzx  esi,al
  2095a8:	69 c6 cd 00 00 00    	imul   eax,esi,0xcd
  2095ae:	c4 e2 68 f7 c0       	bextr  eax,eax,edx
  2095b3:	f6 e3                	mul    bl
  2095b5:	40 28 c6             	sub    sil,al
            float_decimal.digits[i] = new_value + '0';
  2095b8:	89 f0                	mov    eax,esi
  2095ba:	0c 30                	or     al,0x30
  2095bc:	88 44 0f fe          	mov    BYTE PTR [rdi+rcx*1-0x2],al
            if (new_value != 0) {
  2095c0:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  2095c4:	40 84 f6             	test   sil,sil
  2095c7:	74 cf                	je     209598 <Futex+0xfc8>
  2095c9:	eb 1a                	jmp    2095e5 <Futex+0x1015>
                float_decimal.exp += 1;
  2095cb:	41 83 c4 01          	add    r12d,0x1
                float_decimal.digits = one_before[0 .. float_decimal.digits.len + 1];
  2095cf:	49 83 c7 01          	add    r15,0x1
  2095d3:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
                float_decimal.digits[0] = '1';
  2095d8:	c6 40 ff 31          	mov    BYTE PTR [rax-0x1],0x31
                const one_before = @intToPtr([*]u8, @ptrToInt(&float_decimal.digits[0]) - 1);
  2095dc:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2095e0:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax

    if (maybe_precision) |precision| {
        errol.roundToPrecision(&float_decimal, precision, errol.RoundMode.Decimal);

        // exp < 0 means the leading is always 0 as errol result is normalized.
        var num_digits_whole = if (float_decimal.exp > 0) @intCast(usize, float_decimal.exp) else 0;
  2095e5:	45 31 ed             	xor    r13d,r13d
  2095e8:	45 85 e4             	test   r12d,r12d
  2095eb:	44 89 e0             	mov    eax,r12d
  2095ee:	4c 0f 4f e8          	cmovg  r13,rax
        else => @compileError("unknown floating point type " ++ @typeName(T)),
    };
}

pub fn min(x: var, y: var) @typeOf(x + y) {
    return if (x < y) x else y;
  2095f2:	4d 39 fd             	cmp    r13,r15
  2095f5:	4c 89 f9             	mov    rcx,r15
  2095f8:	49 0f 42 cd          	cmovb  rcx,r13
  2095fc:	45 85 e4             	test   r12d,r12d

        // the actual slice into the buffer, we may need to zero-pad between num_digits_whole and this.
        var num_digits_whole_no_pad = math.min(num_digits_whole, float_decimal.digits.len);

        if (num_digits_whole > 0) {
  2095ff:	48 89 4c 24 50       	mov    QWORD PTR [rsp+0x50],rcx
  209604:	7e 57                	jle    20965d <Futex+0x108d>
            // We may have to zero pad, for instance 1e4 requires zero padding.
            try output(context, float_decimal.digits[0..num_digits_whole_no_pad]);
  209606:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  20960b:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  209612:	00 
  209613:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20961a:	00 
  20961b:	48 8d b4 24 98 00 00 	lea    rsi,[rsp+0x98]
  209622:	00 
  209623:	4c 89 f7             	mov    rdi,r14
  209626:	c5 f8 77             	vzeroupper 
  209629:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  20962d:	66 85 c0             	test   ax,ax
  209630:	75 54                	jne    209686 <Futex+0x10b6>

            var i = num_digits_whole_no_pad;
            while (i < num_digits_whole) : (i += 1) {
  209632:	4d 39 fd             	cmp    r13,r15
  209635:	76 3c                	jbe    209673 <Futex+0x10a3>
  209637:	48 8d 2d ea 77 01 00 	lea    rbp,[rip+0x177ea]        # 220e28 <__unnamed_7>
  20963e:	48 8b 5c 24 50       	mov    rbx,QWORD PTR [rsp+0x50]
                try output(context, "0");
  209643:	4c 89 f7             	mov    rdi,r14
  209646:	48 89 ee             	mov    rsi,rbp
  209649:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  20964d:	66 85 c0             	test   ax,ax
  209650:	75 34                	jne    209686 <Futex+0x10b6>
  209652:	48 83 c3 01          	add    rbx,0x1
            while (i < num_digits_whole) : (i += 1) {
  209656:	4c 39 eb             	cmp    rbx,r13
  209659:	72 e8                	jb     209643 <Futex+0x1073>
  20965b:	eb 16                	jmp    209673 <Futex+0x10a3>
            }
        } else {
            try output(context, "0");
  20965d:	48 8d 35 c4 77 01 00 	lea    rsi,[rip+0x177c4]        # 220e28 <__unnamed_7>
  209664:	4c 89 f7             	mov    rdi,r14
  209667:	c5 f8 77             	vzeroupper 
  20966a:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  20966e:	66 85 c0             	test   ax,ax
  209671:	75 13                	jne    209686 <Futex+0x10b6>
        // {.0} special case doesn't want a trailing '.'
        if (precision == 0) {
            return;
        }

        try output(context, ".");
  209673:	48 8d 35 9e 77 01 00 	lea    rsi,[rip+0x1779e]        # 220e18 <__unnamed_8>
  20967a:	4c 89 f7             	mov    rdi,r14
  20967d:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  209681:	66 85 c0             	test   ax,ax
  209684:	74 31                	je     2096b7 <Futex+0x10e7>
  209686:	4c 8b 64 24 08       	mov    r12,QWORD PTR [rsp+0x8]
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20968b:	66 85 c0             	test   ax,ax
  20968e:	0f 85 11 f4 ff ff    	jne    208aa5 <Futex+0x4d5>
        try output(context, fmt[start_index..]);
  209694:	48 8d 35 0d 75 01 00 	lea    rsi,[rip+0x1750d]        # 220ba8 <__unnamed_10>
  20969b:	4c 89 f7             	mov    rdi,r14
  20969e:	41 ff d4             	call   r12
    assert(gCounter == max_counter * 2);
  2096a1:	48 81 3d 74 79 01 00 	cmp    QWORD PTR [rip+0x17974],0x1312d00        # 221020 <gCounter>
  2096a8:	00 2d 31 01 
  2096ac:	0f 84 04 f4 ff ff    	je     208ab6 <Futex+0x4e6>
            @panic("assertion failure");
  2096b2:	e8 f9 05 00 00       	call   209cb0 <panic>

        // Keep track of fractional count printed for case where we pre-pad then post-pad with 0's.
        var printed: usize = 0;

        // Zero-fill until we reach significant digits or run out of precision.
        if (float_decimal.exp <= 0) {
  2096b7:	45 85 e4             	test   r12d,r12d
  2096ba:	0f 8e b3 00 00 00    	jle    209773 <Futex+0x11a3>
  2096c0:	45 31 e4             	xor    r12d,r12d
            }
        }

        // Remaining fractional portion, zero-padding if insufficient.
        debug.assert(precision >= printed);
        if (num_digits_whole_no_pad + precision - printed < float_decimal.digits.len) {
  2096c3:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  2096c8:	48 8d 40 06          	lea    rax,[rax+0x6]
  2096cc:	4c 29 e0             	sub    rax,r12
  2096cf:	4c 39 f8             	cmp    rax,r15
  2096d2:	73 35                	jae    209709 <Futex+0x1139>
  2096d4:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  2096d9:	48 8b 54 24 50       	mov    rdx,QWORD PTR [rsp+0x50]
            try output(context, float_decimal.digits[num_digits_whole_no_pad .. num_digits_whole_no_pad + precision - printed]);
  2096de:	48 01 d1             	add    rcx,rdx
  2096e1:	48 89 8c 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rcx
  2096e8:	00 
  2096e9:	48 29 d0             	sub    rax,rdx
  2096ec:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  2096f3:	00 
  2096f4:	48 8d b4 24 88 00 00 	lea    rsi,[rsp+0x88]
  2096fb:	00 
  2096fc:	4c 89 f7             	mov    rdi,r14
  2096ff:	4c 8b 64 24 08       	mov    r12,QWORD PTR [rsp+0x8]
  209704:	e9 45 f4 ff ff       	jmp    208b4e <Futex+0x57e>
  209709:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  20970e:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
            return;
        } else {
            try output(context, float_decimal.digits[num_digits_whole_no_pad..]);
  209713:	48 01 c8             	add    rax,rcx
  209716:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  20971b:	49 29 cf             	sub    r15,rcx
  20971e:	4c 89 bc 24 80 00 00 	mov    QWORD PTR [rsp+0x80],r15
  209725:	00 
  209726:	48 8d 74 24 78       	lea    rsi,[rsp+0x78]
  20972b:	4c 89 f7             	mov    rdi,r14
  20972e:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  209732:	66 85 c0             	test   ax,ax
  209735:	0f 85 4b ff ff ff    	jne    209686 <Futex+0x10b6>
            printed += float_decimal.digits.len - num_digits_whole_no_pad;
  20973b:	4d 01 fc             	add    r12,r15

            while (printed < precision) : (printed += 1) {
  20973e:	49 83 fc 05          	cmp    r12,0x5
  209742:	0f 87 83 00 00 00    	ja     2097cb <Futex+0x11fb>
  209748:	48 8d 1d d9 76 01 00 	lea    rbx,[rip+0x176d9]        # 220e28 <__unnamed_7>
                try output(context, "0");
  20974f:	4c 89 f7             	mov    rdi,r14
  209752:	48 89 de             	mov    rsi,rbx
  209755:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  209759:	66 85 c0             	test   ax,ax
  20975c:	0f 85 24 ff ff ff    	jne    209686 <Futex+0x10b6>
  209762:	49 83 c4 01          	add    r12,0x1
  209766:	31 c0                	xor    eax,eax
            while (printed < precision) : (printed += 1) {
  209768:	49 83 fc 05          	cmp    r12,0x5
  20976c:	76 e1                	jbe    20974f <Futex+0x117f>
  20976e:	e9 13 ff ff ff       	jmp    209686 <Futex+0x10b6>
            const zero_digit_count = @intCast(usize, -float_decimal.exp);
  209773:	41 f7 dc             	neg    r12d
  209776:	49 63 c4             	movsxd rax,r12d
  209779:	48 83 f8 06          	cmp    rax,0x6
  20977d:	41 bd 06 00 00 00    	mov    r13d,0x6
  209783:	4c 0f 42 e8          	cmovb  r13,rax
            while (i < zeros_to_print) : (i += 1) {
  209787:	4d 85 ed             	test   r13,r13
  20978a:	0f 84 30 ff ff ff    	je     2096c0 <Futex+0x10f0>
  209790:	48 c7 c5 ff ff ff ff 	mov    rbp,0xffffffffffffffff
  209797:	48 8d 1d 8a 76 01 00 	lea    rbx,[rip+0x1768a]        # 220e28 <__unnamed_7>
                try output(context, "0");
  20979e:	4c 89 f7             	mov    rdi,r14
  2097a1:	48 89 de             	mov    rsi,rbx
  2097a4:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  2097a8:	66 85 c0             	test   ax,ax
  2097ab:	0f 85 d5 fe ff ff    	jne    209686 <Futex+0x10b6>
            while (i < zeros_to_print) : (i += 1) {
  2097b1:	4c 8d 65 01          	lea    r12,[rbp+0x1]
  2097b5:	48 83 c5 02          	add    rbp,0x2
  2097b9:	4c 39 ed             	cmp    rbp,r13
  2097bc:	4c 89 e5             	mov    rbp,r12
  2097bf:	72 dd                	jb     20979e <Futex+0x11ce>
            if (printed >= precision) {
  2097c1:	49 83 fc 04          	cmp    r12,0x4
  2097c5:	0f 86 d4 04 00 00    	jbe    209c9f <Futex+0x16cf>
  2097cb:	31 c0                	xor    eax,eax
  2097cd:	4c 8b 64 24 08       	mov    r12,QWORD PTR [rsp+0x8]
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2097d2:	66 85 c0             	test   ax,ax
  2097d5:	0f 85 ca f2 ff ff    	jne    208aa5 <Futex+0x4d5>
  2097db:	e9 b4 fe ff ff       	jmp    209694 <Futex+0x10c4>
  2097e0:	4d 89 e7             	mov    r15,r12
    buffer[j] = 0;
  2097e3:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  2097e8:	42 c6 04 38 00       	mov    BYTE PTR [rax+r15*1],0x0
        .digits = buffer[0..j],
  2097ed:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  2097f2:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
            if (float_decimal.exp >= 0) {
  2097f7:	45 85 e4             	test   r12d,r12d
  2097fa:	0f 89 3a fd ff ff    	jns    20953a <Futex+0xf6a>
  209800:	e9 e3 f9 ff ff       	jmp    2091e8 <Futex+0xc18>
  209805:	c5 fb 10 05 f3 73 ff 	vmovsd xmm0,QWORD PTR [rip+0xffffffffffff73f3]        # 200c00 <__unnamed_441+0x60>
  20980c:	ff 
  20980d:	eb 04                	jmp    209813 <Futex+0x1243>
  20980f:	c5 f9 28 c2          	vmovapd xmm0,xmm2
    var exp = @floatToInt(i16, math.floor(307 + @intToFloat(f64, e) * 0.30103));
  209813:	c5 fb 2c c0          	vcvttsd2si eax,xmm0
    if (exp < 20) {
  209817:	98                   	cwde   
    } else if (@intCast(usize, exp) >= lookup_table.len) {
  209818:	0f b7 c8             	movzx  ecx,ax
  20981b:	81 f9 57 02 00 00    	cmp    ecx,0x257
  209821:	66 b9 57 02          	mov    cx,0x257
  209825:	66 0f 42 c8          	cmovb  cx,ax
    if (exp < 20) {
  209829:	83 f8 14             	cmp    eax,0x14
  20982c:	66 b8 14 00          	mov    ax,0x14
  209830:	66 0f 4d c1          	cmovge ax,cx
    var mid = lookup_table[@intCast(usize, exp)];
  209834:	0f b7 c8             	movzx  ecx,ax
  209837:	48 c1 e1 04          	shl    rcx,0x4
  20983b:	48 8d 15 06 a2 ff ff 	lea    rdx,[rip+0xffffffffffffa206]        # 203a48 <lookup_table.15>
  209842:	c5 7b 10 04 11       	vmovsd xmm8,QWORD PTR [rcx+rdx*1]
  209847:	c5 f9 28 44 24 10    	vmovapd xmm0,XMMWORD PTR [rsp+0x10]
    const p = in.val * val;
  20984d:	c5 bb 59 d8          	vmulsd xmm3,xmm8,xmm0
        .off = in.off * val + e,
  209851:	c5 fb 59 54 11 08    	vmulsd xmm2,xmm0,QWORD PTR [rcx+rdx*1+0x8]
    exp -= 307;
  209857:	8d 80 cd fe ff ff    	lea    eax,[rax-0x133]
    while (mid.val > 10.0 or (mid.val == 10.0 and mid.off >= 0.0)) {
  20985d:	44 0f bf e0          	movsx  r12d,ax
  209861:	c5 fb 10 35 6f 73 ff 	vmovsd xmm6,QWORD PTR [rip+0xffffffffffff736f]        # 200bd8 <__unnamed_441+0x38>
  209868:	ff 
  209869:	c5 fb 10 05 4f 73 ff 	vmovsd xmm0,QWORD PTR [rip+0xffffffffffff734f]        # 200bc0 <__unnamed_441+0x20>
  209870:	ff 
  209871:	c5 fb 10 2d d7 73 ff 	vmovsd xmm5,QWORD PTR [rip+0xffffffffffff73d7]        # 200c50 <app_mask+0x18>
  209878:	ff 
  209879:	c5 fb 10 3d 8f 73 ff 	vmovsd xmm7,QWORD PTR [rip+0xffffffffffff738f]        # 200c10 <__unnamed_441+0x70>
  209880:	ff 
  209881:	c5 f9 2e d8          	vucomisd xmm3,xmm0
  209885:	76 27                	jbe    2098ae <Futex+0x12de>
    hp.val /= 10.0;
  209887:	c5 e3 59 e5          	vmulsd xmm4,xmm3,xmm5
    hp.off += val / 10.0;
  20988b:	c5 e3 59 df          	vmulsd xmm3,xmm3,xmm7
  20988f:	c4 e2 d1 a9 d3       	vfmadd213sd xmm2,xmm5,xmm3
    hp.val += hp.off;
  209894:	c5 db 58 da          	vaddsd xmm3,xmm4,xmm2
    hp.off += val - hp.val;
  209898:	c5 db 5c e3          	vsubsd xmm4,xmm4,xmm3
  20989c:	c5 eb 58 d4          	vaddsd xmm2,xmm2,xmm4
        ten /= 10.0;
  2098a0:	c5 cb 59 f5          	vmulsd xmm6,xmm6,xmm5
    while (mid.val > 10.0 or (mid.val == 10.0 and mid.off >= 0.0)) {
  2098a4:	41 83 c4 01          	add    r12d,0x1
  2098a8:	c5 f9 2e d8          	vucomisd xmm3,xmm0
  2098ac:	77 d9                	ja     209887 <Futex+0x12b7>
  2098ae:	c5 f9 2e d1          	vucomisd xmm2,xmm1
  2098b2:	72 26                	jb     2098da <Futex+0x130a>
  2098b4:	c5 f9 2e d8          	vucomisd xmm3,xmm0
  2098b8:	75 20                	jne    2098da <Futex+0x130a>
  2098ba:	7b cb                	jnp    209887 <Futex+0x12b7>
  2098bc:	eb 1c                	jmp    2098da <Futex+0x130a>
    hp.val *= 10.0;
  2098be:	c5 e3 59 c8          	vmulsd xmm1,xmm3,xmm0
    hp.off *= 10.0;
  2098c2:	c5 eb 59 d0          	vmulsd xmm2,xmm2,xmm0
    hp.val += hp.off;
  2098c6:	c5 eb 58 d9          	vaddsd xmm3,xmm2,xmm1
    hp.off += val - hp.val;
  2098ca:	c5 f3 5c cb          	vsubsd xmm1,xmm1,xmm3
  2098ce:	c5 eb 58 d1          	vaddsd xmm2,xmm2,xmm1
        ten *= 10.0;
  2098d2:	c5 cb 59 f0          	vmulsd xmm6,xmm6,xmm0
    while (mid.val < 1.0 or (mid.val == 1.0 and mid.off < 0.0)) {
  2098d6:	41 83 c4 ff          	add    r12d,0xffffffff
  2098da:	c5 7b 10 0d f6 72 ff 	vmovsd xmm9,QWORD PTR [rip+0xffffffffffff72f6]        # 200bd8 <__unnamed_441+0x38>
  2098e1:	ff 
  2098e2:	c5 79 2e cb          	vucomisd xmm9,xmm3
  2098e6:	77 d6                	ja     2098be <Futex+0x12ee>
  2098e8:	c5 c1 57 ff          	vxorpd xmm7,xmm7,xmm7
  2098ec:	c5 f9 2e fa          	vucomisd xmm7,xmm2
  2098f0:	76 0c                	jbe    2098fe <Futex+0x132e>
  2098f2:	c5 f9 2e 1d de 72 ff 	vucomisd xmm3,QWORD PTR [rip+0xffffffffffff72de]        # 200bd8 <__unnamed_441+0x38>
  2098f9:	ff 
  2098fa:	75 02                	jne    2098fe <Futex+0x132e>
  2098fc:	7b c0                	jnp    2098be <Futex+0x12ee>
        .off = mid.off + (fpnext(val) - val) * lten * ten / 2.0,
  2098fe:	c5 bb 59 0d 02 73 ff 	vmulsd xmm1,xmm8,QWORD PTR [rip+0xffffffffffff7302]        # 200c08 <__unnamed_441+0x68>
  209905:	ff 
  209906:	c5 f3 59 ce          	vmulsd xmm1,xmm1,xmm6
  20990a:	c5 f9 6f 6c 24 10    	vmovdqa xmm5,XMMWORD PTR [rsp+0x10]
    return @bitCast(f64, @bitCast(u64, val) +% 1);
  209910:	c4 e2 79 59 e5       	vpbroadcastq xmm4,xmm5
  209915:	c5 d9 d4 25 83 6b ff 	vpaddq xmm4,xmm4,XMMWORD PTR [rip+0xffffffffffff6b83]        # 2004a0 <__unnamed_295+0x10>
  20991c:	ff 
        .off = mid.off + (fpnext(val) - val) * lten * ten / 2.0,
  20991d:	c5 fb 12 f5          	vmovddup xmm6,xmm5
  209921:	c5 d9 5c e6          	vsubpd xmm4,xmm4,xmm6
  209925:	c5 fb 12 f1          	vmovddup xmm6,xmm1
  209929:	c5 fb 12 ca          	vmovddup xmm1,xmm2
  20992d:	c4 e2 d9 a8 f1       	vfmadd213pd xmm6,xmm4,xmm1
    hp.val += hp.off;
  209932:	c5 fb 12 cb          	vmovddup xmm1,xmm3
  209936:	c5 f1 58 ce          	vaddpd xmm1,xmm1,xmm6
    hp.off += val - hp.val;
  20993a:	c5 e3 5c d1          	vsubsd xmm2,xmm3,xmm1
  20993e:	c5 cb 58 d2          	vaddsd xmm2,xmm6,xmm2
  209942:	c4 e3 79 05 e1 01    	vpermilpd xmm4,xmm1,0x1
  209948:	c5 e3 5c dc          	vsubsd xmm3,xmm3,xmm4
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  20994c:	c4 e3 79 05 f6 01    	vpermilpd xmm6,xmm6,0x1
  209952:	c5 f9 28 25 46 6a ff 	vmovapd xmm4,XMMWORD PTR [rip+0xffffffffffff6a46]        # 2003a0 <__unnamed_526+0x10>
  209959:	ff 
  20995a:	c5 79 28 05 6e 6c ff 	vmovapd xmm8,XMMWORD PTR [rip+0xffffffffffff6c6e]        # 2005d0 <__unnamed_64+0x10>
  209961:	ff 
    hp.off += val - hp.val;
  209962:	c5 cb 58 db          	vaddsd xmm3,xmm6,xmm3
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  209966:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  20996a:	76 42                	jbe    2099ae <Futex+0x13de>
    hp.val /= 10.0;
  20996c:	c5 f1 59 f4          	vmulpd xmm6,xmm1,xmm4
    hp.off /= 10.0;
  209970:	c5 e9 14 eb          	vunpcklpd xmm5,xmm2,xmm3
    hp.off += val / 10.0;
  209974:	c4 c1 71 59 c8       	vmulpd xmm1,xmm1,xmm8
  209979:	c4 e2 d9 aa e9       	vfmsub213pd xmm5,xmm4,xmm1
    hp.val += hp.off;
  20997e:	c5 c9 58 cd          	vaddpd xmm1,xmm6,xmm5
    hp.off += val - hp.val;
  209982:	c5 cb 5c d1          	vsubsd xmm2,xmm6,xmm1
  209986:	c5 d3 58 d2          	vaddsd xmm2,xmm5,xmm2
  20998a:	c4 e3 79 05 d9 01    	vpermilpd xmm3,xmm1,0x1
  209990:	c4 e3 79 05 f6 01    	vpermilpd xmm6,xmm6,0x1
  209996:	c5 cb 5c db          	vsubsd xmm3,xmm6,xmm3
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  20999a:	c4 e3 79 05 f5 01    	vpermilpd xmm6,xmm5,0x1
  2099a0:	41 83 c4 01          	add    r12d,0x1
    hp.off += val - hp.val;
  2099a4:	c5 cb 58 db          	vaddsd xmm3,xmm6,xmm3
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  2099a8:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  2099ac:	77 be                	ja     20996c <Futex+0x139c>
  2099ae:	c5 f9 2e d7          	vucomisd xmm2,xmm7
  2099b2:	72 08                	jb     2099bc <Futex+0x13ec>
  2099b4:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  2099b8:	75 02                	jne    2099bc <Futex+0x13ec>
  2099ba:	7b b0                	jnp    20996c <Futex+0x139c>
  2099bc:	c4 e3 79 05 e1 01    	vpermilpd xmm4,xmm1,0x1
  2099c2:	c5 c9 57 f6          	vxorpd xmm6,xmm6,xmm6
    while (high.val < 1.0 or (high.val == 1.0 and high.off < 0.0)) {
  2099c6:	c5 79 2e c9          	vucomisd xmm9,xmm1
  2099ca:	76 32                	jbe    2099fe <Futex+0x142e>
    hp.val *= 10.0;
  2099cc:	c5 f3 59 e8          	vmulsd xmm5,xmm1,xmm0
    hp.off *= 10.0;
  2099d0:	c5 eb 59 d0          	vmulsd xmm2,xmm2,xmm0
    hp.val += hp.off;
  2099d4:	c5 eb 58 cd          	vaddsd xmm1,xmm2,xmm5
    hp.off += val - hp.val;
  2099d8:	c5 d3 5c e9          	vsubsd xmm5,xmm5,xmm1
  2099dc:	c5 eb 58 d5          	vaddsd xmm2,xmm2,xmm5
    hp.val *= 10.0;
  2099e0:	c5 db 59 e8          	vmulsd xmm5,xmm4,xmm0
    hp.off *= 10.0;
  2099e4:	c5 e3 59 d8          	vmulsd xmm3,xmm3,xmm0
    hp.val += hp.off;
  2099e8:	c5 e3 58 e5          	vaddsd xmm4,xmm3,xmm5
    hp.off += val - hp.val;
  2099ec:	c5 d3 5c ec          	vsubsd xmm5,xmm5,xmm4
  2099f0:	c5 e3 58 dd          	vaddsd xmm3,xmm3,xmm5
    while (high.val < 1.0 or (high.val == 1.0 and high.off < 0.0)) {
  2099f4:	41 83 c4 ff          	add    r12d,0xffffffff
  2099f8:	c5 79 2e c9          	vucomisd xmm9,xmm1
  2099fc:	77 ce                	ja     2099cc <Futex+0x13fc>
  2099fe:	c5 f9 2e f2          	vucomisd xmm6,xmm2
  209a02:	76 09                	jbe    209a0d <Futex+0x143d>
  209a04:	c4 c1 79 2e c9       	vucomisd xmm1,xmm9
  209a09:	75 02                	jne    209a0d <Futex+0x143d>
  209a0b:	7b bf                	jnp    2099cc <Futex+0x13fc>
  209a0d:	41 bf 01 00 00 00    	mov    r15d,0x1
  209a13:	bf 34 0b 00 00       	mov    edi,0xb34
  209a18:	c5 c1 57 ff          	vxorpd xmm7,xmm7,xmm7
  209a1c:	c5 7b 10 0d c4 71 ff 	vmovsd xmm9,QWORD PTR [rip+0xffffffffffff71c4]        # 200be8 <__unnamed_441+0x48>
  209a23:	ff 
  209a24:	c5 7b 10 15 f4 71 ff 	vmovsd xmm10,QWORD PTR [rip+0xffffffffffff71f4]        # 200c20 <__unnamed_441+0x80>
  209a2b:	ff 
  209a2c:	c5 7b 10 05 cc 71 ff 	vmovsd xmm8,QWORD PTR [rip+0xffffffffffff71cc]        # 200c00 <__unnamed_441+0x60>
  209a33:	ff 
    if (e >= 0x3FF + 52 or x == 0) {
  209a34:	c5 f9 2e cf          	vucomisd xmm1,xmm7
  209a38:	c5 f9 28 e9          	vmovapd xmm5,xmm1
  209a3c:	75 06                	jne    209a44 <Futex+0x1474>
  209a3e:	0f 8b c5 00 00 00    	jnp    209b09 <Futex+0x1539>
  209a44:	c4 e1 f9 7e c9       	vmovq  rcx,xmm1
  209a49:	c4 e2 c0 f7 d1       	bextr  rdx,rcx,rdi
  209a4e:	c5 f9 28 e9          	vmovapd xmm5,xmm1
  209a52:	48 81 fa 32 04 00 00 	cmp    rdx,0x432
  209a59:	0f 87 aa 00 00 00    	ja     209b09 <Futex+0x1539>
    if (u >> 63 != 0) {
  209a5f:	48 85 c9             	test   rcx,rcx
  209a62:	78 26                	js     209a8a <Futex+0x14ba>
  209a64:	c4 c1 73 58 ea       	vaddsd xmm5,xmm1,xmm10
  209a69:	c4 c1 53 58 e9       	vaddsd xmm5,xmm5,xmm9
    if (e <= 0x3FF - 1) {
  209a6e:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  209a75:	77 26                	ja     209a9d <Futex+0x14cd>
        if (u >> 63 != 0) {
  209a77:	c5 79 29 c5          	vmovapd xmm5,xmm8
    if (u >> 63 != 0) {
  209a7b:	48 85 c9             	test   rcx,rcx
        if (u >> 63 != 0) {
  209a7e:	0f 88 85 00 00 00    	js     209b09 <Futex+0x1539>
  209a84:	c5 d1 57 ed          	vxorpd xmm5,xmm5,xmm5
  209a88:	eb 7f                	jmp    209b09 <Futex+0x1539>
  209a8a:	c4 c1 73 58 e9       	vaddsd xmm5,xmm1,xmm9
  209a8f:	c4 c1 53 58 ea       	vaddsd xmm5,xmm5,xmm10
    if (e <= 0x3FF - 1) {
  209a94:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  209a9b:	76 da                	jbe    209a77 <Futex+0x14a7>
  209a9d:	c5 d3 5c f1          	vsubsd xmm6,xmm5,xmm1
    } else if (y > 0) {
  209aa1:	c5 f9 2e f7          	vucomisd xmm6,xmm7
  209aa5:	76 62                	jbe    209b09 <Futex+0x1539>
        return x + y - 1;
  209aa7:	c4 c1 53 58 e8       	vaddsd xmm5,xmm5,xmm8
  209aac:	eb 5b                	jmp    209b09 <Futex+0x1539>
        buffer[buf_index] = hdig + '0';
  209aae:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        high.val -= @intToFloat(f64, hdig);
  209ab3:	0f b6 d1             	movzx  edx,cl
        buffer[buf_index] = hdig + '0';
  209ab6:	80 c1 30             	add    cl,0x30
  209ab9:	42 88 0c 38          	mov    BYTE PTR [rax+r15*1],cl
        buf_index += 1;
  209abd:	49 83 c7 01          	add    r15,0x1
        high.val -= @intToFloat(f64, hdig);
  209ac1:	c5 a3 2a ea          	vcvtsi2sd xmm5,xmm11,edx
  209ac5:	c5 f3 5c cd          	vsubsd xmm1,xmm1,xmm5
        low.val -= @intToFloat(f64, ldig);
  209ac9:	c5 db 5c e5          	vsubsd xmm4,xmm4,xmm5
    hp.val *= 10.0;
  209acd:	c5 f3 59 e8          	vmulsd xmm5,xmm1,xmm0
    hp.off *= 10.0;
  209ad1:	c5 eb 59 d0          	vmulsd xmm2,xmm2,xmm0
    hp.val += hp.off;
  209ad5:	c5 eb 58 cd          	vaddsd xmm1,xmm2,xmm5
    hp.off += val - hp.val;
  209ad9:	c5 d3 5c e9          	vsubsd xmm5,xmm5,xmm1
  209add:	c5 eb 58 d5          	vaddsd xmm2,xmm2,xmm5
    hp.val *= 10.0;
  209ae1:	c5 db 59 e8          	vmulsd xmm5,xmm4,xmm0
    hp.off *= 10.0;
  209ae5:	c5 e3 59 d8          	vmulsd xmm3,xmm3,xmm0
    hp.val += hp.off;
  209ae9:	c5 e3 58 e5          	vaddsd xmm4,xmm3,xmm5
    hp.off += val - hp.val;
  209aed:	c5 d3 5c ec          	vsubsd xmm5,xmm5,xmm4
  209af1:	c5 e3 58 dd          	vaddsd xmm3,xmm3,xmm5
    if (e >= 0x3FF + 52 or x == 0) {
  209af5:	c5 f9 2e cf          	vucomisd xmm1,xmm7
  209af9:	c5 f9 28 e9          	vmovapd xmm5,xmm1
  209afd:	0f 85 41 ff ff ff    	jne    209a44 <Futex+0x1474>
  209b03:	0f 8a 3b ff ff ff    	jp     209a44 <Futex+0x1474>
        var hdig = @floatToInt(u8, math.floor(high.val));
  209b09:	c5 fb 2c cd          	vcvttsd2si ecx,xmm5
        if ((high.val == @intToFloat(f64, hdig)) and (high.off < 0)) hdig -= 1;
  209b0d:	0f b6 c9             	movzx  ecx,cl
  209b10:	c5 a3 2a e9          	vcvtsi2sd xmm5,xmm11,ecx
  209b14:	c5 f9 2e cd          	vucomisd xmm1,xmm5
  209b18:	0f 9b c2             	setnp  dl
  209b1b:	0f 94 c3             	sete   bl
  209b1e:	20 d3                	and    bl,dl
  209b20:	c5 f9 2e fa          	vucomisd xmm7,xmm2
  209b24:	0f 97 c2             	seta   dl
  209b27:	20 da                	and    dl,bl
  209b29:	28 d1                	sub    cl,dl
  209b2b:	c5 f9 2e e7          	vucomisd xmm4,xmm7
  209b2f:	c5 f9 28 ec          	vmovapd xmm5,xmm4
  209b33:	75 02                	jne    209b37 <Futex+0x1567>
  209b35:	7b 60                	jnp    209b97 <Futex+0x15c7>
  209b37:	c4 e1 f9 7e e2       	vmovq  rdx,xmm4
  209b3c:	c4 e2 c0 f7 f2       	bextr  rsi,rdx,rdi
  209b41:	c5 f9 28 ec          	vmovapd xmm5,xmm4
  209b45:	48 81 fe 32 04 00 00 	cmp    rsi,0x432
  209b4c:	77 49                	ja     209b97 <Futex+0x15c7>
    if (u >> 63 != 0) {
  209b4e:	48 85 d2             	test   rdx,rdx
  209b51:	78 22                	js     209b75 <Futex+0x15a5>
  209b53:	c4 c1 5b 58 ea       	vaddsd xmm5,xmm4,xmm10
  209b58:	c4 c1 53 58 e9       	vaddsd xmm5,xmm5,xmm9
    if (e <= 0x3FF - 1) {
  209b5d:	48 81 fe fe 03 00 00 	cmp    rsi,0x3fe
  209b64:	77 22                	ja     209b88 <Futex+0x15b8>
        if (u >> 63 != 0) {
  209b66:	c5 79 29 c5          	vmovapd xmm5,xmm8
    if (u >> 63 != 0) {
  209b6a:	48 85 d2             	test   rdx,rdx
        if (u >> 63 != 0) {
  209b6d:	78 28                	js     209b97 <Futex+0x15c7>
  209b6f:	c5 d1 57 ed          	vxorpd xmm5,xmm5,xmm5
  209b73:	eb 22                	jmp    209b97 <Futex+0x15c7>
  209b75:	c4 c1 5b 58 e9       	vaddsd xmm5,xmm4,xmm9
  209b7a:	c4 c1 53 58 ea       	vaddsd xmm5,xmm5,xmm10
    if (e <= 0x3FF - 1) {
  209b7f:	48 81 fe fe 03 00 00 	cmp    rsi,0x3fe
  209b86:	76 de                	jbe    209b66 <Futex+0x1596>
  209b88:	c5 d3 5c f4          	vsubsd xmm6,xmm5,xmm4
    } else if (y > 0) {
  209b8c:	c5 f9 2e f7          	vucomisd xmm6,xmm7
  209b90:	76 05                	jbe    209b97 <Futex+0x15c7>
        return x + y - 1;
  209b92:	c4 c1 53 58 e8       	vaddsd xmm5,xmm5,xmm8
        var ldig = @floatToInt(u8, math.floor(low.val));
  209b97:	c5 fb 2c d5          	vcvttsd2si edx,xmm5
        if ((low.val == @intToFloat(f64, ldig)) and (low.off < 0)) ldig -= 1;
  209b9b:	0f b6 d2             	movzx  edx,dl
  209b9e:	c5 a3 2a ea          	vcvtsi2sd xmm5,xmm11,edx
  209ba2:	c5 f9 2e e5          	vucomisd xmm4,xmm5
  209ba6:	0f 9b c3             	setnp  bl
  209ba9:	0f 94 c0             	sete   al
  209bac:	20 d8                	and    al,bl
  209bae:	c5 f9 2e fb          	vucomisd xmm7,xmm3
  209bb2:	0f 97 c3             	seta   bl
  209bb5:	20 c3                	and    bl,al
  209bb7:	28 da                	sub    dl,bl
        if (ldig != hdig) break;
  209bb9:	38 ca                	cmp    dl,cl
  209bbb:	0f 84 ed fe ff ff    	je     209aae <Futex+0x14de>
    const tmp = (high.val + low.val) / 2.0;
  209bc1:	c5 db 58 c1          	vaddsd xmm0,xmm4,xmm1
  209bc5:	c5 fb 10 0d 3b 70 ff 	vmovsd xmm1,QWORD PTR [rip+0xffffffffffff703b]        # 200c08 <__unnamed_441+0x68>
  209bcc:	ff 
  209bcd:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
    var mdig = @floatToInt(u8, math.floor(tmp + 0.5));
  209bd1:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
    if (e >= 0x3FF + 52 or x == 0) {
  209bd5:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  209bd9:	c5 f9 2e ca          	vucomisd xmm1,xmm2
  209bdd:	75 02                	jne    209be1 <Futex+0x1611>
  209bdf:	7b 74                	jnp    209c55 <Futex+0x1685>
  209be1:	c4 e1 f9 7e c8       	vmovq  rax,xmm1
  209be6:	b9 34 0b 00 00       	mov    ecx,0xb34
  209beb:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  209bf0:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  209bf7:	77 5c                	ja     209c55 <Futex+0x1685>
    if (u >> 63 != 0) {
  209bf9:	48 85 c0             	test   rax,rax
  209bfc:	78 1e                	js     209c1c <Futex+0x164c>
  209bfe:	c4 c1 73 58 d2       	vaddsd xmm2,xmm1,xmm10
  209c03:	c4 c1 6b 58 d1       	vaddsd xmm2,xmm2,xmm9
    if (e <= 0x3FF - 1) {
  209c08:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  209c0f:	77 1e                	ja     209c2f <Futex+0x165f>
    if (u >> 63 != 0) {
  209c11:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  209c14:	78 31                	js     209c47 <Futex+0x1677>
  209c16:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  209c1a:	eb 39                	jmp    209c55 <Futex+0x1685>
  209c1c:	c4 c1 73 58 d1       	vaddsd xmm2,xmm1,xmm9
  209c21:	c4 c1 6b 58 d2       	vaddsd xmm2,xmm2,xmm10
    if (e <= 0x3FF - 1) {
  209c26:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  209c2d:	76 e2                	jbe    209c11 <Futex+0x1641>
  209c2f:	c5 eb 5c c9          	vsubsd xmm1,xmm2,xmm1
    } else if (y > 0) {
  209c33:	c5 e1 57 db          	vxorpd xmm3,xmm3,xmm3
  209c37:	c5 f9 2e cb          	vucomisd xmm1,xmm3
  209c3b:	76 14                	jbe    209c51 <Futex+0x1681>
        return x + y - 1;
  209c3d:	c5 eb 58 0d bb 6f ff 	vaddsd xmm1,xmm2,QWORD PTR [rip+0xffffffffffff6fbb]        # 200c00 <__unnamed_441+0x60>
  209c44:	ff 
  209c45:	eb 0e                	jmp    209c55 <Futex+0x1685>
  209c47:	c5 fb 10 0d b1 6f ff 	vmovsd xmm1,QWORD PTR [rip+0xffffffffffff6fb1]        # 200c00 <__unnamed_441+0x60>
  209c4e:	ff 
  209c4f:	eb 04                	jmp    209c55 <Futex+0x1685>
  209c51:	c5 f9 28 ca          	vmovapd xmm1,xmm2
  209c55:	c5 fb 2c c1          	vcvttsd2si eax,xmm1
    if ((@intToFloat(f64, mdig) - tmp) == 0.5 and (mdig & 0x1) != 0) mdig -= 1;
  209c59:	0f b6 c0             	movzx  eax,al
  209c5c:	c5 a3 2a c8          	vcvtsi2sd xmm1,xmm11,eax
  209c60:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
  209c64:	c5 f9 2e 05 9c 6f ff 	vucomisd xmm0,QWORD PTR [rip+0xffffffffffff6f9c]        # 200c08 <__unnamed_441+0x68>
  209c6b:	ff 
  209c6c:	0f 9b c1             	setnp  cl
  209c6f:	0f 94 c2             	sete   dl
  209c72:	20 ca                	and    dl,cl
  209c74:	20 c2                	and    dl,al
    buffer[buf_index] = mdig + '0';
  209c76:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
    if ((@intToFloat(f64, mdig) - tmp) == 0.5 and (mdig & 0x1) != 0) mdig -= 1;
  209c7b:	28 d0                	sub    al,dl
    buffer[buf_index] = mdig + '0';
  209c7d:	04 30                	add    al,0x30
  209c7f:	42 88 04 39          	mov    BYTE PTR [rcx+r15*1],al
        .digits = buffer[1..buf_index],
  209c83:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  209c88:	48 83 c0 01          	add    rax,0x1
  209c8c:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
            if (float_decimal.exp >= 0) {
  209c91:	45 85 e4             	test   r12d,r12d
  209c94:	0f 89 a0 f8 ff ff    	jns    20953a <Futex+0xf6a>
  209c9a:	e9 49 f5 ff ff       	jmp    2091e8 <Futex+0xc18>
  209c9f:	49 83 c4 01          	add    r12,0x1
  209ca3:	e9 1b fa ff ff       	jmp    2096c3 <Futex+0x10f3>
  209ca8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  209caf:	00 

0000000000209cb0 <panic>:
        // TODO: fix panic in zen.
        builtin.Os.freestanding, builtin.Os.zen => {
            while (true) {}
        },
        else => {
            const first_trace_addr = @ptrToInt(@returnAddress());
  209cb0:	48 83 ec 18          	sub    rsp,0x18
  209cb4:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
            std.debug.panicExtra(error_return_trace, first_trace_addr, "{}", msg);
  209cb9:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  209cbe:	c6 44 24 10 01       	mov    BYTE PTR [rsp+0x10],0x1
  209cc3:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
  209cc8:	e8 03 00 00 00       	call   209cd0 <panicExtra>
  209ccd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000209cd0 <panicExtra>:
    panicExtra(null, first_trace_addr, format, args);
}

var panicking: u8 = 0; // TODO make this a bool

pub fn panicExtra(trace: ?*const builtin.StackTrace, first_trace_addr: ?usize, comptime format: []const u8, args: ...) noreturn {
  209cd0:	41 57                	push   r15
  209cd2:	41 56                	push   r14
  209cd4:	53                   	push   rbx
  209cd5:	48 83 ec 10          	sub    rsp,0x10
  209cd9:	b0 01                	mov    al,0x1
    @setCold(true);

    if (@atomicRmw(u8, &panicking, builtin.AtomicRmwOp.Xchg, 1, builtin.AtomicOrder.SeqCst) == 1) {
  209cdb:	86 05 47 73 01 00    	xchg   BYTE PTR [rip+0x17347],al        # 221028 <panicking>
  209ce1:	49 89 fe             	mov    r14,rdi
  209ce4:	3c 01                	cmp    al,0x1
  209ce6:	74 7e                	je     209d66 <panicExtra+0x96>
    if (stderr_stream) |st| {
  209ce8:	48 8b 1d 41 73 01 00 	mov    rbx,QWORD PTR [rip+0x17341]        # 221030 <stderr_stream>
  209cef:	48 85 db             	test   rbx,rbx
  209cf2:	75 36                	jne    209d2a <panicExtra+0x5a>
        stderr_file = try io.getStdErr();
  209cf4:	48 8d 05 25 33 01 00 	lea    rax,[rip+0x13325]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  209cfb:	48 89 05 26 33 01 00 	mov    QWORD PTR [rip+0x13326],rax        # 21d028 <stderr_file_out_stream>
  209d02:	4c 8d 3d 37 1c 00 00 	lea    r15,[rip+0x1c37]        # 20b940 <FileOutStream_writeFn>
  209d09:	4c 89 3d 20 33 01 00 	mov    QWORD PTR [rip+0x13320],r15        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  209d10:	c7 05 06 33 01 00 02 	mov    DWORD PTR [rip+0x13306],0x2        # 21d020 <stderr_file>
  209d17:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  209d1a:	48 8d 1d 0f 33 01 00 	lea    rbx,[rip+0x1330f]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  209d21:	48 89 1d 08 73 01 00 	mov    QWORD PTR [rip+0x17308],rbx        # 221030 <stderr_stream>
  209d28:	eb 07                	jmp    209d31 <panicExtra+0x61>
  209d2a:	4c 8b 3d ff 32 01 00 	mov    r15,QWORD PTR [rip+0x132ff]        # 21d030 <stderr_file_out_stream+0x8>
                const casted_value = ([]const u8)(value);
  209d31:	c5 f8 10 05 ff 6d 01 	vmovups xmm0,XMMWORD PTR [rip+0x16dff]        # 220b38 <__unnamed_11>
  209d38:	00 
  209d39:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  209d3e:	48 89 e6             	mov    rsi,rsp
                return output(context, casted_value);
  209d41:	48 89 df             	mov    rdi,rbx
  209d44:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  209d47:	66 85 c0             	test   ax,ax
  209d4a:	75 1a                	jne    209d66 <panicExtra+0x96>
        try output(context, fmt[start_index..]);
  209d4c:	48 8d 35 f5 6d 01 00 	lea    rsi,[rip+0x16df5]        # 220b48 <__unnamed_12>
  209d53:	48 89 df             	mov    rdi,rbx
  209d56:	41 ff d7             	call   r15
        // we would want to return here instead of calling abort, so that the thread
        // which first called panic can finish printing a stack trace.
        os.abort();
    }
    const stderr = getStderrStream() catch os.abort();
    stderr.print(format ++ "\n", args) catch os.abort();
  209d59:	66 85 c0             	test   ax,ax
  209d5c:	75 08                	jne    209d66 <panicExtra+0x96>
    if (trace) |t| {
        dumpStackTrace(t);
    }
    dumpCurrentStackTrace(first_trace_addr);
  209d5e:	4c 89 f7             	mov    rdi,r14
  209d61:	e8 5a 03 00 00       	call   20a0c0 <dumpCurrentStackTrace>
  209d66:	e8 55 02 00 00       	call   209fc0 <abort>
  209d6b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000209d70 <warn.16>:
pub fn warn(comptime fmt: []const u8, args: ...) void {
  209d70:	55                   	push   rbp
  209d71:	41 57                	push   r15
  209d73:	41 56                	push   r14
  209d75:	41 55                	push   r13
  209d77:	41 54                	push   r12
  209d79:	53                   	push   rbx
  209d7a:	48 83 ec 58          	sub    rsp,0x58
  209d7e:	49 89 f7             	mov    r15,rsi
  209d81:	48 89 fd             	mov    rbp,rdi
    if (stderr_stream) |st| {
  209d84:	4c 8b 35 a5 72 01 00 	mov    r14,QWORD PTR [rip+0x172a5]        # 221030 <stderr_stream>
  209d8b:	4d 85 f6             	test   r14,r14
  209d8e:	74 09                	je     209d99 <warn.16+0x29>
  209d90:	4c 8b 25 99 32 01 00 	mov    r12,QWORD PTR [rip+0x13299]        # 21d030 <stderr_file_out_stream+0x8>
  209d97:	eb 34                	jmp    209dcd <warn.16+0x5d>
        stderr_file = try io.getStdErr();
  209d99:	48 8d 05 80 32 01 00 	lea    rax,[rip+0x13280]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  209da0:	48 89 05 81 32 01 00 	mov    QWORD PTR [rip+0x13281],rax        # 21d028 <stderr_file_out_stream>
  209da7:	4c 8d 25 92 1b 00 00 	lea    r12,[rip+0x1b92]        # 20b940 <FileOutStream_writeFn>
  209dae:	4c 89 25 7b 32 01 00 	mov    QWORD PTR [rip+0x1327b],r12        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  209db5:	c7 05 61 32 01 00 02 	mov    DWORD PTR [rip+0x13261],0x2        # 21d020 <stderr_file>
  209dbc:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  209dbf:	4c 8d 35 6a 32 01 00 	lea    r14,[rip+0x1326a]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  209dc6:	4c 89 35 63 72 01 00 	mov    QWORD PTR [rip+0x17263],r14        # 221030 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  209dcd:	48 8d 35 94 6d 01 00 	lea    rsi,[rip+0x16d94]        # 220b68 <__unnamed_13>
  209dd4:	4c 89 f7             	mov    rdi,r14
  209dd7:	41 ff d4             	call   r12
  209dda:	66 85 c0             	test   ax,ax
  209ddd:	0f 85 c1 01 00 00    	jne    209fa4 <warn.16+0x234>
    comptime Errors: type,
    output: fn (@typeOf(context), []const u8) Errors!void,
) Errors!void {
    // max_int_digits accounts for the minus sign. when printing an unsigned
    // number we don't need to do that.
    var buf: [max_int_digits - 1]u8 = undefined;
  209de3:	c5 fc 10 05 8d d9 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffd98d]        # 207778 <__unnamed_14+0x1f>
  209dea:	ff 
  209deb:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  209df1:	c5 fc 10 05 60 d9 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffd960]        # 207759 <__unnamed_14>
  209df8:	ff 
  209df9:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
    var a = if (@sizeOf(@typeOf(value)) == 1) u8(value) else value;
    var index: usize = buf.len;

    while (true) {
        const digit = a % base;
  209dff:	49 bd cd cc cc cc cc 	movabs r13,0xcccccccccccccccd
  209e06:	cc cc cc 
  209e09:	48 89 ea             	mov    rdx,rbp
  209e0c:	c4 c2 fb f6 cd       	mulx   rcx,rax,r13
  209e11:	c1 e9 02             	shr    ecx,0x2
  209e14:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  209e1a:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  209e1d:	89 e8                	mov    eax,ebp
  209e1f:	29 c8                	sub    eax,ecx
    return value;
}

fn digitToChar(digit: u8, uppercase: bool) u8 {
    return switch (digit) {
        0...9 => digit + '0',
  209e21:	b1 30                	mov    cl,0x30
  209e23:	3c 0a                	cmp    al,0xa
  209e25:	72 02                	jb     209e29 <warn.16+0xb9>
  209e27:	b1 57                	mov    cl,0x57
  209e29:	48 8d 5c 24 4f       	lea    rbx,[rsp+0x4f]
  209e2e:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209e30:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
        if (a == 0) break;
  209e34:	48 83 fd 0a          	cmp    rbp,0xa
  209e38:	73 0a                	jae    209e44 <warn.16+0xd4>
  209e3a:	b8 40 00 00 00       	mov    eax,0x40
  209e3f:	48 89 d9             	mov    rcx,rbx
  209e42:	eb 54                	jmp    209e98 <warn.16+0x128>
  209e44:	48 89 df             	mov    rdi,rbx
  209e47:	b8 40 00 00 00       	mov    eax,0x40
  209e4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        a /= base;
  209e50:	48 89 ea             	mov    rdx,rbp
  209e53:	c4 c2 f3 f6 d5       	mulx   rdx,rcx,r13
  209e58:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  209e5c:	c4 c2 f3 f6 f5       	mulx   rsi,rcx,r13
  209e61:	c1 ee 02             	shr    esi,0x2
  209e64:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  209e6a:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  209e6d:	89 d1                	mov    ecx,edx
  209e6f:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  209e71:	b3 30                	mov    bl,0x30
  209e73:	80 f9 0a             	cmp    cl,0xa
  209e76:	72 02                	jb     209e7a <warn.16+0x10a>
  209e78:	b3 57                	mov    bl,0x57
  209e7a:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209e7c:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  209e80:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  209e84:	48 83 fd 63          	cmp    rbp,0x63
  209e88:	48 89 d5             	mov    rbp,rdx
  209e8b:	77 c3                	ja     209e50 <warn.16+0xe0>
        const padded_buf = buf[index - padding ..];
  209e8d:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  209e91:	48 83 c1 0f          	add    rcx,0xf
  209e95:	48 89 fb             	mov    rbx,rdi
  209e98:	ba 41 00 00 00       	mov    edx,0x41
  209e9d:	48 29 c2             	sub    rdx,rax
  209ea0:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  209ea4:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  209ea9:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  209eac:	4c 89 f7             	mov    rdi,r14
  209eaf:	c5 f8 77             	vzeroupper 
  209eb2:	41 ff d4             	call   r12
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  209eb5:	66 85 c0             	test   ax,ax
  209eb8:	0f 85 e6 00 00 00    	jne    209fa4 <warn.16+0x234>
                        try output(context, fmt[start_index..i]);
  209ebe:	48 8d 35 b3 6c 01 00 	lea    rsi,[rip+0x16cb3]        # 220b78 <__unnamed_15>
  209ec5:	4c 89 f7             	mov    rdi,r14
  209ec8:	41 ff d4             	call   r12
  209ecb:	66 85 c0             	test   ax,ax
  209ece:	0f 85 d0 00 00 00    	jne    209fa4 <warn.16+0x234>
    var buf: [max_int_digits - 1]u8 = undefined;
  209ed4:	c5 fc 10 05 9c d8 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffd89c]        # 207778 <__unnamed_14+0x1f>
  209edb:	ff 
  209edc:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  209ee2:	c5 fc 10 05 6f d8 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffd86f]        # 207759 <__unnamed_14>
  209ee9:	ff 
  209eea:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  209ef0:	4c 89 fa             	mov    rdx,r15
  209ef3:	c4 c2 fb f6 cd       	mulx   rcx,rax,r13
  209ef8:	c1 e9 02             	shr    ecx,0x2
  209efb:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  209f01:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  209f04:	44 89 f8             	mov    eax,r15d
  209f07:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  209f09:	b1 30                	mov    cl,0x30
  209f0b:	3c 0a                	cmp    al,0xa
  209f0d:	72 02                	jb     209f11 <warn.16+0x1a1>
  209f0f:	b1 57                	mov    cl,0x57
  209f11:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209f13:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
  209f17:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  209f1c:	49 83 ff 0a          	cmp    r15,0xa
  209f20:	72 53                	jb     209f75 <warn.16+0x205>
  209f22:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  209f29:	1f 84 00 00 00 00 00 
        a /= base;
  209f30:	4c 89 fa             	mov    rdx,r15
  209f33:	c4 c2 f3 f6 d5       	mulx   rdx,rcx,r13
  209f38:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  209f3c:	c4 c2 f3 f6 f5       	mulx   rsi,rcx,r13
  209f41:	c1 ee 02             	shr    esi,0x2
  209f44:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  209f4a:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  209f4d:	89 d1                	mov    ecx,edx
  209f4f:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  209f51:	b3 30                	mov    bl,0x30
  209f53:	80 f9 0a             	cmp    cl,0xa
  209f56:	72 02                	jb     209f5a <warn.16+0x1ea>
  209f58:	b3 57                	mov    bl,0x57
  209f5a:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209f5c:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  209f60:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  209f64:	49 83 ff 63          	cmp    r15,0x63
  209f68:	49 89 d7             	mov    r15,rdx
  209f6b:	77 c3                	ja     209f30 <warn.16+0x1c0>
        const padded_buf = buf[index - padding ..];
  209f6d:	48 8d 1c 04          	lea    rbx,[rsp+rax*1]
  209f71:	48 83 c3 0f          	add    rbx,0xf
  209f75:	b9 41 00 00 00       	mov    ecx,0x41
  209f7a:	48 29 c1             	sub    rcx,rax
  209f7d:	48 89 1c 24          	mov    QWORD PTR [rsp],rbx
  209f81:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  209f86:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  209f89:	4c 89 f7             	mov    rdi,r14
  209f8c:	c5 f8 77             	vzeroupper 
  209f8f:	41 ff d4             	call   r12
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  209f92:	66 85 c0             	test   ax,ax
  209f95:	75 0d                	jne    209fa4 <warn.16+0x234>
        try output(context, fmt[start_index..]);
  209f97:	48 8d 35 ea 6b 01 00 	lea    rsi,[rip+0x16bea]        # 220b88 <__unnamed_16>
  209f9e:	4c 89 f7             	mov    rdi,r14
  209fa1:	41 ff d4             	call   r12
    stderr.print(fmt, args) catch return;
  209fa4:	48 83 c4 58          	add    rsp,0x58
  209fa8:	5b                   	pop    rbx
  209fa9:	41 5c                	pop    r12
  209fab:	41 5d                	pop    r13
  209fad:	41 5e                	pop    r14
  209faf:	41 5f                	pop    r15
  209fb1:	5d                   	pop    rbp
  209fb2:	c3                   	ret    
  209fb3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  209fba:	84 00 00 00 00 00 

0000000000209fc0 <abort>:
pub const SIG_DFL = @intToPtr(extern fn (i32) void, 0);
pub const SIG_IGN = @intToPtr(extern fn (i32) void, 1);
pub const empty_sigset = []usize{0} ** sigset_t.len;

pub fn raise(sig: i32) usize {
    var set: sigset_t = undefined;
  209fc0:	50                   	push   rax
  209fc1:	c5 fc 10 05 9f c1 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc19f]        # 206168 <__unnamed_17+0x60>
  209fc8:	ff 
  209fc9:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  209fcf:	c5 fc 10 0d 71 c1 ff 	vmovups ymm1,YMMWORD PTR [rip+0xffffffffffffc171]        # 206148 <__unnamed_17+0x40>
  209fd6:	ff 
  209fd7:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  209fdd:	c5 fc 10 15 43 c1 ff 	vmovups ymm2,YMMWORD PTR [rip+0xffffffffffffc143]        # 206128 <__unnamed_17+0x20>
  209fe4:	ff 
  209fe5:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  209feb:	c5 fc 10 1d 15 c1 ff 	vmovups ymm3,YMMWORD PTR [rip+0xffffffffffffc115]        # 206108 <__unnamed_17>
  209ff2:	ff 
  209ff3:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
    return asm volatile ("syscall"
  209ff9:	4c 8d 0d 38 6c ff ff 	lea    r9,[rip+0xffffffffffff6c38]        # 200c38 <app_mask>
  20a000:	4c 8d 44 24 80       	lea    r8,[rsp-0x80]
  20a005:	b8 0e 00 00 00       	mov    eax,0xe
  20a00a:	bf 00 00 00 00       	mov    edi,0x0
  20a00f:	41 ba 08 00 00 00    	mov    r10d,0x8
  20a015:	4c 89 ce             	mov    rsi,r9
  20a018:	4c 89 c2             	mov    rdx,r8
  20a01b:	0f 05                	syscall 
    return asm volatile ("syscall"
  20a01d:	b8 ba 00 00 00       	mov    eax,0xba
  20a022:	0f 05                	syscall 
    blockAppSignals(&set);
    const tid = @intCast(i32, syscall0(SYS_gettid));
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  20a024:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  20a027:	b8 c8 00 00 00       	mov    eax,0xc8
  20a02c:	be 06 00 00 00       	mov    esi,0x6
  20a031:	0f 05                	syscall 
    return asm volatile ("syscall"
  20a033:	b8 0e 00 00 00       	mov    eax,0xe
  20a038:	bf 02 00 00 00       	mov    edi,0x2
  20a03d:	ba 00 00 00 00       	mov    edx,0x0
  20a042:	41 ba 08 00 00 00    	mov    r10d,0x8
  20a048:	4c 89 c6             	mov    rsi,r8
  20a04b:	0f 05                	syscall 
    var set: sigset_t = undefined;
  20a04d:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  20a053:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  20a059:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  20a05f:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
  20a065:	b8 0e 00 00 00       	mov    eax,0xe
  20a06a:	bf 00 00 00 00       	mov    edi,0x0
  20a06f:	41 ba 08 00 00 00    	mov    r10d,0x8
  20a075:	4c 89 ce             	mov    rsi,r9
  20a078:	4c 89 c2             	mov    rdx,r8
  20a07b:	0f 05                	syscall 
    return asm volatile ("syscall"
  20a07d:	b8 ba 00 00 00       	mov    eax,0xba
  20a082:	0f 05                	syscall 
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  20a084:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  20a087:	b8 c8 00 00 00       	mov    eax,0xc8
  20a08c:	be 09 00 00 00       	mov    esi,0x9
  20a091:	0f 05                	syscall 
    return asm volatile ("syscall"
  20a093:	b8 0e 00 00 00       	mov    eax,0xe
  20a098:	bf 02 00 00 00       	mov    edi,0x2
  20a09d:	31 d2                	xor    edx,edx
  20a09f:	41 ba 08 00 00 00    	mov    r10d,0x8
  20a0a5:	4c 89 c6             	mov    rsi,r8
  20a0a8:	0f 05                	syscall 
  20a0aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            while (true) {}
  20a0b0:	eb fe                	jmp    20a0b0 <abort+0xf0>
  20a0b2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a0b9:	1f 84 00 00 00 00 00 

000000000020a0c0 <dumpCurrentStackTrace>:
pub fn dumpCurrentStackTrace(start_addr: ?usize) void {
  20a0c0:	55                   	push   rbp
  20a0c1:	48 89 e5             	mov    rbp,rsp
  20a0c4:	41 57                	push   r15
  20a0c6:	41 56                	push   r14
  20a0c8:	41 55                	push   r13
  20a0ca:	41 54                	push   r12
  20a0cc:	53                   	push   rbx
  20a0cd:	48 83 e4 e0          	and    rsp,0xffffffffffffffe0
  20a0d1:	48 81 ec a0 01 00 00 	sub    rsp,0x1a0
  20a0d8:	49 89 fe             	mov    r14,rdi
    if (stderr_stream) |st| {
  20a0db:	48 8b 1d 4e 6f 01 00 	mov    rbx,QWORD PTR [rip+0x16f4e]        # 221030 <stderr_stream>
  20a0e2:	48 85 db             	test   rbx,rbx
  20a0e5:	74 39                	je     20a120 <dumpCurrentStackTrace+0x60>
    if (self_debug_info) |info| {
  20a0e7:	48 8b 05 52 6f 01 00 	mov    rax,QWORD PTR [rip+0x16f52]        # 221040 <self_debug_info>
  20a0ee:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20a0f3:	48 85 c0             	test   rax,rax
  20a0f6:	74 6d                	je     20a165 <dumpCurrentStackTrace+0xa5>
// TODO make thread safe
var debug_info_allocator: ?*mem.Allocator = null;
var debug_info_direct_allocator: std.heap.DirectAllocator = undefined;
var debug_info_arena_allocator: std.heap.ArenaAllocator = undefined;
fn getDebugInfoAllocator() *mem.Allocator {
    if (debug_info_allocator) |a| return a;
  20a0f8:	48 83 3d 48 6f 01 00 	cmp    QWORD PTR [rip+0x16f48],0x0        # 221048 <debug_info_allocator>
  20a0ff:	00 
  20a100:	0f 84 4e 01 00 00    	je     20a254 <dumpCurrentStackTrace+0x194>
    for (posix_environ_raw) |ptr| {
  20a106:	48 8b 05 9b 2f 01 00 	mov    rax,QWORD PTR [rip+0x12f9b]        # 21d0a8 <posix_environ_raw+0x8>
  20a10d:	48 85 c0             	test   rax,rax
  20a110:	48 89 5c 24 70       	mov    QWORD PTR [rsp+0x70],rbx
  20a115:	0f 85 a4 01 00 00    	jne    20a2bf <dumpCurrentStackTrace+0x1ff>
  20a11b:	e9 5d 02 00 00       	jmp    20a37d <dumpCurrentStackTrace+0x2bd>
        stderr_file = try io.getStdErr();
  20a120:	48 8d 05 f9 2e 01 00 	lea    rax,[rip+0x12ef9]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a127:	48 89 05 fa 2e 01 00 	mov    QWORD PTR [rip+0x12efa],rax        # 21d028 <stderr_file_out_stream>
  20a12e:	48 8d 05 0b 18 00 00 	lea    rax,[rip+0x180b]        # 20b940 <FileOutStream_writeFn>
  20a135:	48 89 05 f4 2e 01 00 	mov    QWORD PTR [rip+0x12ef4],rax        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20a13c:	c7 05 da 2e 01 00 02 	mov    DWORD PTR [rip+0x12eda],0x2        # 21d020 <stderr_file>
  20a143:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a146:	48 8d 1d e3 2e 01 00 	lea    rbx,[rip+0x12ee3]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20a14d:	48 89 1d dc 6e 01 00 	mov    QWORD PTR [rip+0x16edc],rbx        # 221030 <stderr_stream>
    if (self_debug_info) |info| {
  20a154:	48 8b 05 e5 6e 01 00 	mov    rax,QWORD PTR [rip+0x16ee5]        # 221040 <self_debug_info>
  20a15b:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20a160:	48 85 c0             	test   rax,rax
  20a163:	75 93                	jne    20a0f8 <dumpCurrentStackTrace+0x38>
    if (debug_info_allocator) |a| return a;
  20a165:	48 8b 35 dc 6e 01 00 	mov    rsi,QWORD PTR [rip+0x16edc]        # 221048 <debug_info_allocator>
  20a16c:	48 85 f6             	test   rsi,rsi
  20a16f:	75 56                	jne    20a1c7 <dumpCurrentStackTrace+0x107>

    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  20a171:	c5 fc 10 05 37 6c 01 	vmovups ymm0,YMMWORD PTR [rip+0x16c37]        # 220db0 <__unnamed_18>
  20a178:	00 
  20a179:	c5 fc 11 05 bf 2e 01 	vmovups YMMWORD PTR [rip+0x12ebf],ymm0        # 21d040 <debug_info_direct_allocator>
  20a180:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  20a181:	c5 fa 6f 05 47 6c 01 	vmovdqu xmm0,XMMWORD PTR [rip+0x16c47]        # 220dd0 <__unnamed_19>
  20a188:	00 
  20a189:	c5 fa 7f 05 cf 2e 01 	vmovdqu XMMWORD PTR [rip+0x12ecf],xmm0        # 21d060 <debug_info_arena_allocator>
  20a190:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  20a191:	48 8d 05 a8 2e 01 00 	lea    rax,[rip+0x12ea8]        # 21d040 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  20a198:	48 8b 0d 41 6c 01 00 	mov    rcx,QWORD PTR [rip+0x16c41]        # 220de0 <__unnamed_19+0x10>
  20a19f:	48 89 0d ca 2e 01 00 	mov    QWORD PTR [rip+0x12eca],rcx        # 21d070 <debug_info_arena_allocator+0x10>
  20a1a6:	48 8d 35 b3 2e 01 00 	lea    rsi,[rip+0x12eb3]        # 21d060 <debug_info_arena_allocator>
  20a1ad:	48 89 05 c4 2e 01 00 	mov    QWORD PTR [rip+0x12ec4],rax        # 21d078 <debug_info_arena_allocator+0x18>
  20a1b4:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20a1b8:	c5 fe 7f 05 c0 2e 01 	vmovdqu YMMWORD PTR [rip+0x12ec0],ymm0        # 21d080 <debug_info_arena_allocator+0x20>
  20a1bf:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  20a1c0:	48 89 35 81 6e 01 00 	mov    QWORD PTR [rip+0x16e81],rsi        # 221048 <debug_info_allocator>
  20a1c7:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
        const info = try openSelfDebugInfo(getDebugInfoAllocator());
  20a1cc:	c5 f8 77             	vzeroupper 
  20a1cf:	e8 5c 18 00 00       	call   20ba30 <openSelfDebugInfo>
  20a1d4:	4c 0f bf 7c 24 30    	movsx  r15,WORD PTR [rsp+0x30]
  20a1da:	4d 85 ff             	test   r15,r15
  20a1dd:	74 56                	je     20a235 <dumpCurrentStackTrace+0x175>
  20a1df:	4c 8b 33             	mov    r14,QWORD PTR [rbx]
                        try output(context, fmt[start_index..i]);
  20a1e2:	48 8d 35 47 6a 01 00 	lea    rsi,[rip+0x16a47]        # 220c30 <__unnamed_20>
  20a1e9:	48 89 df             	mov    rdi,rbx
  20a1ec:	41 ff d6             	call   r14
  20a1ef:	66 85 c0             	test   ax,ax
  20a1f2:	0f 85 f9 14 00 00    	jne    20b6f1 <dumpCurrentStackTrace+0x1631>
        stderr.print("Unable to dump stack trace: Unable to open debug info: {}\n", @errorName(err)) catch return;
  20a1f8:	49 c1 e7 04          	shl    r15,0x4
  20a1fc:	48 8d 05 fd 3d 01 00 	lea    rax,[rip+0x13dfd]        # 21e000 <raw+0xf48>
                const casted_value = ([]const u8)(value);
  20a203:	c4 c1 7a 6f 04 07    	vmovdqu xmm0,XMMWORD PTR [r15+rax*1]
  20a209:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
  20a20f:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
                return output(context, casted_value);
  20a214:	48 89 df             	mov    rdi,rbx
  20a217:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20a21a:	66 85 c0             	test   ax,ax
  20a21d:	0f 85 ce 14 00 00    	jne    20b6f1 <dumpCurrentStackTrace+0x1631>
        try output(context, fmt[start_index..]);
  20a223:	48 8d 35 16 6a 01 00 	lea    rsi,[rip+0x16a16]        # 220c40 <__unnamed_21>
  20a22a:	48 89 df             	mov    rdi,rbx
  20a22d:	41 ff d6             	call   r14
  20a230:	e9 bc 14 00 00       	jmp    20b6f1 <dumpCurrentStackTrace+0x1631>
        const info = try openSelfDebugInfo(getDebugInfoAllocator());
  20a235:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  20a23a:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
        self_debug_info = info;
  20a23f:	48 89 05 fa 6d 01 00 	mov    QWORD PTR [rip+0x16dfa],rax        # 221040 <self_debug_info>
    if (debug_info_allocator) |a| return a;
  20a246:	48 83 3d fa 6d 01 00 	cmp    QWORD PTR [rip+0x16dfa],0x0        # 221048 <debug_info_allocator>
  20a24d:	00 
  20a24e:	0f 85 b2 fe ff ff    	jne    20a106 <dumpCurrentStackTrace+0x46>
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  20a254:	c5 fc 10 05 54 6b 01 	vmovups ymm0,YMMWORD PTR [rip+0x16b54]        # 220db0 <__unnamed_18>
  20a25b:	00 
  20a25c:	c5 fc 11 05 dc 2d 01 	vmovups YMMWORD PTR [rip+0x12ddc],ymm0        # 21d040 <debug_info_direct_allocator>
  20a263:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  20a264:	c5 fa 6f 05 64 6b 01 	vmovdqu xmm0,XMMWORD PTR [rip+0x16b64]        # 220dd0 <__unnamed_19>
  20a26b:	00 
  20a26c:	c5 fa 7f 05 ec 2d 01 	vmovdqu XMMWORD PTR [rip+0x12dec],xmm0        # 21d060 <debug_info_arena_allocator>
  20a273:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  20a274:	48 8d 05 c5 2d 01 00 	lea    rax,[rip+0x12dc5]        # 21d040 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  20a27b:	48 8b 0d 5e 6b 01 00 	mov    rcx,QWORD PTR [rip+0x16b5e]        # 220de0 <__unnamed_19+0x10>
  20a282:	48 89 0d e7 2d 01 00 	mov    QWORD PTR [rip+0x12de7],rcx        # 21d070 <debug_info_arena_allocator+0x10>
  20a289:	48 8d 0d d0 2d 01 00 	lea    rcx,[rip+0x12dd0]        # 21d060 <debug_info_arena_allocator>
  20a290:	48 89 05 e1 2d 01 00 	mov    QWORD PTR [rip+0x12de1],rax        # 21d078 <debug_info_arena_allocator+0x18>
  20a297:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20a29b:	c5 fe 7f 05 dd 2d 01 	vmovdqu YMMWORD PTR [rip+0x12ddd],ymm0        # 21d080 <debug_info_arena_allocator+0x20>
  20a2a2:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  20a2a3:	48 89 0d 9e 6d 01 00 	mov    QWORD PTR [rip+0x16d9e],rcx        # 221048 <debug_info_allocator>
  20a2aa:	48 8b 05 f7 2d 01 00 	mov    rax,QWORD PTR [rip+0x12df7]        # 21d0a8 <posix_environ_raw+0x8>
  20a2b1:	48 85 c0             	test   rax,rax
  20a2b4:	48 89 5c 24 70       	mov    QWORD PTR [rsp+0x70],rbx
  20a2b9:	0f 84 be 00 00 00    	je     20a37d <dumpCurrentStackTrace+0x2bd>
  20a2bf:	48 8b 0d da 2d 01 00 	mov    rcx,QWORD PTR [rip+0x12dda]        # 21d0a0 <posix_environ_raw>
  20a2c6:	31 d2                	xor    edx,edx
  20a2c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20a2cf:	00 
  20a2d0:	48 8b 34 d1          	mov    rsi,QWORD PTR [rcx+rdx*8]
  20a2d4:	48 c7 c7 f1 ff ff ff 	mov    rdi,0xfffffffffffffff1
        while (ptr[line_i] != 0 and ptr[line_i] != '=') : (line_i += 1) {}
  20a2db:	8a 5c 3e 0f          	mov    bl,BYTE PTR [rsi+rdi*1+0xf]
  20a2df:	84 db                	test   bl,bl
  20a2e1:	74 1f                	je     20a302 <dumpCurrentStackTrace+0x242>
  20a2e3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a2ea:	84 00 00 00 00 00 
  20a2f0:	80 fb 3d             	cmp    bl,0x3d
  20a2f3:	74 0d                	je     20a302 <dumpCurrentStackTrace+0x242>
  20a2f5:	48 83 c7 01          	add    rdi,0x1
  20a2f9:	0f b6 5c 3e 0f       	movzx  ebx,BYTE PTR [rsi+rdi*1+0xf]
  20a2fe:	84 db                	test   bl,bl
  20a300:	75 ee                	jne    20a2f0 <dumpCurrentStackTrace+0x230>
    if (a.len != b.len) return false;
  20a302:	48 85 ff             	test   rdi,rdi
  20a305:	75 69                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
        if (b[index] != item) return false;
  20a307:	80 3e 5a             	cmp    BYTE PTR [rsi],0x5a
  20a30a:	75 64                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a30c:	80 7e 01 49          	cmp    BYTE PTR [rsi+0x1],0x49
  20a310:	75 5e                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a312:	80 7e 02 47          	cmp    BYTE PTR [rsi+0x2],0x47
  20a316:	75 58                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a318:	80 7e 03 5f          	cmp    BYTE PTR [rsi+0x3],0x5f
  20a31c:	75 52                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a31e:	80 7e 04 44          	cmp    BYTE PTR [rsi+0x4],0x44
  20a322:	75 4c                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a324:	80 7e 05 45          	cmp    BYTE PTR [rsi+0x5],0x45
  20a328:	75 46                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a32a:	80 7e 06 42          	cmp    BYTE PTR [rsi+0x6],0x42
  20a32e:	75 40                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a330:	80 7e 07 55          	cmp    BYTE PTR [rsi+0x7],0x55
  20a334:	75 3a                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a336:	80 7e 08 47          	cmp    BYTE PTR [rsi+0x8],0x47
  20a33a:	75 34                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a33c:	80 7e 09 5f          	cmp    BYTE PTR [rsi+0x9],0x5f
  20a340:	75 2e                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a342:	80 7e 0a 43          	cmp    BYTE PTR [rsi+0xa],0x43
  20a346:	75 28                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a348:	80 7e 0b 4f          	cmp    BYTE PTR [rsi+0xb],0x4f
  20a34c:	75 22                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a34e:	80 7e 0c 4c          	cmp    BYTE PTR [rsi+0xc],0x4c
  20a352:	75 1c                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a354:	80 7e 0d 4f          	cmp    BYTE PTR [rsi+0xd],0x4f
  20a358:	75 16                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a35a:	80 7e 0e 52          	cmp    BYTE PTR [rsi+0xe],0x52
  20a35e:	0f 84 44 14 00 00    	je     20b7a8 <dumpCurrentStackTrace+0x16e8>
  20a364:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a36b:	00 00 00 00 00 
    for (posix_environ_raw) |ptr| {
  20a370:	48 83 c2 01          	add    rdx,0x1
  20a374:	48 39 c2             	cmp    rdx,rax
  20a377:	0f 82 53 ff ff ff    	jb     20a2d0 <dumpCurrentStackTrace+0x210>
    return syscall3(SYS_ioctl, @intCast(usize, fd), TIOCGWINSZ, @ptrToInt(&wsz)) == 0;
  20a37d:	48 63 3d 9c 2c 01 00 	movsxd rdi,DWORD PTR [rip+0x12c9c]        # 21d020 <stderr_file>
  20a384:	48 8d 54 24 30       	lea    rdx,[rsp+0x30]
    return asm volatile ("syscall"
  20a389:	b8 10 00 00 00       	mov    eax,0x10
  20a38e:	be 13 54 00 00       	mov    esi,0x5413
  20a393:	0f 05                	syscall 
  20a395:	48 85 c0             	test   rax,rax
  20a398:	0f 94 44 24 0f       	sete   BYTE PTR [rsp+0xf]
    if (start_addr) |addr| {
  20a39d:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  20a3a2:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  20a3a7:	75 0f                	jne    20a3b8 <dumpCurrentStackTrace+0x2f8>
  20a3a9:	49 8b 0e             	mov    rcx,QWORD PTR [r14]
  20a3ac:	b0 01                	mov    al,0x1
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  20a3ae:	48 85 ed             	test   rbp,rbp
  20a3b1:	75 10                	jne    20a3c3 <dumpCurrentStackTrace+0x303>
  20a3b3:	e9 39 13 00 00       	jmp    20b6f1 <dumpCurrentStackTrace+0x1631>
  20a3b8:	31 c0                	xor    eax,eax
  20a3ba:	48 85 ed             	test   rbp,rbp
  20a3bd:	0f 84 2e 13 00 00    	je     20b6f1 <dumpCurrentStackTrace+0x1631>
  20a3c3:	48 89 ea             	mov    rdx,rbp
  20a3c6:	c4 62 7d 59 25 59 68 	vpbroadcastq ymm12,QWORD PTR [rip+0xffffffffffff6859]        # 200c28 <__unnamed_441+0x88>
  20a3cd:	ff ff 
  20a3cf:	c4 62 7d 59 2d a8 68 	vpbroadcastq ymm13,QWORD PTR [rip+0xffffffffffff68a8]        # 200c80 <app_mask+0x48>
  20a3d6:	ff ff 
  20a3d8:	c5 7d 7f a4 24 00 01 	vmovdqa YMMWORD PTR [rsp+0x100],ymm12
  20a3df:	00 00 
  20a3e1:	c5 7d 7f ac 24 e0 00 	vmovdqa YMMWORD PTR [rsp+0xe0],ymm13
  20a3e8:	00 00 
  20a3ea:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  20a3f1:	00 
  20a3f2:	48 89 74 24 28       	mov    QWORD PTR [rsp+0x28],rsi
  20a3f7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a3fe:	00 00 
        const return_address = @intToPtr(*const usize, fp + @sizeOf(usize)).*;
  20a400:	4c 8b 6a 08          	mov    r13,QWORD PTR [rdx+0x8]
                if (return_address == addr) {
  20a404:	49 39 cd             	cmp    r13,rcx
        switch (addr_state) {
  20a407:	74 17                	je     20a420 <dumpCurrentStackTrace+0x360>
  20a409:	f6 d0                	not    al
  20a40b:	a8 01                	test   al,0x1
  20a40d:	b0 01                	mov    al,0x1
  20a40f:	75 0f                	jne    20a420 <dumpCurrentStackTrace+0x360>
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  20a411:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  20a414:	48 85 d2             	test   rdx,rdx
  20a417:	75 e7                	jne    20a400 <dumpCurrentStackTrace+0x340>
  20a419:	e9 d3 12 00 00       	jmp    20b6f1 <dumpCurrentStackTrace+0x1631>
  20a41e:	66 90                	xchg   ax,ax
  20a420:	48 89 94 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rdx
  20a427:	00 
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  20a428:	48 89 b4 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rsi
  20a42f:	00 
  20a430:	48 8d 05 29 61 00 00 	lea    rax,[rip+0x6129]        # 210560 <FileInStream_readFn>
  20a437:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20a43e:	00 
        pub fn deinit(self: Self) void {
            self.allocator.free(self.items);
        }

        pub fn toSlice(self: Self) []align(A) T {
            return self.items[0..self.len];
  20a43f:	48 8b 86 b8 00 00 00 	mov    rax,QWORD PTR [rsi+0xb8]
  20a446:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  20a44b:	48 85 c0             	test   rax,rax
  20a44e:	0f 84 6c 04 00 00    	je     20a8c0 <dumpCurrentStackTrace+0x800>
  20a454:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20a459:	4c 8b 88 a8 00 00 00 	mov    r9,QWORD PTR [rax+0xa8]
  20a460:	45 31 e4             	xor    r12d,r12d
  20a463:	e9 08 02 00 00       	jmp    20a670 <dumpCurrentStackTrace+0x5b0>
                result = (result << 8) | b;
            }
        },
        builtin.Endian.Little => {
            const ShiftType = math.Log2Int(T);
            for (bytes) |b, index| {
  20a468:	48 89 c3             	mov    rbx,rax
  20a46b:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  20a46f:	48 8d 73 f0          	lea    rsi,[rbx-0x10]
  20a473:	48 89 f7             	mov    rdi,rsi
  20a476:	48 c1 ef 04          	shr    rdi,0x4
  20a47a:	44 8d 47 01          	lea    r8d,[rdi+0x1]
  20a47e:	41 83 e0 01          	and    r8d,0x1
  20a482:	48 85 f6             	test   rsi,rsi
  20a485:	0f 84 bd 01 00 00    	je     20a648 <dumpCurrentStackTrace+0x588>
  20a48b:	49 8d 70 ff          	lea    rsi,[r8-0x1]
  20a48f:	48 29 fe             	sub    rsi,rdi
  20a492:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20a496:	31 ff                	xor    edi,edi
  20a498:	c5 fd 6f 25 00 68 ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff6800]        # 200ca0 <app_mask+0x68>
  20a49f:	ff 
  20a4a0:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  20a4a4:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20a4a8:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  20a4ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20a4b0:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  20a4b6:	c4 e2 7d 32 74 39 04 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x4]
  20a4bd:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  20a4c4:	c4 62 7d 32 44 39 0c 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0xc]
  20a4cb:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  20a4d0:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  20a4d5:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  20a4da:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  20a4df:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  20a4e4:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  20a4e8:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  20a4ed:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  20a4f1:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  20a4f6:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  20a4fa:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  20a4ff:	c4 e2 7d 32 74 39 10 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x10]
  20a506:	c4 e2 7d 32 7c 39 14 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x14]
  20a50d:	c4 62 7d 32 44 39 18 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0x18]
  20a514:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  20a518:	c4 e2 7d 32 6c 39 1c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x1c]
  20a51f:	c4 62 7d 59 15 50 67 	vpbroadcastq ymm10,QWORD PTR [rip+0xffffffffffff6750]        # 200c78 <app_mask+0x40>
  20a526:	ff ff 
  20a528:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  20a52d:	c4 62 7d 59 1d 82 66 	vpbroadcastq ymm11,QWORD PTR [rip+0xffffffffffff6682]        # 200bb8 <__unnamed_441+0x18>
  20a534:	ff ff 
  20a536:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  20a53b:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  20a540:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  20a545:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  20a54a:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  20a54e:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  20a553:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  20a557:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  20a55c:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  20a560:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  20a565:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  20a569:	48 83 c7 20          	add    rdi,0x20
  20a56d:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  20a572:	48 83 c6 02          	add    rsi,0x2
  20a576:	0f 85 34 ff ff ff    	jne    20a4b0 <dumpCurrentStackTrace+0x3f0>
  20a57c:	4d 85 c0             	test   r8,r8
  20a57f:	74 53                	je     20a5d4 <dumpCurrentStackTrace+0x514>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20a581:	c4 e2 7d 32 6c 39 0c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0xc]
  20a588:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  20a58d:	c4 c1 5d d4 f4       	vpaddq ymm6,ymm4,ymm12
  20a592:	c4 c1 4d db f5       	vpand  ymm6,ymm6,ymm13
  20a597:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20a59c:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  20a5a3:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  20a5a7:	c4 c1 5d db e5       	vpand  ymm4,ymm4,ymm13
  20a5ac:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  20a5b1:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  20a5b5:	c4 e2 7d 32 6c 39 04 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x4]
  20a5bc:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20a5c1:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  20a5c5:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  20a5cb:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  20a5d0:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  20a5d4:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  20a5d8:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  20a5dc:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20a5e0:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  20a5e6:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20a5ea:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  20a5ef:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20a5f3:	c4 e1 f9 7e c6       	vmovq  rsi,xmm0
  20a5f8:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  20a5fb:	74 31                	je     20a62e <dumpCurrentStackTrace+0x56e>
  20a5fd:	48 29 d8             	sub    rax,rbx
  20a600:	48 01 d9             	add    rcx,rbx
  20a603:	48 c1 e3 03          	shl    rbx,0x3
  20a607:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a60e:	00 00 
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20a610:	0f b6 39             	movzx  edi,BYTE PTR [rcx]
  20a613:	89 da                	mov    edx,ebx
  20a615:	80 e2 38             	and    dl,0x38
  20a618:	c4 e2 e9 f7 d7       	shlx   rdx,rdi,rdx
  20a61d:	48 09 d6             	or     rsi,rdx
            for (bytes) |b, index| {
  20a620:	48 83 c3 08          	add    rbx,0x8
  20a624:	48 83 c1 01          	add    rcx,0x1
  20a628:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20a62c:	75 e2                	jne    20a610 <dumpCurrentStackTrace+0x550>
            if (st.debug_ranges) |debug_ranges| {
  20a62e:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20a633:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  20a63a:	48 85 c0             	test   rax,rax
  20a63d:	0f 85 fd 00 00 00    	jne    20a740 <dumpCurrentStackTrace+0x680>
  20a643:	e9 68 02 00 00       	jmp    20a8b0 <dumpCurrentStackTrace+0x7f0>
  20a648:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20a64c:	31 ff                	xor    edi,edi
  20a64e:	c5 fd 6f 25 4a 66 ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff664a]        # 200ca0 <app_mask+0x68>
  20a655:	ff 
  20a656:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  20a65a:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20a65e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  20a662:	4d 85 c0             	test   r8,r8
  20a665:	0f 85 16 ff ff ff    	jne    20a581 <dumpCurrentStackTrace+0x4c1>
  20a66b:	e9 64 ff ff ff       	jmp    20a5d4 <dumpCurrentStackTrace+0x514>
        if (compile_unit.pc_range) |range| {
  20a670:	4f 8d 34 64          	lea    r14,[r12+r12*2]
  20a674:	49 c1 e6 04          	shl    r14,0x4
  20a678:	43 80 7c 31 28 01    	cmp    BYTE PTR [r9+r14*1+0x28],0x1
  20a67e:	75 12                	jne    20a692 <dumpCurrentStackTrace+0x5d2>
            if (target_address >= range.start and target_address < range.end) return compile_unit;
  20a680:	4f 39 6c 31 18       	cmp    QWORD PTR [r9+r14*1+0x18],r13
  20a685:	77 0b                	ja     20a692 <dumpCurrentStackTrace+0x5d2>
  20a687:	4f 39 6c 31 20       	cmp    QWORD PTR [r9+r14*1+0x20],r13
  20a68c:	0f 87 4c 04 00 00    	ja     20aade <dumpCurrentStackTrace+0xa1e>
        if (compile_unit.die.getAttrSecOffset(DW.AT_ranges)) |ranges_offset| {
  20a692:	4b 8b 4c 31 08       	mov    rcx,QWORD PTR [r9+r14*1+0x8]
  20a697:	48 8b 41 20          	mov    rax,QWORD PTR [rcx+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  20a69b:	48 85 c0             	test   rax,rax
  20a69e:	0f 84 0c 02 00 00    	je     20a8b0 <dumpCurrentStackTrace+0x7f0>
  20a6a4:	4b 8d 14 31          	lea    rdx,[r9+r14*1]
  20a6a8:	48 83 c2 08          	add    rdx,0x8
  20a6ac:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  20a6b3:	00 
  20a6b4:	48 8b 49 10          	mov    rcx,QWORD PTR [rcx+0x10]
            if (attr.id == id) return &attr.value;
  20a6b8:	48 83 c1 20          	add    rcx,0x20
  20a6bc:	31 d2                	xor    edx,edx
  20a6be:	66 90                	xchg   ax,ax
  20a6c0:	48 83 79 e0 55       	cmp    QWORD PTR [rcx-0x20],0x55
  20a6c5:	74 19                	je     20a6e0 <dumpCurrentStackTrace+0x620>
        for (self.attrs.toSliceConst()) |*attr| {
  20a6c7:	48 83 c2 01          	add    rdx,0x1
  20a6cb:	48 83 c1 28          	add    rcx,0x28
  20a6cf:	48 39 c2             	cmp    rdx,rax
  20a6d2:	72 ec                	jb     20a6c0 <dumpCurrentStackTrace+0x600>
  20a6d4:	e9 d7 01 00 00       	jmp    20a8b0 <dumpCurrentStackTrace+0x7f0>
  20a6d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  20a6e0:	8a 01                	mov    al,BYTE PTR [rcx]
  20a6e2:	3c 05                	cmp    al,0x5
        return switch (form_value.*) {
  20a6e4:	74 41                	je     20a727 <dumpCurrentStackTrace+0x667>
  20a6e6:	3c 02                	cmp    al,0x2
  20a6e8:	0f 85 d2 01 00 00    	jne    20a8c0 <dumpCurrentStackTrace+0x800>
            FormValue.Const => |value| value.asUnsignedLe(),
  20a6ee:	48 8b 41 f0          	mov    rax,QWORD PTR [rcx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  20a6f2:	48 83 f8 08          	cmp    rax,0x8
  20a6f6:	0f 87 c4 01 00 00    	ja     20a8c0 <dumpCurrentStackTrace+0x800>
            FormValue.Const => |value| value.asUnsignedLe(),
  20a6fc:	8a 51 f8             	mov    dl,BYTE PTR [rcx-0x8]
        if (self.signed) return error.InvalidDebugInfo;
  20a6ff:	84 d2                	test   dl,dl
  20a701:	0f 85 b9 01 00 00    	jne    20a8c0 <dumpCurrentStackTrace+0x800>
  20a707:	48 85 c0             	test   rax,rax
  20a70a:	0f 84 7c 01 00 00    	je     20a88c <dumpCurrentStackTrace+0x7cc>
  20a710:	48 8b 49 e8          	mov    rcx,QWORD PTR [rcx-0x18]
  20a714:	48 83 f8 10          	cmp    rax,0x10
  20a718:	0f 83 4a fd ff ff    	jae    20a468 <dumpCurrentStackTrace+0x3a8>
  20a71e:	31 db                	xor    ebx,ebx
  20a720:	31 f6                	xor    esi,esi
  20a722:	e9 d6 fe ff ff       	jmp    20a5fd <dumpCurrentStackTrace+0x53d>
            FormValue.SecOffset => |value| value,
  20a727:	48 8b 71 e8          	mov    rsi,QWORD PTR [rcx-0x18]
            if (st.debug_ranges) |debug_ranges| {
  20a72b:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20a730:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  20a737:	48 85 c0             	test   rax,rax
  20a73a:	0f 84 70 01 00 00    	je     20a8b0 <dumpCurrentStackTrace+0x7f0>
/// Cast an integer to a different integer type. If the value doesn't fit,
/// return an error.
pub fn cast(comptime T: type, x: var) (error{Overflow}!T) {
    comptime assert(@typeId(T) == builtin.TypeId.Int); // must pass an integer
    comptime assert(@typeId(@typeOf(x)) == builtin.TypeId.Int); // must pass an integer
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  20a740:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  20a744:	0f 88 76 01 00 00    	js     20a8c0 <dumpCurrentStackTrace+0x800>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20a74a:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20a74f:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20a752:	b8 08 00 00 00       	mov    eax,0x8
  20a757:	31 d2                	xor    edx,edx
  20a759:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20a75b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const ipos = try math.cast(isize, pos);
                const result = posix.lseek(self.handle, ipos, posix.SEEK_SET);
                const err = posix.getErrno(result);
                if (err > 0) {
  20a761:	0f 83 59 01 00 00    	jae    20a8c0 <dumpCurrentStackTrace+0x800>
  20a767:	4c 89 cb             	mov    rbx,r9
            try self.readNoEof(bytes[0..]);
  20a76a:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  20a771:	00 
  20a772:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20a777:	48 c7 44 24 18 08 00 	mov    QWORD PTR [rsp+0x18],0x8
  20a77e:	00 00 
            return self.readFn(self, buffer);
  20a780:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
  20a785:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  20a78c:	00 
  20a78d:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20a792:	c5 f8 77             	vzeroupper 
  20a795:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
            const amt_read = try self.read(buf);
  20a79c:	66 83 7c 24 30 00    	cmp    WORD PTR [rsp+0x30],0x0
  20a7a2:	0f 85 18 01 00 00    	jne    20a8c0 <dumpCurrentStackTrace+0x800>
  20a7a8:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  20a7ad:	0f 1f 00             	nop    DWORD PTR [rax]
            if (amt_read < buf.len) return error.EndOfStream;
  20a7b0:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  20a7b5:	0f 82 05 01 00 00    	jb     20a8c0 <dumpCurrentStackTrace+0x800>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20a7bb:	4c 8b bc 24 b8 00 00 	mov    r15,QWORD PTR [rsp+0xb8]
  20a7c2:	00 
            try self.readNoEof(bytes[0..]);
  20a7c3:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  20a7ca:	00 
  20a7cb:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20a7d0:	48 c7 44 24 18 08 00 	mov    QWORD PTR [rsp+0x18],0x8
  20a7d7:	00 00 
            return self.readFn(self, buffer);
  20a7d9:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
  20a7de:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  20a7e5:	00 
  20a7e6:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20a7eb:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
            const amt_read = try self.read(buf);
  20a7f2:	66 83 7c 24 30 00    	cmp    WORD PTR [rsp+0x30],0x0
  20a7f8:	0f 85 c2 00 00 00    	jne    20a8c0 <dumpCurrentStackTrace+0x800>
  20a7fe:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20a803:	48 39 44 24 38       	cmp    QWORD PTR [rsp+0x38],rax
  20a808:	0f 82 b2 00 00 00    	jb     20a8c0 <dumpCurrentStackTrace+0x800>
  20a80e:	48 8b 84 24 b8 00 00 	mov    rax,QWORD PTR [rsp+0xb8]
  20a815:	00 
                    if (begin_addr == 0 and end_addr == 0) {
  20a816:	48 89 c1             	mov    rcx,rax
  20a819:	4c 09 f9             	or     rcx,r15
  20a81c:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  20a823:	00 00 
  20a825:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  20a82c:	00 00 
  20a82e:	49 89 d9             	mov    r9,rbx
  20a831:	74 7d                	je     20a8b0 <dumpCurrentStackTrace+0x7f0>
                    if (begin_addr == @maxValue(usize)) {
  20a833:	49 83 ff ff          	cmp    r15,0xffffffffffffffff
  20a837:	74 0e                	je     20a847 <dumpCurrentStackTrace+0x787>
                    if (target_address >= begin_addr and target_address < end_addr) {
  20a839:	4d 39 ef             	cmp    r15,r13
  20a83c:	77 09                	ja     20a847 <dumpCurrentStackTrace+0x787>
  20a83e:	4c 39 e8             	cmp    rax,r13
  20a841:	0f 87 8d 02 00 00    	ja     20aad4 <dumpCurrentStackTrace+0xa14>
            try self.readNoEof(bytes[0..]);
  20a847:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  20a84e:	00 
  20a84f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20a854:	48 c7 44 24 18 08 00 	mov    QWORD PTR [rsp+0x18],0x8
  20a85b:	00 00 
            return self.readFn(self, buffer);
  20a85d:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
  20a862:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  20a869:	00 
  20a86a:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20a86f:	c5 f8 77             	vzeroupper 
  20a872:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
  20a879:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  20a87e:	66 83 7c 24 30 00    	cmp    WORD PTR [rsp+0x30],0x0
  20a884:	0f 84 26 ff ff ff    	je     20a7b0 <dumpCurrentStackTrace+0x6f0>
  20a88a:	eb 34                	jmp    20a8c0 <dumpCurrentStackTrace+0x800>
        return switch (form_value.*) {
  20a88c:	31 f6                	xor    esi,esi
            if (st.debug_ranges) |debug_ranges| {
  20a88e:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20a893:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  20a89a:	48 85 c0             	test   rax,rax
  20a89d:	0f 85 9d fe ff ff    	jne    20a740 <dumpCurrentStackTrace+0x680>
  20a8a3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a8aa:	84 00 00 00 00 00 
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  20a8b0:	49 83 c4 01          	add    r12,0x1
  20a8b4:	4c 3b 64 24 78       	cmp    r12,QWORD PTR [rsp+0x78]
  20a8b9:	0f 82 b1 fd ff ff    	jb     20a670 <dumpCurrentStackTrace+0x5b0>
  20a8bf:	90                   	nop
  20a8c0:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
            return std.fmt.format(self, Error, self.writeFn, format, args);
  20a8c5:	4d 8b 34 24          	mov    r14,QWORD PTR [r12]
                if (tty_color) {
  20a8c9:	80 7c 24 0f 00       	cmp    BYTE PTR [rsp+0xf],0x0
  20a8ce:	74 70                	je     20a940 <dumpCurrentStackTrace+0x880>
                        try output(context, fmt[start_index..i]);
  20a8d0:	4c 89 e7             	mov    rdi,r12
  20a8d3:	48 8d 35 96 63 01 00 	lea    rsi,[rip+0x16396]        # 220c70 <__unnamed_22>
  20a8da:	c5 f8 77             	vzeroupper 
  20a8dd:	41 ff d6             	call   r14
  20a8e0:	41 89 c7             	mov    r15d,eax
  20a8e3:	66 45 85 ff          	test   r15w,r15w
  20a8e7:	0f 85 a3 01 00 00    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
    var buf: [max_int_digits - 1]u8 = undefined;
  20a8ed:	c5 fc 10 05 83 ce ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffce83]        # 207778 <__unnamed_14+0x1f>
  20a8f4:	ff 
  20a8f5:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20a8fb:	c5 fe 6f 05 56 ce ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffce56]        # 207759 <__unnamed_14>
  20a902:	ff 
  20a903:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a909:	44 89 e8             	mov    eax,r13d
  20a90c:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  20a90e:	b1 30                	mov    cl,0x30
  20a910:	3c 0a                	cmp    al,0xa
  20a912:	72 02                	jb     20a916 <dumpCurrentStackTrace+0x856>
  20a914:	b1 57                	mov    cl,0x57
  20a916:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a918:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20a91c:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20a921:	49 83 fd 10          	cmp    r13,0x10
  20a925:	73 7e                	jae    20a9a5 <dumpCurrentStackTrace+0x8e5>
  20a927:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20a92c:	e9 af 00 00 00       	jmp    20a9e0 <dumpCurrentStackTrace+0x920>
  20a931:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a938:	0f 1f 84 00 00 00 00 
  20a93f:	00 
                        try output(context, fmt[start_index..i]);
  20a940:	4c 89 e7             	mov    rdi,r12
  20a943:	48 8d 35 46 63 01 00 	lea    rsi,[rip+0x16346]        # 220c90 <__unnamed_23>
  20a94a:	c5 f8 77             	vzeroupper 
  20a94d:	41 ff d6             	call   r14
  20a950:	41 89 c7             	mov    r15d,eax
  20a953:	66 45 85 ff          	test   r15w,r15w
  20a957:	0f 85 33 01 00 00    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
    var buf: [max_int_digits - 1]u8 = undefined;
  20a95d:	c5 fc 10 05 13 ce ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffce13]        # 207778 <__unnamed_14+0x1f>
  20a964:	ff 
  20a965:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20a96b:	c5 fe 6f 05 e6 cd ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffcde6]        # 207759 <__unnamed_14>
  20a972:	ff 
  20a973:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a979:	44 89 e8             	mov    eax,r13d
  20a97c:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  20a97e:	b1 30                	mov    cl,0x30
  20a980:	3c 0a                	cmp    al,0xa
  20a982:	72 02                	jb     20a986 <dumpCurrentStackTrace+0x8c6>
  20a984:	b1 57                	mov    cl,0x57
  20a986:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a988:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20a98c:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20a991:	49 83 fd 10          	cmp    r13,0x10
  20a995:	0f 83 7e 00 00 00    	jae    20aa19 <dumpCurrentStackTrace+0x959>
  20a99b:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20a9a0:	e9 ab 00 00 00       	jmp    20aa50 <dumpCurrentStackTrace+0x990>
        a /= base;
  20a9a5:	4c 89 e9             	mov    rcx,r13
  20a9a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20a9af:	00 
  20a9b0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a9b4:	89 ca                	mov    edx,ecx
  20a9b6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  20a9b9:	b3 30                	mov    bl,0x30
  20a9bb:	80 fa 0a             	cmp    dl,0xa
  20a9be:	72 02                	jb     20a9c2 <dumpCurrentStackTrace+0x902>
  20a9c0:	b3 57                	mov    bl,0x57
  20a9c2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a9c4:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20a9c8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20a9cc:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  20a9d3:	49 89 cd             	mov    r13,rcx
  20a9d6:	77 d8                	ja     20a9b0 <dumpCurrentStackTrace+0x8f0>
        const padded_buf = buf[index - padding ..];
  20a9d8:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20a9dc:	48 83 c1 2f          	add    rcx,0x2f
  20a9e0:	ba 41 00 00 00       	mov    edx,0x41
  20a9e5:	48 29 c2             	sub    rdx,rax
  20a9e8:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20a9ed:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20a9f2:	4c 89 e7             	mov    rdi,r12
  20a9f5:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20a9fa:	c5 f8 77             	vzeroupper 
  20a9fd:	41 ff d6             	call   r14
  20aa00:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20aa03:	66 45 85 ff          	test   r15w,r15w
  20aa07:	0f 85 83 00 00 00    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
        try output(context, fmt[start_index..]);
  20aa0d:	4c 89 e7             	mov    rdi,r12
  20aa10:	48 8d 35 69 62 01 00 	lea    rsi,[rip+0x16269]        # 220c80 <__unnamed_24>
  20aa17:	eb 6a                	jmp    20aa83 <dumpCurrentStackTrace+0x9c3>
        a /= base;
  20aa19:	4c 89 e9             	mov    rcx,r13
  20aa1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  20aa20:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20aa24:	89 ca                	mov    edx,ecx
  20aa26:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  20aa29:	b3 30                	mov    bl,0x30
  20aa2b:	80 fa 0a             	cmp    dl,0xa
  20aa2e:	72 02                	jb     20aa32 <dumpCurrentStackTrace+0x972>
  20aa30:	b3 57                	mov    bl,0x57
  20aa32:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20aa34:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20aa38:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20aa3c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  20aa43:	49 89 cd             	mov    r13,rcx
  20aa46:	77 d8                	ja     20aa20 <dumpCurrentStackTrace+0x960>
        const padded_buf = buf[index - padding ..];
  20aa48:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20aa4c:	48 83 c1 2f          	add    rcx,0x2f
  20aa50:	ba 41 00 00 00       	mov    edx,0x41
  20aa55:	48 29 c2             	sub    rdx,rax
  20aa58:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20aa5d:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20aa62:	4c 89 e7             	mov    rdi,r12
  20aa65:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20aa6a:	c5 f8 77             	vzeroupper 
  20aa6d:	41 ff d6             	call   r14
  20aa70:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20aa73:	66 45 85 ff          	test   r15w,r15w
  20aa77:	75 17                	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
        try output(context, fmt[start_index..]);
  20aa79:	4c 89 e7             	mov    rdi,r12
  20aa7c:	48 8d 35 1d 62 01 00 	lea    rsi,[rip+0x1621d]        # 220ca0 <__unnamed_25>
  20aa83:	41 ff d6             	call   r14
  20aa86:	41 89 c7             	mov    r15d,eax
  20aa89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  20aa90:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  20aa97:	00 00 
  20aa99:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  20aaa0:	00 00 
        try printSourceAtAddress(debug_info, out_stream, return_address, tty_color);
  20aaa2:	66 45 85 ff          	test   r15w,r15w
  20aaa6:	0f 85 f8 0b 00 00    	jne    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20aaac:	31 c0                	xor    eax,eax
  20aaae:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  20aab5:	00 
  20aab6:	48 8b 94 24 b0 00 00 	mov    rdx,QWORD PTR [rsp+0xb0]
  20aabd:	00 
  20aabe:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  20aac3:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  20aac6:	48 85 d2             	test   rdx,rdx
  20aac9:	0f 85 31 f9 ff ff    	jne    20a400 <dumpCurrentStackTrace+0x340>
  20aacf:	e9 1d 0c 00 00       	jmp    20b6f1 <dumpCurrentStackTrace+0x1631>
  20aad4:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  20aadb:	00 
  20aadc:	eb 08                	jmp    20aae6 <dumpCurrentStackTrace+0xa26>
            const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  20aade:	4b 8d 04 31          	lea    rax,[r9+r14*1]
  20aae2:	48 83 c0 08          	add    rax,0x8
  20aae6:	48 8b 00             	mov    rax,QWORD PTR [rax]
        }

        pub fn toSliceConst(self: Self) []align(A) const T {
            return self.items[0..self.len];
  20aae9:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  20aaed:	48 85 c9             	test   rcx,rcx
  20aaf0:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
  20aaf5:	0f 84 84 0b 00 00    	je     20b67f <dumpCurrentStackTrace+0x15bf>
  20aafb:	4d 01 f1             	add    r9,r14
  20aafe:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  20ab02:	31 d2                	xor    edx,edx
  20ab04:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ab0b:	00 00 00 00 00 
            if (attr.id == id) return &attr.value;
  20ab10:	48 83 38 03          	cmp    QWORD PTR [rax],0x3
  20ab14:	74 12                	je     20ab28 <dumpCurrentStackTrace+0xa68>
        for (self.attrs.toSliceConst()) |*attr| {
  20ab16:	48 83 c2 01          	add    rdx,0x1
  20ab1a:	48 83 c0 28          	add    rax,0x28
  20ab1e:	48 39 ca             	cmp    rdx,rcx
  20ab21:	72 ed                	jb     20ab10 <dumpCurrentStackTrace+0xa50>
  20ab23:	e9 57 0b 00 00       	jmp    20b67f <dumpCurrentStackTrace+0x15bf>
  20ab28:	8a 50 20             	mov    dl,BYTE PTR [rax+0x20]
  20ab2b:	80 fa 0a             	cmp    dl,0xa
        return switch (form_value.*) {
  20ab2e:	74 2f                	je     20ab5f <dumpCurrentStackTrace+0xa9f>
  20ab30:	48 8d 0d d1 b9 ff ff 	lea    rcx,[rip+0xffffffffffffb9d1]        # 206508 <__unnamed_26>
  20ab37:	80 fa 09             	cmp    dl,0x9
  20ab3a:	0f 85 a4 00 00 00    	jne    20abe4 <dumpCurrentStackTrace+0xb24>
            FormValue.String => |value| value,
  20ab40:	66 c7 44 24 10 00 00 	mov    WORD PTR [rsp+0x10],0x0
  20ab47:	c5 fa 6f 40 08       	vmovdqu xmm0,XMMWORD PTR [rax+0x8]
  20ab4c:	48 8d 44 24 18       	lea    rax,[rsp+0x18]
  20ab51:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
        return switch (form_value.*) {
  20ab55:	48 8d 4c 24 10       	lea    rcx,[rsp+0x10]
  20ab5a:	e9 85 00 00 00       	jmp    20abe4 <dumpCurrentStackTrace+0xb24>
            FormValue.StrPtr => |offset| getString(st, offset),
  20ab5f:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
  20ab63:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
    const pos = st.debug_str.offset + offset;
  20ab68:	48 8b 41 70          	mov    rax,QWORD PTR [rcx+0x70]
  20ab6c:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  20ab70:	78 45                	js     20abb7 <dumpCurrentStackTrace+0xaf7>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20ab72:	48 63 39             	movsxd rdi,DWORD PTR [rcx]
  20ab75:	b8 08 00 00 00       	mov    eax,0x8
  20ab7a:	31 d2                	xor    edx,edx
  20ab7c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20ab7e:	48 89 c1             	mov    rcx,rax
  20ab81:	48 f7 d9             	neg    rcx
  20ab84:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20ab8a:	b8 00 00 00 00       	mov    eax,0x0
  20ab8f:	48 0f 46 c8          	cmovbe rcx,rax
  20ab93:	66 b8 02 00          	mov    ax,0x2
  20ab97:	48 83 f9 1d          	cmp    rcx,0x1d
  20ab9b:	0f 87 a2 09 00 00    	ja     20b543 <dumpCurrentStackTrace+0x1483>
  20aba1:	48 8d 15 58 61 ff ff 	lea    rdx,[rip+0xffffffffffff6158]        # 200d00 <__unnamed_9+0x20>
  20aba8:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  20abac:	48 01 d1             	add    rcx,rdx
  20abaf:	ff e1                	jmp    rcx
  20abb1:	66 b8 22 00          	mov    ax,0x22
  20abb5:	eb 04                	jmp    20abbb <dumpCurrentStackTrace+0xafb>
  20abb7:	66 b8 23 00          	mov    ax,0x23
    try st.self_exe_file.seekTo(pos);
  20abbb:	66 89 44 24 30       	mov    WORD PTR [rsp+0x30],ax
  20abc0:	48 8b 84 24 d6 00 00 	mov    rax,QWORD PTR [rsp+0xd6]
  20abc7:	00 
  20abc8:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20abcd:	48 89 41 d1          	mov    QWORD PTR [rcx-0x2f],rax
  20abd1:	c5 fa 6f 84 24 c8 00 	vmovdqu xmm0,XMMWORD PTR [rsp+0xc8]
  20abd8:	00 00 
  20abda:	c5 fa 7f 41 c3       	vmovdqu XMMWORD PTR [rcx-0x3d],xmm0
        return switch (form_value.*) {
  20abdf:	48 8d 4c 24 30       	lea    rcx,[rsp+0x30]
  20abe4:	44 0f b7 39          	movzx  r15d,WORD PTR [rcx]
  20abe8:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
  20abec:	48 89 84 24 4e 01 00 	mov    QWORD PTR [rsp+0x14e],rax
  20abf3:	00 
  20abf4:	c5 fa 6f 41 02       	vmovdqu xmm0,XMMWORD PTR [rcx+0x2]
  20abf9:	c5 f9 7f 84 24 40 01 	vmovdqa XMMWORD PTR [rsp+0x140],xmm0
  20ac00:	00 00 
            const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  20ac02:	66 45 85 ff          	test   r15w,r15w
  20ac06:	0f 85 98 0a 00 00    	jne    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20ac0c:	48 8d 84 24 46 01 00 	lea    rax,[rsp+0x146]
  20ac13:	00 
  20ac14:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20ac18:	c5 f9 7f 84 24 20 01 	vmovdqa XMMWORD PTR [rsp+0x120],xmm0
  20ac1f:	00 00 
            if (getLineNumberInfo(debug_info, compile_unit, address - 1)) |line_info| {
  20ac21:	49 8d 4d ff          	lea    rcx,[r13-0x1]
  20ac25:	48 8d bc 24 58 01 00 	lea    rdi,[rsp+0x158]
  20ac2c:	00 
  20ac2d:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  20ac32:	4c 89 ca             	mov    rdx,r9
  20ac35:	c5 f8 77             	vzeroupper 
  20ac38:	e8 33 9b 00 00       	call   214770 <getLineNumberInfo>
  20ac3d:	44 0f b7 bc 24 58 01 	movzx  r15d,WORD PTR [rsp+0x158]
  20ac44:	00 00 
  20ac46:	66 45 85 ff          	test   r15w,r15w
  20ac4a:	74 77                	je     20acc3 <dumpCurrentStackTrace+0xc03>
            } else |err| switch (err) {
  20ac4c:	44 89 f8             	mov    eax,r15d
  20ac4f:	25 fe ff 00 00       	and    eax,0xfffe
  20ac54:	83 f8 24             	cmp    eax,0x24
  20ac57:	0f 85 47 0a 00 00    	jne    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20ac5d:	4d 8b 34 24          	mov    r14,QWORD PTR [r12]
                        try output(context, fmt[start_index..i]);
  20ac61:	4c 89 e7             	mov    rdi,r12
  20ac64:	48 8d 35 f5 60 01 00 	lea    rsi,[rip+0x160f5]        # 220d60 <__unnamed_27>
  20ac6b:	41 ff d6             	call   r14
  20ac6e:	41 89 c7             	mov    r15d,eax
  20ac71:	66 45 85 ff          	test   r15w,r15w
  20ac75:	0f 85 15 fe ff ff    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
    var buf: [max_int_digits - 1]u8 = undefined;
  20ac7b:	c5 fc 10 05 f5 ca ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffcaf5]        # 207778 <__unnamed_14+0x1f>
  20ac82:	ff 
  20ac83:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20ac89:	c5 fe 6f 05 c8 ca ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffcac8]        # 207759 <__unnamed_14>
  20ac90:	ff 
  20ac91:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20ac97:	44 89 e8             	mov    eax,r13d
  20ac9a:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  20ac9c:	b1 30                	mov    cl,0x30
  20ac9e:	3c 0a                	cmp    al,0xa
  20aca0:	72 02                	jb     20aca4 <dumpCurrentStackTrace+0xbe4>
  20aca2:	b1 57                	mov    cl,0x57
  20aca4:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20aca6:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20acaa:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20acaf:	49 83 fd 10          	cmp    r13,0x10
  20acb3:	0f 83 b8 04 00 00    	jae    20b171 <dumpCurrentStackTrace+0x10b1>
  20acb9:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20acbe:	e9 ed 04 00 00       	jmp    20b1b0 <dumpCurrentStackTrace+0x10f0>
  20acc3:	48 8d 84 24 60 01 00 	lea    rax,[rsp+0x160]
  20acca:	00 
            if (getLineNumberInfo(debug_info, compile_unit, address - 1)) |line_info| {
  20accb:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  20accf:	c5 fe 7f 84 24 80 00 	vmovdqu YMMWORD PTR [rsp+0x80],ymm0
  20acd6:	00 00 
  20acd8:	48 8b 40 20          	mov    rax,QWORD PTR [rax+0x20]
  20acdc:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  20ace3:	00 
  20ace4:	4c 89 e3             	mov    rbx,r12
  20ace7:	4c 8b a4 24 80 00 00 	mov    r12,QWORD PTR [rsp+0x80]
  20acee:	00 
  20acef:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20acf6:	00 
  20acf7:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  20acfc:	4c 8b 33             	mov    r14,QWORD PTR [rbx]
                if (tty_color) {
  20acff:	80 7c 24 0f 00       	cmp    BYTE PTR [rsp+0xf],0x0
  20ad04:	0f 84 cb 01 00 00    	je     20aed5 <dumpCurrentStackTrace+0xe15>
                        try output(context, fmt[start_index..i]);
  20ad0a:	48 89 df             	mov    rdi,rbx
  20ad0d:	48 8d 35 9c 5f 01 00 	lea    rsi,[rip+0x15f9c]        # 220cb0 <__unnamed_28>
  20ad14:	c5 f8 77             	vzeroupper 
  20ad17:	41 ff d6             	call   r14
  20ad1a:	41 89 c7             	mov    r15d,eax
  20ad1d:	66 45 85 ff          	test   r15w,r15w
  20ad21:	0f 85 dc 09 00 00    	jne    20b703 <dumpCurrentStackTrace+0x1643>
                const casted_value = ([]const u8)(value);
  20ad27:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  20ad2e:	00 
  20ad2f:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20ad33:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  20ad39:	48 89 df             	mov    rdi,rbx
  20ad3c:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20ad41:	41 ff d6             	call   r14
  20ad44:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20ad47:	66 45 85 ff          	test   r15w,r15w
  20ad4b:	0f 85 b2 09 00 00    	jne    20b703 <dumpCurrentStackTrace+0x1643>
                        try output(context, fmt[start_index..i]);
  20ad51:	48 89 df             	mov    rdi,rbx
  20ad54:	48 8d 35 65 5f 01 00 	lea    rsi,[rip+0x15f65]        # 220cc0 <__unnamed_29>
  20ad5b:	41 ff d6             	call   r14
  20ad5e:	41 89 c7             	mov    r15d,eax
  20ad61:	66 45 85 ff          	test   r15w,r15w
  20ad65:	0f 85 c1 09 00 00    	jne    20b72c <dumpCurrentStackTrace+0x166c>
    var buf: [max_int_digits - 1]u8 = undefined;
  20ad6b:	c5 fc 10 05 05 ca ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffca05]        # 207778 <__unnamed_14+0x1f>
  20ad72:	ff 
  20ad73:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20ad79:	c5 fe 6f 05 d8 c9 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc9d8]        # 207759 <__unnamed_14>
  20ad80:	ff 
  20ad81:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        const digit = a % base;
  20ad87:	4c 89 e2             	mov    rdx,r12
  20ad8a:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  20ad91:	cc cc cc 
  20ad94:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  20ad99:	c1 e9 02             	shr    ecx,0x2
  20ad9c:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20ada2:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20ada5:	44 89 e0             	mov    eax,r12d
  20ada8:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20adaa:	b1 30                	mov    cl,0x30
  20adac:	3c 0a                	cmp    al,0xa
  20adae:	72 02                	jb     20adb2 <dumpCurrentStackTrace+0xcf2>
  20adb0:	b1 57                	mov    cl,0x57
  20adb2:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20adb4:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20adb8:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20adbd:	49 83 fc 0a          	cmp    r12,0xa
  20adc1:	73 0d                	jae    20add0 <dumpCurrentStackTrace+0xd10>
  20adc3:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20adc8:	eb 58                	jmp    20ae22 <dumpCurrentStackTrace+0xd62>
  20adca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        a /= base;
  20add0:	4c 89 e2             	mov    rdx,r12
  20add3:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  20adda:	cc cc cc 
  20addd:	48 89 ce             	mov    rsi,rcx
  20ade0:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  20ade5:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20ade9:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  20adee:	c1 ee 02             	shr    esi,0x2
  20adf1:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  20adf7:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  20adfa:	89 d1                	mov    ecx,edx
  20adfc:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  20adfe:	b3 30                	mov    bl,0x30
  20ae00:	80 f9 0a             	cmp    cl,0xa
  20ae03:	72 02                	jb     20ae07 <dumpCurrentStackTrace+0xd47>
  20ae05:	b3 57                	mov    bl,0x57
  20ae07:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20ae09:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20ae0d:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20ae11:	49 83 fc 63          	cmp    r12,0x63
  20ae15:	49 89 d4             	mov    r12,rdx
  20ae18:	77 b6                	ja     20add0 <dumpCurrentStackTrace+0xd10>
        const padded_buf = buf[index - padding ..];
  20ae1a:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20ae1e:	48 83 c1 2f          	add    rcx,0x2f
  20ae22:	ba 41 00 00 00       	mov    edx,0x41
  20ae27:	48 29 c2             	sub    rdx,rax
  20ae2a:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20ae2f:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  20ae34:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        return output(context, padded_buf);
  20ae39:	4c 89 e7             	mov    rdi,r12
  20ae3c:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20ae41:	c5 f8 77             	vzeroupper 
  20ae44:	41 ff d6             	call   r14
  20ae47:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20ae4a:	66 45 85 ff          	test   r15w,r15w
  20ae4e:	0f 85 dd 08 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20ae54:	4c 89 e7             	mov    rdi,r12
  20ae57:	48 8d 35 72 5e 01 00 	lea    rsi,[rip+0x15e72]        # 220cd0 <__unnamed_30>
  20ae5e:	41 ff d6             	call   r14
  20ae61:	41 89 c7             	mov    r15d,eax
  20ae64:	66 45 85 ff          	test   r15w,r15w
  20ae68:	0f 85 c3 08 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
    var buf: [max_int_digits - 1]u8 = undefined;
  20ae6e:	c5 fc 10 05 02 c9 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc902]        # 207778 <__unnamed_14+0x1f>
  20ae75:	ff 
  20ae76:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20ae7c:	c5 fe 6f 05 d5 c8 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc8d5]        # 207759 <__unnamed_14>
  20ae83:	ff 
  20ae84:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
  20ae8a:	48 8b 54 24 78       	mov    rdx,QWORD PTR [rsp+0x78]
        const digit = a % base;
  20ae8f:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  20ae96:	cc cc cc 
  20ae99:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  20ae9e:	c1 e9 02             	shr    ecx,0x2
  20aea1:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20aea7:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20aeaa:	89 d0                	mov    eax,edx
  20aeac:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20aeae:	b1 30                	mov    cl,0x30
  20aeb0:	3c 0a                	cmp    al,0xa
  20aeb2:	72 02                	jb     20aeb6 <dumpCurrentStackTrace+0xdf6>
  20aeb4:	b1 57                	mov    cl,0x57
  20aeb6:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20aeb8:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20aebc:	b9 40 00 00 00       	mov    ecx,0x40
        if (a == 0) break;
  20aec1:	48 83 fa 0a          	cmp    rdx,0xa
  20aec5:	0f 83 62 03 00 00    	jae    20b22d <dumpCurrentStackTrace+0x116d>
  20aecb:	48 8d 44 24 6f       	lea    rax,[rsp+0x6f]
  20aed0:	e9 af 03 00 00       	jmp    20b284 <dumpCurrentStackTrace+0x11c4>
                const casted_value = ([]const u8)(value);
  20aed5:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  20aedc:	00 
  20aedd:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20aee1:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  20aee7:	48 89 df             	mov    rdi,rbx
  20aeea:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20aeef:	c5 f8 77             	vzeroupper 
  20aef2:	41 ff d6             	call   r14
  20aef5:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20aef8:	66 45 85 ff          	test   r15w,r15w
  20aefc:	0f 85 01 08 00 00    	jne    20b703 <dumpCurrentStackTrace+0x1643>
                        try output(context, fmt[start_index..i]);
  20af02:	48 89 df             	mov    rdi,rbx
  20af05:	48 8d 35 04 5e 01 00 	lea    rsi,[rip+0x15e04]        # 220d10 <__unnamed_31>
  20af0c:	41 ff d6             	call   r14
  20af0f:	41 89 c7             	mov    r15d,eax
  20af12:	66 45 85 ff          	test   r15w,r15w
  20af16:	0f 85 f9 07 00 00    	jne    20b715 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  20af1c:	c5 fc 10 05 54 c8 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc854]        # 207778 <__unnamed_14+0x1f>
  20af23:	ff 
  20af24:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20af2a:	c5 fe 6f 05 27 c8 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc827]        # 207759 <__unnamed_14>
  20af31:	ff 
  20af32:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        const digit = a % base;
  20af38:	4c 89 e2             	mov    rdx,r12
  20af3b:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  20af42:	cc cc cc 
  20af45:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  20af4a:	c1 e9 02             	shr    ecx,0x2
  20af4d:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20af53:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20af56:	44 89 e0             	mov    eax,r12d
  20af59:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20af5b:	b1 30                	mov    cl,0x30
  20af5d:	3c 0a                	cmp    al,0xa
  20af5f:	72 02                	jb     20af63 <dumpCurrentStackTrace+0xea3>
  20af61:	b1 57                	mov    cl,0x57
  20af63:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20af65:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20af69:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20af6e:	49 83 fc 0a          	cmp    r12,0xa
  20af72:	73 0c                	jae    20af80 <dumpCurrentStackTrace+0xec0>
  20af74:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20af79:	eb 57                	jmp    20afd2 <dumpCurrentStackTrace+0xf12>
  20af7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        a /= base;
  20af80:	4c 89 e2             	mov    rdx,r12
  20af83:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  20af8a:	cc cc cc 
  20af8d:	48 89 ce             	mov    rsi,rcx
  20af90:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  20af95:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20af99:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  20af9e:	c1 ee 02             	shr    esi,0x2
  20afa1:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  20afa7:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  20afaa:	89 d1                	mov    ecx,edx
  20afac:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  20afae:	b3 30                	mov    bl,0x30
  20afb0:	80 f9 0a             	cmp    cl,0xa
  20afb3:	72 02                	jb     20afb7 <dumpCurrentStackTrace+0xef7>
  20afb5:	b3 57                	mov    bl,0x57
  20afb7:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20afb9:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20afbd:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20afc1:	49 83 fc 63          	cmp    r12,0x63
  20afc5:	49 89 d4             	mov    r12,rdx
  20afc8:	77 b6                	ja     20af80 <dumpCurrentStackTrace+0xec0>
        const padded_buf = buf[index - padding ..];
  20afca:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20afce:	48 83 c1 2f          	add    rcx,0x2f
  20afd2:	ba 41 00 00 00       	mov    edx,0x41
  20afd7:	48 29 c2             	sub    rdx,rax
  20afda:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20afdf:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  20afe4:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        return output(context, padded_buf);
  20afe9:	4c 89 e7             	mov    rdi,r12
  20afec:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20aff1:	c5 f8 77             	vzeroupper 
  20aff4:	41 ff d6             	call   r14
  20aff7:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20affa:	66 45 85 ff          	test   r15w,r15w
  20affe:	0f 85 2d 07 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20b004:	4c 89 e7             	mov    rdi,r12
  20b007:	48 8d 35 12 5d 01 00 	lea    rsi,[rip+0x15d12]        # 220d20 <__unnamed_32>
  20b00e:	41 ff d6             	call   r14
  20b011:	41 89 c7             	mov    r15d,eax
  20b014:	66 45 85 ff          	test   r15w,r15w
  20b018:	0f 85 13 07 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
    var buf: [max_int_digits - 1]u8 = undefined;
  20b01e:	c5 fc 10 05 52 c7 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc752]        # 207778 <__unnamed_14+0x1f>
  20b025:	ff 
  20b026:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20b02c:	c5 fe 6f 05 25 c7 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc725]        # 207759 <__unnamed_14>
  20b033:	ff 
  20b034:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
  20b03a:	48 8b 7c 24 78       	mov    rdi,QWORD PTR [rsp+0x78]
        const digit = a % base;
  20b03f:	48 89 fa             	mov    rdx,rdi
  20b042:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  20b049:	cc cc cc 
  20b04c:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  20b051:	c1 e9 02             	shr    ecx,0x2
  20b054:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20b05a:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20b05d:	89 f8                	mov    eax,edi
  20b05f:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20b061:	b1 30                	mov    cl,0x30
  20b063:	3c 0a                	cmp    al,0xa
  20b065:	72 02                	jb     20b069 <dumpCurrentStackTrace+0xfa9>
  20b067:	b1 57                	mov    cl,0x57
  20b069:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b06b:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20b06f:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20b074:	48 83 ff 0a          	cmp    rdi,0xa
  20b078:	73 16                	jae    20b090 <dumpCurrentStackTrace+0xfd0>
  20b07a:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20b07f:	eb 61                	jmp    20b0e2 <dumpCurrentStackTrace+0x1022>
  20b081:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b088:	0f 1f 84 00 00 00 00 
  20b08f:	00 
        a /= base;
  20b090:	48 89 fa             	mov    rdx,rdi
  20b093:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  20b09a:	cc cc cc 
  20b09d:	48 89 ce             	mov    rsi,rcx
  20b0a0:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  20b0a5:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20b0a9:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  20b0ae:	c1 ee 02             	shr    esi,0x2
  20b0b1:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  20b0b7:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  20b0ba:	89 d1                	mov    ecx,edx
  20b0bc:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  20b0be:	b3 30                	mov    bl,0x30
  20b0c0:	80 f9 0a             	cmp    cl,0xa
  20b0c3:	72 02                	jb     20b0c7 <dumpCurrentStackTrace+0x1007>
  20b0c5:	b3 57                	mov    bl,0x57
  20b0c7:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b0c9:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20b0cd:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20b0d1:	48 83 ff 63          	cmp    rdi,0x63
  20b0d5:	48 89 d7             	mov    rdi,rdx
  20b0d8:	77 b6                	ja     20b090 <dumpCurrentStackTrace+0xfd0>
        const padded_buf = buf[index - padding ..];
  20b0da:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20b0de:	48 83 c1 2f          	add    rcx,0x2f
  20b0e2:	ba 41 00 00 00       	mov    edx,0x41
  20b0e7:	48 29 c2             	sub    rdx,rax
  20b0ea:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20b0ef:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20b0f4:	4c 89 e7             	mov    rdi,r12
  20b0f7:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20b0fc:	c5 f8 77             	vzeroupper 
  20b0ff:	41 ff d6             	call   r14
  20b102:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b105:	66 45 85 ff          	test   r15w,r15w
  20b109:	0f 85 22 06 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20b10f:	4c 89 e7             	mov    rdi,r12
  20b112:	48 8d 35 17 5c 01 00 	lea    rsi,[rip+0x15c17]        # 220d30 <__unnamed_33>
  20b119:	41 ff d6             	call   r14
  20b11c:	41 89 c7             	mov    r15d,eax
  20b11f:	66 45 85 ff          	test   r15w,r15w
  20b123:	0f 85 08 06 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
    var buf: [max_int_digits - 1]u8 = undefined;
  20b129:	c5 fc 10 05 47 c6 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc647]        # 207778 <__unnamed_14+0x1f>
  20b130:	ff 
  20b131:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20b137:	c5 fe 6f 05 1a c6 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc61a]        # 207759 <__unnamed_14>
  20b13e:	ff 
  20b13f:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b145:	44 89 e8             	mov    eax,r13d
  20b148:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  20b14a:	b1 30                	mov    cl,0x30
  20b14c:	3c 0a                	cmp    al,0xa
  20b14e:	72 02                	jb     20b152 <dumpCurrentStackTrace+0x1092>
  20b150:	b1 57                	mov    cl,0x57
  20b152:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b154:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20b158:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20b15d:	49 83 fd 10          	cmp    r13,0x10
  20b161:	0f 83 ac 01 00 00    	jae    20b313 <dumpCurrentStackTrace+0x1253>
  20b167:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20b16c:	e9 df 01 00 00       	jmp    20b350 <dumpCurrentStackTrace+0x1290>
        a /= base;
  20b171:	4c 89 e9             	mov    rcx,r13
  20b174:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b17b:	00 00 00 00 00 
  20b180:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b184:	89 ca                	mov    edx,ecx
  20b186:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  20b189:	b3 30                	mov    bl,0x30
  20b18b:	80 fa 0a             	cmp    dl,0xa
  20b18e:	72 02                	jb     20b192 <dumpCurrentStackTrace+0x10d2>
  20b190:	b3 57                	mov    bl,0x57
  20b192:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b194:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20b198:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20b19c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  20b1a3:	49 89 cd             	mov    r13,rcx
  20b1a6:	77 d8                	ja     20b180 <dumpCurrentStackTrace+0x10c0>
        const padded_buf = buf[index - padding ..];
  20b1a8:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20b1ac:	48 83 c1 2f          	add    rcx,0x2f
  20b1b0:	ba 41 00 00 00       	mov    edx,0x41
  20b1b5:	48 29 c2             	sub    rdx,rax
  20b1b8:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20b1bd:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20b1c2:	4c 89 e7             	mov    rdi,r12
  20b1c5:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20b1ca:	c5 f8 77             	vzeroupper 
  20b1cd:	41 ff d6             	call   r14
  20b1d0:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20b1d3:	66 45 85 ff          	test   r15w,r15w
  20b1d7:	0f 85 b3 f8 ff ff    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
                        try output(context, fmt[start_index..i]);
  20b1dd:	4c 89 e7             	mov    rdi,r12
  20b1e0:	48 8d 35 89 5b 01 00 	lea    rsi,[rip+0x15b89]        # 220d70 <__unnamed_34>
  20b1e7:	41 ff d6             	call   r14
  20b1ea:	41 89 c7             	mov    r15d,eax
  20b1ed:	66 45 85 ff          	test   r15w,r15w
  20b1f1:	0f 85 99 f8 ff ff    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
                const casted_value = ([]const u8)(value);
  20b1f7:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  20b1fe:	00 00 
  20b200:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  20b206:	4c 89 e7             	mov    rdi,r12
  20b209:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b20e:	41 ff d6             	call   r14
  20b211:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b214:	66 45 85 ff          	test   r15w,r15w
  20b218:	0f 85 72 f8 ff ff    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
        try output(context, fmt[start_index..]);
  20b21e:	4c 89 e7             	mov    rdi,r12
  20b221:	48 8d 35 58 5b 01 00 	lea    rsi,[rip+0x15b58]        # 220d80 <__unnamed_35>
  20b228:	e9 56 f8 ff ff       	jmp    20aa83 <dumpCurrentStackTrace+0x9c3>
  20b22d:	48 89 d0             	mov    rax,rdx
        a /= base;
  20b230:	48 89 c2             	mov    rdx,rax
  20b233:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  20b23a:	cc cc cc 
  20b23d:	48 89 f7             	mov    rdi,rsi
  20b240:	c4 e2 cb f6 d7       	mulx   rdx,rsi,rdi
  20b245:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20b249:	c4 e2 cb f6 ff       	mulx   rdi,rsi,rdi
  20b24e:	c1 ef 02             	shr    edi,0x2
  20b251:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  20b257:	8d 3c bf             	lea    edi,[rdi+rdi*4]
  20b25a:	89 d6                	mov    esi,edx
  20b25c:	29 fe                	sub    esi,edi
        0...9 => digit + '0',
  20b25e:	b3 30                	mov    bl,0x30
  20b260:	40 80 fe 0a          	cmp    sil,0xa
  20b264:	72 02                	jb     20b268 <dumpCurrentStackTrace+0x11a8>
  20b266:	b3 57                	mov    bl,0x57
  20b268:	40 00 f3             	add    bl,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b26b:	88 5c 0c 2e          	mov    BYTE PTR [rsp+rcx*1+0x2e],bl
        if (a == 0) break;
  20b26f:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  20b273:	48 83 f8 63          	cmp    rax,0x63
  20b277:	48 89 d0             	mov    rax,rdx
  20b27a:	77 b4                	ja     20b230 <dumpCurrentStackTrace+0x1170>
        const padded_buf = buf[index - padding ..];
  20b27c:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  20b280:	48 83 c0 2f          	add    rax,0x2f
  20b284:	ba 41 00 00 00       	mov    edx,0x41
  20b289:	48 29 ca             	sub    rdx,rcx
  20b28c:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20b291:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20b296:	4c 89 e7             	mov    rdi,r12
  20b299:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20b29e:	c5 f8 77             	vzeroupper 
  20b2a1:	41 ff d6             	call   r14
  20b2a4:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b2a7:	66 45 85 ff          	test   r15w,r15w
  20b2ab:	0f 85 80 04 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20b2b1:	4c 89 e7             	mov    rdi,r12
  20b2b4:	48 8d 35 25 5a 01 00 	lea    rsi,[rip+0x15a25]        # 220ce0 <__unnamed_36>
  20b2bb:	41 ff d6             	call   r14
  20b2be:	41 89 c7             	mov    r15d,eax
  20b2c1:	66 45 85 ff          	test   r15w,r15w
  20b2c5:	0f 85 66 04 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
    var buf: [max_int_digits - 1]u8 = undefined;
  20b2cb:	c5 fc 10 05 a5 c4 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc4a5]        # 207778 <__unnamed_14+0x1f>
  20b2d2:	ff 
  20b2d3:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20b2d9:	c5 fe 6f 05 78 c4 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc478]        # 207759 <__unnamed_14>
  20b2e0:	ff 
  20b2e1:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b2e7:	44 89 e8             	mov    eax,r13d
  20b2ea:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  20b2ec:	b1 30                	mov    cl,0x30
  20b2ee:	3c 0a                	cmp    al,0xa
  20b2f0:	72 02                	jb     20b2f4 <dumpCurrentStackTrace+0x1234>
  20b2f2:	b1 57                	mov    cl,0x57
  20b2f4:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b2f6:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20b2fa:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20b2ff:	49 83 fd 10          	cmp    r13,0x10
  20b303:	0f 83 d4 00 00 00    	jae    20b3dd <dumpCurrentStackTrace+0x131d>
  20b309:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20b30e:	e9 fd 00 00 00       	jmp    20b410 <dumpCurrentStackTrace+0x1350>
        a /= base;
  20b313:	4c 89 e9             	mov    rcx,r13
  20b316:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b31d:	00 00 00 
  20b320:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b324:	89 ca                	mov    edx,ecx
  20b326:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  20b329:	b3 30                	mov    bl,0x30
  20b32b:	80 fa 0a             	cmp    dl,0xa
  20b32e:	72 02                	jb     20b332 <dumpCurrentStackTrace+0x1272>
  20b330:	b3 57                	mov    bl,0x57
  20b332:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b334:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20b338:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20b33c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  20b343:	49 89 cd             	mov    r13,rcx
  20b346:	77 d8                	ja     20b320 <dumpCurrentStackTrace+0x1260>
        const padded_buf = buf[index - padding ..];
  20b348:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20b34c:	48 83 c1 2f          	add    rcx,0x2f
  20b350:	ba 41 00 00 00       	mov    edx,0x41
  20b355:	48 29 c2             	sub    rdx,rax
  20b358:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20b35d:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20b362:	4c 89 e7             	mov    rdi,r12
  20b365:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20b36a:	c5 f8 77             	vzeroupper 
  20b36d:	41 ff d6             	call   r14
  20b370:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20b373:	66 45 85 ff          	test   r15w,r15w
  20b377:	0f 85 b4 03 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20b37d:	4c 89 e7             	mov    rdi,r12
  20b380:	48 8d 35 b9 59 01 00 	lea    rsi,[rip+0x159b9]        # 220d40 <__unnamed_37>
  20b387:	41 ff d6             	call   r14
  20b38a:	41 89 c7             	mov    r15d,eax
  20b38d:	66 45 85 ff          	test   r15w,r15w
  20b391:	0f 85 9a 03 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                const casted_value = ([]const u8)(value);
  20b397:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  20b39e:	00 00 
  20b3a0:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  20b3a6:	4c 89 e7             	mov    rdi,r12
  20b3a9:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b3ae:	41 ff d6             	call   r14
  20b3b1:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b3b4:	66 45 85 ff          	test   r15w,r15w
  20b3b8:	0f 85 73 03 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
        try output(context, fmt[start_index..]);
  20b3be:	4c 89 e7             	mov    rdi,r12
  20b3c1:	48 8d 35 88 59 01 00 	lea    rsi,[rip+0x15988]        # 220d50 <__unnamed_38>
  20b3c8:	41 ff d6             	call   r14
  20b3cb:	41 89 c7             	mov    r15d,eax
                    try out_stream.print(
  20b3ce:	66 45 85 ff          	test   r15w,r15w
  20b3d2:	0f 84 3e 02 00 00    	je     20b616 <dumpCurrentStackTrace+0x1556>
  20b3d8:	e9 54 03 00 00       	jmp    20b731 <dumpCurrentStackTrace+0x1671>
        a /= base;
  20b3dd:	4c 89 e9             	mov    rcx,r13
  20b3e0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b3e4:	89 ca                	mov    edx,ecx
  20b3e6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  20b3e9:	b3 30                	mov    bl,0x30
  20b3eb:	80 fa 0a             	cmp    dl,0xa
  20b3ee:	72 02                	jb     20b3f2 <dumpCurrentStackTrace+0x1332>
  20b3f0:	b3 57                	mov    bl,0x57
  20b3f2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b3f4:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20b3f8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20b3fc:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  20b403:	49 89 cd             	mov    r13,rcx
  20b406:	77 d8                	ja     20b3e0 <dumpCurrentStackTrace+0x1320>
        const padded_buf = buf[index - padding ..];
  20b408:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20b40c:	48 83 c1 2f          	add    rcx,0x2f
  20b410:	ba 41 00 00 00       	mov    edx,0x41
  20b415:	48 29 c2             	sub    rdx,rax
  20b418:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20b41d:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20b422:	4c 89 e7             	mov    rdi,r12
  20b425:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20b42a:	c5 f8 77             	vzeroupper 
  20b42d:	41 ff d6             	call   r14
  20b430:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20b433:	66 45 85 ff          	test   r15w,r15w
  20b437:	0f 85 f4 02 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20b43d:	4c 89 e7             	mov    rdi,r12
  20b440:	48 8d 35 a9 58 01 00 	lea    rsi,[rip+0x158a9]        # 220cf0 <__unnamed_39>
  20b447:	41 ff d6             	call   r14
  20b44a:	41 89 c7             	mov    r15d,eax
  20b44d:	66 45 85 ff          	test   r15w,r15w
  20b451:	0f 85 da 02 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                const casted_value = ([]const u8)(value);
  20b457:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  20b45e:	00 00 
  20b460:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  20b466:	4c 89 e7             	mov    rdi,r12
  20b469:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b46e:	41 ff d6             	call   r14
  20b471:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b474:	66 45 85 ff          	test   r15w,r15w
  20b478:	0f 85 b3 02 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
        try output(context, fmt[start_index..]);
  20b47e:	4c 89 e7             	mov    rdi,r12
  20b481:	48 8d 35 78 58 01 00 	lea    rsi,[rip+0x15878]        # 220d00 <__unnamed_40>
  20b488:	41 ff d6             	call   r14
  20b48b:	41 89 c7             	mov    r15d,eax
                    try out_stream.print(
  20b48e:	66 45 85 ff          	test   r15w,r15w
  20b492:	0f 85 99 02 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
  20b498:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20b49d:	48 8b b8 a0 00 00 00 	mov    rdi,QWORD PTR [rax+0xa0]
                    if (printLineFromFile(debug_info.allocator(), out_stream, line_info)) {
  20b4a4:	4c 89 e6             	mov    rsi,r12
  20b4a7:	48 8d 94 24 80 00 00 	lea    rdx,[rsp+0x80]
  20b4ae:	00 
  20b4af:	e8 ec b2 00 00       	call   2167a0 <printLineFromFile>
  20b4b4:	41 89 c7             	mov    r15d,eax
  20b4b7:	41 0f b7 c7          	movzx  eax,r15w
  20b4bb:	83 f8 26             	cmp    eax,0x26
  20b4be:	0f 84 52 01 00 00    	je     20b616 <dumpCurrentStackTrace+0x1556>
  20b4c4:	66 45 85 ff          	test   r15w,r15w
  20b4c8:	0f 85 84 00 00 00    	jne    20b552 <dumpCurrentStackTrace+0x1492>
  20b4ce:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
                        if (line_info.column == 0) {
  20b4d3:	48 85 c0             	test   rax,rax
  20b4d6:	0f 84 1f 01 00 00    	je     20b5fb <dumpCurrentStackTrace+0x153b>
  20b4dc:	48 83 f8 01          	cmp    rax,0x1
  20b4e0:	74 41                	je     20b523 <dumpCurrentStackTrace+0x1463>
  20b4e2:	bb 01 00 00 00       	mov    ebx,0x1
  20b4e7:	c6 44 24 10 20       	mov    BYTE PTR [rsp+0x10],0x20
        pub fn write(self: *Self, bytes: []const u8) !void {
            return self.writeFn(self, bytes);
        }

        pub fn writeByte(self: *Self, byte: u8) !void {
            const slice = (*[1]u8)(&byte)[0..];
  20b4ec:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  20b4f1:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20b4f6:	48 c7 44 24 38 01 00 	mov    QWORD PTR [rsp+0x38],0x1
  20b4fd:	00 00 
            return self.writeFn(self, slice);
  20b4ff:	4c 89 e7             	mov    rdi,r12
  20b502:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b507:	41 ff 14 24          	call   QWORD PTR [r12]
  20b50b:	41 89 c7             	mov    r15d,eax
                                    try out_stream.writeByte(' ');
  20b50e:	66 45 85 ff          	test   r15w,r15w
  20b512:	0f 85 19 02 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
  20b518:	48 83 c3 01          	add    rbx,0x1
                                while (col_i < line_info.column) : (col_i += 1) {
  20b51c:	48 3b 5c 24 78       	cmp    rbx,QWORD PTR [rsp+0x78]
  20b521:	72 c4                	jb     20b4e7 <dumpCurrentStackTrace+0x1427>
            return self.writeFn(self, bytes);
  20b523:	4c 89 e7             	mov    rdi,r12
  20b526:	48 8d 35 33 57 01 00 	lea    rsi,[rip+0x15733]        # 220c60 <__unnamed_41>
  20b52d:	41 ff 14 24          	call   QWORD PTR [r12]
  20b531:	41 89 c7             	mov    r15d,eax
  20b534:	66 45 85 ff          	test   r15w,r15w
  20b538:	0f 84 d8 00 00 00    	je     20b616 <dumpCurrentStackTrace+0x1556>
  20b53e:	e9 29 02 00 00       	jmp    20b76c <dumpCurrentStackTrace+0x16ac>
  20b543:	48 83 f9 4b          	cmp    rcx,0x4b
  20b547:	0f 85 6e f6 ff ff    	jne    20abbb <dumpCurrentStackTrace+0xafb>
  20b54d:	e9 5f f6 ff ff       	jmp    20abb1 <dumpCurrentStackTrace+0xaf1>
        const bytes = @sliceToBytes(memory);
  20b552:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20b559:	00 
        if (bytes.len == 0) return;
  20b55a:	48 85 c0             	test   rax,rax
  20b55d:	0f 84 2d f5 ff ff    	je     20aa90 <dumpCurrentStackTrace+0x9d0>
  20b563:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  20b56a:	00 
        const bytes = @sliceToBytes(memory);
  20b56b:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20b572:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b573:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b577:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  20b57c:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  20b581:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b586:	ff d2                	call   rdx
  20b588:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  20b58f:	00 00 
  20b591:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  20b598:	00 00 
        try printSourceAtAddress(debug_info, out_stream, return_address, tty_color);
  20b59a:	66 45 85 ff          	test   r15w,r15w
  20b59e:	0f 84 08 f5 ff ff    	je     20aaac <dumpCurrentStackTrace+0x9ec>
  20b5a4:	e9 fb 00 00 00       	jmp    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20b5a9:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  20b5ae:	48 89 8c 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rcx
  20b5b5:	00 
  20b5b6:	48 8d 05 a3 4f 00 00 	lea    rax,[rip+0x4fa3]        # 210560 <FileInStream_readFn>
  20b5bd:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  20b5c4:	00 
  20b5c5:	48 8b b1 a0 00 00 00 	mov    rsi,QWORD PTR [rcx+0xa0]
  20b5cc:	4c 8d 74 24 30       	lea    r14,[rsp+0x30]
            return readStringRaw(self.allocator(), in_stream);
  20b5d1:	4c 89 f7             	mov    rdi,r14
  20b5d4:	48 8d 94 24 c0 00 00 	lea    rdx,[rsp+0xc0]
  20b5db:	00 
  20b5dc:	4c 89 cb             	mov    rbx,r9
  20b5df:	c5 f8 77             	vzeroupper 
  20b5e2:	e8 39 8d 00 00       	call   214320 <readStringRaw>
  20b5e7:	49 89 d9             	mov    r9,rbx
        return switch (form_value.*) {
  20b5ea:	4c 89 f1             	mov    rcx,r14
  20b5ed:	e9 f2 f5 ff ff       	jmp    20abe4 <dumpCurrentStackTrace+0xb24>
  20b5f2:	66 b8 1e 00          	mov    ax,0x1e
  20b5f6:	e9 c0 f5 ff ff       	jmp    20abbb <dumpCurrentStackTrace+0xafb>
  20b5fb:	4c 89 e7             	mov    rdi,r12
  20b5fe:	48 8d 35 4b 56 01 00 	lea    rsi,[rip+0x1564b]        # 220c50 <__unnamed_42>
  20b605:	41 ff 14 24          	call   QWORD PTR [r12]
  20b609:	41 89 c7             	mov    r15d,eax
  20b60c:	66 45 85 ff          	test   r15w,r15w
  20b610:	0f 85 56 01 00 00    	jne    20b76c <dumpCurrentStackTrace+0x16ac>
        const bytes = @sliceToBytes(memory);
  20b616:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20b61d:	00 
        if (bytes.len == 0) return;
  20b61e:	48 85 c0             	test   rax,rax
  20b621:	74 25                	je     20b648 <dumpCurrentStackTrace+0x1588>
  20b623:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  20b62a:	00 
        const bytes = @sliceToBytes(memory);
  20b62b:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20b632:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b633:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b637:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  20b63c:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  20b641:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b646:	ff d2                	call   rdx
  20b648:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  20b64f:	00 
  20b650:	48 8b 94 24 b0 00 00 	mov    rdx,QWORD PTR [rsp+0xb0]
  20b657:	00 
  20b658:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  20b65f:	00 00 
  20b661:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  20b668:	00 00 
  20b66a:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  20b66f:	31 c0                	xor    eax,eax
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  20b671:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  20b674:	48 85 d2             	test   rdx,rdx
  20b677:	0f 85 83 ed ff ff    	jne    20a400 <dumpCurrentStackTrace+0x340>
  20b67d:	eb 72                	jmp    20b6f1 <dumpCurrentStackTrace+0x1631>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  20b67f:	48 8b 05 7a ae ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffae7a]        # 206500 <__unnamed_43+0x10>
  20b686:	48 89 84 24 4e 01 00 	mov    QWORD PTR [rsp+0x14e],rax
  20b68d:	00 
  20b68e:	c5 fa 6f 05 5c ae ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffae5c]        # 2064f2 <__unnamed_43+0x2>
  20b695:	ff 
  20b696:	c5 f9 7f 84 24 40 01 	vmovdqa XMMWORD PTR [rsp+0x140],xmm0
  20b69d:	00 00 
  20b69f:	66 41 bf 24 00       	mov    r15w,0x24
            return std.fmt.format(self, Error, self.writeFn, format, args);
  20b6a4:	49 8b 1c 24          	mov    rbx,QWORD PTR [r12]
                        try output(context, fmt[start_index..i]);
  20b6a8:	48 8d 35 e1 56 01 00 	lea    rsi,[rip+0x156e1]        # 220d90 <__unnamed_44>
  20b6af:	4c 89 e7             	mov    rdi,r12
  20b6b2:	c5 f8 77             	vzeroupper 
  20b6b5:	ff d3                	call   rbx
  20b6b7:	66 85 c0             	test   ax,ax
  20b6ba:	75 35                	jne    20b6f1 <dumpCurrentStackTrace+0x1631>
        stderr.print("Unable to dump stack trace: {}\n", @errorName(err)) catch return;
  20b6bc:	49 0f bf c7          	movsx  rax,r15w
  20b6c0:	48 c1 e0 04          	shl    rax,0x4
  20b6c4:	48 8d 0d 35 29 01 00 	lea    rcx,[rip+0x12935]        # 21e000 <raw+0xf48>
                const casted_value = ([]const u8)(value);
  20b6cb:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  20b6d0:	c5 f8 29 44 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm0
  20b6d6:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
                return output(context, casted_value);
  20b6db:	4c 89 e7             	mov    rdi,r12
  20b6de:	ff d3                	call   rbx
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b6e0:	66 85 c0             	test   ax,ax
  20b6e3:	75 0c                	jne    20b6f1 <dumpCurrentStackTrace+0x1631>
        try output(context, fmt[start_index..]);
  20b6e5:	48 8d 35 b4 56 01 00 	lea    rsi,[rip+0x156b4]        # 220da0 <__unnamed_45>
  20b6ec:	4c 89 e7             	mov    rdi,r12
  20b6ef:	ff d3                	call   rbx
    const stderr = getStderrStream() catch return;
  20b6f1:	48 8d 65 d8          	lea    rsp,[rbp-0x28]
  20b6f5:	5b                   	pop    rbx
  20b6f6:	41 5c                	pop    r12
  20b6f8:	41 5d                	pop    r13
  20b6fa:	41 5e                	pop    r14
  20b6fc:	41 5f                	pop    r15
  20b6fe:	5d                   	pop    rbp
  20b6ff:	c5 f8 77             	vzeroupper 
  20b702:	c3                   	ret    
  20b703:	49 89 dc             	mov    r12,rbx
        const bytes = @sliceToBytes(memory);
  20b706:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20b70d:	00 
        if (bytes.len == 0) return;
  20b70e:	48 85 c0             	test   rax,rax
  20b711:	75 2f                	jne    20b742 <dumpCurrentStackTrace+0x1682>
  20b713:	eb 8f                	jmp    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20b715:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        const bytes = @sliceToBytes(memory);
  20b71a:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20b721:	00 
        if (bytes.len == 0) return;
  20b722:	48 85 c0             	test   rax,rax
  20b725:	75 1b                	jne    20b742 <dumpCurrentStackTrace+0x1682>
  20b727:	e9 78 ff ff ff       	jmp    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20b72c:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        const bytes = @sliceToBytes(memory);
  20b731:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20b738:	00 
        if (bytes.len == 0) return;
  20b739:	48 85 c0             	test   rax,rax
  20b73c:	0f 84 62 ff ff ff    	je     20b6a4 <dumpCurrentStackTrace+0x15e4>
  20b742:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  20b749:	00 
        const bytes = @sliceToBytes(memory);
  20b74a:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20b751:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b752:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b756:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  20b75b:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  20b760:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b765:	ff d2                	call   rdx
  20b767:	e9 38 ff ff ff       	jmp    20b6a4 <dumpCurrentStackTrace+0x15e4>
        const bytes = @sliceToBytes(memory);
  20b76c:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20b773:	00 
        if (bytes.len == 0) return;
  20b774:	48 85 c0             	test   rax,rax
  20b777:	74 25                	je     20b79e <dumpCurrentStackTrace+0x16de>
  20b779:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  20b780:	00 
        const bytes = @sliceToBytes(memory);
  20b781:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20b788:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b789:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b78d:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  20b792:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  20b797:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b79c:	ff d2                	call   rdx
  20b79e:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
  20b7a3:	e9 fc fe ff ff       	jmp    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20b7a8:	48 c7 c0 fe ff ff ff 	mov    rax,0xfffffffffffffffe
        while (ptr[end_i] != 0) : (end_i += 1) {}
  20b7af:	80 7c 06 11 00       	cmp    BYTE PTR [rsi+rax*1+0x11],0x0
  20b7b4:	48 8d 40 01          	lea    rax,[rax+0x1]
  20b7b8:	75 f5                	jne    20b7af <dumpCurrentStackTrace+0x16ef>
  20b7ba:	c6 44 24 0f 01       	mov    BYTE PTR [rsp+0xf],0x1
        const addr = @ptrToInt(self.buffer.ptr) + self.end_index;
        const rem = @rem(addr, alignment);
        const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
        const adjusted_index = self.end_index + march_forward_bytes;
        const new_end_index = adjusted_index + n;
        if (new_end_index > self.buffer.len) {
  20b7bf:	48 3d 81 00 00 00    	cmp    rax,0x81
        if (n == 0) {
  20b7c5:	0f 83 b2 eb ff ff    	jae    20a37d <dumpCurrentStackTrace+0x2bd>
  20b7cb:	e9 cd eb ff ff       	jmp    20a39d <dumpCurrentStackTrace+0x2dd>

000000000020b7d0 <MainFuncs_linuxThreadMain>:
            const arg = if (@sizeOf(Context) == 0) {} else @intToPtr(*const Context, ctx_addr).*;
  20b7d0:	4c 8b 07             	mov    r8,QWORD PTR [rdi]
    while (pContext.counter < max_counter) {
  20b7d3:	b8 7f 96 98 00       	mov    eax,0x98967f
  20b7d8:	31 c9                	xor    ecx,ecx
  20b7da:	49 3b 00             	cmp    rax,QWORD PTR [r8]
  20b7dd:	49 8b 40 08          	mov    rax,QWORD PTR [r8+0x8]
  20b7e1:	48 19 c1             	sbb    rcx,rax
  20b7e4:	0f 82 88 00 00 00    	jb     20b872 <MainFuncs_linuxThreadMain+0xa2>
  20b7ea:	48 8d 3d 47 58 01 00 	lea    rdi,[rip+0x15847]        # 221038 <produce>
  20b7f1:	83 3d 40 58 01 00 01 	cmp    DWORD PTR [rip+0x15840],0x1        # 221038 <produce>
        while (produce_val != produceSignal) {
  20b7f8:	74 25                	je     20b81f <MainFuncs_linuxThreadMain+0x4f>
  20b7fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            gProducer_wait_count += 1;
  20b800:	48 83 05 f8 57 01 00 	add    QWORD PTR [rip+0x157f8],0x1        # 221000 <gProducer_wait_count>
  20b807:	01 
        : "rcx", "r11"
    );
}

pub fn syscall4(number: usize, arg1: usize, arg2: usize, arg3: usize, arg4: usize) usize {
    return asm volatile ("syscall"
  20b808:	b8 ca 00 00 00       	mov    eax,0xca
  20b80d:	31 f6                	xor    esi,esi
  20b80f:	31 d2                	xor    edx,edx
  20b811:	45 31 d2             	xor    r10d,r10d
  20b814:	0f 05                	syscall 
  20b816:	83 3d 1b 58 01 00 01 	cmp    DWORD PTR [rip+0x1581b],0x1        # 221038 <produce>
        while (produce_val != produceSignal) {
  20b81d:	75 e1                	jne    20b800 <MainFuncs_linuxThreadMain+0x30>
        _ = @atomicRmw(@typeOf(gCounter), &gCounter, AtomicRmwOp.Add, 1, AtomicOrder.SeqCst);
  20b81f:	f0 48 81 05 f5 57 01 	lock add QWORD PTR [rip+0x157f5],0x1        # 221020 <gCounter>
  20b826:	00 01 00 00 00 
        pContext.counter += 1;
  20b82b:	49 83 00 01          	add    QWORD PTR [r8],0x1
  20b82f:	49 83 50 08 00       	adc    QWORD PTR [r8+0x8],0x0
        _ = @atomicRmw(@typeOf(produce), &produce, AtomicRmwOp.Xchg, consumeSignal, AtomicOrder.SeqCst);
  20b834:	31 c0                	xor    eax,eax
  20b836:	87 05 fc 57 01 00    	xchg   DWORD PTR [rip+0x157fc],eax        # 221038 <produce>
  20b83c:	83 3d f5 57 01 00 01 	cmp    DWORD PTR [rip+0x157f5],0x1        # 221038 <produce>
        if (produce_val != produceSignal) {
  20b843:	74 1c                	je     20b861 <MainFuncs_linuxThreadMain+0x91>
            gProducer_wake_count += 1;
  20b845:	48 83 05 c3 57 01 00 	add    QWORD PTR [rip+0x157c3],0x1        # 221010 <gProducer_wake_count>
  20b84c:	01 
  20b84d:	b8 ca 00 00 00       	mov    eax,0xca
  20b852:	be 01 00 00 00       	mov    esi,0x1
  20b857:	ba 01 00 00 00       	mov    edx,0x1
  20b85c:	45 31 d2             	xor    r10d,r10d
  20b85f:	0f 05                	syscall 
    while (pContext.counter < max_counter) {
  20b861:	49 8b 40 08          	mov    rax,QWORD PTR [r8+0x8]
  20b865:	49 81 38 80 96 98 00 	cmp    QWORD PTR [r8],0x989680
  20b86c:	48 83 d8 00          	sbb    rax,0x0
  20b870:	72 a4                	jb     20b816 <MainFuncs_linuxThreadMain+0x46>
                    return 0;
  20b872:	31 c0                	xor    eax,eax
  20b874:	c3                   	ret    
  20b875:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b87c:	00 00 00 00 

000000000020b880 <MainFuncs_linuxThreadMain.21>:
            const arg = if (@sizeOf(Context) == 0) {} else @intToPtr(*const Context, ctx_addr).*;
  20b880:	4c 8b 07             	mov    r8,QWORD PTR [rdi]
    while (pContext.counter < max_counter) {
  20b883:	b8 7f 96 98 00       	mov    eax,0x98967f
  20b888:	31 c9                	xor    ecx,ecx
  20b88a:	49 3b 00             	cmp    rax,QWORD PTR [r8]
  20b88d:	49 1b 48 08          	sbb    rcx,QWORD PTR [r8+0x8]
  20b891:	0f 82 9d 00 00 00    	jb     20b934 <MainFuncs_linuxThreadMain.21+0xb4>
  20b897:	48 8d 3d 9a 57 01 00 	lea    rdi,[rip+0x1579a]        # 221038 <produce>
  20b89e:	66 90                	xchg   ax,ax
        _ = @atomicRmw(@typeOf(produce), &produce, AtomicRmwOp.Xchg, produceSignal, AtomicOrder.SeqCst);
  20b8a0:	b8 01 00 00 00       	mov    eax,0x1
  20b8a5:	87 05 8d 57 01 00    	xchg   DWORD PTR [rip+0x1578d],eax        # 221038 <produce>
  20b8ab:	83 3d 86 57 01 00 00 	cmp    DWORD PTR [rip+0x15786],0x0        # 221038 <produce>
        if (produce_val != consumeSignal) {
  20b8b2:	74 4e                	je     20b902 <MainFuncs_linuxThreadMain.21+0x82>
            gConsumer_wake_count += 1;
  20b8b4:	48 83 05 5c 57 01 00 	add    QWORD PTR [rip+0x1575c],0x1        # 221018 <gConsumer_wake_count>
  20b8bb:	01 
  20b8bc:	b8 ca 00 00 00       	mov    eax,0xca
  20b8c1:	be 01 00 00 00       	mov    esi,0x1
  20b8c6:	ba 01 00 00 00       	mov    edx,0x1
  20b8cb:	45 31 d2             	xor    r10d,r10d
  20b8ce:	0f 05                	syscall 
  20b8d0:	83 3d 61 57 01 00 00 	cmp    DWORD PTR [rip+0x15761],0x0        # 221038 <produce>
        while (produce_val != consumeSignal) {
  20b8d7:	74 29                	je     20b902 <MainFuncs_linuxThreadMain.21+0x82>
  20b8d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
            gConsumer_wait_count += 1;
  20b8e0:	48 83 05 20 57 01 00 	add    QWORD PTR [rip+0x15720],0x1        # 221008 <gConsumer_wait_count>
  20b8e7:	01 
  20b8e8:	b8 ca 00 00 00       	mov    eax,0xca
  20b8ed:	31 f6                	xor    esi,esi
  20b8ef:	ba 01 00 00 00       	mov    edx,0x1
  20b8f4:	45 31 d2             	xor    r10d,r10d
  20b8f7:	0f 05                	syscall 
  20b8f9:	83 3d 38 57 01 00 00 	cmp    DWORD PTR [rip+0x15738],0x0        # 221038 <produce>
        while (produce_val != consumeSignal) {
  20b900:	75 de                	jne    20b8e0 <MainFuncs_linuxThreadMain.21+0x60>
        _ = @atomicRmw(@typeOf(gCounter), &gCounter, AtomicRmwOp.Add, 1, AtomicOrder.SeqCst);
  20b902:	f0 48 81 05 12 57 01 	lock add QWORD PTR [rip+0x15712],0x1        # 221020 <gCounter>
  20b909:	00 01 00 00 00 
        pContext.counter += 1;
  20b90e:	49 8b 00             	mov    rax,QWORD PTR [r8]
  20b911:	49 8b 48 08          	mov    rcx,QWORD PTR [r8+0x8]
  20b915:	48 83 c0 01          	add    rax,0x1
  20b919:	48 83 d1 00          	adc    rcx,0x0
  20b91d:	49 89 00             	mov    QWORD PTR [r8],rax
  20b920:	49 89 48 08          	mov    QWORD PTR [r8+0x8],rcx
    while (pContext.counter < max_counter) {
  20b924:	48 3d 80 96 98 00    	cmp    rax,0x989680
  20b92a:	48 83 d9 00          	sbb    rcx,0x0
  20b92e:	0f 82 6c ff ff ff    	jb     20b8a0 <MainFuncs_linuxThreadMain.21+0x20>
                    return 0;
  20b934:	31 c0                	xor    eax,eax
  20b936:	c3                   	ret    
  20b937:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20b93e:	00 00 

000000000020b940 <FileOutStream_writeFn>:
    fn writeFn(out_stream: *Stream, bytes: []const u8) !void {
  20b940:	53                   	push   rbx
  20b941:	49 89 f0             	mov    r8,rsi
    while (index < bytes.len) {
  20b944:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  20b948:	48 85 d2             	test   rdx,rdx
  20b94b:	0f 84 98 00 00 00    	je     20b9e9 <FileOutStream_writeFn+0xa9>
        return self.file.write(bytes);
  20b951:	48 8b 47 f8          	mov    rax,QWORD PTR [rdi-0x8]
  20b955:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20b958:	45 31 c9             	xor    r9d,r9d
  20b95b:	41 ba 00 f0 ff 7f    	mov    r10d,0x7ffff000
  20b961:	48 8d 1d 10 54 ff ff 	lea    rbx,[rip+0xffffffffffff5410]        # 200d78 <__unnamed_9+0x98>
  20b968:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20b96f:	00 
        const amt_to_write = math.min(bytes.len - index, usize(max_bytes_len));
  20b970:	4c 29 ca             	sub    rdx,r9
    return if (x < y) x else y;
  20b973:	48 81 fa 00 f0 ff 7f 	cmp    rdx,0x7ffff000
  20b97a:	49 0f 43 d2          	cmovae rdx,r10
  20b97e:	49 8b 30             	mov    rsi,QWORD PTR [r8]
        const rc = posix.write(fd, bytes.ptr + index, amt_to_write);
  20b981:	4c 01 ce             	add    rsi,r9
  20b984:	b8 01 00 00 00       	mov    eax,0x1
  20b989:	0f 05                	syscall 
  20b98b:	48 89 c1             	mov    rcx,rax
  20b98e:	48 81 f9 00 f0 ff ff 	cmp    rcx,0xfffffffffffff000
  20b995:	77 39                	ja     20b9d0 <FileOutStream_writeFn+0x90>
  20b997:	31 d2                	xor    edx,edx
        if (write_err > 0) {
  20b999:	48 83 fa 04          	cmp    rdx,0x4
  20b99d:	74 3d                	je     20b9dc <FileOutStream_writeFn+0x9c>
  20b99f:	48 83 fa 59          	cmp    rdx,0x59
  20b9a3:	77 48                	ja     20b9ed <FileOutStream_writeFn+0xad>
  20b9a5:	66 b8 09 00          	mov    ax,0x9
  20b9a9:	48 63 14 93          	movsxd rdx,DWORD PTR [rbx+rdx*4]
  20b9ad:	48 01 da             	add    rdx,rbx
  20b9b0:	ff e2                	jmp    rdx
        index += rc;
  20b9b2:	49 01 c9             	add    r9,rcx
    while (index < bytes.len) {
  20b9b5:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  20b9b9:	31 c0                	xor    eax,eax
  20b9bb:	4c 39 ca             	cmp    rdx,r9
  20b9be:	77 b0                	ja     20b970 <FileOutStream_writeFn+0x30>
  20b9c0:	eb 25                	jmp    20b9e7 <FileOutStream_writeFn+0xa7>
  20b9c2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b9c9:	1f 84 00 00 00 00 00 
  20b9d0:	48 89 ca             	mov    rdx,rcx
  20b9d3:	48 f7 da             	neg    rdx
        if (write_err > 0) {
  20b9d6:	48 83 fa 04          	cmp    rdx,0x4
  20b9da:	75 c3                	jne    20b99f <FileOutStream_writeFn+0x5f>
    while (index < bytes.len) {
  20b9dc:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  20b9e0:	4c 39 ca             	cmp    rdx,r9
  20b9e3:	77 8b                	ja     20b970 <FileOutStream_writeFn+0x30>
  20b9e5:	31 c0                	xor    eax,eax
  20b9e7:	5b                   	pop    rbx
  20b9e8:	c3                   	ret    
  20b9e9:	31 c0                	xor    eax,eax
  20b9eb:	5b                   	pop    rbx
  20b9ec:	c3                   	ret    
        if (write_err > 0) {
  20b9ed:	48 83 fa 7a          	cmp    rdx,0x7a
  20b9f1:	75 06                	jne    20b9f9 <FileOutStream_writeFn+0xb9>
  20b9f3:	66 b8 0c 00          	mov    ax,0xc
  20b9f7:	5b                   	pop    rbx
  20b9f8:	c3                   	ret    
  20b9f9:	66 b8 02 00          	mov    ax,0x2
  20b9fd:	5b                   	pop    rbx
  20b9fe:	c3                   	ret    
  20b9ff:	66 b8 10 00          	mov    ax,0x10
  20ba03:	5b                   	pop    rbx
  20ba04:	c3                   	ret    
  20ba05:	66 b8 0e 00          	mov    ax,0xe
  20ba09:	5b                   	pop    rbx
  20ba0a:	c3                   	ret    
  20ba0b:	66 b8 0a 00          	mov    ax,0xa
  20ba0f:	5b                   	pop    rbx
  20ba10:	c3                   	ret    
  20ba11:	66 b8 0d 00          	mov    ax,0xd
  20ba15:	5b                   	pop    rbx
  20ba16:	c3                   	ret    
  20ba17:	66 b8 0f 00          	mov    ax,0xf
  20ba1b:	5b                   	pop    rbx
  20ba1c:	c3                   	ret    
  20ba1d:	66 b8 08 00          	mov    ax,0x8
  20ba21:	5b                   	pop    rbx
  20ba22:	c3                   	ret    
  20ba23:	66 b8 0b 00          	mov    ax,0xb
  20ba27:	5b                   	pop    rbx
  20ba28:	c3                   	ret    
  20ba29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000020ba30 <openSelfDebugInfo>:
            return Self{
  20ba30:	55                   	push   rbp
  20ba31:	41 57                	push   r15
  20ba33:	41 56                	push   r14
  20ba35:	41 55                	push   r13
  20ba37:	41 54                	push   r12
  20ba39:	53                   	push   rbx
  20ba3a:	48 81 ec 28 05 00 00 	sub    rsp,0x528
  20ba41:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  20ba45:	c5 f8 29 84 24 90 03 	vmovaps XMMWORD PTR [rsp+0x390],xmm0
  20ba4c:	00 00 
  20ba4e:	c5 f8 29 84 24 70 03 	vmovaps XMMWORD PTR [rsp+0x370],xmm0
  20ba55:	00 00 
  20ba57:	49 89 f7             	mov    r15,rsi
  20ba5a:	49 89 fe             	mov    r14,rdi
            const st = try allocator.create(ElfStackTrace{
  20ba5d:	c5 fc 10 05 23 a7 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffa723]        # 206188 <__unnamed_46>
  20ba64:	ff 
  20ba65:	c5 fc 11 84 24 b0 04 	vmovups YMMWORD PTR [rsp+0x4b0],ymm0
  20ba6c:	00 00 
  20ba6e:	48 c7 84 24 a0 03 00 	mov    QWORD PTR [rsp+0x3a0],0x0
  20ba75:	00 00 00 00 00 
  20ba7a:	c5 fc 10 05 26 a7 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffa726]        # 2061a8 <__unnamed_46+0x20>
  20ba81:	ff 
  20ba82:	c5 fc 11 84 24 d0 04 	vmovups YMMWORD PTR [rsp+0x4d0],ymm0
  20ba89:	00 00 
  20ba8b:	48 c7 84 24 80 03 00 	mov    QWORD PTR [rsp+0x380],0x0
  20ba92:	00 00 00 00 00 
  20ba97:	c5 fe 6f 05 21 a7 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffa721]        # 2061c0 <__unnamed_46+0x38>
  20ba9e:	ff 
  20ba9f:	c5 fe 7f 84 24 e8 04 	vmovdqu YMMWORD PTR [rsp+0x4e8],ymm0
  20baa6:	00 00 
  20baa8:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20baaf:	00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20bab0:	ba c8 00 00 00       	mov    edx,0xc8
  20bab5:	b9 04 00 00 00       	mov    ecx,0x4
  20baba:	c5 f8 77             	vzeroupper 
  20babd:	41 ff 17             	call   QWORD PTR [r15]
  20bac0:	0f b7 84 24 a0 00 00 	movzx  eax,WORD PTR [rsp+0xa0]
  20bac7:	00 
  20bac8:	66 85 c0             	test   ax,ax
  20bacb:	74 19                	je     20bae6 <openSelfDebugInfo+0xb6>
  20bacd:	66 41 89 06          	mov    WORD PTR [r14],ax
  20bad1:	48 8b 84 24 1a 04 00 	mov    rax,QWORD PTR [rsp+0x41a]
  20bad8:	00 
  20bad9:	48 8b 8c 24 20 04 00 	mov    rcx,QWORD PTR [rsp+0x420]
  20bae0:	00 
  20bae1:	e9 40 0c 00 00       	jmp    20c726 <openSelfDebugInfo+0xcf6>
        assert(byte_slice.len == byte_count);
  20bae6:	48 81 bc 24 b0 00 00 	cmp    QWORD PTR [rsp+0xb0],0xc8
  20baed:	00 c8 00 00 00 
    if (!ok) {
  20baf2:	0f 85 0a 36 00 00    	jne    20f102 <openSelfDebugInfo+0x36d2>
  20baf8:	48 8b 9c 24 a8 00 00 	mov    rbx,QWORD PTR [rsp+0xa8]
  20baff:	00 
        ptr.* = init;
  20bb00:	c5 fc 10 84 24 a8 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4a8]
  20bb07:	00 00 
  20bb09:	c5 fe 6f 8c 24 c8 04 	vmovdqu ymm1,YMMWORD PTR [rsp+0x4c8]
  20bb10:	00 00 
  20bb12:	c5 fe 6f 94 24 e8 04 	vmovdqu ymm2,YMMWORD PTR [rsp+0x4e8]
  20bb19:	00 00 
  20bb1b:	c5 fe 6f 9c 24 08 05 	vmovdqu ymm3,YMMWORD PTR [rsp+0x508]
  20bb22:	00 00 
  20bb24:	c5 fe 7f 5b 60       	vmovdqu YMMWORD PTR [rbx+0x60],ymm3
  20bb29:	c5 fe 7f 53 40       	vmovdqu YMMWORD PTR [rbx+0x40],ymm2
  20bb2e:	c5 fe 7f 4b 20       	vmovdqu YMMWORD PTR [rbx+0x20],ymm1
  20bb33:	c5 fc 11 03          	vmovups YMMWORD PTR [rbx],ymm0
  20bb37:	48 c7 83 80 00 00 00 	mov    QWORD PTR [rbx+0x80],0x0
  20bb3e:	00 00 00 00 
  20bb42:	48 8b 84 24 a0 03 00 	mov    rax,QWORD PTR [rsp+0x3a0]
  20bb49:	00 
  20bb4a:	48 89 83 98 00 00 00 	mov    QWORD PTR [rbx+0x98],rax
  20bb51:	c5 f8 28 84 24 90 03 	vmovaps xmm0,XMMWORD PTR [rsp+0x390]
  20bb58:	00 00 
  20bb5a:	c5 f8 11 83 88 00 00 	vmovups XMMWORD PTR [rbx+0x88],xmm0
  20bb61:	00 
  20bb62:	4c 89 bb a0 00 00 00 	mov    QWORD PTR [rbx+0xa0],r15
  20bb69:	48 8b 84 24 80 03 00 	mov    rax,QWORD PTR [rsp+0x380]
  20bb70:	00 
  20bb71:	48 89 83 b8 00 00 00 	mov    QWORD PTR [rbx+0xb8],rax
  20bb78:	c5 f8 28 84 24 70 03 	vmovaps xmm0,XMMWORD PTR [rsp+0x370]
  20bb7f:	00 00 
  20bb81:	c5 f8 11 83 a8 00 00 	vmovups XMMWORD PTR [rbx+0xa8],xmm0
  20bb88:	00 
  20bb89:	4c 89 bb c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],r15
            var fixed_buffer_mem: [proc_file_path.len + 1]u8 = undefined;
  20bb90:	48 8b 05 8a a6 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffa68a]        # 206221 <__unnamed_47+0x7>
  20bb97:	48 89 44 24 67       	mov    QWORD PTR [rsp+0x67],rax
  20bb9c:	48 8b 05 77 a6 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffa677]        # 20621a <__unnamed_47>
  20bba3:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
            var fixed_allocator = std.heap.FixedBufferAllocator.init(fixed_buffer_mem[0..]);
  20bba8:	c5 fa 6f 05 68 50 01 	vmovdqu xmm0,XMMWORD PTR [rip+0x15068]        # 220c18 <__unnamed_48>
  20bbaf:	00 
  20bbb0:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  20bbb7:	00 00 
  20bbb9:	48 8b 05 68 50 01 00 	mov    rax,QWORD PTR [rip+0x15068]        # 220c28 <__unnamed_48+0x10>
  20bbc0:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20bbc7:	00 
  20bbc8:	48 c7 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],0x0
  20bbcf:	00 00 00 00 00 
  20bbd4:	48 8d 44 24 60       	lea    rax,[rsp+0x60]
  20bbd9:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  20bbe0:	00 
  20bbe1:	48 c7 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],0xf
  20bbe8:	00 0f 00 00 00 
            return os.File.openRead(&fixed_allocator.allocator, proc_file_path);
  20bbed:	48 8d 15 14 50 01 00 	lea    rdx,[rip+0x15014]        # 220c08 <__unnamed_49>
  20bbf4:	48 8d bc 24 b8 02 00 	lea    rdi,[rsp+0x2b8]
  20bbfb:	00 
  20bbfc:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20bc03:	00 
  20bc04:	c5 f8 77             	vzeroupper 
  20bc07:	e8 64 42 00 00       	call   20fe70 <File_openRead>
  20bc0c:	48 8b ac 24 b8 02 00 	mov    rbp,QWORD PTR [rsp+0x2b8]
  20bc13:	00 
            st.self_exe_file = try os.openSelfExe();
  20bc14:	66 85 ed             	test   bp,bp
  20bc17:	74 3e                	je     20bc57 <openSelfDebugInfo+0x227>
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20bc19:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20bc1d:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20bc24:	00 
  20bc25:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20bc2c:	00 c8 00 00 00 
  20bc31:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20bc38:	00 
  20bc39:	4c 89 ff             	mov    rdi,r15
  20bc3c:	ff d0                	call   rax
  20bc3e:	66 41 89 2e          	mov    WORD PTR [r14],bp
  20bc42:	48 8b 84 24 0c 04 00 	mov    rax,QWORD PTR [rsp+0x40c]
  20bc49:	00 
  20bc4a:	48 8b 8c 24 12 04 00 	mov    rcx,QWORD PTR [rsp+0x412]
  20bc51:	00 
  20bc52:	e9 cf 0a 00 00       	jmp    20c726 <openSelfDebugInfo+0xcf6>
  20bc57:	48 c1 ed 20          	shr    rbp,0x20
  20bc5b:	89 2b                	mov    DWORD PTR [rbx],ebp
            try st.elf.openFile(allocator, &st.self_exe_file);
  20bc5d:	4c 8d 63 08          	lea    r12,[rbx+0x8]
        elf.auto_close_stream = true;
    }

    /// Call close when done.
    pub fn openFile(elf: *Elf, allocator: *mem.Allocator, file: *os.File) !void {
        elf.allocator = allocator;
  20bc61:	4c 89 7b 50          	mov    QWORD PTR [rbx+0x50],r15
        elf.in_file = file;
  20bc65:	48 89 5b 08          	mov    QWORD PTR [rbx+0x8],rbx
        elf.auto_close_stream = false;
  20bc69:	c6 43 10 00          	mov    BYTE PTR [rbx+0x10],0x0

        var file_stream = io.FileInStream.init(elf.in_file);
  20bc6d:	48 89 5c 24 20       	mov    QWORD PTR [rsp+0x20],rbx
  20bc72:	48 8d 05 e7 48 00 00 	lea    rax,[rip+0x48e7]        # 210560 <FileInStream_readFn>
  20bc79:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20bc7e:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  20bc85:	00 
        const in = &file_stream.stream;

        var magic: [4]u8 = undefined;
        try in.readNoEof(magic[0..]);
  20bc86:	48 89 84 24 b8 02 00 	mov    QWORD PTR [rsp+0x2b8],rax
  20bc8d:	00 
  20bc8e:	48 c7 84 24 c0 02 00 	mov    QWORD PTR [rsp+0x2c0],0x4
  20bc95:	00 04 00 00 00 
        return self.file.read(buffer);
  20bc9a:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  20bc9f:	4c 8d ac 24 a0 00 00 	lea    r13,[rsp+0xa0]
  20bca6:	00 
  20bca7:	48 8d 94 24 b8 02 00 	lea    rdx,[rsp+0x2b8]
  20bcae:	00 
  20bcaf:	4c 89 ef             	mov    rdi,r13
  20bcb2:	e8 99 47 00 00       	call   210450 <File_read>
  20bcb7:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20bcbe:	00 
            const amt_read = try self.read(buf);
  20bcbf:	66 85 ed             	test   bp,bp
  20bcc2:	75 16                	jne    20bcda <openSelfDebugInfo+0x2aa>
  20bcc4:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20bccb:	00 
  20bccc:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20bcd0:	48 3b 84 24 c0 02 00 	cmp    rax,QWORD PTR [rsp+0x2c0]
  20bcd7:	00 
  20bcd8:	73 50                	jae    20bd2a <openSelfDebugInfo+0x2fa>
  20bcda:	66 85 ed             	test   bp,bp
  20bcdd:	0f 84 77 06 00 00    	je     20c35a <openSelfDebugInfo+0x92a>
  20bce3:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20bce6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20bced:	00 00 00 
    return asm volatile ("syscall"
  20bcf0:	b8 03 00 00 00       	mov    eax,0x3
  20bcf5:	0f 05                	syscall 
            switch (err) {
  20bcf7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20bcfb:	74 f3                	je     20bcf0 <openSelfDebugInfo+0x2c0>
        /// Remove and return the first node in the list.
        ///
        /// Returns:
        ///     A pointer to the first node in the list.
        pub fn popFirst(list: *Self) ?*Node {
            const first = list.first orelse return null;
  20bcfd:	48 8b 05 4c 53 01 00 	mov    rax,QWORD PTR [rip+0x1534c]        # 221050 <emfile_promise_queue>
  20bd04:	48 85 c0             	test   rax,rax
  20bd07:	0f 84 2b 01 00 00    	je     20be38 <openSelfDebugInfo+0x408>
            if (node.prev) |prev_node| {
  20bd0d:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20bd10:	48 85 c9             	test   rcx,rcx
  20bd13:	0f 84 b5 00 00 00    	je     20bdce <openSelfDebugInfo+0x39e>
                prev_node.next = node.next;
  20bd19:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20bd1d:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20bd21:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20bd25:	e9 af 00 00 00       	jmp    20bdd9 <openSelfDebugInfo+0x3a9>
        if (b[index] != item) return false;
  20bd2a:	80 bc 24 50 01 00 00 	cmp    BYTE PTR [rsp+0x150],0x7f
  20bd31:	7f 
  20bd32:	0f 85 15 06 00 00    	jne    20c34d <openSelfDebugInfo+0x91d>
  20bd38:	80 bc 24 51 01 00 00 	cmp    BYTE PTR [rsp+0x151],0x45
  20bd3f:	45 
  20bd40:	0f 85 07 06 00 00    	jne    20c34d <openSelfDebugInfo+0x91d>
  20bd46:	80 bc 24 52 01 00 00 	cmp    BYTE PTR [rsp+0x152],0x4c
  20bd4d:	4c 
  20bd4e:	0f 85 f9 05 00 00    	jne    20c34d <openSelfDebugInfo+0x91d>
  20bd54:	80 bc 24 53 01 00 00 	cmp    BYTE PTR [rsp+0x153],0x46
  20bd5b:	46 
  20bd5c:	0f 85 17 01 00 00    	jne    20be79 <openSelfDebugInfo+0x449>
  20bd62:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20bd67:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
            try self.readNoEof(result[0..]);
  20bd6c:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20bd71:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  20bd78:	00 00 
  20bd7a:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20bd81:	00 
  20bd82:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20bd87:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20bd8b:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20bd92:	00 
            const amt_read = try self.read(buf);
  20bd93:	66 85 ed             	test   bp,bp
  20bd96:	0f 85 3e ff ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20bd9c:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20bda3:	00 
  20bda4:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20bda8:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20bdad:	0f 82 27 ff ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
            return result[0];
  20bdb3:	8a 44 24 07          	mov    al,BYTE PTR [rsp+0x7]
        if (!mem.eql(u8, magic, "\x7fELF")) return error.InvalidFormat;

        elf.is_64 = switch (try in.readByte()) {
  20bdb7:	3c 01                	cmp    al,0x1
  20bdb9:	0f 84 cc 00 00 00    	je     20be8b <openSelfDebugInfo+0x45b>
  20bdbf:	3c 02                	cmp    al,0x2
  20bdc1:	0f 85 86 05 00 00    	jne    20c34d <openSelfDebugInfo+0x91d>
  20bdc7:	b0 01                	mov    al,0x1
  20bdc9:	e9 bf 00 00 00       	jmp    20be8d <openSelfDebugInfo+0x45d>
                list.first = node.next;
  20bdce:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20bdd2:	48 89 0d 77 52 01 00 	mov    QWORD PTR [rip+0x15277],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20bdd9:	48 85 c9             	test   rcx,rcx
  20bddc:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20bddf:	48 8d 35 72 52 01 00 	lea    rsi,[rip+0x15272]        # 221058 <emfile_promise_queue+0x8>
  20bde6:	48 0f 45 f1          	cmovne rsi,rcx
  20bdea:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20bded:	48 83 05 6b 52 01 00 	add    QWORD PTR [rip+0x1526b],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20bdf4:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20bdf5:	74 1e                	je     20be15 <openSelfDebugInfo+0x3e5>
  20bdf7:	48 83 3d 51 52 01 00 	cmp    QWORD PTR [rip+0x15251],0x0        # 221050 <emfile_promise_queue>
  20bdfe:	00 
  20bdff:	0f 84 fd 32 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20be05:	48 8b 0d 4c 52 01 00 	mov    rcx,QWORD PTR [rip+0x1524c]        # 221058 <emfile_promise_queue+0x8>
  20be0c:	48 85 c9             	test   rcx,rcx
  20be0f:	0f 84 ed 32 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20be15:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20be19:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20be1d:	0f 1f 00             	nop    DWORD PTR [rax]
  20be20:	48 89 c1             	mov    rcx,rax
  20be23:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20be27:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20be2d:	75 f1                	jne    20be20 <openSelfDebugInfo+0x3f0>
  20be2f:	a8 01                	test   al,0x1
  20be31:	75 05                	jne    20be38 <openSelfDebugInfo+0x408>
  20be33:	c5 f8 77             	vzeroupper 
  20be36:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20be38:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20be3c:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20be43:	00 
  20be44:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20be4b:	00 c8 00 00 00 
  20be50:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20be57:	00 
  20be58:	4c 89 ff             	mov    rdi,r15
  20be5b:	c5 f8 77             	vzeroupper 
  20be5e:	ff d0                	call   rax
  20be60:	66 41 89 2e          	mov    WORD PTR [r14],bp
  20be64:	48 8b 84 24 fe 03 00 	mov    rax,QWORD PTR [rsp+0x3fe]
  20be6b:	00 
  20be6c:	48 8b 8c 24 04 04 00 	mov    rcx,QWORD PTR [rsp+0x404]
  20be73:	00 
  20be74:	e9 ad 08 00 00       	jmp    20c726 <openSelfDebugInfo+0xcf6>
  20be79:	66 bd 21 00          	mov    bp,0x21
  20be7d:	66 85 ed             	test   bp,bp
  20be80:	0f 85 5d fe ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
  20be86:	e9 cf 04 00 00       	jmp    20c35a <openSelfDebugInfo+0x92a>
  20be8b:	31 c0                	xor    eax,eax
  20be8d:	88 43 11             	mov    BYTE PTR [rbx+0x11],al
            try self.readNoEof(result[0..]);
  20be90:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20be95:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20be9a:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  20bea1:	00 00 
  20bea3:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20beaa:	00 
  20beab:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20beb0:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20beb5:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20beb9:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20bec0:	00 
            const amt_read = try self.read(buf);
  20bec1:	66 85 ed             	test   bp,bp
  20bec4:	0f 85 10 fe ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20beca:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20bed1:	00 
  20bed2:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20bed6:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20bedb:	0f 82 f9 fd ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
            return result[0];
  20bee1:	8a 44 24 07          	mov    al,BYTE PTR [rsp+0x7]
            1 => false,
            2 => true,
            else => return error.InvalidFormat,
        };

        elf.endian = switch (try in.readByte()) {
  20bee5:	3c 01                	cmp    al,0x1
  20bee7:	74 0c                	je     20bef5 <openSelfDebugInfo+0x4c5>
  20bee9:	3c 02                	cmp    al,0x2
  20beeb:	0f 85 5c 04 00 00    	jne    20c34d <openSelfDebugInfo+0x91d>
  20bef1:	31 c0                	xor    eax,eax
  20bef3:	eb 02                	jmp    20bef7 <openSelfDebugInfo+0x4c7>
  20bef5:	b0 01                	mov    al,0x1
  20bef7:	48 8d 4b 12          	lea    rcx,[rbx+0x12]
  20befb:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  20bf00:	88 01                	mov    BYTE PTR [rcx],al
            try self.readNoEof(result[0..]);
  20bf02:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20bf07:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20bf0c:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  20bf13:	00 00 
  20bf15:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20bf1c:	00 
  20bf1d:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20bf22:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20bf27:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20bf2b:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20bf32:	00 
            const amt_read = try self.read(buf);
  20bf33:	66 85 ed             	test   bp,bp
  20bf36:	0f 85 9e fd ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20bf3c:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20bf43:	00 
  20bf44:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20bf48:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20bf4d:	0f 82 87 fd ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
            2 => builtin.Endian.Big,
            else => return error.InvalidFormat,
        };

        const version_byte = try in.readByte();
        if (version_byte != 1) return error.InvalidFormat;
  20bf53:	80 7c 24 07 01       	cmp    BYTE PTR [rsp+0x7],0x1
  20bf58:	0f 85 ef 03 00 00    	jne    20c34d <openSelfDebugInfo+0x91d>

        // skip over padding
        try elf.in_file.seekForward(9);
  20bf5e:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20bf62:	48 63 38             	movsxd rdi,DWORD PTR [rax]
    return asm volatile ("syscall"
  20bf65:	b8 08 00 00 00       	mov    eax,0x8
  20bf6a:	be 09 00 00 00       	mov    esi,0x9
  20bf6f:	ba 01 00 00 00       	mov    edx,0x1
  20bf74:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20bf76:	48 89 c2             	mov    rdx,rax
  20bf79:	48 f7 da             	neg    rdx
  20bf7c:	31 c9                	xor    ecx,ecx
  20bf7e:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20bf84:	48 0f 47 ca          	cmova  rcx,rdx
                if (err > 0) {
  20bf88:	48 83 f9 1d          	cmp    rcx,0x1d
  20bf8c:	0f 87 4b 31 00 00    	ja     20f0dd <openSelfDebugInfo+0x36ad>
  20bf92:	48 8d 05 47 4f ff ff 	lea    rax,[rip+0xffffffffffff4f47]        # 200ee0 <__unnamed_9+0x200>
  20bf99:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  20bf9d:	48 01 c1             	add    rcx,rax
  20bfa0:	66 bd 02 00          	mov    bp,0x2
  20bfa4:	ff e1                	jmp    rcx
  20bfa6:	66 bd 22 00          	mov    bp,0x22
  20bfaa:	66 85 ed             	test   bp,bp
  20bfad:	0f 85 30 fd ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
  20bfb3:	e9 a2 03 00 00       	jmp    20c35a <openSelfDebugInfo+0x92a>

        elf.file_type = switch (try in.readInt(elf.endian, u16)) {
  20bfb8:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
  20bfbb:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20bfbf:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            try self.readNoEof(bytes[0..]);
  20bfc4:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20bfc9:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20bfd0:	00 00 
  20bfd2:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20bfd9:	00 
  20bfda:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20bfdf:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20bfe4:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20bfe8:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20bfef:	00 
            const amt_read = try self.read(buf);
  20bff0:	66 85 ed             	test   bp,bp
  20bff3:	0f 85 e1 fc ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20bff9:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20c000:	00 
  20c001:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20c005:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20c00a:	0f 82 ca fc ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
  20c010:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20c015:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20c01a:	89 ca                	mov    edx,ecx
  20c01c:	c1 e2 08             	shl    edx,0x8
  20c01f:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20c021:	c1 e0 08             	shl    eax,0x8
  20c024:	09 c8                	or     eax,ecx
    switch (endian) {
  20c026:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20c02b:	66 0f 45 c2          	cmovne ax,dx
  20c02f:	83 c0 ff             	add    eax,0xffffffff
  20c032:	0f b7 c8             	movzx  ecx,ax
  20c035:	83 f9 03             	cmp    ecx,0x3
  20c038:	0f 87 0f 03 00 00    	ja     20c34d <openSelfDebugInfo+0x91d>
  20c03e:	24 03                	and    al,0x3
  20c040:	88 43 13             	mov    BYTE PTR [rbx+0x13],al
            3 => FileType.Shared,
            4 => FileType.Core,
            else => return error.InvalidFormat,
        };

        elf.arch = switch (try in.readInt(elf.endian, u16)) {
  20c043:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  20c046:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20c04a:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20c04f:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20c054:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20c05b:	00 00 
  20c05d:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20c064:	00 
  20c065:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20c06a:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20c06f:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20c073:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20c07a:	00 
            const amt_read = try self.read(buf);
  20c07b:	66 85 ed             	test   bp,bp
  20c07e:	0f 85 56 fc ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20c084:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20c08b:	00 
  20c08c:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20c090:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20c095:	0f 82 3f fc ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
  20c09b:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20c0a0:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20c0a5:	89 ca                	mov    edx,ecx
  20c0a7:	c1 e2 08             	shl    edx,0x8
  20c0aa:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20c0ac:	c1 e0 08             	shl    eax,0x8
  20c0af:	09 c8                	or     eax,ecx
    switch (endian) {
  20c0b1:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20c0b6:	66 0f 45 c2          	cmovne ax,dx
  20c0ba:	8d 48 fe             	lea    ecx,[rax-0x2]
  20c0bd:	0f b7 c9             	movzx  ecx,cx
  20c0c0:	83 f9 3c             	cmp    ecx,0x3c
  20c0c3:	77 1a                	ja     20c0df <openSelfDebugInfo+0x6af>
  20c0c5:	31 c0                	xor    eax,eax
  20c0c7:	48 8d 15 8a 4e ff ff 	lea    rdx,[rip+0xffffffffffff4e8a]        # 200f58 <__unnamed_9+0x278>
  20c0ce:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  20c0d2:	48 01 d1             	add    rcx,rdx
  20c0d5:	66 bd 21 00          	mov    bp,0x21
  20c0d9:	ff e1                	jmp    rcx
  20c0db:	b0 01                	mov    al,0x1
  20c0dd:	eb 28                	jmp    20c107 <openSelfDebugInfo+0x6d7>
  20c0df:	0f b7 c0             	movzx  eax,ax
  20c0e2:	3d b7 00 00 00       	cmp    eax,0xb7
  20c0e7:	0f 85 60 02 00 00    	jne    20c34d <openSelfDebugInfo+0x91d>
  20c0ed:	b0 08                	mov    al,0x8
  20c0ef:	eb 16                	jmp    20c107 <openSelfDebugInfo+0x6d7>
  20c0f1:	b0 06                	mov    al,0x6
  20c0f3:	eb 12                	jmp    20c107 <openSelfDebugInfo+0x6d7>
  20c0f5:	b0 07                	mov    al,0x7
  20c0f7:	eb 0e                	jmp    20c107 <openSelfDebugInfo+0x6d7>
  20c0f9:	b0 02                	mov    al,0x2
  20c0fb:	eb 0a                	jmp    20c107 <openSelfDebugInfo+0x6d7>
  20c0fd:	b0 04                	mov    al,0x4
  20c0ff:	eb 06                	jmp    20c107 <openSelfDebugInfo+0x6d7>
  20c101:	b0 03                	mov    al,0x3
  20c103:	eb 02                	jmp    20c107 <openSelfDebugInfo+0x6d7>
  20c105:	b0 05                	mov    al,0x5
  20c107:	24 0f                	and    al,0xf
  20c109:	88 43 14             	mov    BYTE PTR [rbx+0x14],al
            0x3E => Arch.x86_64,
            0xb7 => Arch.AArch64,
            else => return error.InvalidFormat,
        };

        const elf_version = try in.readInt(elf.endian, u32);
  20c10c:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  20c10f:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20c113:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20c118:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20c11d:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20c124:	00 00 
  20c126:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20c12d:	00 
  20c12e:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20c133:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20c138:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20c13c:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20c143:	00 
            const amt_read = try self.read(buf);
  20c144:	66 85 ed             	test   bp,bp
  20c147:	0f 85 8d fb ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20c14d:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20c154:	00 
  20c155:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20c159:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20c15e:	0f 82 76 fb ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
  20c164:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20c169:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20c16e:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20c173:	74 23                	je     20c198 <openSelfDebugInfo+0x768>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20c175:	c1 e1 08             	shl    ecx,0x8
  20c178:	09 c1                	or     ecx,eax
  20c17a:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20c17f:	c1 e2 10             	shl    edx,0x10
  20c182:	09 ca                	or     edx,ecx
  20c184:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20c189:	c1 e0 18             	shl    eax,0x18
  20c18c:	09 d0                	or     eax,edx
        if (elf_version != 1) return error.InvalidFormat;
  20c18e:	83 f8 01             	cmp    eax,0x1
  20c191:	74 27                	je     20c1ba <openSelfDebugInfo+0x78a>
  20c193:	e9 b5 01 00 00       	jmp    20c34d <openSelfDebugInfo+0x91d>
                result = (result << 8) | b;
  20c198:	c1 e0 08             	shl    eax,0x8
  20c19b:	09 c8                	or     eax,ecx
  20c19d:	c1 e0 08             	shl    eax,0x8
  20c1a0:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20c1a5:	09 c1                	or     ecx,eax
  20c1a7:	c1 e1 08             	shl    ecx,0x8
  20c1aa:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20c1af:	09 c8                	or     eax,ecx
  20c1b1:	83 f8 01             	cmp    eax,0x1
  20c1b4:	0f 85 93 01 00 00    	jne    20c34d <openSelfDebugInfo+0x91d>
  20c1ba:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]

        if (elf.is_64) {
  20c1bd:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20c1c1:	80 7b 11 01          	cmp    BYTE PTR [rbx+0x11],0x1
  20c1c5:	0f 85 58 23 00 00    	jne    20e523 <openSelfDebugInfo+0x2af3>
            elf.entry_addr = try in.readInt(elf.endian, u64);
  20c1cb:	0f b6 54 24 38       	movzx  edx,BYTE PTR [rsp+0x38]
  20c1d0:	48 8d bc 24 28 04 00 	lea    rdi,[rsp+0x428]
  20c1d7:	00 
  20c1d8:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20c1dd:	e8 3e 41 00 00       	call   210320 <InStream(ReadError)_readInt.33>
  20c1e2:	0f b7 ac 24 28 04 00 	movzx  ebp,WORD PTR [rsp+0x428]
  20c1e9:	00 
  20c1ea:	66 85 ed             	test   bp,bp
  20c1ed:	0f 85 e7 fa ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20c1f3:	48 8b 84 24 30 04 00 	mov    rax,QWORD PTR [rsp+0x430]
  20c1fa:	00 
  20c1fb:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
            elf.program_header_offset = try in.readInt(elf.endian, u64);
  20c1ff:	0f b6 53 12          	movzx  edx,BYTE PTR [rbx+0x12]
  20c203:	48 8d bc 24 10 02 00 	lea    rdi,[rsp+0x210]
  20c20a:	00 
  20c20b:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20c210:	e8 0b 41 00 00       	call   210320 <InStream(ReadError)_readInt.33>
  20c215:	0f b7 ac 24 10 02 00 	movzx  ebp,WORD PTR [rsp+0x210]
  20c21c:	00 
  20c21d:	66 85 ed             	test   bp,bp
  20c220:	0f 85 b4 fa ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20c226:	48 8b 84 24 18 02 00 	mov    rax,QWORD PTR [rsp+0x218]
  20c22d:	00 
  20c22e:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
            elf.section_header_offset = try in.readInt(elf.endian, u64);
  20c232:	0f b6 53 12          	movzx  edx,BYTE PTR [rbx+0x12]
  20c236:	48 8d bc 24 e0 01 00 	lea    rdi,[rsp+0x1e0]
  20c23d:	00 
  20c23e:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20c243:	e8 d8 40 00 00       	call   210320 <InStream(ReadError)_readInt.33>
  20c248:	0f b7 ac 24 e0 01 00 	movzx  ebp,WORD PTR [rsp+0x1e0]
  20c24f:	00 
  20c250:	66 85 ed             	test   bp,bp
  20c253:	0f 85 81 fa ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20c259:	48 8b 84 24 e8 01 00 	mov    rax,QWORD PTR [rsp+0x1e8]
  20c260:	00 
  20c261:	48 89 43 28          	mov    QWORD PTR [rbx+0x28],rax
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
        }

        // skip over flags
        try elf.in_file.seekForward(4);
  20c265:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20c269:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20c26c:	b8 08 00 00 00       	mov    eax,0x8
  20c271:	be 04 00 00 00       	mov    esi,0x4
  20c276:	ba 01 00 00 00       	mov    edx,0x1
  20c27b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20c27d:	48 89 c2             	mov    rdx,rax
  20c280:	48 f7 da             	neg    rdx
  20c283:	31 c9                	xor    ecx,ecx
  20c285:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20c28b:	48 0f 47 ca          	cmova  rcx,rdx
  20c28f:	48 83 f9 1d          	cmp    rcx,0x1d
  20c293:	0f 87 44 2e 00 00    	ja     20f0dd <openSelfDebugInfo+0x36ad>
  20c299:	48 8d 05 ac 4d ff ff 	lea    rax,[rip+0xffffffffffff4dac]        # 20104c <__unnamed_9+0x36c>
  20c2a0:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  20c2a4:	48 01 c1             	add    rcx,rax
  20c2a7:	66 bd 02 00          	mov    bp,0x2
  20c2ab:	ff e1                	jmp    rcx

        const header_size = try in.readInt(elf.endian, u16);
  20c2ad:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20c2b2:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20c2b4:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20c2b8:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20c2bd:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20c2c2:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20c2c9:	00 00 
  20c2cb:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20c2d2:	00 
  20c2d3:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20c2d8:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20c2dd:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20c2e1:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20c2e8:	00 
            const amt_read = try self.read(buf);
  20c2e9:	66 85 ed             	test   bp,bp
  20c2ec:	0f 85 e8 f9 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20c2f2:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20c2f9:	00 
  20c2fa:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20c2fe:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20c303:	0f 82 d1 f9 ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
  20c309:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20c30e:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20c313:	89 ca                	mov    edx,ecx
  20c315:	c1 e2 08             	shl    edx,0x8
  20c318:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20c31a:	c1 e0 08             	shl    eax,0x8
  20c31d:	09 c8                	or     eax,ecx
    switch (endian) {
  20c31f:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20c324:	66 0f 45 c2          	cmovne ax,dx
        if ((elf.is_64 and header_size != 64) or (!elf.is_64 and header_size != 52)) {
  20c328:	8a 4b 11             	mov    cl,BYTE PTR [rbx+0x11]
  20c32b:	80 f9 01             	cmp    cl,0x1
  20c32e:	75 08                	jne    20c338 <openSelfDebugInfo+0x908>
  20c330:	0f b7 d0             	movzx  edx,ax
  20c333:	83 fa 40             	cmp    edx,0x40
  20c336:	75 15                	jne    20c34d <openSelfDebugInfo+0x91d>
  20c338:	0f b7 c0             	movzx  eax,ax
  20c33b:	83 f8 34             	cmp    eax,0x34
  20c33e:	0f 84 c2 23 00 00    	je     20e706 <openSelfDebugInfo+0x2cd6>
  20c344:	80 f1 01             	xor    cl,0x1
  20c347:	0f 84 b9 23 00 00    	je     20e706 <openSelfDebugInfo+0x2cd6>
  20c34d:	66 bd 21 00          	mov    bp,0x21
  20c351:	66 85 ed             	test   bp,bp
  20c354:	0f 85 89 f9 ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
            st.debug_info = (try st.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  20c35a:	48 8d 15 57 48 01 00 	lea    rdx,[rip+0x14857]        # 220bb8 <__unnamed_50>
  20c361:	48 8d bc 24 a8 02 00 	lea    rdi,[rsp+0x2a8]
  20c368:	00 
  20c369:	4c 89 e6             	mov    rsi,r12
  20c36c:	c5 f8 77             	vzeroupper 
  20c36f:	e8 ac 38 00 00       	call   20fc20 <Elf_findSection>
  20c374:	66 83 bc 24 a8 02 00 	cmp    WORD PTR [rsp+0x2a8],0x0
  20c37b:	00 00 
  20c37d:	74 7b                	je     20c3fa <openSelfDebugInfo+0x9ca>
        const bytes = @sliceToBytes(memory);
  20c37f:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20c383:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20c387:	74 26                	je     20c3af <openSelfDebugInfo+0x97f>
  20c389:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20c38d:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20c391:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20c395:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20c39c:	00 
  20c39d:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20c3a4:	00 
  20c3a5:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c3ac:	00 
  20c3ad:	ff d2                	call   rdx
    }

    pub fn close(elf: *Elf) void {
        elf.allocator.free(elf.section_headers);

        if (elf.auto_close_stream) elf.in_file.close();
  20c3af:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20c3b3:	0f 85 8c 02 00 00    	jne    20c645 <openSelfDebugInfo+0xc15>
  20c3b9:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c3bd:	48 63 38             	movsxd rdi,DWORD PTR [rax]
    return asm volatile ("syscall"
  20c3c0:	b8 03 00 00 00       	mov    eax,0x3
  20c3c5:	0f 05                	syscall 
            switch (err) {
  20c3c7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c3cb:	74 f3                	je     20c3c0 <openSelfDebugInfo+0x990>
            const first = list.first orelse return null;
  20c3cd:	48 8b 05 7c 4c 01 00 	mov    rax,QWORD PTR [rip+0x14c7c]        # 221050 <emfile_promise_queue>
  20c3d4:	48 85 c0             	test   rax,rax
  20c3d7:	0f 84 68 02 00 00    	je     20c645 <openSelfDebugInfo+0xc15>
            if (node.prev) |prev_node| {
  20c3dd:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c3e0:	48 85 c9             	test   rcx,rcx
  20c3e3:	0f 84 f8 01 00 00    	je     20c5e1 <openSelfDebugInfo+0xbb1>
                prev_node.next = node.next;
  20c3e9:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c3ed:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c3f1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c3f5:	e9 f2 01 00 00       	jmp    20c5ec <openSelfDebugInfo+0xbbc>
  20c3fa:	48 8b 84 24 b0 02 00 	mov    rax,QWORD PTR [rsp+0x2b0]
  20c401:	00 
  20c402:	48 85 c0             	test   rax,rax
  20c405:	0f 84 a5 00 00 00    	je     20c4b0 <openSelfDebugInfo+0xa80>
  20c40b:	48 89 43 60          	mov    QWORD PTR [rbx+0x60],rax
            st.debug_abbrev = (try st.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  20c40f:	48 8d 15 b2 47 01 00 	lea    rdx,[rip+0x147b2]        # 220bc8 <__unnamed_51>
  20c416:	48 8d bc 24 98 02 00 	lea    rdi,[rsp+0x298]
  20c41d:	00 
  20c41e:	4c 89 e6             	mov    rsi,r12
  20c421:	e8 fa 37 00 00       	call   20fc20 <Elf_findSection>
  20c426:	66 83 bc 24 98 02 00 	cmp    WORD PTR [rsp+0x298],0x0
  20c42d:	00 00 
  20c42f:	0f 84 f6 00 00 00    	je     20c52b <openSelfDebugInfo+0xafb>
        const bytes = @sliceToBytes(memory);
  20c435:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20c439:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20c43d:	74 26                	je     20c465 <openSelfDebugInfo+0xa35>
  20c43f:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20c443:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20c447:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20c44b:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20c452:	00 
  20c453:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20c45a:	00 
  20c45b:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c462:	00 
  20c463:	ff d2                	call   rdx
  20c465:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20c469:	0f 85 69 04 00 00    	jne    20c8d8 <openSelfDebugInfo+0xea8>
  20c46f:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c473:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20c476:	b8 03 00 00 00       	mov    eax,0x3
  20c47b:	0f 05                	syscall 
  20c47d:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c481:	74 f3                	je     20c476 <openSelfDebugInfo+0xa46>
            const first = list.first orelse return null;
  20c483:	48 8b 05 c6 4b 01 00 	mov    rax,QWORD PTR [rip+0x14bc6]        # 221050 <emfile_promise_queue>
  20c48a:	48 85 c0             	test   rax,rax
  20c48d:	0f 84 45 04 00 00    	je     20c8d8 <openSelfDebugInfo+0xea8>
            if (node.prev) |prev_node| {
  20c493:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c496:	48 85 c9             	test   rcx,rcx
  20c499:	0f 84 d5 03 00 00    	je     20c874 <openSelfDebugInfo+0xe44>
                prev_node.next = node.next;
  20c49f:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c4a3:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c4a7:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c4ab:	e9 cf 03 00 00       	jmp    20c87f <openSelfDebugInfo+0xe4f>
        const bytes = @sliceToBytes(memory);
  20c4b0:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20c4b4:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20c4b8:	74 26                	je     20c4e0 <openSelfDebugInfo+0xab0>
  20c4ba:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20c4be:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20c4c2:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20c4c6:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20c4cd:	00 
  20c4ce:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20c4d5:	00 
  20c4d6:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c4dd:	00 
  20c4de:	ff d2                	call   rdx
  20c4e0:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20c4e4:	0f 85 33 05 00 00    	jne    20ca1d <openSelfDebugInfo+0xfed>
  20c4ea:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c4ee:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20c4f1:	b8 03 00 00 00       	mov    eax,0x3
  20c4f6:	0f 05                	syscall 
  20c4f8:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c4fc:	74 f3                	je     20c4f1 <openSelfDebugInfo+0xac1>
            const first = list.first orelse return null;
  20c4fe:	48 8b 05 4b 4b 01 00 	mov    rax,QWORD PTR [rip+0x14b4b]        # 221050 <emfile_promise_queue>
  20c505:	48 85 c0             	test   rax,rax
  20c508:	0f 84 0f 05 00 00    	je     20ca1d <openSelfDebugInfo+0xfed>
            if (node.prev) |prev_node| {
  20c50e:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c511:	48 85 c9             	test   rcx,rcx
  20c514:	0f 84 9f 04 00 00    	je     20c9b9 <openSelfDebugInfo+0xf89>
                prev_node.next = node.next;
  20c51a:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c51e:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c522:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c526:	e9 99 04 00 00       	jmp    20c9c4 <openSelfDebugInfo+0xf94>
  20c52b:	48 8b 84 24 a0 02 00 	mov    rax,QWORD PTR [rsp+0x2a0]
  20c532:	00 
  20c533:	48 85 c0             	test   rax,rax
  20c536:	0f 84 07 02 00 00    	je     20c743 <openSelfDebugInfo+0xd13>
  20c53c:	48 89 43 68          	mov    QWORD PTR [rbx+0x68],rax
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  20c540:	48 8d 15 91 46 01 00 	lea    rdx,[rip+0x14691]        # 220bd8 <__unnamed_52>
  20c547:	48 8d bc 24 88 02 00 	lea    rdi,[rsp+0x288]
  20c54e:	00 
  20c54f:	4c 89 e6             	mov    rsi,r12
  20c552:	e8 c9 36 00 00       	call   20fc20 <Elf_findSection>
  20c557:	66 83 bc 24 88 02 00 	cmp    WORD PTR [rsp+0x288],0x0
  20c55e:	00 00 
  20c560:	0f 84 58 02 00 00    	je     20c7be <openSelfDebugInfo+0xd8e>
        const bytes = @sliceToBytes(memory);
  20c566:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20c56a:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20c56e:	74 26                	je     20c596 <openSelfDebugInfo+0xb66>
  20c570:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20c574:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20c578:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20c57c:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20c583:	00 
  20c584:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20c58b:	00 
  20c58c:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c593:	00 
  20c594:	ff d2                	call   rdx
  20c596:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20c59a:	0f 85 df 06 00 00    	jne    20cc7f <openSelfDebugInfo+0x124f>
  20c5a0:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c5a4:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20c5a7:	b8 03 00 00 00       	mov    eax,0x3
  20c5ac:	0f 05                	syscall 
  20c5ae:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c5b2:	74 f3                	je     20c5a7 <openSelfDebugInfo+0xb77>
            const first = list.first orelse return null;
  20c5b4:	48 8b 05 95 4a 01 00 	mov    rax,QWORD PTR [rip+0x14a95]        # 221050 <emfile_promise_queue>
  20c5bb:	48 85 c0             	test   rax,rax
  20c5be:	0f 84 bb 06 00 00    	je     20cc7f <openSelfDebugInfo+0x124f>
            if (node.prev) |prev_node| {
  20c5c4:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c5c7:	48 85 c9             	test   rcx,rcx
  20c5ca:	0f 84 4b 06 00 00    	je     20cc1b <openSelfDebugInfo+0x11eb>
                prev_node.next = node.next;
  20c5d0:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c5d4:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c5d8:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c5dc:	e9 45 06 00 00       	jmp    20cc26 <openSelfDebugInfo+0x11f6>
                list.first = node.next;
  20c5e1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c5e5:	48 89 0d 64 4a 01 00 	mov    QWORD PTR [rip+0x14a64],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20c5ec:	48 85 c9             	test   rcx,rcx
  20c5ef:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20c5f2:	48 8d 35 5f 4a 01 00 	lea    rsi,[rip+0x14a5f]        # 221058 <emfile_promise_queue+0x8>
  20c5f9:	48 0f 45 f1          	cmovne rsi,rcx
  20c5fd:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20c600:	48 83 05 58 4a 01 00 	add    QWORD PTR [rip+0x14a58],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20c607:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20c608:	74 1e                	je     20c628 <openSelfDebugInfo+0xbf8>
  20c60a:	48 83 3d 3e 4a 01 00 	cmp    QWORD PTR [rip+0x14a3e],0x0        # 221050 <emfile_promise_queue>
  20c611:	00 
  20c612:	0f 84 ea 2a 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20c618:	48 8b 0d 39 4a 01 00 	mov    rcx,QWORD PTR [rip+0x14a39]        # 221058 <emfile_promise_queue+0x8>
  20c61f:	48 85 c9             	test   rcx,rcx
  20c622:	0f 84 da 2a 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20c628:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20c62c:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20c630:	48 89 c1             	mov    rcx,rax
  20c633:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20c637:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20c63d:	75 f1                	jne    20c630 <openSelfDebugInfo+0xc00>
  20c63f:	a8 01                	test   al,0x1
  20c641:	75 02                	jne    20c645 <openSelfDebugInfo+0xc15>
  20c643:	ff 17                	call   QWORD PTR [rdi]
  20c645:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20c648:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20c64f:	00 
  20c650:	b8 03 00 00 00       	mov    eax,0x3
  20c655:	0f 05                	syscall 
            switch (err) {
  20c657:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c65b:	74 f3                	je     20c650 <openSelfDebugInfo+0xc20>
            const first = list.first orelse return null;
  20c65d:	48 8b 05 ec 49 01 00 	mov    rax,QWORD PTR [rip+0x149ec]        # 221050 <emfile_promise_queue>
  20c664:	48 85 c0             	test   rax,rax
  20c667:	74 7c                	je     20c6e5 <openSelfDebugInfo+0xcb5>
            if (node.prev) |prev_node| {
  20c669:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c66c:	48 85 c9             	test   rcx,rcx
  20c66f:	74 0e                	je     20c67f <openSelfDebugInfo+0xc4f>
                prev_node.next = node.next;
  20c671:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c675:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c679:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c67d:	eb 0b                	jmp    20c68a <openSelfDebugInfo+0xc5a>
                list.first = node.next;
  20c67f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c683:	48 89 0d c6 49 01 00 	mov    QWORD PTR [rip+0x149c6],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20c68a:	48 85 c9             	test   rcx,rcx
  20c68d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20c690:	48 8d 35 c1 49 01 00 	lea    rsi,[rip+0x149c1]        # 221058 <emfile_promise_queue+0x8>
  20c697:	48 0f 45 f1          	cmovne rsi,rcx
  20c69b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20c69e:	48 83 05 ba 49 01 00 	add    QWORD PTR [rip+0x149ba],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20c6a5:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20c6a6:	74 1e                	je     20c6c6 <openSelfDebugInfo+0xc96>
  20c6a8:	48 83 3d a0 49 01 00 	cmp    QWORD PTR [rip+0x149a0],0x0        # 221050 <emfile_promise_queue>
  20c6af:	00 
  20c6b0:	0f 84 4c 2a 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20c6b6:	48 8b 0d 9b 49 01 00 	mov    rcx,QWORD PTR [rip+0x1499b]        # 221058 <emfile_promise_queue+0x8>
  20c6bd:	48 85 c9             	test   rcx,rcx
  20c6c0:	0f 84 3c 2a 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20c6c6:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20c6ca:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20c6ce:	66 90                	xchg   ax,ax
  20c6d0:	48 89 c1             	mov    rcx,rax
  20c6d3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20c6d7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20c6dd:	75 f1                	jne    20c6d0 <openSelfDebugInfo+0xca0>
  20c6df:	a8 01                	test   al,0x1
  20c6e1:	75 02                	jne    20c6e5 <openSelfDebugInfo+0xcb5>
  20c6e3:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20c6e5:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20c6e9:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20c6f0:	00 
  20c6f1:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20c6f8:	00 c8 00 00 00 
  20c6fd:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c704:	00 
  20c705:	4c 89 ff             	mov    rdi,r15
  20c708:	ff d0                	call   rax
            st.debug_info = (try st.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  20c70a:	0f b7 84 24 a8 02 00 	movzx  eax,WORD PTR [rsp+0x2a8]
  20c711:	00 
  20c712:	66 41 89 06          	mov    WORD PTR [r14],ax
  20c716:	48 8b 84 24 f0 03 00 	mov    rax,QWORD PTR [rsp+0x3f0]
  20c71d:	00 
  20c71e:	48 8b 8c 24 f6 03 00 	mov    rcx,QWORD PTR [rsp+0x3f6]
  20c725:	00 
  20c726:	49 89 4e 08          	mov    QWORD PTR [r14+0x8],rcx
  20c72a:	49 89 46 02          	mov    QWORD PTR [r14+0x2],rax
  20c72e:	48 81 c4 28 05 00 00 	add    rsp,0x528
  20c735:	5b                   	pop    rbx
  20c736:	41 5c                	pop    r12
  20c738:	41 5d                	pop    r13
  20c73a:	41 5e                	pop    r14
  20c73c:	41 5f                	pop    r15
  20c73e:	5d                   	pop    rbp
  20c73f:	c5 f8 77             	vzeroupper 
  20c742:	c3                   	ret    
        const bytes = @sliceToBytes(memory);
  20c743:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20c747:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20c74b:	74 26                	je     20c773 <openSelfDebugInfo+0xd43>
  20c74d:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20c751:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20c755:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20c759:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20c760:	00 
  20c761:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20c768:	00 
  20c769:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c770:	00 
  20c771:	ff d2                	call   rdx
  20c773:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20c777:	0f 85 42 06 00 00    	jne    20cdbf <openSelfDebugInfo+0x138f>
  20c77d:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c781:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20c784:	b8 03 00 00 00       	mov    eax,0x3
  20c789:	0f 05                	syscall 
            switch (err) {
  20c78b:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c78f:	74 f3                	je     20c784 <openSelfDebugInfo+0xd54>
            const first = list.first orelse return null;
  20c791:	48 8b 05 b8 48 01 00 	mov    rax,QWORD PTR [rip+0x148b8]        # 221050 <emfile_promise_queue>
  20c798:	48 85 c0             	test   rax,rax
  20c79b:	0f 84 1e 06 00 00    	je     20cdbf <openSelfDebugInfo+0x138f>
            if (node.prev) |prev_node| {
  20c7a1:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c7a4:	48 85 c9             	test   rcx,rcx
  20c7a7:	0f 84 ae 05 00 00    	je     20cd5b <openSelfDebugInfo+0x132b>
                prev_node.next = node.next;
  20c7ad:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c7b1:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c7b5:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c7b9:	e9 a8 05 00 00       	jmp    20cd66 <openSelfDebugInfo+0x1336>
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  20c7be:	48 8b 84 24 90 02 00 	mov    rax,QWORD PTR [rsp+0x290]
  20c7c5:	00 
  20c7c6:	48 85 c0             	test   rax,rax
  20c7c9:	0f 84 1b 03 00 00    	je     20caea <openSelfDebugInfo+0x10ba>
  20c7cf:	48 89 43 70          	mov    QWORD PTR [rbx+0x70],rax
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  20c7d3:	48 8d 15 0e 44 01 00 	lea    rdx,[rip+0x1440e]        # 220be8 <__unnamed_53>
  20c7da:	48 8d bc 24 78 02 00 	lea    rdi,[rsp+0x278]
  20c7e1:	00 
  20c7e2:	4c 89 e6             	mov    rsi,r12
  20c7e5:	e8 36 34 00 00       	call   20fc20 <Elf_findSection>
  20c7ea:	66 83 bc 24 78 02 00 	cmp    WORD PTR [rsp+0x278],0x0
  20c7f1:	00 00 
  20c7f3:	0f 84 6c 03 00 00    	je     20cb65 <openSelfDebugInfo+0x1135>
        const bytes = @sliceToBytes(memory);
  20c7f9:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20c7fd:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20c801:	74 26                	je     20c829 <openSelfDebugInfo+0xdf9>
  20c803:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20c807:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20c80b:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20c80f:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20c816:	00 
  20c817:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20c81e:	00 
  20c81f:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c826:	00 
  20c827:	ff d2                	call   rdx
  20c829:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20c82d:	0f 85 d8 14 00 00    	jne    20dd0b <openSelfDebugInfo+0x22db>
  20c833:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c837:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20c83a:	b8 03 00 00 00       	mov    eax,0x3
  20c83f:	0f 05                	syscall 
  20c841:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c845:	74 f3                	je     20c83a <openSelfDebugInfo+0xe0a>
            const first = list.first orelse return null;
  20c847:	48 8b 05 02 48 01 00 	mov    rax,QWORD PTR [rip+0x14802]        # 221050 <emfile_promise_queue>
  20c84e:	48 85 c0             	test   rax,rax
  20c851:	0f 84 b4 14 00 00    	je     20dd0b <openSelfDebugInfo+0x22db>
            if (node.prev) |prev_node| {
  20c857:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c85a:	48 85 c9             	test   rcx,rcx
  20c85d:	0f 84 44 14 00 00    	je     20dca7 <openSelfDebugInfo+0x2277>
                prev_node.next = node.next;
  20c863:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c867:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c86b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c86f:	e9 3e 14 00 00       	jmp    20dcb2 <openSelfDebugInfo+0x2282>
                list.first = node.next;
  20c874:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c878:	48 89 0d d1 47 01 00 	mov    QWORD PTR [rip+0x147d1],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20c87f:	48 85 c9             	test   rcx,rcx
  20c882:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20c885:	48 8d 35 cc 47 01 00 	lea    rsi,[rip+0x147cc]        # 221058 <emfile_promise_queue+0x8>
  20c88c:	48 0f 45 f1          	cmovne rsi,rcx
  20c890:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20c893:	48 83 05 c5 47 01 00 	add    QWORD PTR [rip+0x147c5],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20c89a:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20c89b:	74 1e                	je     20c8bb <openSelfDebugInfo+0xe8b>
  20c89d:	48 83 3d ab 47 01 00 	cmp    QWORD PTR [rip+0x147ab],0x0        # 221050 <emfile_promise_queue>
  20c8a4:	00 
  20c8a5:	0f 84 57 28 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20c8ab:	48 8b 0d a6 47 01 00 	mov    rcx,QWORD PTR [rip+0x147a6]        # 221058 <emfile_promise_queue+0x8>
  20c8b2:	48 85 c9             	test   rcx,rcx
  20c8b5:	0f 84 47 28 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20c8bb:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20c8bf:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20c8c3:	48 89 c1             	mov    rcx,rax
  20c8c6:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20c8ca:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20c8d0:	75 f1                	jne    20c8c3 <openSelfDebugInfo+0xe93>
  20c8d2:	a8 01                	test   al,0x1
  20c8d4:	75 02                	jne    20c8d8 <openSelfDebugInfo+0xea8>
  20c8d6:	ff 17                	call   QWORD PTR [rdi]
  20c8d8:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20c8db:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20c8e0:	b8 03 00 00 00       	mov    eax,0x3
  20c8e5:	0f 05                	syscall 
            switch (err) {
  20c8e7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c8eb:	74 f3                	je     20c8e0 <openSelfDebugInfo+0xeb0>
            const first = list.first orelse return null;
  20c8ed:	48 8b 05 5c 47 01 00 	mov    rax,QWORD PTR [rip+0x1475c]        # 221050 <emfile_promise_queue>
  20c8f4:	48 85 c0             	test   rax,rax
  20c8f7:	74 7a                	je     20c973 <openSelfDebugInfo+0xf43>
            if (node.prev) |prev_node| {
  20c8f9:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c8fc:	48 85 c9             	test   rcx,rcx
  20c8ff:	74 0e                	je     20c90f <openSelfDebugInfo+0xedf>
                prev_node.next = node.next;
  20c901:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c905:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c909:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c90d:	eb 0b                	jmp    20c91a <openSelfDebugInfo+0xeea>
                list.first = node.next;
  20c90f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c913:	48 89 0d 36 47 01 00 	mov    QWORD PTR [rip+0x14736],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20c91a:	48 85 c9             	test   rcx,rcx
  20c91d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20c920:	48 8d 35 31 47 01 00 	lea    rsi,[rip+0x14731]        # 221058 <emfile_promise_queue+0x8>
  20c927:	48 0f 45 f1          	cmovne rsi,rcx
  20c92b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20c92e:	48 83 05 2a 47 01 00 	add    QWORD PTR [rip+0x1472a],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20c935:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20c936:	74 1e                	je     20c956 <openSelfDebugInfo+0xf26>
  20c938:	48 83 3d 10 47 01 00 	cmp    QWORD PTR [rip+0x14710],0x0        # 221050 <emfile_promise_queue>
  20c93f:	00 
  20c940:	0f 84 bc 27 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20c946:	48 8b 0d 0b 47 01 00 	mov    rcx,QWORD PTR [rip+0x1470b]        # 221058 <emfile_promise_queue+0x8>
  20c94d:	48 85 c9             	test   rcx,rcx
  20c950:	0f 84 ac 27 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20c956:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20c95a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20c95e:	48 89 c1             	mov    rcx,rax
  20c961:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20c965:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20c96b:	75 f1                	jne    20c95e <openSelfDebugInfo+0xf2e>
  20c96d:	a8 01                	test   al,0x1
  20c96f:	75 02                	jne    20c973 <openSelfDebugInfo+0xf43>
  20c971:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20c973:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20c977:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20c97e:	00 
  20c97f:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20c986:	00 c8 00 00 00 
  20c98b:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c992:	00 
  20c993:	4c 89 ff             	mov    rdi,r15
  20c996:	ff d0                	call   rax
            st.debug_abbrev = (try st.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  20c998:	0f b7 84 24 98 02 00 	movzx  eax,WORD PTR [rsp+0x298]
  20c99f:	00 
  20c9a0:	66 41 89 06          	mov    WORD PTR [r14],ax
  20c9a4:	48 8b 84 24 e2 03 00 	mov    rax,QWORD PTR [rsp+0x3e2]
  20c9ab:	00 
  20c9ac:	48 8b 8c 24 e8 03 00 	mov    rcx,QWORD PTR [rsp+0x3e8]
  20c9b3:	00 
  20c9b4:	e9 6d fd ff ff       	jmp    20c726 <openSelfDebugInfo+0xcf6>
                list.first = node.next;
  20c9b9:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c9bd:	48 89 0d 8c 46 01 00 	mov    QWORD PTR [rip+0x1468c],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20c9c4:	48 85 c9             	test   rcx,rcx
  20c9c7:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20c9ca:	48 8d 35 87 46 01 00 	lea    rsi,[rip+0x14687]        # 221058 <emfile_promise_queue+0x8>
  20c9d1:	48 0f 45 f1          	cmovne rsi,rcx
  20c9d5:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20c9d8:	48 83 05 80 46 01 00 	add    QWORD PTR [rip+0x14680],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20c9df:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20c9e0:	74 1e                	je     20ca00 <openSelfDebugInfo+0xfd0>
  20c9e2:	48 83 3d 66 46 01 00 	cmp    QWORD PTR [rip+0x14666],0x0        # 221050 <emfile_promise_queue>
  20c9e9:	00 
  20c9ea:	0f 84 12 27 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20c9f0:	48 8b 0d 61 46 01 00 	mov    rcx,QWORD PTR [rip+0x14661]        # 221058 <emfile_promise_queue+0x8>
  20c9f7:	48 85 c9             	test   rcx,rcx
  20c9fa:	0f 84 02 27 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20ca00:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20ca04:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20ca08:	48 89 c1             	mov    rcx,rax
  20ca0b:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20ca0f:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20ca15:	75 f1                	jne    20ca08 <openSelfDebugInfo+0xfd8>
  20ca17:	a8 01                	test   al,0x1
  20ca19:	75 02                	jne    20ca1d <openSelfDebugInfo+0xfed>
  20ca1b:	ff 17                	call   QWORD PTR [rdi]
  20ca1d:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20ca20:	b8 03 00 00 00       	mov    eax,0x3
  20ca25:	0f 05                	syscall 
            switch (err) {
  20ca27:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20ca2b:	74 f3                	je     20ca20 <openSelfDebugInfo+0xff0>
            const first = list.first orelse return null;
  20ca2d:	48 8b 05 1c 46 01 00 	mov    rax,QWORD PTR [rip+0x1461c]        # 221050 <emfile_promise_queue>
  20ca34:	48 85 c0             	test   rax,rax
  20ca37:	74 7a                	je     20cab3 <openSelfDebugInfo+0x1083>
            if (node.prev) |prev_node| {
  20ca39:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20ca3c:	48 85 c9             	test   rcx,rcx
  20ca3f:	74 0e                	je     20ca4f <openSelfDebugInfo+0x101f>
                prev_node.next = node.next;
  20ca41:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20ca45:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20ca49:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20ca4d:	eb 0b                	jmp    20ca5a <openSelfDebugInfo+0x102a>
                list.first = node.next;
  20ca4f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20ca53:	48 89 0d f6 45 01 00 	mov    QWORD PTR [rip+0x145f6],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20ca5a:	48 85 c9             	test   rcx,rcx
  20ca5d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20ca60:	48 8d 35 f1 45 01 00 	lea    rsi,[rip+0x145f1]        # 221058 <emfile_promise_queue+0x8>
  20ca67:	48 0f 45 f1          	cmovne rsi,rcx
  20ca6b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20ca6e:	48 83 05 ea 45 01 00 	add    QWORD PTR [rip+0x145ea],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20ca75:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20ca76:	74 1e                	je     20ca96 <openSelfDebugInfo+0x1066>
  20ca78:	48 83 3d d0 45 01 00 	cmp    QWORD PTR [rip+0x145d0],0x0        # 221050 <emfile_promise_queue>
  20ca7f:	00 
  20ca80:	0f 84 7c 26 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20ca86:	48 8b 0d cb 45 01 00 	mov    rcx,QWORD PTR [rip+0x145cb]        # 221058 <emfile_promise_queue+0x8>
  20ca8d:	48 85 c9             	test   rcx,rcx
  20ca90:	0f 84 6c 26 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20ca96:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20ca9a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20ca9e:	48 89 c1             	mov    rcx,rax
  20caa1:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20caa5:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20caab:	75 f1                	jne    20ca9e <openSelfDebugInfo+0x106e>
  20caad:	a8 01                	test   al,0x1
  20caaf:	75 02                	jne    20cab3 <openSelfDebugInfo+0x1083>
  20cab1:	ff 17                	call   QWORD PTR [rdi]
  20cab3:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20cab7:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20cabe:	00 
  20cabf:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20cac6:	00 c8 00 00 00 
  20cacb:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20cad2:	00 
  20cad3:	4c 89 ff             	mov    rdi,r15
  20cad6:	ff d0                	call   rax
  20cad8:	c5 fa 6f 05 a0 3d ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff3da0]        # 200880 <__unnamed_54>
  20cadf:	ff 
  20cae0:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  20cae5:	e9 44 fc ff ff       	jmp    20c72e <openSelfDebugInfo+0xcfe>
        const bytes = @sliceToBytes(memory);
  20caea:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20caee:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20caf2:	74 26                	je     20cb1a <openSelfDebugInfo+0x10ea>
  20caf4:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20caf8:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20cafc:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20cb00:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20cb07:	00 
  20cb08:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20cb0f:	00 
  20cb10:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20cb17:	00 
  20cb18:	ff d2                	call   rdx
  20cb1a:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20cb1e:	0f 85 27 13 00 00    	jne    20de4b <openSelfDebugInfo+0x241b>
  20cb24:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20cb28:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20cb2b:	b8 03 00 00 00       	mov    eax,0x3
  20cb30:	0f 05                	syscall 
            switch (err) {
  20cb32:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20cb36:	74 f3                	je     20cb2b <openSelfDebugInfo+0x10fb>
            const first = list.first orelse return null;
  20cb38:	48 8b 05 11 45 01 00 	mov    rax,QWORD PTR [rip+0x14511]        # 221050 <emfile_promise_queue>
  20cb3f:	48 85 c0             	test   rax,rax
  20cb42:	0f 84 03 13 00 00    	je     20de4b <openSelfDebugInfo+0x241b>
            if (node.prev) |prev_node| {
  20cb48:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20cb4b:	48 85 c9             	test   rcx,rcx
  20cb4e:	0f 84 93 12 00 00    	je     20dde7 <openSelfDebugInfo+0x23b7>
                prev_node.next = node.next;
  20cb54:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20cb58:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20cb5c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cb60:	e9 8d 12 00 00       	jmp    20ddf2 <openSelfDebugInfo+0x23c2>
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  20cb65:	48 8b 84 24 80 02 00 	mov    rax,QWORD PTR [rsp+0x280]
  20cb6c:	00 
  20cb6d:	48 85 c0             	test   rax,rax
  20cb70:	0f 84 e2 02 00 00    	je     20ce58 <openSelfDebugInfo+0x1428>
  20cb76:	48 89 43 78          	mov    QWORD PTR [rbx+0x78],rax
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  20cb7a:	48 8d 15 77 40 01 00 	lea    rdx,[rip+0x14077]        # 220bf8 <__unnamed_55>
  20cb81:	48 8d bc 24 68 02 00 	lea    rdi,[rsp+0x268]
  20cb88:	00 
  20cb89:	4c 89 e6             	mov    rsi,r12
  20cb8c:	e8 8f 30 00 00       	call   20fc20 <Elf_findSection>
  20cb91:	66 83 bc 24 68 02 00 	cmp    WORD PTR [rsp+0x268],0x0
  20cb98:	00 00 
  20cb9a:	0f 84 33 03 00 00    	je     20ced3 <openSelfDebugInfo+0x14a3>
        const bytes = @sliceToBytes(memory);
  20cba0:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20cba4:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20cba8:	74 26                	je     20cbd0 <openSelfDebugInfo+0x11a0>
  20cbaa:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20cbae:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20cbb2:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20cbb6:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20cbbd:	00 
  20cbbe:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20cbc5:	00 
  20cbc6:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20cbcd:	00 
  20cbce:	ff d2                	call   rdx
  20cbd0:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20cbd4:	0f 85 a2 13 00 00    	jne    20df7c <openSelfDebugInfo+0x254c>
  20cbda:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20cbde:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20cbe1:	b8 03 00 00 00       	mov    eax,0x3
  20cbe6:	0f 05                	syscall 
  20cbe8:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20cbec:	74 f3                	je     20cbe1 <openSelfDebugInfo+0x11b1>
            const first = list.first orelse return null;
  20cbee:	48 8b 05 5b 44 01 00 	mov    rax,QWORD PTR [rip+0x1445b]        # 221050 <emfile_promise_queue>
  20cbf5:	48 85 c0             	test   rax,rax
  20cbf8:	0f 84 7e 13 00 00    	je     20df7c <openSelfDebugInfo+0x254c>
            if (node.prev) |prev_node| {
  20cbfe:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20cc01:	48 85 c9             	test   rcx,rcx
  20cc04:	0f 84 0e 13 00 00    	je     20df18 <openSelfDebugInfo+0x24e8>
                prev_node.next = node.next;
  20cc0a:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20cc0e:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20cc12:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cc16:	e9 08 13 00 00       	jmp    20df23 <openSelfDebugInfo+0x24f3>
                list.first = node.next;
  20cc1b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cc1f:	48 89 0d 2a 44 01 00 	mov    QWORD PTR [rip+0x1442a],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20cc26:	48 85 c9             	test   rcx,rcx
  20cc29:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20cc2c:	48 8d 35 25 44 01 00 	lea    rsi,[rip+0x14425]        # 221058 <emfile_promise_queue+0x8>
  20cc33:	48 0f 45 f1          	cmovne rsi,rcx
  20cc37:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20cc3a:	48 83 05 1e 44 01 00 	add    QWORD PTR [rip+0x1441e],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20cc41:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20cc42:	74 1e                	je     20cc62 <openSelfDebugInfo+0x1232>
  20cc44:	48 83 3d 04 44 01 00 	cmp    QWORD PTR [rip+0x14404],0x0        # 221050 <emfile_promise_queue>
  20cc4b:	00 
  20cc4c:	0f 84 b0 24 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20cc52:	48 8b 0d ff 43 01 00 	mov    rcx,QWORD PTR [rip+0x143ff]        # 221058 <emfile_promise_queue+0x8>
  20cc59:	48 85 c9             	test   rcx,rcx
  20cc5c:	0f 84 a0 24 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20cc62:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20cc66:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20cc6a:	48 89 c1             	mov    rcx,rax
  20cc6d:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20cc71:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20cc77:	75 f1                	jne    20cc6a <openSelfDebugInfo+0x123a>
  20cc79:	a8 01                	test   al,0x1
  20cc7b:	75 02                	jne    20cc7f <openSelfDebugInfo+0x124f>
  20cc7d:	ff 17                	call   QWORD PTR [rdi]
  20cc7f:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20cc82:	b8 03 00 00 00       	mov    eax,0x3
  20cc87:	0f 05                	syscall 
            switch (err) {
  20cc89:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20cc8d:	74 f3                	je     20cc82 <openSelfDebugInfo+0x1252>
            const first = list.first orelse return null;
  20cc8f:	48 8b 05 ba 43 01 00 	mov    rax,QWORD PTR [rip+0x143ba]        # 221050 <emfile_promise_queue>
  20cc96:	48 85 c0             	test   rax,rax
  20cc99:	74 7a                	je     20cd15 <openSelfDebugInfo+0x12e5>
            if (node.prev) |prev_node| {
  20cc9b:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20cc9e:	48 85 c9             	test   rcx,rcx
  20cca1:	74 0e                	je     20ccb1 <openSelfDebugInfo+0x1281>
                prev_node.next = node.next;
  20cca3:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20cca7:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20ccab:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20ccaf:	eb 0b                	jmp    20ccbc <openSelfDebugInfo+0x128c>
                list.first = node.next;
  20ccb1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20ccb5:	48 89 0d 94 43 01 00 	mov    QWORD PTR [rip+0x14394],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20ccbc:	48 85 c9             	test   rcx,rcx
  20ccbf:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20ccc2:	48 8d 35 8f 43 01 00 	lea    rsi,[rip+0x1438f]        # 221058 <emfile_promise_queue+0x8>
  20ccc9:	48 0f 45 f1          	cmovne rsi,rcx
  20cccd:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20ccd0:	48 83 05 88 43 01 00 	add    QWORD PTR [rip+0x14388],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20ccd7:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20ccd8:	74 1e                	je     20ccf8 <openSelfDebugInfo+0x12c8>
  20ccda:	48 83 3d 6e 43 01 00 	cmp    QWORD PTR [rip+0x1436e],0x0        # 221050 <emfile_promise_queue>
  20cce1:	00 
  20cce2:	0f 84 1a 24 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20cce8:	48 8b 0d 69 43 01 00 	mov    rcx,QWORD PTR [rip+0x14369]        # 221058 <emfile_promise_queue+0x8>
  20ccef:	48 85 c9             	test   rcx,rcx
  20ccf2:	0f 84 0a 24 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20ccf8:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20ccfc:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20cd00:	48 89 c1             	mov    rcx,rax
  20cd03:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20cd07:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20cd0d:	75 f1                	jne    20cd00 <openSelfDebugInfo+0x12d0>
  20cd0f:	a8 01                	test   al,0x1
  20cd11:	75 02                	jne    20cd15 <openSelfDebugInfo+0x12e5>
  20cd13:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20cd15:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20cd19:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20cd20:	00 
  20cd21:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20cd28:	00 c8 00 00 00 
  20cd2d:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20cd34:	00 
  20cd35:	4c 89 ff             	mov    rdi,r15
  20cd38:	ff d0                	call   rax
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  20cd3a:	0f b7 84 24 88 02 00 	movzx  eax,WORD PTR [rsp+0x288]
  20cd41:	00 
  20cd42:	66 41 89 06          	mov    WORD PTR [r14],ax
  20cd46:	48 8b 84 24 d4 03 00 	mov    rax,QWORD PTR [rsp+0x3d4]
  20cd4d:	00 
  20cd4e:	48 8b 8c 24 da 03 00 	mov    rcx,QWORD PTR [rsp+0x3da]
  20cd55:	00 
  20cd56:	e9 cb f9 ff ff       	jmp    20c726 <openSelfDebugInfo+0xcf6>
                list.first = node.next;
  20cd5b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cd5f:	48 89 0d ea 42 01 00 	mov    QWORD PTR [rip+0x142ea],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20cd66:	48 85 c9             	test   rcx,rcx
  20cd69:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20cd6c:	48 8d 35 e5 42 01 00 	lea    rsi,[rip+0x142e5]        # 221058 <emfile_promise_queue+0x8>
  20cd73:	48 0f 45 f1          	cmovne rsi,rcx
  20cd77:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20cd7a:	48 83 05 de 42 01 00 	add    QWORD PTR [rip+0x142de],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20cd81:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20cd82:	74 1e                	je     20cda2 <openSelfDebugInfo+0x1372>
  20cd84:	48 83 3d c4 42 01 00 	cmp    QWORD PTR [rip+0x142c4],0x0        # 221050 <emfile_promise_queue>
  20cd8b:	00 
  20cd8c:	0f 84 70 23 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20cd92:	48 8b 0d bf 42 01 00 	mov    rcx,QWORD PTR [rip+0x142bf]        # 221058 <emfile_promise_queue+0x8>
  20cd99:	48 85 c9             	test   rcx,rcx
  20cd9c:	0f 84 60 23 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20cda2:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20cda6:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20cdaa:	48 89 c1             	mov    rcx,rax
  20cdad:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20cdb1:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20cdb7:	75 f1                	jne    20cdaa <openSelfDebugInfo+0x137a>
  20cdb9:	a8 01                	test   al,0x1
  20cdbb:	75 02                	jne    20cdbf <openSelfDebugInfo+0x138f>
  20cdbd:	ff 17                	call   QWORD PTR [rdi]
  20cdbf:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20cdc2:	b8 03 00 00 00       	mov    eax,0x3
  20cdc7:	0f 05                	syscall 
            switch (err) {
  20cdc9:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20cdcd:	74 f3                	je     20cdc2 <openSelfDebugInfo+0x1392>
            const first = list.first orelse return null;
  20cdcf:	48 8b 05 7a 42 01 00 	mov    rax,QWORD PTR [rip+0x1427a]        # 221050 <emfile_promise_queue>
  20cdd6:	48 85 c0             	test   rax,rax
  20cdd9:	0f 84 d4 fc ff ff    	je     20cab3 <openSelfDebugInfo+0x1083>
            if (node.prev) |prev_node| {
  20cddf:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20cde2:	48 85 c9             	test   rcx,rcx
  20cde5:	74 0e                	je     20cdf5 <openSelfDebugInfo+0x13c5>
                prev_node.next = node.next;
  20cde7:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20cdeb:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20cdef:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cdf3:	eb 0b                	jmp    20ce00 <openSelfDebugInfo+0x13d0>
                list.first = node.next;
  20cdf5:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cdf9:	48 89 0d 50 42 01 00 	mov    QWORD PTR [rip+0x14250],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20ce00:	48 85 c9             	test   rcx,rcx
  20ce03:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20ce06:	48 8d 35 4b 42 01 00 	lea    rsi,[rip+0x1424b]        # 221058 <emfile_promise_queue+0x8>
  20ce0d:	48 0f 45 f1          	cmovne rsi,rcx
  20ce11:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20ce14:	48 83 05 44 42 01 00 	add    QWORD PTR [rip+0x14244],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20ce1b:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20ce1c:	74 1e                	je     20ce3c <openSelfDebugInfo+0x140c>
  20ce1e:	48 83 3d 2a 42 01 00 	cmp    QWORD PTR [rip+0x1422a],0x0        # 221050 <emfile_promise_queue>
  20ce25:	00 
  20ce26:	0f 84 d6 22 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20ce2c:	48 8b 0d 25 42 01 00 	mov    rcx,QWORD PTR [rip+0x14225]        # 221058 <emfile_promise_queue+0x8>
  20ce33:	48 85 c9             	test   rcx,rcx
  20ce36:	0f 84 c6 22 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20ce3c:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20ce40:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20ce44:	48 89 c1             	mov    rcx,rax
  20ce47:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20ce4b:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20ce51:	75 f1                	jne    20ce44 <openSelfDebugInfo+0x1414>
  20ce53:	e9 55 fc ff ff       	jmp    20caad <openSelfDebugInfo+0x107d>
        const bytes = @sliceToBytes(memory);
  20ce58:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20ce5c:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20ce60:	74 26                	je     20ce88 <openSelfDebugInfo+0x1458>
  20ce62:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20ce66:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20ce6a:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20ce6e:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20ce75:	00 
  20ce76:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20ce7d:	00 
  20ce7e:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20ce85:	00 
  20ce86:	ff d2                	call   rdx
  20ce88:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20ce8c:	0f 85 2a 12 00 00    	jne    20e0bc <openSelfDebugInfo+0x268c>
  20ce92:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20ce96:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20ce99:	b8 03 00 00 00       	mov    eax,0x3
  20ce9e:	0f 05                	syscall 
            switch (err) {
  20cea0:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20cea4:	74 f3                	je     20ce99 <openSelfDebugInfo+0x1469>
            const first = list.first orelse return null;
  20cea6:	48 8b 05 a3 41 01 00 	mov    rax,QWORD PTR [rip+0x141a3]        # 221050 <emfile_promise_queue>
  20cead:	48 85 c0             	test   rax,rax
  20ceb0:	0f 84 06 12 00 00    	je     20e0bc <openSelfDebugInfo+0x268c>
            if (node.prev) |prev_node| {
  20ceb6:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20ceb9:	48 85 c9             	test   rcx,rcx
  20cebc:	0f 84 96 11 00 00    	je     20e058 <openSelfDebugInfo+0x2628>
                prev_node.next = node.next;
  20cec2:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20cec6:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20ceca:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cece:	e9 90 11 00 00       	jmp    20e063 <openSelfDebugInfo+0x2633>
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  20ced3:	48 8b 84 24 70 02 00 	mov    rax,QWORD PTR [rsp+0x270]
  20ceda:	00 
  20cedb:	48 89 83 80 00 00 00 	mov    QWORD PTR [rbx+0x80],rax
    const debug_info_end = st.debug_info.offset + st.debug_info.size;
  20cee2:	48 8b 43 60          	mov    rax,QWORD PTR [rbx+0x60]
  20cee6:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  20ceea:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  20ceef:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  20cef3:	48 89 9c 24 40 01 00 	mov    QWORD PTR [rsp+0x140],rbx
  20cefa:	00 
  20cefb:	48 8d 05 5e 36 00 00 	lea    rax,[rip+0x365e]        # 210560 <FileInStream_readFn>
  20cf02:	48 89 84 24 48 01 00 	mov    QWORD PTR [rsp+0x148],rax
  20cf09:	00 
  20cf0a:	48 89 4c 24 50       	mov    QWORD PTR [rsp+0x50],rcx
    while (this_unit_offset < debug_info_end) {
  20cf0f:	48 85 c9             	test   rcx,rcx
  20cf12:	0f 84 cc 0f 00 00    	je     20dee4 <openSelfDebugInfo+0x24b4>
  20cf18:	48 8d 83 88 00 00 00 	lea    rax,[rbx+0x88]
  20cf1f:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  20cf24:	48 8d 83 a8 00 00 00 	lea    rax,[rbx+0xa8]
  20cf2b:	48 89 84 24 78 01 00 	mov    QWORD PTR [rsp+0x178],rax
  20cf32:	00 
  20cf33:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  20cf38:	48 01 44 24 50       	add    QWORD PTR [rsp+0x50],rax
  20cf3d:	66 c7 84 24 9e 00 00 	mov    WORD PTR [rsp+0x9e],0x1e
  20cf44:	00 1e 00 
  20cf47:	c4 e2 7d 19 05 d8 3c 	vbroadcastsd ymm0,QWORD PTR [rip+0xffffffffffff3cd8]        # 200c28 <__unnamed_441+0x88>
  20cf4e:	ff ff 
  20cf50:	c5 fc 11 84 24 80 04 	vmovups YMMWORD PTR [rsp+0x480],ymm0
  20cf57:	00 00 
  20cf59:	c4 e2 7d 59 05 1e 3d 	vpbroadcastq ymm0,QWORD PTR [rip+0xffffffffffff3d1e]        # 200c80 <app_mask+0x48>
  20cf60:	ff ff 
  20cf62:	c5 fe 7f 84 24 60 04 	vmovdqu YMMWORD PTR [rsp+0x460],ymm0
  20cf69:	00 00 
  20cf6b:	66 c7 44 24 04 02 00 	mov    WORD PTR [rsp+0x4],0x2
  20cf72:	31 c0                	xor    eax,eax
  20cf74:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  20cf7b:	00 
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  20cf7c:	48 83 7c 24 38 00    	cmp    QWORD PTR [rsp+0x38],0x0
  20cf82:	0f 88 08 14 00 00    	js     20e390 <openSelfDebugInfo+0x2960>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20cf88:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
    return asm volatile ("syscall"
  20cf8b:	b8 08 00 00 00       	mov    eax,0x8
  20cf90:	31 d2                	xor    edx,edx
  20cf92:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  20cf97:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20cf99:	48 89 c1             	mov    rcx,rax
  20cf9c:	48 f7 d9             	neg    rcx
  20cf9f:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20cfa5:	b8 00 00 00 00       	mov    eax,0x0
  20cfaa:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  20cfae:	48 85 c9             	test   rcx,rcx
  20cfb1:	0f 85 01 14 00 00    	jne    20e3b8 <openSelfDebugInfo+0x2988>
            try self.readNoEof(bytes[0..]);
  20cfb7:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20cfbc:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20cfc1:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20cfc8:	00 00 
            return self.readFn(self, buffer);
  20cfca:	4c 89 ef             	mov    rdi,r13
  20cfcd:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  20cfd4:	00 
  20cfd5:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20cfda:	c5 f8 77             	vzeroupper 
  20cfdd:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  20cfe4:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20cfeb:	00 
  20cfec:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20cfee:	66 85 c9             	test   cx,cx
  20cff1:	0f 85 51 13 00 00    	jne    20e348 <openSelfDebugInfo+0x2918>
  20cff7:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20cffe:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20cfff:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20d004:	0f 82 3a 13 00 00    	jb     20e344 <openSelfDebugInfo+0x2914>
  20d00a:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20d00f:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20d014:	48 c1 e1 08          	shl    rcx,0x8
  20d018:	48 09 c1             	or     rcx,rax
  20d01b:	0f b6 44 24 0a       	movzx  eax,BYTE PTR [rsp+0xa]
  20d020:	48 c1 e0 10          	shl    rax,0x10
  20d024:	48 09 c8             	or     rax,rcx
  20d027:	0f b6 4c 24 0b       	movzx  ecx,BYTE PTR [rsp+0xb]
  20d02c:	48 c1 e1 18          	shl    rcx,0x18
  20d030:	48 09 c1             	or     rcx,rax
  20d033:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
    is_64.* = (first_32_bits == 0xffffffff);
  20d038:	83 f9 ff             	cmp    ecx,0xffffffff
    if (is_64.*) {
  20d03b:	74 20                	je     20d05d <openSelfDebugInfo+0x162d>
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  20d03d:	83 7c 24 48 ef       	cmp    DWORD PTR [rsp+0x48],0xffffffef
  20d042:	0f 87 5c 13 00 00    	ja     20e3a4 <openSelfDebugInfo+0x2974>
  20d048:	c7 44 24 40 00 00 00 	mov    DWORD PTR [rsp+0x40],0x0
  20d04f:	00 
        if (unit_length == 0) return;
  20d050:	48 83 7c 24 48 00    	cmp    QWORD PTR [rsp+0x48],0x0
  20d056:	75 77                	jne    20d0cf <openSelfDebugInfo+0x169f>
  20d058:	e9 87 0e 00 00       	jmp    20dee4 <openSelfDebugInfo+0x24b4>
            try self.readNoEof(bytes[0..]);
  20d05d:	48 8d 84 24 b8 02 00 	lea    rax,[rsp+0x2b8]
  20d064:	00 
  20d065:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d06a:	48 c7 44 24 68 08 00 	mov    QWORD PTR [rsp+0x68],0x8
  20d071:	00 00 
            return self.readFn(self, buffer);
  20d073:	4c 89 ef             	mov    rdi,r13
  20d076:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  20d07d:	00 
  20d07e:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20d083:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  20d08a:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d091:	00 
  20d092:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20d094:	66 85 c9             	test   cx,cx
  20d097:	0f 85 ab 12 00 00    	jne    20e348 <openSelfDebugInfo+0x2918>
  20d09d:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20d0a4:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20d0a5:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20d0aa:	0f 82 94 12 00 00    	jb     20e344 <openSelfDebugInfo+0x2914>
  20d0b0:	48 8b 84 24 b8 02 00 	mov    rax,QWORD PTR [rsp+0x2b8]
  20d0b7:	00 
  20d0b8:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  20d0bd:	b0 01                	mov    al,0x1
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  20d0bf:	89 44 24 40          	mov    DWORD PTR [rsp+0x40],eax
        if (unit_length == 0) return;
  20d0c3:	48 83 7c 24 48 00    	cmp    QWORD PTR [rsp+0x48],0x0
  20d0c9:	0f 84 15 0e 00 00    	je     20dee4 <openSelfDebugInfo+0x24b4>
        const version = try in_stream.readInt(st.elf.endian, u16);
  20d0cf:	40 8a 6b 12          	mov    bpl,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  20d0d3:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20d0d8:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d0dd:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20d0e4:	00 00 
            return self.readFn(self, buffer);
  20d0e6:	4c 89 ef             	mov    rdi,r13
  20d0e9:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  20d0f0:	00 
  20d0f1:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20d0f6:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  20d0fd:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d104:	00 
  20d105:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20d107:	66 85 c9             	test   cx,cx
  20d10a:	0f 85 38 12 00 00    	jne    20e348 <openSelfDebugInfo+0x2918>
  20d110:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20d117:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20d118:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20d11d:	0f 82 21 12 00 00    	jb     20e344 <openSelfDebugInfo+0x2914>
  20d123:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
  20d128:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  20d12d:	89 c1                	mov    ecx,eax
  20d12f:	c1 e1 08             	shl    ecx,0x8
  20d132:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20d134:	c1 e2 08             	shl    edx,0x8
  20d137:	09 c2                	or     edx,eax
    switch (endian) {
  20d139:	40 f6 c5 01          	test   bpl,0x1
  20d13d:	66 0f 45 d1          	cmovne dx,cx
  20d141:	48 89 94 24 60 02 00 	mov    QWORD PTR [rsp+0x260],rdx
  20d148:	00 
        if (version < 2 or version > 5) return error.InvalidDebugInfo;
  20d149:	8d 42 fe             	lea    eax,[rdx-0x2]
  20d14c:	0f b7 c0             	movzx  eax,ax
  20d14f:	83 f8 03             	cmp    eax,0x3
  20d152:	0f 87 4c 12 00 00    	ja     20e3a4 <openSelfDebugInfo+0x2974>
  20d158:	40 8a 6b 12          	mov    bpl,BYTE PTR [rbx+0x12]
        const debug_abbrev_offset = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  20d15c:	80 7c 24 40 00       	cmp    BYTE PTR [rsp+0x40],0x0
  20d161:	74 37                	je     20d19a <openSelfDebugInfo+0x176a>
  20d163:	40 0f b6 d5          	movzx  edx,bpl
  20d167:	48 8d bc 24 38 03 00 	lea    rdi,[rsp+0x338]
  20d16e:	00 
  20d16f:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  20d176:	00 
  20d177:	e8 a4 31 00 00       	call   210320 <InStream(ReadError)_readInt.33>
  20d17c:	0f b7 bc 24 38 03 00 	movzx  edi,WORD PTR [rsp+0x338]
  20d183:	00 
  20d184:	66 85 ff             	test   di,di
  20d187:	0f 85 f8 0f 00 00    	jne    20e185 <openSelfDebugInfo+0x2755>
  20d18d:	48 8b 84 24 40 03 00 	mov    rax,QWORD PTR [rsp+0x340]
  20d194:	00 
  20d195:	e9 96 00 00 00       	jmp    20d230 <openSelfDebugInfo+0x1800>
            try self.readNoEof(bytes[0..]);
  20d19a:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20d19f:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d1a4:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20d1ab:	00 00 
            return self.readFn(self, buffer);
  20d1ad:	4c 89 ef             	mov    rdi,r13
  20d1b0:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  20d1b7:	00 
  20d1b8:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20d1bd:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  20d1c4:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d1cb:	00 
  20d1cc:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20d1ce:	66 85 c9             	test   cx,cx
  20d1d1:	0f 85 71 11 00 00    	jne    20e348 <openSelfDebugInfo+0x2918>
  20d1d7:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20d1de:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20d1df:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20d1e4:	0f 82 5a 11 00 00    	jb     20e344 <openSelfDebugInfo+0x2914>
  20d1ea:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20d1ef:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20d1f4:	40 f6 c5 01          	test   bpl,0x1
  20d1f8:	74 1b                	je     20d215 <openSelfDebugInfo+0x17e5>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20d1fa:	c1 e1 08             	shl    ecx,0x8
  20d1fd:	09 c1                	or     ecx,eax
  20d1ff:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20d204:	c1 e2 10             	shl    edx,0x10
  20d207:	09 ca                	or     edx,ecx
  20d209:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20d20e:	c1 e0 18             	shl    eax,0x18
  20d211:	09 d0                	or     eax,edx
  20d213:	eb 19                	jmp    20d22e <openSelfDebugInfo+0x17fe>
                result = (result << 8) | b;
  20d215:	c1 e0 08             	shl    eax,0x8
  20d218:	09 c8                	or     eax,ecx
  20d21a:	c1 e0 08             	shl    eax,0x8
  20d21d:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20d222:	09 c1                	or     ecx,eax
  20d224:	c1 e1 08             	shl    ecx,0x8
  20d227:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20d22c:	09 c8                	or     eax,ecx
  20d22e:	89 c0                	mov    eax,eax
  20d230:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
            try self.readNoEof(result[0..]);
  20d235:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20d23a:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d23f:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  20d246:	00 00 
            return self.readFn(self, buffer);
  20d248:	4c 89 ef             	mov    rdi,r13
  20d24b:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  20d252:	00 
  20d253:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20d258:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  20d25f:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d266:	00 
  20d267:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20d269:	66 85 c9             	test   cx,cx
  20d26c:	0f 85 d6 10 00 00    	jne    20e348 <openSelfDebugInfo+0x2918>
  20d272:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20d279:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20d27a:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20d27f:	0f 82 bf 10 00 00    	jb     20e344 <openSelfDebugInfo+0x2914>
        if (address_size != @sizeOf(usize)) return error.InvalidDebugInfo;
  20d285:	80 7c 24 07 08       	cmp    BYTE PTR [rsp+0x7],0x8
  20d28a:	66 bf 25 00          	mov    di,0x25
  20d28e:	0f 85 f1 0e 00 00    	jne    20e185 <openSelfDebugInfo+0x2755>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20d294:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20d297:	b8 08 00 00 00       	mov    eax,0x8
  20d29c:	be 00 00 00 00       	mov    esi,0x0
  20d2a1:	ba 01 00 00 00       	mov    edx,0x1
  20d2a6:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20d2a8:	48 89 c2             	mov    rdx,rax
  20d2ab:	48 f7 da             	neg    rdx
  20d2ae:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20d2b3:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20d2b9:	b9 00 00 00 00       	mov    ecx,0x0
  20d2be:	48 0f 46 d1          	cmovbe rdx,rcx
    pub fn getPos(self: *File) !usize {
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const result = posix.lseek(self.handle, 0, posix.SEEK_CUR);
                const err = posix.getErrno(result);
                if (err > 0) {
  20d2c2:	48 85 d2             	test   rdx,rdx
  20d2c5:	0f 85 16 11 00 00    	jne    20e3e1 <openSelfDebugInfo+0x29b1>
            return self.items[0..self.len];
  20d2cb:	48 8b 83 98 00 00 00 	mov    rax,QWORD PTR [rbx+0x98]
    for (st.abbrev_table_list.toSlice()) |*header| {
  20d2d2:	48 85 c0             	test   rax,rax
  20d2d5:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  20d2da:	74 24                	je     20d300 <openSelfDebugInfo+0x18d0>
  20d2dc:	48 8b b3 88 00 00 00 	mov    rsi,QWORD PTR [rbx+0x88]
        if (header.offset == abbrev_offset) {
  20d2e3:	48 83 c6 08          	add    rsi,0x8
  20d2e7:	31 c9                	xor    ecx,ecx
  20d2e9:	48 39 56 f8          	cmp    QWORD PTR [rsi-0x8],rdx
  20d2ed:	0f 84 48 01 00 00    	je     20d43b <openSelfDebugInfo+0x1a0b>
    for (st.abbrev_table_list.toSlice()) |*header| {
  20d2f3:	48 83 c1 01          	add    rcx,0x1
  20d2f7:	48 83 c6 28          	add    rsi,0x28
  20d2fb:	48 39 c1             	cmp    rcx,rax
  20d2fe:	72 e9                	jb     20d2e9 <openSelfDebugInfo+0x18b9>
    try st.self_exe_file.seekTo(st.debug_abbrev.offset + abbrev_offset);
  20d300:	48 8b 43 68          	mov    rax,QWORD PTR [rbx+0x68]
  20d304:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  20d308:	48 01 d6             	add    rsi,rdx
  20d30b:	0f 88 7f 10 00 00    	js     20e390 <openSelfDebugInfo+0x2960>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20d311:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20d314:	b8 08 00 00 00       	mov    eax,0x8
  20d319:	31 d2                	xor    edx,edx
  20d31b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20d31d:	48 89 c1             	mov    rcx,rax
  20d320:	48 f7 d9             	neg    rcx
  20d323:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20d329:	b8 00 00 00 00       	mov    eax,0x0
  20d32e:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  20d332:	48 85 c9             	test   rcx,rcx
  20d335:	0f 85 2d 11 00 00    	jne    20e468 <openSelfDebugInfo+0x2a38>
        .table = try parseAbbrevTable(st),
  20d33b:	4c 89 ef             	mov    rdi,r13
  20d33e:	48 89 de             	mov    rsi,rbx
  20d341:	e8 4a 32 00 00       	call   210590 <parseAbbrevTable>
  20d346:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d34d:	00 
  20d34e:	89 c8                	mov    eax,ecx
  20d350:	66 85 c9             	test   cx,cx
  20d353:	0f 85 ef 0f 00 00    	jne    20e348 <openSelfDebugInfo+0x2918>
    try st.abbrev_table_list.append(AbbrevTableHeader{
  20d359:	48 8d 84 24 a8 00 00 	lea    rax,[rsp+0xa8]
  20d360:	00 
  20d361:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  20d365:	c5 fe 7f 44 24 60    	vmovdqu YMMWORD PTR [rsp+0x60],ymm0
            }
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
        }

        pub fn addOne(self: *Self) !*T {
            const new_length = self.len + 1;
  20d36b:	48 8b ab 98 00 00 00 	mov    rbp,QWORD PTR [rbx+0x98]
            var better_capacity = self.items.len;
  20d372:	48 8b 8b 90 00 00 00 	mov    rcx,QWORD PTR [rbx+0x90]
            if (better_capacity >= new_capacity) return;
  20d379:	48 39 e9             	cmp    rcx,rbp
  20d37c:	76 05                	jbe    20d383 <openSelfDebugInfo+0x1953>
            try self.ensureCapacity(new_length);
            const result = &self.items[self.len];
  20d37e:	48 89 e8             	mov    rax,rbp
  20d381:	eb 5d                	jmp    20d3e0 <openSelfDebugInfo+0x19b0>
                better_capacity += better_capacity / 2 + 8;
  20d383:	48 89 c8             	mov    rax,rcx
  20d386:	48 d1 e8             	shr    rax,1
  20d389:	48 01 c1             	add    rcx,rax
  20d38c:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20d390:	48 39 e9             	cmp    rcx,rbp
  20d393:	76 ee                	jbe    20d383 <openSelfDebugInfo+0x1953>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20d395:	48 8b b3 a0 00 00 00 	mov    rsi,QWORD PTR [rbx+0xa0]
  20d39c:	48 8d bc 24 b8 02 00 	lea    rdi,[rsp+0x2b8]
  20d3a3:	00 
  20d3a4:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
  20d3a9:	c5 f8 77             	vzeroupper 
  20d3ac:	e8 0f 3e 00 00       	call   2111c0 <Allocator_alignedRealloc.44>
  20d3b1:	0f b7 8c 24 b8 02 00 	movzx  ecx,WORD PTR [rsp+0x2b8]
  20d3b8:	00 
  20d3b9:	89 c8                	mov    eax,ecx
  20d3bb:	66 85 c9             	test   cx,cx
  20d3be:	0f 85 84 0f 00 00    	jne    20e348 <openSelfDebugInfo+0x2918>
  20d3c4:	48 8d 84 24 c0 02 00 	lea    rax,[rsp+0x2c0]
  20d3cb:	00 
  20d3cc:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20d3d0:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20d3d5:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  20d3d9:	48 8b 83 98 00 00 00 	mov    rax,QWORD PTR [rbx+0x98]
  20d3e0:	48 83 c5 01          	add    rbp,0x1
  20d3e4:	48 8b 8b 88 00 00 00 	mov    rcx,QWORD PTR [rbx+0x88]
            self.len = new_length;
  20d3eb:	48 89 ab 98 00 00 00 	mov    QWORD PTR [rbx+0x98],rbp
            new_item_ptr.* = item;
  20d3f2:	48 8d 04 80          	lea    rax,[rax+rax*4]
  20d3f6:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  20d3fb:	48 89 14 c1          	mov    QWORD PTR [rcx+rax*8],rdx
  20d3ff:	c5 fe 6f 44 24 60    	vmovdqu ymm0,YMMWORD PTR [rsp+0x60]
  20d405:	c5 fe 7f 44 c1 08    	vmovdqu YMMWORD PTR [rcx+rax*8+0x8],ymm0
    return &st.abbrev_table_list.items[st.abbrev_table_list.len - 1].table;
  20d40b:	48 8b 83 88 00 00 00 	mov    rax,QWORD PTR [rbx+0x88]
  20d412:	48 8b 8b 98 00 00 00 	mov    rcx,QWORD PTR [rbx+0x98]
  20d419:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  20d41d:	48 8d 04 c8          	lea    rax,[rax+rcx*8]
  20d421:	48 83 c0 e0          	add    rax,0xffffffffffffffe0
  20d425:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20d42a:	66 bf 23 00          	mov    di,0x23
  20d42e:	48 83 7c 24 18 00    	cmp    QWORD PTR [rsp+0x18],0x0
  20d434:	79 1a                	jns    20d450 <openSelfDebugInfo+0x1a20>
  20d436:	e9 4a 0d 00 00       	jmp    20e185 <openSelfDebugInfo+0x2755>
  20d43b:	48 89 74 24 30       	mov    QWORD PTR [rsp+0x30],rsi
  20d440:	66 bf 23 00          	mov    di,0x23
  20d444:	48 83 7c 24 18 00    	cmp    QWORD PTR [rsp+0x18],0x0
  20d44a:	0f 88 35 0d 00 00    	js     20e185 <openSelfDebugInfo+0x2755>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20d450:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20d453:	b8 08 00 00 00       	mov    eax,0x8
  20d458:	31 d2                	xor    edx,edx
  20d45a:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
  20d45f:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20d461:	48 89 c1             	mov    rcx,rax
  20d464:	48 f7 d9             	neg    rcx
  20d467:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20d46d:	b8 00 00 00 00       	mov    eax,0x0
  20d472:	48 0f 46 c8          	cmovbe rcx,rax
  20d476:	48 85 c9             	test   rcx,rcx
  20d479:	0f 85 c4 0f 00 00    	jne    20e443 <openSelfDebugInfo+0x2a13>
  20d47f:	48 8b 83 a0 00 00 00 	mov    rax,QWORD PTR [rbx+0xa0]
    var in_file_stream = io.FileInStream.init(in_file);
  20d486:	48 89 84 24 58 02 00 	mov    QWORD PTR [rsp+0x258],rax
  20d48d:	00 
  20d48e:	48 89 9c 24 50 01 00 	mov    QWORD PTR [rsp+0x150],rbx
  20d495:	00 
  20d496:	48 8d 05 c3 30 00 00 	lea    rax,[rip+0x30c3]        # 210560 <FileInStream_readFn>
  20d49d:	48 89 84 24 58 01 00 	mov    QWORD PTR [rsp+0x158],rax
  20d4a4:	00 
            try self.readNoEof(result[0..]);
  20d4a5:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20d4aa:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20d4af:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20d4b6:	00 00 
        return self.file.read(buffer);
  20d4b8:	48 8b b4 24 50 01 00 	mov    rsi,QWORD PTR [rsp+0x150]
  20d4bf:	00 
  20d4c0:	48 8d bc 24 88 01 00 	lea    rdi,[rsp+0x188]
  20d4c7:	00 
  20d4c8:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20d4cd:	c5 f8 77             	vzeroupper 
  20d4d0:	e8 7b 2f 00 00       	call   210450 <File_read>
  20d4d5:	c5 fa 6f 84 24 88 01 	vmovdqu xmm0,XMMWORD PTR [rsp+0x188]
  20d4dc:	00 00 
  20d4de:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
            return self.readFn(self, buffer);
  20d4e4:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20d4e9:	66 85 c9             	test   cx,cx
  20d4ec:	0f 85 67 0c 00 00    	jne    20e159 <openSelfDebugInfo+0x2729>
  20d4f2:	0f b6 44 24 40       	movzx  eax,BYTE PTR [rsp+0x40]
  20d4f7:	48 89 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rax
  20d4fe:	00 
  20d4ff:	48 8d 04 c5 04 00 00 	lea    rax,[rax*8+0x4]
  20d506:	00 
  20d507:	48 89 84 24 50 02 00 	mov    QWORD PTR [rsp+0x250],rax
  20d50e:	00 
  20d50f:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20d514:	31 c9                	xor    ecx,ecx
  20d516:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  20d51b:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  20d51d:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  20d522:	0f 82 2d 0c 00 00    	jb     20e155 <openSelfDebugInfo+0x2725>
            return result[0];
  20d528:	0f b6 44 24 07       	movzx  eax,BYTE PTR [rsp+0x7]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20d52d:	89 c2                	mov    edx,eax
  20d52f:	83 e2 7f             	and    edx,0x7f
  20d532:	89 ee                	mov    esi,ebp
  20d534:	83 e6 3f             	and    esi,0x3f
  20d537:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20d53c:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20d541:	48 39 d6             	cmp    rsi,rdx
  20d544:	0f 85 13 0c 00 00    	jne    20e15d <openSelfDebugInfo+0x272d>
        result |= operand;
  20d54a:	48 09 4c 24 18       	or     QWORD PTR [rsp+0x18],rcx
        if ((byte & 0b10000000) == 0) return result;
  20d54f:	84 c0                	test   al,al
  20d551:	79 44                	jns    20d597 <openSelfDebugInfo+0x1b67>
        shift += 7;
  20d553:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  20d557:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20d55c:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20d561:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20d568:	00 00 
            return self.readFn(self, buffer);
  20d56a:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20d56f:	48 8d b4 24 58 01 00 	lea    rsi,[rsp+0x158]
  20d576:	00 
  20d577:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20d57c:	ff 94 24 58 01 00 00 	call   QWORD PTR [rsp+0x158]
  20d583:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  20d588:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20d58d:	66 85 c9             	test   cx,cx
  20d590:	74 8b                	je     20d51d <openSelfDebugInfo+0x1aed>
  20d592:	e9 c2 0b 00 00       	jmp    20e159 <openSelfDebugInfo+0x2729>
            return self.items[0..self.len];
  20d597:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  20d59c:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
    for (abbrev_table.toSliceConst()) |*table_entry| {
  20d5a0:	48 85 c0             	test   rax,rax
  20d5a3:	0f 84 b1 0d 00 00    	je     20e35a <openSelfDebugInfo+0x292a>
  20d5a9:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20d5ae:	48 8b 29             	mov    rbp,QWORD PTR [rcx]
  20d5b1:	31 c9                	xor    ecx,ecx
        if (table_entry.abbrev_code == abbrev_code) return table_entry;
  20d5b3:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  20d5b8:	48 39 55 08          	cmp    QWORD PTR [rbp+0x8],rdx
  20d5bc:	74 12                	je     20d5d0 <openSelfDebugInfo+0x1ba0>
    for (abbrev_table.toSliceConst()) |*table_entry| {
  20d5be:	48 83 c1 01          	add    rcx,0x1
  20d5c2:	48 83 c5 38          	add    rbp,0x38
  20d5c6:	48 39 c1             	cmp    rcx,rax
  20d5c9:	72 e8                	jb     20d5b3 <openSelfDebugInfo+0x1b83>
  20d5cb:	e9 8a 0d 00 00       	jmp    20e35a <openSelfDebugInfo+0x292a>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  20d5d0:	48 85 ed             	test   rbp,rbp
  20d5d3:	0f 84 81 0d 00 00    	je     20e35a <openSelfDebugInfo+0x292a>
        .tag_id = table_entry.tag_id,
  20d5d9:	48 8b 45 10          	mov    rax,QWORD PTR [rbp+0x10]
        .has_children = table_entry.has_children,
  20d5dd:	8a 4d 00             	mov    cl,BYTE PTR [rbp+0x0]
  20d5e0:	48 8b b3 a0 00 00 00 	mov    rsi,QWORD PTR [rbx+0xa0]
  20d5e7:	48 8d 94 24 f7 02 00 	lea    rdx,[rsp+0x2f7]
  20d5ee:	00 
    var result = Die{
  20d5ef:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20d5f3:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
  20d5f7:	48 c7 42 10 00 00 00 	mov    QWORD PTR [rdx+0x10],0x0
  20d5fe:	00 
  20d5ff:	48 89 84 24 e0 01 00 	mov    QWORD PTR [rsp+0x1e0],rax
  20d606:	00 
  20d607:	88 8c 24 e8 01 00 00 	mov    BYTE PTR [rsp+0x1e8],cl
  20d60e:	c5 fa 6f 84 24 f0 02 	vmovdqu xmm0,XMMWORD PTR [rsp+0x2f0]
  20d615:	00 00 
  20d617:	c5 fa 6f 8c 24 ff 02 	vmovdqu xmm1,XMMWORD PTR [rsp+0x2ff]
  20d61e:	00 00 
  20d620:	48 8d 84 24 e9 01 00 	lea    rax,[rsp+0x1e9]
  20d627:	00 
  20d628:	c5 fa 7f 48 0f       	vmovdqu XMMWORD PTR [rax+0xf],xmm1
  20d62d:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  20d631:	48 89 b4 24 08 02 00 	mov    QWORD PTR [rsp+0x208],rsi
  20d638:	00 
    try result.attrs.resize(table_entry.attrs.len);
  20d639:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
            var better_capacity = self.items.len;
  20d63d:	48 8b 8c 24 f8 01 00 	mov    rcx,QWORD PTR [rsp+0x1f8]
  20d644:	00 
  20d645:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
            if (better_capacity >= new_capacity) return;
  20d64a:	48 39 c1             	cmp    rcx,rax
  20d64d:	73 5a                	jae    20d6a9 <openSelfDebugInfo+0x1c79>
                better_capacity += better_capacity / 2 + 8;
  20d64f:	48 89 c8             	mov    rax,rcx
  20d652:	48 d1 e8             	shr    rax,1
  20d655:	48 01 c1             	add    rcx,rax
  20d658:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20d65c:	48 3b 4c 24 18       	cmp    rcx,QWORD PTR [rsp+0x18]
  20d661:	72 ec                	jb     20d64f <openSelfDebugInfo+0x1c1f>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20d663:	48 8d bc 24 88 01 00 	lea    rdi,[rsp+0x188]
  20d66a:	00 
  20d66b:	48 8d 94 24 f0 01 00 	lea    rdx,[rsp+0x1f0]
  20d672:	00 
  20d673:	e8 d8 68 00 00       	call   213f50 <Allocator_alignedRealloc.47>
  20d678:	0f b7 8c 24 88 01 00 	movzx  ecx,WORD PTR [rsp+0x188]
  20d67f:	00 
  20d680:	89 c8                	mov    eax,ecx
  20d682:	66 85 c9             	test   cx,cx
  20d685:	0f 85 87 0e 00 00    	jne    20e512 <openSelfDebugInfo+0x2ae2>
  20d68b:	48 8d 84 24 90 01 00 	lea    rax,[rsp+0x190]
  20d692:	00 
  20d693:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20d697:	48 8d 84 24 f0 01 00 	lea    rax,[rsp+0x1f0]
  20d69e:	00 
  20d69f:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            return self.items[0..self.len];
  20d6a3:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  20d6a7:	eb 05                	jmp    20d6ae <openSelfDebugInfo+0x1c7e>
  20d6a9:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20d6ae:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  20d6b5:	00 
            self.len = new_len;
  20d6b6:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20d6bb:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  20d6c2:	00 
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  20d6c3:	48 83 bc 24 68 01 00 	cmp    QWORD PTR [rsp+0x168],0x0
  20d6ca:	00 00 
  20d6cc:	0f 84 c9 00 00 00    	je     20d79b <openSelfDebugInfo+0x1d6b>
  20d6d2:	48 8b 45 18          	mov    rax,QWORD PTR [rbp+0x18]
  20d6d6:	48 8b ac 24 f0 01 00 	mov    rbp,QWORD PTR [rsp+0x1f0]
  20d6dd:	00 
  20d6de:	48 83 c0 08          	add    rax,0x8
  20d6e2:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20d6e7:	48 83 c5 08          	add    rbp,0x8
  20d6eb:	31 c0                	xor    eax,eax
  20d6ed:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20d6f2:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20d6f7:	48 8b 48 f8          	mov    rcx,QWORD PTR [rax-0x8]
  20d6fb:	48 89 8c 24 60 01 00 	mov    QWORD PTR [rsp+0x160],rcx
  20d702:	00 
  20d703:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20d706:	48 8b b3 a0 00 00 00 	mov    rsi,QWORD PTR [rbx+0xa0]
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  20d70d:	48 8d bc 24 48 03 00 	lea    rdi,[rsp+0x348]
  20d714:	00 
  20d715:	48 8d 94 24 58 01 00 	lea    rdx,[rsp+0x158]
  20d71c:	00 
  20d71d:	4c 8b 84 24 38 01 00 	mov    r8,QWORD PTR [rsp+0x138]
  20d724:	00 
  20d725:	c5 f8 77             	vzeroupper 
  20d728:	e8 23 3d 00 00       	call   211450 <parseFormValue>
  20d72d:	0f b7 8c 24 48 03 00 	movzx  ecx,WORD PTR [rsp+0x348]
  20d734:	00 
  20d735:	89 c8                	mov    eax,ecx
  20d737:	66 85 c9             	test   cx,cx
  20d73a:	0f 85 cd 0c 00 00    	jne    20e40d <openSelfDebugInfo+0x29dd>
        result.attrs.items[i] = Die.Attr{
  20d740:	48 8d 84 24 50 03 00 	lea    rax,[rsp+0x350]
  20d747:	00 
  20d748:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  20d74c:	c5 fc 11 84 24 10 03 	vmovups YMMWORD PTR [rsp+0x310],ymm0
  20d753:	00 00 
  20d755:	48 8b 84 24 60 01 00 	mov    rax,QWORD PTR [rsp+0x160]
  20d75c:	00 
  20d75d:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  20d761:	c5 fe 6f 84 24 10 03 	vmovdqu ymm0,YMMWORD PTR [rsp+0x310]
  20d768:	00 00 
  20d76a:	c5 fe 7f 45 00       	vmovdqu YMMWORD PTR [rbp+0x0],ymm0
  20d76f:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  20d774:	48 89 c1             	mov    rcx,rax
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  20d777:	48 83 c1 01          	add    rcx,0x1
  20d77b:	48 83 44 24 18 10    	add    QWORD PTR [rsp+0x18],0x10
  20d781:	48 83 c5 28          	add    rbp,0x28
  20d785:	48 89 c8             	mov    rax,rcx
  20d788:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20d78d:	48 3b 8c 24 68 01 00 	cmp    rcx,QWORD PTR [rsp+0x168]
  20d794:	00 
  20d795:	0f 82 57 ff ff ff    	jb     20d6f2 <openSelfDebugInfo+0x1cc2>
    return result;
  20d79b:	c5 fc 10 84 24 e0 01 	vmovups ymm0,YMMWORD PTR [rsp+0x1e0]
  20d7a2:	00 00 
  20d7a4:	c5 fc 10 8c 24 f0 01 	vmovups ymm1,YMMWORD PTR [rsp+0x1f0]
  20d7ab:	00 00 
  20d7ad:	48 8d 84 24 2e 04 00 	lea    rax,[rsp+0x42e]
  20d7b4:	00 
  20d7b5:	c5 fc 11 48 10       	vmovups YMMWORD PTR [rax+0x10],ymm1
  20d7ba:	c5 fc 11 00          	vmovups YMMWORD PTR [rax],ymm0
  20d7be:	c5 fc 10 84 24 28 04 	vmovups ymm0,YMMWORD PTR [rsp+0x428]
  20d7c5:	00 00 
  20d7c7:	c5 fc 10 8c 24 3e 04 	vmovups ymm1,YMMWORD PTR [rsp+0x43e]
  20d7ce:	00 00 
  20d7d0:	c5 fc 11 84 24 10 02 	vmovups YMMWORD PTR [rsp+0x210],ymm0
  20d7d7:	00 00 
  20d7d9:	c5 fc 11 8c 24 26 02 	vmovups YMMWORD PTR [rsp+0x226],ymm1
  20d7e0:	00 00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20d7e2:	ba 30 00 00 00       	mov    edx,0x30
  20d7e7:	b9 08 00 00 00       	mov    ecx,0x8
  20d7ec:	4c 89 ef             	mov    rdi,r13
  20d7ef:	48 8b b4 24 58 02 00 	mov    rsi,QWORD PTR [rsp+0x258]
  20d7f6:	00 
  20d7f7:	c5 f8 77             	vzeroupper 
  20d7fa:	ff 16                	call   QWORD PTR [rsi]
  20d7fc:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d803:	00 
  20d804:	89 c8                	mov    eax,ecx
  20d806:	66 85 c9             	test   cx,cx
  20d809:	0f 85 39 0b 00 00    	jne    20e348 <openSelfDebugInfo+0x2918>
        assert(byte_slice.len == byte_count);
  20d80f:	48 83 bc 24 b0 00 00 	cmp    QWORD PTR [rsp+0xb0],0x30
  20d816:	00 30 
    if (!ok) {
  20d818:	0f 85 e4 18 00 00    	jne    20f102 <openSelfDebugInfo+0x36d2>
  20d81e:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  20d825:	00 
  20d826:	48 8d 84 24 16 02 00 	lea    rax,[rsp+0x216]
  20d82d:	00 
        ptr.* = init;
  20d82e:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  20d832:	c5 fe 6f 48 10       	vmovdqu ymm1,YMMWORD PTR [rax+0x10]
  20d837:	c5 fe 7f 01          	vmovdqu YMMWORD PTR [rcx],ymm0
  20d83b:	c5 fe 7f 49 10       	vmovdqu YMMWORD PTR [rcx+0x10],ymm1
  20d840:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
        if (compile_unit_die.tag_id != DW.TAG_compile_unit) return error.InvalidDebugInfo;
  20d845:	48 83 39 11          	cmp    QWORD PTR [rcx],0x11
  20d849:	0f 85 55 0b 00 00    	jne    20e3a4 <openSelfDebugInfo+0x2974>
  20d84f:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20d854:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  20d858:	48 85 c9             	test   rcx,rcx
  20d85b:	74 25                	je     20d882 <openSelfDebugInfo+0x1e52>
  20d85d:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20d862:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  20d866:	48 89 d0             	mov    rax,rdx
  20d869:	31 f6                	xor    esi,esi
            if (attr.id == id) return &attr.value;
  20d86b:	48 83 38 11          	cmp    QWORD PTR [rax],0x11
  20d86f:	0f 84 52 01 00 00    	je     20d9c7 <openSelfDebugInfo+0x1f97>
        for (self.attrs.toSliceConst()) |*attr| {
  20d875:	48 83 c6 01          	add    rsi,0x1
  20d879:	48 83 c0 28          	add    rax,0x28
  20d87d:	48 39 ce             	cmp    rsi,rcx
  20d880:	72 e9                	jb     20d86b <openSelfDebugInfo+0x1e3b>
        const pc_range = x: {
  20d882:	48 8d 05 3f 8a ff ff 	lea    rax,[rip+0xffffffffffff8a3f]        # 2062c8 <__unnamed_56>
  20d889:	48 8b 48 10          	mov    rcx,QWORD PTR [rax+0x10]
  20d88d:	48 89 8c 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],rcx
  20d894:	00 
  20d895:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20d899:	c5 f9 7f 84 24 a0 01 	vmovdqa XMMWORD PTR [rsp+0x1a0],xmm0
  20d8a0:	00 00 
            const new_length = self.len + 1;
  20d8a2:	48 8b ab b8 00 00 00 	mov    rbp,QWORD PTR [rbx+0xb8]
            var better_capacity = self.items.len;
  20d8a9:	48 8b 8b b0 00 00 00 	mov    rcx,QWORD PTR [rbx+0xb0]
            if (better_capacity >= new_capacity) return;
  20d8b0:	48 39 e9             	cmp    rcx,rbp
  20d8b3:	76 05                	jbe    20d8ba <openSelfDebugInfo+0x1e8a>
            const result = &self.items[self.len];
  20d8b5:	48 89 e8             	mov    rax,rbp
  20d8b8:	eb 5e                	jmp    20d918 <openSelfDebugInfo+0x1ee8>
                better_capacity += better_capacity / 2 + 8;
  20d8ba:	48 89 c8             	mov    rax,rcx
  20d8bd:	48 d1 e8             	shr    rax,1
  20d8c0:	48 01 c1             	add    rcx,rax
  20d8c3:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20d8c7:	48 39 e9             	cmp    rcx,rbp
  20d8ca:	76 ee                	jbe    20d8ba <openSelfDebugInfo+0x1e8a>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20d8cc:	48 8b b3 c0 00 00 00 	mov    rsi,QWORD PTR [rbx+0xc0]
  20d8d3:	4c 89 ef             	mov    rdi,r13
  20d8d6:	48 8b 94 24 78 01 00 	mov    rdx,QWORD PTR [rsp+0x178]
  20d8dd:	00 
  20d8de:	c5 f8 77             	vzeroupper 
  20d8e1:	e8 fa 6b 00 00       	call   2144e0 <Allocator_alignedRealloc.54>
  20d8e6:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d8ed:	00 
  20d8ee:	89 c8                	mov    eax,ecx
  20d8f0:	66 85 c9             	test   cx,cx
  20d8f3:	0f 85 4f 0a 00 00    	jne    20e348 <openSelfDebugInfo+0x2918>
  20d8f9:	48 8d 84 24 a8 00 00 	lea    rax,[rsp+0xa8]
  20d900:	00 
  20d901:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20d905:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  20d90c:	00 
  20d90d:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  20d911:	48 8b 83 b8 00 00 00 	mov    rax,QWORD PTR [rbx+0xb8]
  20d918:	48 83 c5 01          	add    rbp,0x1
  20d91c:	48 8b 8b a8 00 00 00 	mov    rcx,QWORD PTR [rbx+0xa8]
  20d923:	48 8d 04 40          	lea    rax,[rax+rax*2]
  20d927:	48 c1 e0 04          	shl    rax,0x4
            self.len = new_length;
  20d92b:	48 89 ab b8 00 00 00 	mov    QWORD PTR [rbx+0xb8],rbp
            new_item_ptr.* = item;
  20d932:	48 8b 94 24 60 02 00 	mov    rdx,QWORD PTR [rsp+0x260]
  20d939:	00 
  20d93a:	66 89 14 01          	mov    WORD PTR [rcx+rax*1],dx
  20d93e:	8b 54 24 40          	mov    edx,DWORD PTR [rsp+0x40]
  20d942:	88 54 01 02          	mov    BYTE PTR [rcx+rax*1+0x2],dl
  20d946:	8a 94 24 77 01 00 00 	mov    dl,BYTE PTR [rsp+0x177]
  20d94d:	88 54 01 07          	mov    BYTE PTR [rcx+rax*1+0x7],dl
  20d951:	8b 94 24 73 01 00 00 	mov    edx,DWORD PTR [rsp+0x173]
  20d958:	89 54 01 03          	mov    DWORD PTR [rcx+rax*1+0x3],edx
  20d95c:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  20d961:	48 89 54 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],rdx
  20d966:	48 8b 94 24 80 01 00 	mov    rdx,QWORD PTR [rsp+0x180]
  20d96d:	00 
  20d96e:	48 89 d6             	mov    rsi,rdx
  20d971:	48 89 74 01 10       	mov    QWORD PTR [rcx+rax*1+0x10],rsi
  20d976:	48 8b 94 24 b0 01 00 	mov    rdx,QWORD PTR [rsp+0x1b0]
  20d97d:	00 
  20d97e:	48 89 54 01 28       	mov    QWORD PTR [rcx+rax*1+0x28],rdx
  20d983:	c5 f9 6f 84 24 a0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1a0]
  20d98a:	00 00 
  20d98c:	c5 fa 7f 44 01 18    	vmovdqu XMMWORD PTR [rcx+rax*1+0x18],xmm0
  20d992:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  20d997:	48 03 44 24 38       	add    rax,QWORD PTR [rsp+0x38]
        this_unit_offset += next_offset;
  20d99c:	48 03 84 24 50 02 00 	add    rax,QWORD PTR [rsp+0x250]
  20d9a3:	00 
        cu_index += 1;
  20d9a4:	48 83 c6 01          	add    rsi,0x1
  20d9a8:	48 89 b4 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rsi
  20d9af:	00 
  20d9b0:	31 ff                	xor    edi,edi
  20d9b2:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
    while (this_unit_offset < debug_info_end) {
  20d9b7:	48 3b 44 24 50       	cmp    rax,QWORD PTR [rsp+0x50]
  20d9bc:	0f 82 ba f5 ff ff    	jb     20cf7c <openSelfDebugInfo+0x154c>
  20d9c2:	e9 be 07 00 00       	jmp    20e185 <openSelfDebugInfo+0x2755>
        return switch (form_value.*) {
  20d9c7:	40 8a 78 20          	mov    dil,BYTE PTR [rax+0x20]
  20d9cb:	48 8d 35 7e 28 ff ff 	lea    rsi,[rip+0xffffffffffff287e]        # 200250 <__unnamed_57>
  20d9d2:	40 84 ff             	test   dil,dil
  20d9d5:	75 19                	jne    20d9f0 <openSelfDebugInfo+0x1fc0>
            FormValue.Address => |value| value,
  20d9d7:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  20d9db:	66 c7 84 24 a0 00 00 	mov    WORD PTR [rsp+0xa0],0x0
  20d9e2:	00 00 00 
  20d9e5:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20d9ec:	00 
  20d9ed:	4c 89 ee             	mov    rsi,r13
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  20d9f0:	0f b7 3e             	movzx  edi,WORD PTR [rsi]
        const pc_range = x: {
  20d9f3:	48 8d 05 ce 88 ff ff 	lea    rax,[rip+0xffffffffffff88ce]        # 2062c8 <__unnamed_56>
  20d9fa:	89 fd                	mov    ebp,edi
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  20d9fc:	83 ff 24             	cmp    edi,0x24
  20d9ff:	0f 84 84 fe ff ff    	je     20d889 <openSelfDebugInfo+0x1e59>
  20da05:	89 ef                	mov    edi,ebp
  20da07:	66 85 ff             	test   di,di
  20da0a:	0f 85 75 07 00 00    	jne    20e185 <openSelfDebugInfo+0x2755>
  20da10:	4c 8b 4e 08          	mov    r9,QWORD PTR [rsi+0x8]
            if (attr.id == id) return &attr.value;
  20da14:	48 83 c2 20          	add    rdx,0x20
  20da18:	31 f6                	xor    esi,esi
  20da1a:	48 83 7a e0 12       	cmp    QWORD PTR [rdx-0x20],0x12
  20da1f:	74 12                	je     20da33 <openSelfDebugInfo+0x2003>
        for (self.attrs.toSliceConst()) |*attr| {
  20da21:	48 83 c6 01          	add    rsi,0x1
  20da25:	48 83 c2 28          	add    rdx,0x28
  20da29:	48 39 ce             	cmp    rsi,rcx
  20da2c:	72 ec                	jb     20da1a <openSelfDebugInfo+0x1fea>
  20da2e:	e9 4f fe ff ff       	jmp    20d882 <openSelfDebugInfo+0x1e52>
  20da33:	8a 0a                	mov    cl,BYTE PTR [rdx]
  20da35:	80 f9 02             	cmp    cl,0x2
                    const pc_end = switch (high_pc_value.*) {
  20da38:	74 15                	je     20da4f <openSelfDebugInfo+0x201f>
  20da3a:	66 bf 25 00          	mov    di,0x25
  20da3e:	84 c9                	test   cl,cl
  20da40:	0f 85 3f 07 00 00    	jne    20e185 <openSelfDebugInfo+0x2755>
                        FormValue.Address => |value| value,
  20da46:	48 8b 7a e8          	mov    rdi,QWORD PTR [rdx-0x18]
  20da4a:	e9 33 02 00 00       	jmp    20dc82 <openSelfDebugInfo+0x2252>
                        FormValue.Const => |value| b: {
  20da4f:	48 8b 4a f0          	mov    rcx,QWORD PTR [rdx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  20da53:	48 83 f9 08          	cmp    rcx,0x8
  20da57:	0f 87 47 09 00 00    	ja     20e3a4 <openSelfDebugInfo+0x2974>
  20da5d:	f6 42 f8 01          	test   BYTE PTR [rdx-0x8],0x1
  20da61:	66 bf 25 00          	mov    di,0x25
  20da65:	0f 85 1a 07 00 00    	jne    20e185 <openSelfDebugInfo+0x2755>
  20da6b:	48 85 c9             	test   rcx,rcx
            for (bytes) |b, index| {
  20da6e:	74 13                	je     20da83 <openSelfDebugInfo+0x2053>
  20da70:	48 8b 52 e8          	mov    rdx,QWORD PTR [rdx-0x18]
  20da74:	48 83 f9 10          	cmp    rcx,0x10
  20da78:	73 10                	jae    20da8a <openSelfDebugInfo+0x205a>
  20da7a:	31 c0                	xor    eax,eax
  20da7c:	31 ff                	xor    edi,edi
  20da7e:	e9 d3 01 00 00       	jmp    20dc56 <openSelfDebugInfo+0x2226>
  20da83:	31 ff                	xor    edi,edi
  20da85:	e9 f5 01 00 00       	jmp    20dc7f <openSelfDebugInfo+0x224f>
  20da8a:	48 89 c8             	mov    rax,rcx
  20da8d:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  20da91:	48 8d 78 f0          	lea    rdi,[rax-0x10]
  20da95:	48 89 fd             	mov    rbp,rdi
  20da98:	48 c1 ed 04          	shr    rbp,0x4
  20da9c:	44 8d 45 01          	lea    r8d,[rbp+0x1]
  20daa0:	41 83 e0 01          	and    r8d,0x1
  20daa4:	48 85 ff             	test   rdi,rdi
  20daa7:	0f 84 01 01 00 00    	je     20dbae <openSelfDebugInfo+0x217e>
  20daad:	49 8d 78 ff          	lea    rdi,[r8-0x1]
  20dab1:	48 29 ef             	sub    rdi,rbp
  20dab4:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20dab8:	31 ed                	xor    ebp,ebp
  20daba:	c5 fd 6f 25 de 31 ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff31de]        # 200ca0 <app_mask+0x68>
  20dac1:	ff 
  20dac2:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  20dac6:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20daca:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20dace:	c4 e2 7d 32 2c 2a    	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1]
  20dad4:	c4 e2 7d 32 74 2a 04 	vpmovzxbq ymm6,DWORD PTR [rdx+rbp*1+0x4]
  20dadb:	c4 e2 7d 32 7c 2a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rbp*1+0x8]
  20dae2:	c4 62 7d 32 44 2a 0c 	vpmovzxbq ymm8,DWORD PTR [rdx+rbp*1+0xc]
  20dae9:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  20daee:	c5 7e 6f a4 24 80 04 	vmovdqu ymm12,YMMWORD PTR [rsp+0x480]
  20daf5:	00 00 
  20daf7:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  20dafc:	c5 7e 6f ac 24 60 04 	vmovdqu ymm13,YMMWORD PTR [rsp+0x460]
  20db03:	00 00 
  20db05:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  20db0a:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  20db0f:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  20db14:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  20db18:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  20db1d:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  20db21:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  20db26:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  20db2a:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  20db2f:	c4 e2 7d 32 74 2a 10 	vpmovzxbq ymm6,DWORD PTR [rdx+rbp*1+0x10]
  20db36:	c4 e2 7d 32 7c 2a 14 	vpmovzxbq ymm7,DWORD PTR [rdx+rbp*1+0x14]
  20db3d:	c4 62 7d 32 44 2a 18 	vpmovzxbq ymm8,DWORD PTR [rdx+rbp*1+0x18]
  20db44:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  20db48:	c4 e2 7d 32 6c 2a 1c 	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1+0x1c]
  20db4f:	c4 62 7d 59 15 20 31 	vpbroadcastq ymm10,QWORD PTR [rip+0xffffffffffff3120]        # 200c78 <app_mask+0x40>
  20db56:	ff ff 
  20db58:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  20db5d:	c4 62 7d 59 1d 52 30 	vpbroadcastq ymm11,QWORD PTR [rip+0xffffffffffff3052]        # 200bb8 <__unnamed_441+0x18>
  20db64:	ff ff 
  20db66:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  20db6b:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  20db70:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  20db75:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  20db7a:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  20db7e:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  20db83:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  20db87:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  20db8c:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  20db90:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  20db95:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  20db99:	48 83 c5 20          	add    rbp,0x20
  20db9d:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  20dba2:	48 83 c7 02          	add    rdi,0x2
  20dba6:	0f 85 22 ff ff ff    	jne    20dace <openSelfDebugInfo+0x209e>
  20dbac:	eb 1a                	jmp    20dbc8 <openSelfDebugInfo+0x2198>
  20dbae:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20dbb2:	31 ed                	xor    ebp,ebp
  20dbb4:	c5 fd 6f 25 e4 30 ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff30e4]        # 200ca0 <app_mask+0x68>
  20dbbb:	ff 
  20dbbc:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  20dbc0:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20dbc4:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  20dbc8:	4d 85 c0             	test   r8,r8
  20dbcb:	74 60                	je     20dc2d <openSelfDebugInfo+0x21fd>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20dbcd:	c4 e2 7d 32 6c 2a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1+0xc]
  20dbd4:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  20dbd9:	c5 dd d4 b4 24 80 04 	vpaddq ymm6,ymm4,YMMWORD PTR [rsp+0x480]
  20dbe0:	00 00 
  20dbe2:	c5 7e 6f 84 24 60 04 	vmovdqu ymm8,YMMWORD PTR [rsp+0x460]
  20dbe9:	00 00 
  20dbeb:	c4 c1 4d db f0       	vpand  ymm6,ymm6,ymm8
  20dbf0:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20dbf5:	c4 e2 7d 32 7c 2a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rbp*1+0x8]
  20dbfc:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  20dc00:	c4 c1 5d db e0       	vpand  ymm4,ymm4,ymm8
  20dc05:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  20dc0a:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  20dc0e:	c4 e2 7d 32 6c 2a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1+0x4]
  20dc15:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20dc1a:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  20dc1e:	c4 e2 7d 32 2c 2a    	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1]
  20dc24:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  20dc29:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  20dc2d:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  20dc31:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  20dc35:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20dc39:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  20dc3f:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20dc43:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  20dc48:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20dc4c:	c4 e1 f9 7e c7       	vmovq  rdi,xmm0
  20dc51:	48 39 c1             	cmp    rcx,rax
            for (bytes) |b, index| {
  20dc54:	74 29                	je     20dc7f <openSelfDebugInfo+0x224f>
  20dc56:	48 29 c1             	sub    rcx,rax
  20dc59:	48 01 c2             	add    rdx,rax
  20dc5c:	48 c1 e0 03          	shl    rax,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20dc60:	0f b6 2a             	movzx  ebp,BYTE PTR [rdx]
  20dc63:	89 c6                	mov    esi,eax
  20dc65:	40 80 e6 38          	and    sil,0x38
  20dc69:	c4 e2 c9 f7 f5       	shlx   rsi,rbp,rsi
  20dc6e:	48 09 f7             	or     rdi,rsi
            for (bytes) |b, index| {
  20dc71:	48 83 c0 08          	add    rax,0x8
  20dc75:	48 83 c2 01          	add    rdx,0x1
  20dc79:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  20dc7d:	75 e1                	jne    20dc60 <openSelfDebugInfo+0x2230>
                            break :b (low_pc + offset);
  20dc7f:	4c 01 cf             	add    rdi,r9
                    break :x PcRange{
  20dc82:	4c 89 8c 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],r9
  20dc89:	00 
  20dc8a:	48 89 bc 24 c8 01 00 	mov    QWORD PTR [rsp+0x1c8],rdi
  20dc91:	00 
  20dc92:	c6 84 24 d0 01 00 00 	mov    BYTE PTR [rsp+0x1d0],0x1
  20dc99:	01 
        const pc_range = x: {
  20dc9a:	48 8d 84 24 c0 01 00 	lea    rax,[rsp+0x1c0]
  20dca1:	00 
  20dca2:	e9 e2 fb ff ff       	jmp    20d889 <openSelfDebugInfo+0x1e59>
                list.first = node.next;
  20dca7:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20dcab:	48 89 0d 9e 33 01 00 	mov    QWORD PTR [rip+0x1339e],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20dcb2:	48 85 c9             	test   rcx,rcx
  20dcb5:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20dcb8:	48 8d 35 99 33 01 00 	lea    rsi,[rip+0x13399]        # 221058 <emfile_promise_queue+0x8>
  20dcbf:	48 0f 45 f1          	cmovne rsi,rcx
  20dcc3:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20dcc6:	48 83 05 92 33 01 00 	add    QWORD PTR [rip+0x13392],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20dccd:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20dcce:	74 1e                	je     20dcee <openSelfDebugInfo+0x22be>
  20dcd0:	48 83 3d 78 33 01 00 	cmp    QWORD PTR [rip+0x13378],0x0        # 221050 <emfile_promise_queue>
  20dcd7:	00 
  20dcd8:	0f 84 24 14 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20dcde:	48 8b 0d 73 33 01 00 	mov    rcx,QWORD PTR [rip+0x13373]        # 221058 <emfile_promise_queue+0x8>
  20dce5:	48 85 c9             	test   rcx,rcx
  20dce8:	0f 84 14 14 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20dcee:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20dcf2:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20dcf6:	48 89 c1             	mov    rcx,rax
  20dcf9:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20dcfd:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20dd03:	75 f1                	jne    20dcf6 <openSelfDebugInfo+0x22c6>
  20dd05:	a8 01                	test   al,0x1
  20dd07:	75 02                	jne    20dd0b <openSelfDebugInfo+0x22db>
  20dd09:	ff 17                	call   QWORD PTR [rdi]
  20dd0b:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
    return asm volatile ("syscall"
  20dd0e:	b8 03 00 00 00       	mov    eax,0x3
  20dd13:	0f 05                	syscall 
            switch (err) {
  20dd15:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20dd19:	74 f3                	je     20dd0e <openSelfDebugInfo+0x22de>
            const first = list.first orelse return null;
  20dd1b:	48 8b 05 2e 33 01 00 	mov    rax,QWORD PTR [rip+0x1332e]        # 221050 <emfile_promise_queue>
  20dd22:	48 85 c0             	test   rax,rax
  20dd25:	74 7a                	je     20dda1 <openSelfDebugInfo+0x2371>
            if (node.prev) |prev_node| {
  20dd27:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20dd2a:	48 85 c9             	test   rcx,rcx
  20dd2d:	74 0e                	je     20dd3d <openSelfDebugInfo+0x230d>
                prev_node.next = node.next;
  20dd2f:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20dd33:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20dd37:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20dd3b:	eb 0b                	jmp    20dd48 <openSelfDebugInfo+0x2318>
                list.first = node.next;
  20dd3d:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20dd41:	48 89 0d 08 33 01 00 	mov    QWORD PTR [rip+0x13308],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20dd48:	48 85 c9             	test   rcx,rcx
  20dd4b:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20dd4e:	48 8d 35 03 33 01 00 	lea    rsi,[rip+0x13303]        # 221058 <emfile_promise_queue+0x8>
  20dd55:	48 0f 45 f1          	cmovne rsi,rcx
  20dd59:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20dd5c:	48 83 05 fc 32 01 00 	add    QWORD PTR [rip+0x132fc],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20dd63:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20dd64:	74 1e                	je     20dd84 <openSelfDebugInfo+0x2354>
  20dd66:	48 83 3d e2 32 01 00 	cmp    QWORD PTR [rip+0x132e2],0x0        # 221050 <emfile_promise_queue>
  20dd6d:	00 
  20dd6e:	0f 84 8e 13 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20dd74:	48 8b 0d dd 32 01 00 	mov    rcx,QWORD PTR [rip+0x132dd]        # 221058 <emfile_promise_queue+0x8>
  20dd7b:	48 85 c9             	test   rcx,rcx
  20dd7e:	0f 84 7e 13 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20dd84:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20dd88:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20dd8c:	48 89 c1             	mov    rcx,rax
  20dd8f:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20dd93:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20dd99:	75 f1                	jne    20dd8c <openSelfDebugInfo+0x235c>
  20dd9b:	a8 01                	test   al,0x1
  20dd9d:	75 02                	jne    20dda1 <openSelfDebugInfo+0x2371>
  20dd9f:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20dda1:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20dda5:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20ddac:	00 
  20ddad:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20ddb4:	00 c8 00 00 00 
  20ddb9:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20ddc0:	00 
  20ddc1:	4c 89 ff             	mov    rdi,r15
  20ddc4:	ff d0                	call   rax
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  20ddc6:	0f b7 84 24 78 02 00 	movzx  eax,WORD PTR [rsp+0x278]
  20ddcd:	00 
  20ddce:	66 41 89 06          	mov    WORD PTR [r14],ax
  20ddd2:	48 8b 84 24 c6 03 00 	mov    rax,QWORD PTR [rsp+0x3c6]
  20ddd9:	00 
  20ddda:	48 8b 8c 24 cc 03 00 	mov    rcx,QWORD PTR [rsp+0x3cc]
  20dde1:	00 
  20dde2:	e9 3f e9 ff ff       	jmp    20c726 <openSelfDebugInfo+0xcf6>
                list.first = node.next;
  20dde7:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20ddeb:	48 89 0d 5e 32 01 00 	mov    QWORD PTR [rip+0x1325e],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20ddf2:	48 85 c9             	test   rcx,rcx
  20ddf5:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20ddf8:	48 8d 35 59 32 01 00 	lea    rsi,[rip+0x13259]        # 221058 <emfile_promise_queue+0x8>
  20ddff:	48 0f 45 f1          	cmovne rsi,rcx
  20de03:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20de06:	48 83 05 52 32 01 00 	add    QWORD PTR [rip+0x13252],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20de0d:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20de0e:	74 1e                	je     20de2e <openSelfDebugInfo+0x23fe>
  20de10:	48 83 3d 38 32 01 00 	cmp    QWORD PTR [rip+0x13238],0x0        # 221050 <emfile_promise_queue>
  20de17:	00 
  20de18:	0f 84 e4 12 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20de1e:	48 8b 0d 33 32 01 00 	mov    rcx,QWORD PTR [rip+0x13233]        # 221058 <emfile_promise_queue+0x8>
  20de25:	48 85 c9             	test   rcx,rcx
  20de28:	0f 84 d4 12 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20de2e:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20de32:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20de36:	48 89 c1             	mov    rcx,rax
  20de39:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20de3d:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20de43:	75 f1                	jne    20de36 <openSelfDebugInfo+0x2406>
  20de45:	a8 01                	test   al,0x1
  20de47:	75 02                	jne    20de4b <openSelfDebugInfo+0x241b>
  20de49:	ff 17                	call   QWORD PTR [rdi]
  20de4b:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20de4e:	b8 03 00 00 00       	mov    eax,0x3
  20de53:	0f 05                	syscall 
            switch (err) {
  20de55:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20de59:	74 f3                	je     20de4e <openSelfDebugInfo+0x241e>
            const first = list.first orelse return null;
  20de5b:	48 8b 05 ee 31 01 00 	mov    rax,QWORD PTR [rip+0x131ee]        # 221050 <emfile_promise_queue>
  20de62:	48 85 c0             	test   rax,rax
  20de65:	0f 84 48 ec ff ff    	je     20cab3 <openSelfDebugInfo+0x1083>
            if (node.prev) |prev_node| {
  20de6b:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20de6e:	48 85 c9             	test   rcx,rcx
  20de71:	74 0e                	je     20de81 <openSelfDebugInfo+0x2451>
                prev_node.next = node.next;
  20de73:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20de77:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20de7b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20de7f:	eb 0b                	jmp    20de8c <openSelfDebugInfo+0x245c>
                list.first = node.next;
  20de81:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20de85:	48 89 0d c4 31 01 00 	mov    QWORD PTR [rip+0x131c4],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20de8c:	48 85 c9             	test   rcx,rcx
  20de8f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20de92:	48 8d 35 bf 31 01 00 	lea    rsi,[rip+0x131bf]        # 221058 <emfile_promise_queue+0x8>
  20de99:	48 0f 45 f1          	cmovne rsi,rcx
  20de9d:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20dea0:	48 83 05 b8 31 01 00 	add    QWORD PTR [rip+0x131b8],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20dea7:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20dea8:	74 1e                	je     20dec8 <openSelfDebugInfo+0x2498>
  20deaa:	48 83 3d 9e 31 01 00 	cmp    QWORD PTR [rip+0x1319e],0x0        # 221050 <emfile_promise_queue>
  20deb1:	00 
  20deb2:	0f 84 4a 12 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20deb8:	48 8b 0d 99 31 01 00 	mov    rcx,QWORD PTR [rip+0x13199]        # 221058 <emfile_promise_queue+0x8>
  20debf:	48 85 c9             	test   rcx,rcx
  20dec2:	0f 84 3a 12 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20dec8:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20decc:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20ded0:	48 89 c1             	mov    rcx,rax
  20ded3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20ded7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20dedd:	75 f1                	jne    20ded0 <openSelfDebugInfo+0x24a0>
  20dedf:	e9 c9 eb ff ff       	jmp    20caad <openSelfDebugInfo+0x107d>
  20dee4:	31 ff                	xor    edi,edi
  20dee6:	89 fd                	mov    ebp,edi
            try scanAllCompileUnits(st);
  20dee8:	66 85 ff             	test   di,di
  20deeb:	0f 85 9f 02 00 00    	jne    20e190 <openSelfDebugInfo+0x2760>
            return st;
  20def1:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  20def7:	0f b7 84 24 de 01 00 	movzx  eax,WORD PTR [rsp+0x1de]
  20defe:	00 
  20deff:	66 41 89 46 06       	mov    WORD PTR [r14+0x6],ax
  20df04:	8b 84 24 da 01 00 00 	mov    eax,DWORD PTR [rsp+0x1da]
  20df0b:	41 89 46 02          	mov    DWORD PTR [r14+0x2],eax
  20df0f:	49 89 5e 08          	mov    QWORD PTR [r14+0x8],rbx
  20df13:	e9 16 e8 ff ff       	jmp    20c72e <openSelfDebugInfo+0xcfe>
                list.first = node.next;
  20df18:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20df1c:	48 89 0d 2d 31 01 00 	mov    QWORD PTR [rip+0x1312d],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20df23:	48 85 c9             	test   rcx,rcx
  20df26:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20df29:	48 8d 35 28 31 01 00 	lea    rsi,[rip+0x13128]        # 221058 <emfile_promise_queue+0x8>
  20df30:	48 0f 45 f1          	cmovne rsi,rcx
  20df34:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20df37:	48 83 05 21 31 01 00 	add    QWORD PTR [rip+0x13121],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20df3e:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20df3f:	74 1e                	je     20df5f <openSelfDebugInfo+0x252f>
  20df41:	48 83 3d 07 31 01 00 	cmp    QWORD PTR [rip+0x13107],0x0        # 221050 <emfile_promise_queue>
  20df48:	00 
  20df49:	0f 84 b3 11 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20df4f:	48 8b 0d 02 31 01 00 	mov    rcx,QWORD PTR [rip+0x13102]        # 221058 <emfile_promise_queue+0x8>
  20df56:	48 85 c9             	test   rcx,rcx
  20df59:	0f 84 a3 11 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20df5f:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20df63:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20df67:	48 89 c1             	mov    rcx,rax
  20df6a:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20df6e:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20df74:	75 f1                	jne    20df67 <openSelfDebugInfo+0x2537>
  20df76:	a8 01                	test   al,0x1
  20df78:	75 02                	jne    20df7c <openSelfDebugInfo+0x254c>
  20df7a:	ff 17                	call   QWORD PTR [rdi]
  20df7c:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20df7f:	b8 03 00 00 00       	mov    eax,0x3
  20df84:	0f 05                	syscall 
            switch (err) {
  20df86:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20df8a:	74 f3                	je     20df7f <openSelfDebugInfo+0x254f>
            const first = list.first orelse return null;
  20df8c:	48 8b 05 bd 30 01 00 	mov    rax,QWORD PTR [rip+0x130bd]        # 221050 <emfile_promise_queue>
  20df93:	48 85 c0             	test   rax,rax
  20df96:	74 7a                	je     20e012 <openSelfDebugInfo+0x25e2>
            if (node.prev) |prev_node| {
  20df98:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20df9b:	48 85 c9             	test   rcx,rcx
  20df9e:	74 0e                	je     20dfae <openSelfDebugInfo+0x257e>
                prev_node.next = node.next;
  20dfa0:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20dfa4:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20dfa8:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20dfac:	eb 0b                	jmp    20dfb9 <openSelfDebugInfo+0x2589>
                list.first = node.next;
  20dfae:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20dfb2:	48 89 0d 97 30 01 00 	mov    QWORD PTR [rip+0x13097],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20dfb9:	48 85 c9             	test   rcx,rcx
  20dfbc:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20dfbf:	48 8d 35 92 30 01 00 	lea    rsi,[rip+0x13092]        # 221058 <emfile_promise_queue+0x8>
  20dfc6:	48 0f 45 f1          	cmovne rsi,rcx
  20dfca:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20dfcd:	48 83 05 8b 30 01 00 	add    QWORD PTR [rip+0x1308b],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20dfd4:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20dfd5:	74 1e                	je     20dff5 <openSelfDebugInfo+0x25c5>
  20dfd7:	48 83 3d 71 30 01 00 	cmp    QWORD PTR [rip+0x13071],0x0        # 221050 <emfile_promise_queue>
  20dfde:	00 
  20dfdf:	0f 84 1d 11 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20dfe5:	48 8b 0d 6c 30 01 00 	mov    rcx,QWORD PTR [rip+0x1306c]        # 221058 <emfile_promise_queue+0x8>
  20dfec:	48 85 c9             	test   rcx,rcx
  20dfef:	0f 84 0d 11 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20dff5:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20dff9:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20dffd:	48 89 c1             	mov    rcx,rax
  20e000:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20e004:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20e00a:	75 f1                	jne    20dffd <openSelfDebugInfo+0x25cd>
  20e00c:	a8 01                	test   al,0x1
  20e00e:	75 02                	jne    20e012 <openSelfDebugInfo+0x25e2>
  20e010:	ff 17                	call   QWORD PTR [rdi]
  20e012:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20e016:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20e01d:	00 
  20e01e:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20e025:	00 c8 00 00 00 
  20e02a:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20e031:	00 
  20e032:	4c 89 ff             	mov    rdi,r15
  20e035:	ff d0                	call   rax
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  20e037:	0f b7 84 24 68 02 00 	movzx  eax,WORD PTR [rsp+0x268]
  20e03e:	00 
  20e03f:	66 41 89 06          	mov    WORD PTR [r14],ax
  20e043:	48 8b 84 24 b8 03 00 	mov    rax,QWORD PTR [rsp+0x3b8]
  20e04a:	00 
  20e04b:	48 8b 8c 24 be 03 00 	mov    rcx,QWORD PTR [rsp+0x3be]
  20e052:	00 
  20e053:	e9 ce e6 ff ff       	jmp    20c726 <openSelfDebugInfo+0xcf6>
                list.first = node.next;
  20e058:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e05c:	48 89 0d ed 2f 01 00 	mov    QWORD PTR [rip+0x12fed],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20e063:	48 85 c9             	test   rcx,rcx
  20e066:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20e069:	48 8d 35 e8 2f 01 00 	lea    rsi,[rip+0x12fe8]        # 221058 <emfile_promise_queue+0x8>
  20e070:	48 0f 45 f1          	cmovne rsi,rcx
  20e074:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20e077:	48 83 05 e1 2f 01 00 	add    QWORD PTR [rip+0x12fe1],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20e07e:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20e07f:	74 1e                	je     20e09f <openSelfDebugInfo+0x266f>
  20e081:	48 83 3d c7 2f 01 00 	cmp    QWORD PTR [rip+0x12fc7],0x0        # 221050 <emfile_promise_queue>
  20e088:	00 
  20e089:	0f 84 73 10 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20e08f:	48 8b 0d c2 2f 01 00 	mov    rcx,QWORD PTR [rip+0x12fc2]        # 221058 <emfile_promise_queue+0x8>
  20e096:	48 85 c9             	test   rcx,rcx
  20e099:	0f 84 63 10 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20e09f:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20e0a3:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20e0a7:	48 89 c1             	mov    rcx,rax
  20e0aa:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20e0ae:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20e0b4:	75 f1                	jne    20e0a7 <openSelfDebugInfo+0x2677>
  20e0b6:	a8 01                	test   al,0x1
  20e0b8:	75 02                	jne    20e0bc <openSelfDebugInfo+0x268c>
  20e0ba:	ff 17                	call   QWORD PTR [rdi]
  20e0bc:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20e0bf:	b8 03 00 00 00       	mov    eax,0x3
  20e0c4:	0f 05                	syscall 
            switch (err) {
  20e0c6:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20e0ca:	74 f3                	je     20e0bf <openSelfDebugInfo+0x268f>
            const first = list.first orelse return null;
  20e0cc:	48 8b 05 7d 2f 01 00 	mov    rax,QWORD PTR [rip+0x12f7d]        # 221050 <emfile_promise_queue>
  20e0d3:	48 85 c0             	test   rax,rax
  20e0d6:	0f 84 d7 e9 ff ff    	je     20cab3 <openSelfDebugInfo+0x1083>
            if (node.prev) |prev_node| {
  20e0dc:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20e0df:	48 85 c9             	test   rcx,rcx
  20e0e2:	74 0e                	je     20e0f2 <openSelfDebugInfo+0x26c2>
                prev_node.next = node.next;
  20e0e4:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20e0e8:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20e0ec:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e0f0:	eb 0b                	jmp    20e0fd <openSelfDebugInfo+0x26cd>
                list.first = node.next;
  20e0f2:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e0f6:	48 89 0d 53 2f 01 00 	mov    QWORD PTR [rip+0x12f53],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20e0fd:	48 85 c9             	test   rcx,rcx
  20e100:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20e103:	48 8d 35 4e 2f 01 00 	lea    rsi,[rip+0x12f4e]        # 221058 <emfile_promise_queue+0x8>
  20e10a:	48 0f 45 f1          	cmovne rsi,rcx
  20e10e:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20e111:	48 83 05 47 2f 01 00 	add    QWORD PTR [rip+0x12f47],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20e118:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20e119:	74 1e                	je     20e139 <openSelfDebugInfo+0x2709>
  20e11b:	48 83 3d 2d 2f 01 00 	cmp    QWORD PTR [rip+0x12f2d],0x0        # 221050 <emfile_promise_queue>
  20e122:	00 
  20e123:	0f 84 d9 0f 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20e129:	48 8b 0d 28 2f 01 00 	mov    rcx,QWORD PTR [rip+0x12f28]        # 221058 <emfile_promise_queue+0x8>
  20e130:	48 85 c9             	test   rcx,rcx
  20e133:	0f 84 c9 0f 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20e139:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20e13d:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20e141:	48 89 c1             	mov    rcx,rax
  20e144:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20e148:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20e14e:	75 f1                	jne    20e141 <openSelfDebugInfo+0x2711>
  20e150:	e9 58 e9 ff ff       	jmp    20caad <openSelfDebugInfo+0x107d>
  20e155:	66 b9 20 00          	mov    cx,0x20
  20e159:	89 cf                	mov    edi,ecx
  20e15b:	eb 04                	jmp    20e161 <openSelfDebugInfo+0x2731>
  20e15d:	66 bf 25 00          	mov    di,0x25
    const abbrev_code = try readULeb128(in_stream);
  20e161:	c5 fe 6f 84 24 a0 00 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa0]
  20e168:	00 00 
  20e16a:	c5 fe 6f 8c 24 b6 00 	vmovdqu ymm1,YMMWORD PTR [rsp+0xb6]
  20e171:	00 00 
  20e173:	c5 fe 7f 8c 24 26 02 	vmovdqu YMMWORD PTR [rsp+0x226],ymm1
  20e17a:	00 00 
  20e17c:	c5 fe 7f 84 24 10 02 	vmovdqu YMMWORD PTR [rsp+0x210],ymm0
  20e183:	00 00 
  20e185:	89 fd                	mov    ebp,edi
            try scanAllCompileUnits(st);
  20e187:	66 85 ff             	test   di,di
  20e18a:	0f 84 61 fd ff ff    	je     20def1 <openSelfDebugInfo+0x24c1>
        const bytes = @sliceToBytes(memory);
  20e190:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20e194:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20e198:	74 29                	je     20e1c3 <openSelfDebugInfo+0x2793>
  20e19a:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20e19e:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20e1a2:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20e1a6:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20e1ad:	00 
  20e1ae:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20e1b5:	00 
  20e1b6:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20e1bd:	00 
  20e1be:	c5 f8 77             	vzeroupper 
  20e1c1:	ff d2                	call   rdx
  20e1c3:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20e1c7:	0f 85 9d 00 00 00    	jne    20e26a <openSelfDebugInfo+0x283a>
  20e1cd:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20e1d1:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20e1d4:	b8 03 00 00 00       	mov    eax,0x3
  20e1d9:	0f 05                	syscall 
            switch (err) {
  20e1db:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20e1df:	74 f3                	je     20e1d4 <openSelfDebugInfo+0x27a4>
            const first = list.first orelse return null;
  20e1e1:	48 8b 05 68 2e 01 00 	mov    rax,QWORD PTR [rip+0x12e68]        # 221050 <emfile_promise_queue>
  20e1e8:	48 85 c0             	test   rax,rax
  20e1eb:	74 7d                	je     20e26a <openSelfDebugInfo+0x283a>
            if (node.prev) |prev_node| {
  20e1ed:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20e1f0:	48 85 c9             	test   rcx,rcx
  20e1f3:	74 0e                	je     20e203 <openSelfDebugInfo+0x27d3>
                prev_node.next = node.next;
  20e1f5:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20e1f9:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20e1fd:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e201:	eb 0b                	jmp    20e20e <openSelfDebugInfo+0x27de>
                list.first = node.next;
  20e203:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e207:	48 89 0d 42 2e 01 00 	mov    QWORD PTR [rip+0x12e42],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20e20e:	48 85 c9             	test   rcx,rcx
  20e211:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20e214:	48 8d 35 3d 2e 01 00 	lea    rsi,[rip+0x12e3d]        # 221058 <emfile_promise_queue+0x8>
  20e21b:	48 0f 45 f1          	cmovne rsi,rcx
  20e21f:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20e222:	48 83 05 36 2e 01 00 	add    QWORD PTR [rip+0x12e36],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20e229:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20e22a:	74 1e                	je     20e24a <openSelfDebugInfo+0x281a>
  20e22c:	48 83 3d 1c 2e 01 00 	cmp    QWORD PTR [rip+0x12e1c],0x0        # 221050 <emfile_promise_queue>
  20e233:	00 
  20e234:	0f 84 c8 0e 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20e23a:	48 8b 0d 17 2e 01 00 	mov    rcx,QWORD PTR [rip+0x12e17]        # 221058 <emfile_promise_queue+0x8>
  20e241:	48 85 c9             	test   rcx,rcx
  20e244:	0f 84 b8 0e 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20e24a:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20e24e:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20e252:	48 89 c1             	mov    rcx,rax
  20e255:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20e259:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20e25f:	75 f1                	jne    20e252 <openSelfDebugInfo+0x2822>
  20e261:	a8 01                	test   al,0x1
  20e263:	75 05                	jne    20e26a <openSelfDebugInfo+0x283a>
  20e265:	c5 f8 77             	vzeroupper 
  20e268:	ff 17                	call   QWORD PTR [rdi]
  20e26a:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20e26d:	b8 03 00 00 00       	mov    eax,0x3
  20e272:	0f 05                	syscall 
            switch (err) {
  20e274:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20e278:	74 f3                	je     20e26d <openSelfDebugInfo+0x283d>
            const first = list.first orelse return null;
  20e27a:	48 8b 05 cf 2d 01 00 	mov    rax,QWORD PTR [rip+0x12dcf]        # 221050 <emfile_promise_queue>
  20e281:	48 85 c0             	test   rax,rax
  20e284:	74 7d                	je     20e303 <openSelfDebugInfo+0x28d3>
            if (node.prev) |prev_node| {
  20e286:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20e289:	48 85 c9             	test   rcx,rcx
  20e28c:	74 0e                	je     20e29c <openSelfDebugInfo+0x286c>
                prev_node.next = node.next;
  20e28e:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20e292:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20e296:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e29a:	eb 0b                	jmp    20e2a7 <openSelfDebugInfo+0x2877>
                list.first = node.next;
  20e29c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e2a0:	48 89 0d a9 2d 01 00 	mov    QWORD PTR [rip+0x12da9],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20e2a7:	48 85 c9             	test   rcx,rcx
  20e2aa:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20e2ad:	48 8d 35 a4 2d 01 00 	lea    rsi,[rip+0x12da4]        # 221058 <emfile_promise_queue+0x8>
  20e2b4:	48 0f 45 f1          	cmovne rsi,rcx
  20e2b8:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20e2bb:	48 83 05 9d 2d 01 00 	add    QWORD PTR [rip+0x12d9d],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20e2c2:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20e2c3:	74 1e                	je     20e2e3 <openSelfDebugInfo+0x28b3>
  20e2c5:	48 83 3d 83 2d 01 00 	cmp    QWORD PTR [rip+0x12d83],0x0        # 221050 <emfile_promise_queue>
  20e2cc:	00 
  20e2cd:	0f 84 2f 0e 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
  20e2d3:	48 8b 0d 7e 2d 01 00 	mov    rcx,QWORD PTR [rip+0x12d7e]        # 221058 <emfile_promise_queue+0x8>
  20e2da:	48 85 c9             	test   rcx,rcx
  20e2dd:	0f 84 1f 0e 00 00    	je     20f102 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20e2e3:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20e2e7:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20e2eb:	48 89 c1             	mov    rcx,rax
  20e2ee:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20e2f2:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20e2f8:	75 f1                	jne    20e2eb <openSelfDebugInfo+0x28bb>
  20e2fa:	a8 01                	test   al,0x1
  20e2fc:	75 05                	jne    20e303 <openSelfDebugInfo+0x28d3>
  20e2fe:	c5 f8 77             	vzeroupper 
  20e301:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20e303:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20e307:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20e30e:	00 
  20e30f:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20e316:	00 c8 00 00 00 
  20e31b:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20e322:	00 
  20e323:	4c 89 ff             	mov    rdi,r15
  20e326:	c5 f8 77             	vzeroupper 
  20e329:	ff d0                	call   rax
  20e32b:	66 41 89 2e          	mov    WORD PTR [r14],bp
  20e32f:	48 8b 84 24 aa 03 00 	mov    rax,QWORD PTR [rsp+0x3aa]
  20e336:	00 
  20e337:	48 8b 8c 24 b0 03 00 	mov    rcx,QWORD PTR [rsp+0x3b0]
  20e33e:	00 
  20e33f:	e9 e2 e3 ff ff       	jmp    20c726 <openSelfDebugInfo+0xcf6>
  20e344:	66 b8 20 00          	mov    ax,0x20
  20e348:	89 c7                	mov    edi,eax
  20e34a:	89 fd                	mov    ebp,edi
  20e34c:	66 85 ff             	test   di,di
  20e34f:	0f 85 3b fe ff ff    	jne    20e190 <openSelfDebugInfo+0x2760>
  20e355:	e9 97 fb ff ff       	jmp    20def1 <openSelfDebugInfo+0x24c1>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  20e35a:	c5 fc 10 05 26 80 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff8026]        # 206388 <__unnamed_58+0x18>
  20e361:	ff 
  20e362:	c5 fc 11 84 24 26 02 	vmovups YMMWORD PTR [rsp+0x226],ymm0
  20e369:	00 00 
  20e36b:	c5 fe 6f 05 ff 7f ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff7fff]        # 206372 <__unnamed_58+0x2>
  20e372:	ff 
  20e373:	c5 fe 7f 84 24 10 02 	vmovdqu YMMWORD PTR [rsp+0x210],ymm0
  20e37a:	00 00 
  20e37c:	66 bf 25 00          	mov    di,0x25
  20e380:	89 fd                	mov    ebp,edi
            try scanAllCompileUnits(st);
  20e382:	66 85 ff             	test   di,di
  20e385:	0f 85 05 fe ff ff    	jne    20e190 <openSelfDebugInfo+0x2760>
  20e38b:	e9 61 fb ff ff       	jmp    20def1 <openSelfDebugInfo+0x24c1>
  20e390:	66 bf 23 00          	mov    di,0x23
  20e394:	89 fd                	mov    ebp,edi
  20e396:	66 85 ff             	test   di,di
  20e399:	0f 85 f1 fd ff ff    	jne    20e190 <openSelfDebugInfo+0x2760>
  20e39f:	e9 4d fb ff ff       	jmp    20def1 <openSelfDebugInfo+0x24c1>
  20e3a4:	66 bf 25 00          	mov    di,0x25
  20e3a8:	89 fd                	mov    ebp,edi
  20e3aa:	66 85 ff             	test   di,di
  20e3ad:	0f 85 dd fd ff ff    	jne    20e190 <openSelfDebugInfo+0x2760>
  20e3b3:	e9 39 fb ff ff       	jmp    20def1 <openSelfDebugInfo+0x24c1>
  20e3b8:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  20e3bc:	48 83 f8 17          	cmp    rax,0x17
  20e3c0:	0f 87 d4 00 00 00    	ja     20e49a <openSelfDebugInfo+0x2a6a>
  20e3c6:	48 8d 0d 6f 2d ff ff 	lea    rcx,[rip+0xffffffffffff2d6f]        # 20113c <__unnamed_9+0x45c>
  20e3cd:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  20e3d1:	48 01 c8             	add    rax,rcx
  20e3d4:	66 c7 44 24 04 22 00 	mov    WORD PTR [rsp+0x4],0x22
  20e3db:	66 bf 02 00          	mov    di,0x2
  20e3df:	ff e0                	jmp    rax
  20e3e1:	48 8d 4a fa          	lea    rcx,[rdx-0x6]
  20e3e5:	48 83 f9 17          	cmp    rcx,0x17
  20e3e9:	0f 87 c2 00 00 00    	ja     20e4b1 <openSelfDebugInfo+0x2a81>
  20e3ef:	66 bf 1e 00          	mov    di,0x1e
  20e3f3:	48 8d 05 a2 2d ff ff 	lea    rax,[rip+0xffffffffffff2da2]        # 20119c <__unnamed_9+0x4bc>
  20e3fa:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  20e3fe:	48 01 c1             	add    rcx,rax
  20e401:	66 c7 84 24 9e 00 00 	mov    WORD PTR [rsp+0x9e],0x22
  20e408:	00 22 00 
  20e40b:	ff e1                	jmp    rcx
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  20e40d:	c5 fc 10 84 24 b8 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2b8]
  20e414:	00 00 
  20e416:	c5 fc 10 8c 24 ce 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2ce]
  20e41d:	00 00 
  20e41f:	c5 fc 11 8c 24 26 02 	vmovups YMMWORD PTR [rsp+0x226],ymm1
  20e426:	00 00 
  20e428:	c5 fc 11 84 24 10 02 	vmovups YMMWORD PTR [rsp+0x210],ymm0
  20e42f:	00 00 
  20e431:	89 c7                	mov    edi,eax
  20e433:	89 fd                	mov    ebp,edi
            try scanAllCompileUnits(st);
  20e435:	66 85 ff             	test   di,di
  20e438:	0f 85 52 fd ff ff    	jne    20e190 <openSelfDebugInfo+0x2760>
  20e43e:	e9 ae fa ff ff       	jmp    20def1 <openSelfDebugInfo+0x24c1>
  20e443:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  20e447:	48 83 f8 17          	cmp    rax,0x17
  20e44b:	77 4d                	ja     20e49a <openSelfDebugInfo+0x2a6a>
  20e44d:	48 8d 0d 08 2e ff ff 	lea    rcx,[rip+0xffffffffffff2e08]        # 20125c <__unnamed_9+0x57c>
  20e454:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  20e458:	48 01 c8             	add    rax,rcx
  20e45b:	66 c7 44 24 04 22 00 	mov    WORD PTR [rsp+0x4],0x22
  20e462:	66 bf 02 00          	mov    di,0x2
  20e466:	ff e0                	jmp    rax
  20e468:	66 bf 02 00          	mov    di,0x2
  20e46c:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  20e470:	48 83 f8 17          	cmp    rax,0x17
  20e474:	77 7c                	ja     20e4f2 <openSelfDebugInfo+0x2ac2>
  20e476:	48 8d 0d 7f 2d ff ff 	lea    rcx,[rip+0xffffffffffff2d7f]        # 2011fc <__unnamed_9+0x51c>
  20e47d:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  20e481:	48 01 c8             	add    rax,rcx
  20e484:	ff e0                	jmp    rax
  20e486:	66 bf 22 00          	mov    di,0x22
  20e48a:	89 fd                	mov    ebp,edi
  20e48c:	66 85 ff             	test   di,di
  20e48f:	0f 85 fb fc ff ff    	jne    20e190 <openSelfDebugInfo+0x2760>
  20e495:	e9 57 fa ff ff       	jmp    20def1 <openSelfDebugInfo+0x24c1>
  20e49a:	66 c7 44 24 04 22 00 	mov    WORD PTR [rsp+0x4],0x22
  20e4a1:	66 bf 02 00          	mov    di,0x2
  20e4a5:	48 83 f9 4b          	cmp    rcx,0x4b
  20e4a9:	0f 85 d6 fc ff ff    	jne    20e185 <openSelfDebugInfo+0x2755>
  20e4af:	eb 2a                	jmp    20e4db <openSelfDebugInfo+0x2aab>
  20e4b1:	66 c7 84 24 9e 00 00 	mov    WORD PTR [rsp+0x9e],0x22
  20e4b8:	00 22 00 
                if (err > 0) {
  20e4bb:	48 83 fa 4b          	cmp    rdx,0x4b
  20e4bf:	75 1a                	jne    20e4db <openSelfDebugInfo+0x2aab>
  20e4c1:	0f b7 84 24 9e 00 00 	movzx  eax,WORD PTR [rsp+0x9e]
  20e4c8:	00 
  20e4c9:	89 c7                	mov    edi,eax
  20e4cb:	89 fd                	mov    ebp,edi
  20e4cd:	66 85 ff             	test   di,di
  20e4d0:	0f 85 ba fc ff ff    	jne    20e190 <openSelfDebugInfo+0x2760>
  20e4d6:	e9 16 fa ff ff       	jmp    20def1 <openSelfDebugInfo+0x24c1>
  20e4db:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  20e4e0:	89 c7                	mov    edi,eax
  20e4e2:	89 fd                	mov    ebp,edi
  20e4e4:	66 85 ff             	test   di,di
  20e4e7:	0f 85 a3 fc ff ff    	jne    20e190 <openSelfDebugInfo+0x2760>
  20e4ed:	e9 ff f9 ff ff       	jmp    20def1 <openSelfDebugInfo+0x24c1>
                if (err > 0) {
  20e4f2:	48 83 f9 4b          	cmp    rcx,0x4b
  20e4f6:	0f 85 89 fc ff ff    	jne    20e185 <openSelfDebugInfo+0x2755>
  20e4fc:	eb 88                	jmp    20e486 <openSelfDebugInfo+0x2a56>
  20e4fe:	66 bf 1e 00          	mov    di,0x1e
  20e502:	89 fd                	mov    ebp,edi
  20e504:	66 85 ff             	test   di,di
  20e507:	0f 85 83 fc ff ff    	jne    20e190 <openSelfDebugInfo+0x2760>
  20e50d:	e9 df f9 ff ff       	jmp    20def1 <openSelfDebugInfo+0x24c1>
    try result.attrs.resize(table_entry.attrs.len);
  20e512:	c5 fc 10 44 24 60    	vmovups ymm0,YMMWORD PTR [rsp+0x60]
  20e518:	c5 fc 10 4c 24 76    	vmovups ymm1,YMMWORD PTR [rsp+0x76]
  20e51e:	e9 fc fe ff ff       	jmp    20e41f <openSelfDebugInfo+0x29ef>
            try self.readNoEof(bytes[0..]);
  20e523:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e528:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e52d:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20e534:	00 00 
  20e536:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e53d:	00 
  20e53e:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e543:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e548:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e54c:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e553:	00 
            const amt_read = try self.read(buf);
  20e554:	66 85 ed             	test   bp,bp
  20e557:	0f 85 7d d7 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20e55d:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e564:	00 
  20e565:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e569:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e56e:	0f 82 66 d7 ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
  20e574:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20e579:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20e57e:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e583:	74 1b                	je     20e5a0 <openSelfDebugInfo+0x2b70>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e585:	c1 e1 08             	shl    ecx,0x8
  20e588:	09 c1                	or     ecx,eax
  20e58a:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20e58f:	c1 e2 10             	shl    edx,0x10
  20e592:	09 ca                	or     edx,ecx
  20e594:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20e599:	c1 e0 18             	shl    eax,0x18
  20e59c:	09 d0                	or     eax,edx
  20e59e:	eb 19                	jmp    20e5b9 <openSelfDebugInfo+0x2b89>
                result = (result << 8) | b;
  20e5a0:	c1 e0 08             	shl    eax,0x8
  20e5a3:	09 c8                	or     eax,ecx
  20e5a5:	c1 e0 08             	shl    eax,0x8
  20e5a8:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20e5ad:	09 c1                	or     ecx,eax
  20e5af:	c1 e1 08             	shl    ecx,0x8
  20e5b2:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20e5b7:	09 c8                	or     eax,ecx
            elf.entry_addr = u64(try in.readInt(elf.endian, u32));
  20e5b9:	89 c0                	mov    eax,eax
  20e5bb:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
  20e5bf:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  20e5c2:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20e5c6:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e5cb:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e5d0:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20e5d7:	00 00 
  20e5d9:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e5e0:	00 
  20e5e1:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e5e6:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e5eb:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e5ef:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e5f6:	00 
            const amt_read = try self.read(buf);
  20e5f7:	66 85 ed             	test   bp,bp
  20e5fa:	0f 85 da d6 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20e600:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e607:	00 
  20e608:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e60c:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e611:	0f 82 c3 d6 ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
  20e617:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20e61c:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20e621:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e626:	74 1b                	je     20e643 <openSelfDebugInfo+0x2c13>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e628:	c1 e1 08             	shl    ecx,0x8
  20e62b:	09 c1                	or     ecx,eax
  20e62d:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20e632:	c1 e2 10             	shl    edx,0x10
  20e635:	09 ca                	or     edx,ecx
  20e637:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20e63c:	c1 e0 18             	shl    eax,0x18
  20e63f:	09 d0                	or     eax,edx
  20e641:	eb 19                	jmp    20e65c <openSelfDebugInfo+0x2c2c>
                result = (result << 8) | b;
  20e643:	c1 e0 08             	shl    eax,0x8
  20e646:	09 c8                	or     eax,ecx
  20e648:	c1 e0 08             	shl    eax,0x8
  20e64b:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20e650:	09 c1                	or     ecx,eax
  20e652:	c1 e1 08             	shl    ecx,0x8
  20e655:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20e65a:	09 c8                	or     eax,ecx
  20e65c:	89 c0                	mov    eax,eax
  20e65e:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
  20e662:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  20e665:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20e669:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e66e:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e673:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20e67a:	00 00 
  20e67c:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e683:	00 
  20e684:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e689:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e68e:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e692:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e699:	00 
            const amt_read = try self.read(buf);
  20e69a:	66 85 ed             	test   bp,bp
  20e69d:	0f 85 37 d6 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20e6a3:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e6aa:	00 
  20e6ab:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e6af:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e6b4:	0f 82 20 d6 ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
  20e6ba:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20e6bf:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20e6c4:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e6c9:	74 1b                	je     20e6e6 <openSelfDebugInfo+0x2cb6>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e6cb:	c1 e1 08             	shl    ecx,0x8
  20e6ce:	09 c1                	or     ecx,eax
  20e6d0:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20e6d5:	c1 e2 10             	shl    edx,0x10
  20e6d8:	09 ca                	or     edx,ecx
  20e6da:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20e6df:	c1 e0 18             	shl    eax,0x18
  20e6e2:	09 d0                	or     eax,edx
  20e6e4:	eb 19                	jmp    20e6ff <openSelfDebugInfo+0x2ccf>
                result = (result << 8) | b;
  20e6e6:	c1 e0 08             	shl    eax,0x8
  20e6e9:	09 c8                	or     eax,ecx
  20e6eb:	c1 e0 08             	shl    eax,0x8
  20e6ee:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20e6f3:	09 c1                	or     ecx,eax
  20e6f5:	c1 e1 08             	shl    ecx,0x8
  20e6f8:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20e6fd:	09 c8                	or     eax,ecx
  20e6ff:	89 c0                	mov    eax,eax
  20e701:	e9 5b db ff ff       	jmp    20c261 <openSelfDebugInfo+0x831>
        const ph_entry_size = try in.readInt(elf.endian, u16);
  20e706:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20e70b:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e70d:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20e711:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e716:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e71b:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20e722:	00 00 
  20e724:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e72b:	00 
  20e72c:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e731:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e736:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e73a:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e741:	00 
            const amt_read = try self.read(buf);
  20e742:	66 85 ed             	test   bp,bp
  20e745:	0f 85 8f d5 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20e74b:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e752:	00 
  20e753:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e757:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e75c:	0f 82 78 d5 ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
  20e762:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e767:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  20e76c:	89 c1                	mov    ecx,eax
  20e76e:	c1 e1 08             	shl    ecx,0x8
  20e771:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20e773:	c1 e2 08             	shl    edx,0x8
  20e776:	09 c2                	or     edx,eax
    switch (endian) {
  20e778:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e77d:	66 0f 45 d1          	cmovne dx,cx
  20e781:	89 54 24 48          	mov    DWORD PTR [rsp+0x48],edx
        const ph_entry_count = try in.readInt(elf.endian, u16);
  20e785:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20e78a:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e78c:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20e790:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e795:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e79a:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20e7a1:	00 00 
  20e7a3:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e7aa:	00 
  20e7ab:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e7b0:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e7b5:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e7b9:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e7c0:	00 
            const amt_read = try self.read(buf);
  20e7c1:	66 85 ed             	test   bp,bp
  20e7c4:	0f 85 10 d5 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20e7ca:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e7d1:	00 
  20e7d2:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e7d6:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e7db:	0f 82 f9 d4 ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
  20e7e1:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e7e6:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  20e7eb:	89 c1                	mov    ecx,eax
  20e7ed:	c1 e1 08             	shl    ecx,0x8
  20e7f0:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20e7f2:	c1 e2 08             	shl    edx,0x8
  20e7f5:	09 c2                	or     edx,eax
    switch (endian) {
  20e7f7:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e7fc:	66 0f 45 d1          	cmovne dx,cx
  20e800:	89 54 24 50          	mov    DWORD PTR [rsp+0x50],edx
        const sh_entry_size = try in.readInt(elf.endian, u16);
  20e804:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20e809:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e80b:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20e80f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e814:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e819:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20e820:	00 00 
  20e822:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e829:	00 
  20e82a:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e82f:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e834:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e838:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e83f:	00 
            const amt_read = try self.read(buf);
  20e840:	66 85 ed             	test   bp,bp
  20e843:	0f 85 91 d4 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20e849:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e850:	00 
  20e851:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e855:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e85a:	0f 82 7a d4 ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
  20e860:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e865:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  20e86a:	89 c1                	mov    ecx,eax
  20e86c:	c1 e1 08             	shl    ecx,0x8
  20e86f:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20e871:	c1 e2 08             	shl    edx,0x8
  20e874:	09 c2                	or     edx,eax
    switch (endian) {
  20e876:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e87b:	66 0f 45 d1          	cmovne dx,cx
  20e87f:	89 54 24 40          	mov    DWORD PTR [rsp+0x40],edx
        const sh_entry_count = try in.readInt(elf.endian, u16);
  20e883:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20e888:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e88a:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20e88e:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e893:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e898:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20e89f:	00 00 
  20e8a1:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e8a8:	00 
  20e8a9:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e8ae:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e8b3:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e8b7:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e8be:	00 
            const amt_read = try self.read(buf);
  20e8bf:	66 85 ed             	test   bp,bp
  20e8c2:	0f 85 12 d4 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20e8c8:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e8cf:	00 
  20e8d0:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e8d4:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e8d9:	0f 82 fb d3 ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
  20e8df:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e8e4:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  20e8e9:	89 c1                	mov    ecx,eax
  20e8eb:	c1 e1 08             	shl    ecx,0x8
  20e8ee:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20e8f0:	c1 e2 08             	shl    edx,0x8
  20e8f3:	09 c2                	or     edx,eax
    switch (endian) {
  20e8f5:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e8fa:	66 0f 45 d1          	cmovne dx,cx
  20e8fe:	89 54 24 38          	mov    DWORD PTR [rsp+0x38],edx
        elf.string_section_index = u64(try in.readInt(elf.endian, u16));
  20e902:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  20e905:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  20e909:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e90e:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e913:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20e91a:	00 00 
  20e91c:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e923:	00 
  20e924:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20e929:	48 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],rdi
            return self.readFn(self, buffer);
  20e92e:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e933:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e937:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e93e:	00 
            const amt_read = try self.read(buf);
  20e93f:	66 85 ed             	test   bp,bp
  20e942:	0f 85 92 d3 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20e948:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e94f:	00 
  20e950:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e954:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e959:	0f 82 7b d3 ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
  20e95f:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e964:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20e969:	89 ca                	mov    edx,ecx
  20e96b:	c1 e2 08             	shl    edx,0x8
  20e96e:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20e970:	c1 e0 08             	shl    eax,0x8
  20e973:	09 c8                	or     eax,ecx
    switch (endian) {
  20e975:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  20e97a:	66 0f 45 c2          	cmovne ax,dx
  20e97e:	0f b7 c0             	movzx  eax,ax
  20e981:	48 89 43 30          	mov    QWORD PTR [rbx+0x30],rax
        if (elf.string_section_index >= sh_entry_count) return error.InvalidFormat;
  20e985:	66 3b 44 24 38       	cmp    ax,WORD PTR [rsp+0x38]
  20e98a:	0f 83 bd d9 ff ff    	jae    20c34d <openSelfDebugInfo+0x91d>
  20e990:	0f b7 4c 24 38       	movzx  ecx,WORD PTR [rsp+0x38]
        const sh_byte_count = u64(sh_entry_size) * u64(sh_entry_count);
  20e995:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  20e99a:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  20e99f:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  20e9a4:	48 0f af c1          	imul   rax,rcx
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  20e9a8:	48 03 43 28          	add    rax,QWORD PTR [rbx+0x28]
  20e9ac:	73 1f                	jae    20e9cd <openSelfDebugInfo+0x2f9d>
  20e9ae:	48 8d 05 1b 1e ff ff 	lea    rax,[rip+0xffffffffffff1e1b]        # 2007d0 <__unnamed_59>
  20e9b5:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  20e9ba:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20e9bf:	0f b7 28             	movzx  ebp,WORD PTR [rax]
        const end_sh = try math.add(u64, elf.section_header_offset, sh_byte_count);
  20e9c2:	66 85 ed             	test   bp,bp
  20e9c5:	0f 85 0f d3 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20e9cb:	eb 23                	jmp    20e9f0 <openSelfDebugInfo+0x2fc0>
  20e9cd:	66 c7 84 24 a0 00 00 	mov    WORD PTR [rsp+0xa0],0x0
  20e9d4:	00 00 00 
  20e9d7:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20e9de:	00 
  20e9df:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20e9e4:	0f b7 28             	movzx  ebp,WORD PTR [rax]
  20e9e7:	66 85 ed             	test   bp,bp
  20e9ea:	0f 85 ea d2 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20e9f0:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20e9f5:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
        const ph_byte_count = u64(ph_entry_size) * u64(ph_entry_count);
  20e9f9:	0f b7 44 24 48       	movzx  eax,WORD PTR [rsp+0x48]
  20e9fe:	0f b7 4c 24 50       	movzx  ecx,WORD PTR [rsp+0x50]
  20ea03:	48 0f af c8          	imul   rcx,rax
  20ea07:	48 03 4b 20          	add    rcx,QWORD PTR [rbx+0x20]
  20ea0b:	73 15                	jae    20ea22 <openSelfDebugInfo+0x2ff2>
  20ea0d:	48 8d 05 bc 1d ff ff 	lea    rax,[rip+0xffffffffffff1dbc]        # 2007d0 <__unnamed_59>
  20ea14:	0f b7 28             	movzx  ebp,WORD PTR [rax]
        const end_ph = try math.add(u64, elf.program_header_offset, ph_byte_count);
  20ea17:	66 85 ed             	test   bp,bp
  20ea1a:	0f 85 ba d2 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20ea20:	eb 26                	jmp    20ea48 <openSelfDebugInfo+0x3018>
  20ea22:	48 8d 84 24 a0 00 00 	lea    rax,[rsp+0xa0]
  20ea29:	00 
  20ea2a:	66 c7 84 24 a0 00 00 	mov    WORD PTR [rsp+0xa0],0x0
  20ea31:	00 00 00 
  20ea34:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  20ea3b:	00 
  20ea3c:	0f b7 28             	movzx  ebp,WORD PTR [rax]
  20ea3f:	66 85 ed             	test   bp,bp
  20ea42:	0f 85 92 d2 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20ea48:	4c 8b 40 08          	mov    r8,QWORD PTR [rax+0x8]
        const stream_end = try elf.in_file.getEndPos();
  20ea4c:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
pub fn accept4(fd: i32, noalias addr: *sockaddr, noalias len: *socklen_t, flags: u32) usize {
    return syscall4(SYS_accept4, @intCast(usize, fd), @ptrToInt(addr), @ptrToInt(len), flags);
}

pub fn fstat(fd: i32, stat_buf: *Stat) usize {
    return syscall2(SYS_fstat, @intCast(usize, fd), @ptrToInt(stat_buf));
  20ea50:	48 63 38             	movsxd rdi,DWORD PTR [rax]
        }
    }
}

pub fn posixFStat(fd: i32) !posix.Stat {
    var stat: posix.Stat = undefined;
  20ea53:	c5 fc 10 05 4d 78 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff784d]        # 2062a8 <__unnamed_60+0x70>
  20ea5a:	ff 
  20ea5b:	c5 fc 11 84 24 10 01 	vmovups YMMWORD PTR [rsp+0x110],ymm0
  20ea62:	00 00 
  20ea64:	c5 fc 10 05 2c 78 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff782c]        # 206298 <__unnamed_60+0x60>
  20ea6b:	ff 
  20ea6c:	c5 fc 11 84 24 00 01 	vmovups YMMWORD PTR [rsp+0x100],ymm0
  20ea73:	00 00 
  20ea75:	c5 fc 10 05 fb 77 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff77fb]        # 206278 <__unnamed_60+0x40>
  20ea7c:	ff 
  20ea7d:	c5 fc 11 84 24 e0 00 	vmovups YMMWORD PTR [rsp+0xe0],ymm0
  20ea84:	00 00 
  20ea86:	c5 fc 10 05 ca 77 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff77ca]        # 206258 <__unnamed_60+0x20>
  20ea8d:	ff 
  20ea8e:	c5 fc 11 84 24 c0 00 	vmovups YMMWORD PTR [rsp+0xc0],ymm0
  20ea95:	00 00 
  20ea97:	c5 fe 6f 05 99 77 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff7799]        # 206238 <__unnamed_60>
  20ea9e:	ff 
  20ea9f:	c5 fe 7f 84 24 a0 00 	vmovdqu YMMWORD PTR [rsp+0xa0],ymm0
  20eaa6:	00 00 
  20eaa8:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20eaaf:	00 
    return asm volatile ("syscall"
  20eab0:	b8 05 00 00 00       	mov    eax,0x5
  20eab5:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20eab7:	48 89 c6             	mov    rsi,rax
  20eaba:	48 f7 de             	neg    rsi
  20eabd:	31 c9                	xor    ecx,ecx
  20eabf:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20eac5:	48 0f 47 ce          	cmova  rcx,rsi
    const err = posix.getErrno(posix.fstat(fd, &stat));
    if (err > 0) {
  20eac9:	48 85 c9             	test   rcx,rcx
  20eacc:	74 26                	je     20eaf4 <openSelfDebugInfo+0x30c4>
  20eace:	48 83 f9 09          	cmp    rcx,0x9
  20ead2:	0f 84 18 06 00 00    	je     20f0f0 <openSelfDebugInfo+0x36c0>
  20ead8:	48 83 f9 0c          	cmp    rcx,0xc
  20eadc:	0f 85 28 06 00 00    	jne    20f10a <openSelfDebugInfo+0x36da>
  20eae2:	66 bd 04 00          	mov    bp,0x4
            try st.elf.openFile(allocator, &st.self_exe_file);
  20eae6:	66 85 ed             	test   bp,bp
  20eae9:	0f 85 f4 d1 ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
  20eaef:	e9 66 d8 ff ff       	jmp    20c35a <openSelfDebugInfo+0x92a>
            posix.ENOMEM => error.SystemResources,
            else => os.unexpectedErrorPosix(err),
        };
    }

    return stat;
  20eaf4:	48 8b 84 24 d0 00 00 	mov    rax,QWORD PTR [rsp+0xd0]
  20eafb:	00 
  20eafc:	48 89 84 24 60 01 00 	mov    QWORD PTR [rsp+0x160],rax
  20eb03:	00 
  20eb04:	66 bd 21 00          	mov    bp,0x21
        if (stream_end < end_sh or stream_end < end_ph) {
  20eb08:	48 39 d0             	cmp    rax,rdx
  20eb0b:	0f 82 c9 d1 ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
  20eb11:	4c 39 84 24 60 01 00 	cmp    QWORD PTR [rsp+0x160],r8
  20eb18:	00 
  20eb19:	0f 82 bb d1 ff ff    	jb     20bcda <openSelfDebugInfo+0x2aa>
        try elf.in_file.seekTo(elf.section_header_offset);
  20eb1f:	48 8b 73 28          	mov    rsi,QWORD PTR [rbx+0x28]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  20eb23:	48 85 f6             	test   rsi,rsi
  20eb26:	0f 88 f0 05 00 00    	js     20f11c <openSelfDebugInfo+0x36ec>
  20eb2c:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20eb30:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20eb33:	31 ed                	xor    ebp,ebp
    return asm volatile ("syscall"
  20eb35:	b8 08 00 00 00       	mov    eax,0x8
  20eb3a:	31 d2                	xor    edx,edx
  20eb3c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20eb3e:	48 89 c1             	mov    rcx,rax
  20eb41:	48 f7 d9             	neg    rcx
  20eb44:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20eb4a:	48 0f 46 cd          	cmovbe rcx,rbp
  20eb4e:	48 83 f9 1d          	cmp    rcx,0x1d
  20eb52:	0f 87 85 05 00 00    	ja     20f0dd <openSelfDebugInfo+0x36ad>
  20eb58:	48 8d 05 65 25 ff ff 	lea    rax,[rip+0xffffffffffff2565]        # 2010c4 <__unnamed_9+0x3e4>
  20eb5f:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  20eb63:	48 01 c1             	add    rcx,rax
  20eb66:	66 bd 02 00          	mov    bp,0x2
  20eb6a:	ff e1                	jmp    rcx
        elf.section_headers = try elf.allocator.alloc(SectionHeader, sh_entry_count);
  20eb6c:	48 8b 73 50          	mov    rsi,QWORD PTR [rbx+0x50]
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  20eb70:	48 8b 54 24 38       	mov    rdx,QWORD PTR [rsp+0x38]
  20eb75:	48 c1 e2 06          	shl    rdx,0x6
  20eb79:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20eb80:	00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20eb81:	b9 04 00 00 00       	mov    ecx,0x4
  20eb86:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  20eb8d:	00 
  20eb8e:	c5 f8 77             	vzeroupper 
  20eb91:	ff 16                	call   QWORD PTR [rsi]
  20eb93:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20eb9a:	00 
  20eb9b:	66 85 ed             	test   bp,bp
  20eb9e:	0f 85 36 d1 ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
        assert(byte_slice.len == byte_count);
  20eba4:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  20ebab:	00 
  20ebac:	48 39 84 24 b0 00 00 	cmp    QWORD PTR [rsp+0xb0],rax
  20ebb3:	00 
    if (!ok) {
  20ebb4:	0f 85 48 05 00 00    	jne    20f102 <openSelfDebugInfo+0x36d2>
  20ebba:	48 8d 43 50          	lea    rax,[rbx+0x50]
  20ebbe:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  20ebc3:	48 8d 43 40          	lea    rax,[rbx+0x40]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20ebc7:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  20ebcc:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20ebd3:	00 
  20ebd4:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20ebd9:	48 89 43 40          	mov    QWORD PTR [rbx+0x40],rax
  20ebdd:	48 8d 43 48          	lea    rax,[rbx+0x48]
  20ebe1:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  20ebe6:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  20ebeb:	48 89 43 48          	mov    QWORD PTR [rbx+0x48],rax
        if (elf.is_64) {
  20ebef:	80 7b 11 01          	cmp    BYTE PTR [rbx+0x11],0x1
  20ebf3:	0f 85 35 05 00 00    	jne    20f12e <openSelfDebugInfo+0x36fe>
            if (sh_entry_size != 64) return error.InvalidFormat;
  20ebf9:	83 7c 24 40 40       	cmp    DWORD PTR [rsp+0x40],0x40
  20ebfe:	0f 85 a0 0e 00 00    	jne    20faa4 <openSelfDebugInfo+0x4074>
                elf_section.name = try in.readInt(elf.endian, u32);
  20ec04:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20ec09:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20ec0b:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20ec0f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20ec14:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20ec19:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20ec20:	00 00 
  20ec22:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20ec29:	00 
  20ec2a:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20ec2f:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20ec34:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20ec38:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20ec3f:	00 
            const amt_read = try self.read(buf);
  20ec40:	66 85 ed             	test   bp,bp
  20ec43:	0f 85 97 0e 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20ec49:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20ec50:	00 
  20ec51:	31 c9                	xor    ecx,ecx
  20ec53:	48 89 8c 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rcx
  20ec5a:	00 
  20ec5b:	b9 38 00 00 00       	mov    ecx,0x38
  20ec60:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  20ec65:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20ec6a:	0f 82 6c 0e 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20ec70:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20ec75:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20ec7a:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20ec7f:	74 1b                	je     20ec9c <openSelfDebugInfo+0x326c>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20ec81:	c1 e1 08             	shl    ecx,0x8
  20ec84:	09 c1                	or     ecx,eax
  20ec86:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20ec8b:	c1 e2 10             	shl    edx,0x10
  20ec8e:	09 ca                	or     edx,ecx
  20ec90:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20ec95:	c1 e0 18             	shl    eax,0x18
  20ec98:	09 d0                	or     eax,edx
  20ec9a:	eb 19                	jmp    20ecb5 <openSelfDebugInfo+0x3285>
                result = (result << 8) | b;
  20ec9c:	c1 e0 08             	shl    eax,0x8
  20ec9f:	09 c8                	or     eax,ecx
  20eca1:	c1 e0 08             	shl    eax,0x8
  20eca4:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20eca9:	09 c1                	or     ecx,eax
  20ecab:	c1 e1 08             	shl    ecx,0x8
  20ecae:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20ecb3:	09 c8                	or     eax,ecx
  20ecb5:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20ecba:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20ecbf:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  20ecc3:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20ecc8:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20eccb:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20eccf:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20ecd4:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20ecd9:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20ece0:	00 00 
            return self.readFn(self, buffer);
  20ece2:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20ece9:	00 
  20ecea:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20ecef:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20ecf4:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20ecf8:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20ecff:	00 
            const amt_read = try self.read(buf);
  20ed00:	66 85 ed             	test   bp,bp
  20ed03:	0f 85 d7 0d 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20ed09:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20ed10:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20ed11:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20ed16:	0f 82 c0 0d 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20ed1c:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20ed21:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20ed26:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20ed2b:	74 1b                	je     20ed48 <openSelfDebugInfo+0x3318>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20ed2d:	c1 e1 08             	shl    ecx,0x8
  20ed30:	09 c1                	or     ecx,eax
  20ed32:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20ed37:	c1 e2 10             	shl    edx,0x10
  20ed3a:	09 ca                	or     edx,ecx
  20ed3c:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20ed41:	c1 e0 18             	shl    eax,0x18
  20ed44:	09 d0                	or     eax,edx
  20ed46:	eb 19                	jmp    20ed61 <openSelfDebugInfo+0x3331>
                result = (result << 8) | b;
  20ed48:	c1 e0 08             	shl    eax,0x8
  20ed4b:	09 c8                	or     eax,ecx
  20ed4d:	c1 e0 08             	shl    eax,0x8
  20ed50:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20ed55:	09 c1                	or     ecx,eax
  20ed57:	c1 e1 08             	shl    ecx,0x8
  20ed5a:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20ed5f:	09 c8                	or     eax,ecx
  20ed61:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20ed66:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20ed6b:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = try in.readInt(elf.endian, u64);
  20ed6f:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20ed74:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20ed77:	48 8d bc 24 48 03 00 	lea    rdi,[rsp+0x348]
  20ed7e:	00 
  20ed7f:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20ed84:	e8 97 15 00 00       	call   210320 <InStream(ReadError)_readInt.33>
  20ed89:	0f b7 ac 24 48 03 00 	movzx  ebp,WORD PTR [rsp+0x348]
  20ed90:	00 
  20ed91:	66 85 ed             	test   bp,bp
  20ed94:	0f 85 06 0b 00 00    	jne    20f8a0 <openSelfDebugInfo+0x3e70>
  20ed9a:	48 8b 84 24 50 03 00 	mov    rax,QWORD PTR [rsp+0x350]
  20eda1:	00 
  20eda2:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20eda7:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20edac:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = try in.readInt(elf.endian, u64);
  20edb1:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20edb6:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20edb9:	48 8d bc 24 10 03 00 	lea    rdi,[rsp+0x310]
  20edc0:	00 
  20edc1:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20edc6:	e8 55 15 00 00       	call   210320 <InStream(ReadError)_readInt.33>
  20edcb:	0f b7 ac 24 10 03 00 	movzx  ebp,WORD PTR [rsp+0x310]
  20edd2:	00 
  20edd3:	66 85 ed             	test   bp,bp
  20edd6:	0f 85 1a 0b 00 00    	jne    20f8f6 <openSelfDebugInfo+0x3ec6>
  20eddc:	48 8b 84 24 18 03 00 	mov    rax,QWORD PTR [rsp+0x318]
  20ede3:	00 
  20ede4:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20ede9:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20edee:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = try in.readInt(elf.endian, u64);
  20edf3:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20edf8:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20edfb:	48 8d bc 24 f0 02 00 	lea    rdi,[rsp+0x2f0]
  20ee02:	00 
  20ee03:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20ee08:	e8 13 15 00 00       	call   210320 <InStream(ReadError)_readInt.33>
  20ee0d:	0f b7 ac 24 f0 02 00 	movzx  ebp,WORD PTR [rsp+0x2f0]
  20ee14:	00 
  20ee15:	66 85 ed             	test   bp,bp
  20ee18:	0f 85 2e 0b 00 00    	jne    20f94c <openSelfDebugInfo+0x3f1c>
  20ee1e:	48 8b 84 24 f8 02 00 	mov    rax,QWORD PTR [rsp+0x2f8]
  20ee25:	00 
  20ee26:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20ee2b:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20ee30:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = try in.readInt(elf.endian, u64);
  20ee35:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20ee3a:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20ee3d:	48 8d bc 24 88 01 00 	lea    rdi,[rsp+0x188]
  20ee44:	00 
  20ee45:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20ee4a:	e8 d1 14 00 00       	call   210320 <InStream(ReadError)_readInt.33>
  20ee4f:	0f b7 ac 24 88 01 00 	movzx  ebp,WORD PTR [rsp+0x188]
  20ee56:	00 
  20ee57:	66 85 ed             	test   bp,bp
  20ee5a:	0f 85 42 0b 00 00    	jne    20f9a2 <openSelfDebugInfo+0x3f72>
  20ee60:	48 8b 84 24 90 01 00 	mov    rax,QWORD PTR [rsp+0x190]
  20ee67:	00 
  20ee68:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20ee6d:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20ee72:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  20ee77:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20ee7c:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20ee7f:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20ee83:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20ee88:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20ee8d:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20ee94:	00 00 
            return self.readFn(self, buffer);
  20ee96:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20ee9d:	00 
  20ee9e:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20eea3:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20eea8:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20eeac:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20eeb3:	00 
            const amt_read = try self.read(buf);
  20eeb4:	66 85 ed             	test   bp,bp
  20eeb7:	0f 85 23 0c 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20eebd:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20eec4:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20eec5:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20eeca:	0f 82 0c 0c 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20eed0:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20eed5:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20eeda:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20eedf:	74 1b                	je     20eefc <openSelfDebugInfo+0x34cc>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20eee1:	c1 e1 08             	shl    ecx,0x8
  20eee4:	09 c1                	or     ecx,eax
  20eee6:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20eeeb:	c1 e2 10             	shl    edx,0x10
  20eeee:	09 ca                	or     edx,ecx
  20eef0:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20eef5:	c1 e0 18             	shl    eax,0x18
  20eef8:	09 d0                	or     eax,edx
  20eefa:	eb 19                	jmp    20ef15 <openSelfDebugInfo+0x34e5>
                result = (result << 8) | b;
  20eefc:	c1 e0 08             	shl    eax,0x8
  20eeff:	09 c8                	or     eax,ecx
  20ef01:	c1 e0 08             	shl    eax,0x8
  20ef04:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20ef09:	09 c1                	or     ecx,eax
  20ef0b:	c1 e1 08             	shl    ecx,0x8
  20ef0e:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20ef13:	09 c8                	or     eax,ecx
  20ef15:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20ef1a:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20ef1f:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  20ef23:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20ef28:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20ef2b:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20ef2f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20ef34:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20ef39:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20ef40:	00 00 
            return self.readFn(self, buffer);
  20ef42:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20ef49:	00 
  20ef4a:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20ef4f:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20ef54:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20ef58:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20ef5f:	00 
            const amt_read = try self.read(buf);
  20ef60:	66 85 ed             	test   bp,bp
  20ef63:	0f 85 77 0b 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20ef69:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20ef70:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20ef71:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20ef76:	0f 82 60 0b 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20ef7c:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20ef81:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20ef86:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20ef8b:	74 1b                	je     20efa8 <openSelfDebugInfo+0x3578>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20ef8d:	c1 e1 08             	shl    ecx,0x8
  20ef90:	09 c1                	or     ecx,eax
  20ef92:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20ef97:	c1 e2 10             	shl    edx,0x10
  20ef9a:	09 ca                	or     edx,ecx
  20ef9c:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20efa1:	c1 e0 18             	shl    eax,0x18
  20efa4:	09 d0                	or     eax,edx
  20efa6:	eb 19                	jmp    20efc1 <openSelfDebugInfo+0x3591>
                result = (result << 8) | b;
  20efa8:	c1 e0 08             	shl    eax,0x8
  20efab:	09 c8                	or     eax,ecx
  20efad:	c1 e0 08             	shl    eax,0x8
  20efb0:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20efb5:	09 c1                	or     ecx,eax
  20efb7:	c1 e1 08             	shl    ecx,0x8
  20efba:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20efbf:	09 c8                	or     eax,ecx
  20efc1:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20efc6:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20efcb:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  20efcf:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20efd4:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20efd7:	48 8d bc 24 c0 01 00 	lea    rdi,[rsp+0x1c0]
  20efde:	00 
  20efdf:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20efe4:	e8 37 13 00 00       	call   210320 <InStream(ReadError)_readInt.33>
  20efe9:	0f b7 ac 24 c0 01 00 	movzx  ebp,WORD PTR [rsp+0x1c0]
  20eff0:	00 
  20eff1:	66 85 ed             	test   bp,bp
  20eff4:	0f 85 fe 09 00 00    	jne    20f9f8 <openSelfDebugInfo+0x3fc8>
  20effa:	48 8b 84 24 c8 01 00 	mov    rax,QWORD PTR [rsp+0x1c8]
  20f001:	00 
  20f002:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f007:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f00c:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  20f011:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f016:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20f019:	48 8d bc 24 a0 01 00 	lea    rdi,[rsp+0x1a0]
  20f020:	00 
  20f021:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f026:	e8 f5 12 00 00       	call   210320 <InStream(ReadError)_readInt.33>
  20f02b:	0f b7 ac 24 a0 01 00 	movzx  ebp,WORD PTR [rsp+0x1a0]
  20f032:	00 
  20f033:	66 85 ed             	test   bp,bp
  20f036:	0f 85 12 0a 00 00    	jne    20fa4e <openSelfDebugInfo+0x401e>
  20f03c:	48 8b 84 24 a8 01 00 	mov    rax,QWORD PTR [rsp+0x1a8]
  20f043:	00 
  20f044:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f049:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f04e:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  20f052:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  20f059:	00 
  20f05a:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  20f05d:	48 83 c1 01          	add    rcx,0x1
  20f061:	48 89 c8             	mov    rax,rcx
  20f064:	48 89 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rax
  20f06b:	00 
  20f06c:	48 3b 4c 24 38       	cmp    rcx,QWORD PTR [rsp+0x38]
  20f071:	0f 83 90 0a 00 00    	jae    20fb07 <openSelfDebugInfo+0x40d7>
  20f077:	48 83 44 24 40 40    	add    QWORD PTR [rsp+0x40],0x40
  20f07d:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  20f082:	48 8b 00             	mov    rax,QWORD PTR [rax]
                elf_section.name = try in.readInt(elf.endian, u32);
  20f085:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20f08a:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f08f:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f092:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f096:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f09b:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f0a0:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f0a7:	00 00 
            return self.readFn(self, buffer);
  20f0a9:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f0b0:	00 
  20f0b1:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f0b6:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f0bb:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f0bf:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f0c6:	00 
  20f0c7:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f0ce:	00 
            const amt_read = try self.read(buf);
  20f0cf:	66 85 ed             	test   bp,bp
  20f0d2:	0f 84 8d fb ff ff    	je     20ec65 <openSelfDebugInfo+0x3235>
  20f0d8:	e9 03 0a 00 00       	jmp    20fae0 <openSelfDebugInfo+0x40b0>
  20f0dd:	66 bd 02 00          	mov    bp,0x2
  20f0e1:	48 83 f9 4b          	cmp    rcx,0x4b
  20f0e5:	0f 85 ef cb ff ff    	jne    20bcda <openSelfDebugInfo+0x2aa>
  20f0eb:	e9 b6 ce ff ff       	jmp    20bfa6 <openSelfDebugInfo+0x576>
  20f0f0:	66 bd 1e 00          	mov    bp,0x1e
            try st.elf.openFile(allocator, &st.self_exe_file);
  20f0f4:	66 85 ed             	test   bp,bp
  20f0f7:	0f 85 e6 cb ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
  20f0fd:	e9 58 d2 ff ff       	jmp    20c35a <openSelfDebugInfo+0x92a>
            @panic("assertion failure");
  20f102:	c5 f8 77             	vzeroupper 
  20f105:	e8 a6 ab ff ff       	call   209cb0 <panic>
  20f10a:	66 bd 02 00          	mov    bp,0x2
            try st.elf.openFile(allocator, &st.self_exe_file);
  20f10e:	66 85 ed             	test   bp,bp
  20f111:	0f 85 cc cb ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
  20f117:	e9 3e d2 ff ff       	jmp    20c35a <openSelfDebugInfo+0x92a>
  20f11c:	66 bd 23 00          	mov    bp,0x23
  20f120:	66 85 ed             	test   bp,bp
  20f123:	0f 85 ba cb ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
  20f129:	e9 2c d2 ff ff       	jmp    20c35a <openSelfDebugInfo+0x92a>
            if (sh_entry_size != 40) return error.InvalidFormat;
  20f12e:	83 7c 24 40 28       	cmp    DWORD PTR [rsp+0x40],0x28
  20f133:	0f 85 6b 09 00 00    	jne    20faa4 <openSelfDebugInfo+0x4074>
                elf_section.name = try in.readInt(elf.endian, u32);
  20f139:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f13e:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f140:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f144:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f149:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f14e:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f155:	00 00 
  20f157:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f15e:	00 
  20f15f:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20f164:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f169:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f16d:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f174:	00 
            const amt_read = try self.read(buf);
  20f175:	66 85 ed             	test   bp,bp
  20f178:	0f 85 62 09 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20f17e:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f185:	00 
  20f186:	31 c9                	xor    ecx,ecx
  20f188:	48 89 8c 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rcx
  20f18f:	00 
  20f190:	b9 38 00 00 00       	mov    ecx,0x38
  20f195:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  20f19a:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f19f:	0f 82 37 09 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20f1a5:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f1aa:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f1af:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f1b4:	74 1b                	je     20f1d1 <openSelfDebugInfo+0x37a1>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f1b6:	c1 e1 08             	shl    ecx,0x8
  20f1b9:	09 c1                	or     ecx,eax
  20f1bb:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f1c0:	c1 e2 10             	shl    edx,0x10
  20f1c3:	09 ca                	or     edx,ecx
  20f1c5:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f1ca:	c1 e0 18             	shl    eax,0x18
  20f1cd:	09 d0                	or     eax,edx
  20f1cf:	eb 19                	jmp    20f1ea <openSelfDebugInfo+0x37ba>
                result = (result << 8) | b;
  20f1d1:	c1 e0 08             	shl    eax,0x8
  20f1d4:	09 c8                	or     eax,ecx
  20f1d6:	c1 e0 08             	shl    eax,0x8
  20f1d9:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f1de:	09 c1                	or     ecx,eax
  20f1e0:	c1 e1 08             	shl    ecx,0x8
  20f1e3:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f1e8:	09 c8                	or     eax,ecx
  20f1ea:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f1ef:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f1f4:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  20f1f8:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f1fd:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f200:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f204:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f209:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f20e:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f215:	00 00 
            return self.readFn(self, buffer);
  20f217:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f21e:	00 
  20f21f:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f224:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f229:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f22d:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f234:	00 
            const amt_read = try self.read(buf);
  20f235:	66 85 ed             	test   bp,bp
  20f238:	0f 85 a2 08 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20f23e:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f245:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f246:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f24b:	0f 82 8b 08 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20f251:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f256:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f25b:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f260:	74 1b                	je     20f27d <openSelfDebugInfo+0x384d>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f262:	c1 e1 08             	shl    ecx,0x8
  20f265:	09 c1                	or     ecx,eax
  20f267:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f26c:	c1 e2 10             	shl    edx,0x10
  20f26f:	09 ca                	or     edx,ecx
  20f271:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f276:	c1 e0 18             	shl    eax,0x18
  20f279:	09 d0                	or     eax,edx
  20f27b:	eb 19                	jmp    20f296 <openSelfDebugInfo+0x3866>
                result = (result << 8) | b;
  20f27d:	c1 e0 08             	shl    eax,0x8
  20f280:	09 c8                	or     eax,ecx
  20f282:	c1 e0 08             	shl    eax,0x8
  20f285:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f28a:	09 c1                	or     ecx,eax
  20f28c:	c1 e1 08             	shl    ecx,0x8
  20f28f:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f294:	09 c8                	or     eax,ecx
  20f296:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f29b:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f2a0:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = u64(try in.readInt(elf.endian, u32));
  20f2a4:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f2a9:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f2ac:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f2b0:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f2b5:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f2ba:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f2c1:	00 00 
            return self.readFn(self, buffer);
  20f2c3:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f2ca:	00 
  20f2cb:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f2d0:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f2d5:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f2d9:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f2e0:	00 
            const amt_read = try self.read(buf);
  20f2e1:	66 85 ed             	test   bp,bp
  20f2e4:	0f 85 f6 07 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20f2ea:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f2f1:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f2f2:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f2f7:	0f 82 df 07 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20f2fd:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f302:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f307:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f30c:	74 1b                	je     20f329 <openSelfDebugInfo+0x38f9>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f30e:	c1 e1 08             	shl    ecx,0x8
  20f311:	09 c1                	or     ecx,eax
  20f313:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f318:	c1 e2 10             	shl    edx,0x10
  20f31b:	09 ca                	or     edx,ecx
  20f31d:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f322:	c1 e0 18             	shl    eax,0x18
  20f325:	09 d0                	or     eax,edx
  20f327:	eb 19                	jmp    20f342 <openSelfDebugInfo+0x3912>
                result = (result << 8) | b;
  20f329:	c1 e0 08             	shl    eax,0x8
  20f32c:	09 c8                	or     eax,ecx
  20f32e:	c1 e0 08             	shl    eax,0x8
  20f331:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f336:	09 c1                	or     ecx,eax
  20f338:	c1 e1 08             	shl    ecx,0x8
  20f33b:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f340:	09 c8                	or     eax,ecx
  20f342:	89 c0                	mov    eax,eax
  20f344:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f349:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f34e:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = u64(try in.readInt(elf.endian, u32));
  20f353:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f358:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f35b:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f35f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f364:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f369:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f370:	00 00 
            return self.readFn(self, buffer);
  20f372:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f379:	00 
  20f37a:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f37f:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f384:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f388:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f38f:	00 
            const amt_read = try self.read(buf);
  20f390:	66 85 ed             	test   bp,bp
  20f393:	0f 85 47 07 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20f399:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f3a0:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f3a1:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f3a6:	0f 82 30 07 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20f3ac:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f3b1:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f3b6:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f3bb:	74 1b                	je     20f3d8 <openSelfDebugInfo+0x39a8>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f3bd:	c1 e1 08             	shl    ecx,0x8
  20f3c0:	09 c1                	or     ecx,eax
  20f3c2:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f3c7:	c1 e2 10             	shl    edx,0x10
  20f3ca:	09 ca                	or     edx,ecx
  20f3cc:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f3d1:	c1 e0 18             	shl    eax,0x18
  20f3d4:	09 d0                	or     eax,edx
  20f3d6:	eb 19                	jmp    20f3f1 <openSelfDebugInfo+0x39c1>
                result = (result << 8) | b;
  20f3d8:	c1 e0 08             	shl    eax,0x8
  20f3db:	09 c8                	or     eax,ecx
  20f3dd:	c1 e0 08             	shl    eax,0x8
  20f3e0:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f3e5:	09 c1                	or     ecx,eax
  20f3e7:	c1 e1 08             	shl    ecx,0x8
  20f3ea:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f3ef:	09 c8                	or     eax,ecx
  20f3f1:	89 c0                	mov    eax,eax
  20f3f3:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f3f8:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f3fd:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = u64(try in.readInt(elf.endian, u32));
  20f402:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f407:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f40a:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f40e:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f413:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f418:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f41f:	00 00 
            return self.readFn(self, buffer);
  20f421:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f428:	00 
  20f429:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f42e:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f433:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f437:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f43e:	00 
            const amt_read = try self.read(buf);
  20f43f:	66 85 ed             	test   bp,bp
  20f442:	0f 85 98 06 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20f448:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f44f:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f450:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f455:	0f 82 81 06 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20f45b:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f460:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f465:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f46a:	74 1b                	je     20f487 <openSelfDebugInfo+0x3a57>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f46c:	c1 e1 08             	shl    ecx,0x8
  20f46f:	09 c1                	or     ecx,eax
  20f471:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f476:	c1 e2 10             	shl    edx,0x10
  20f479:	09 ca                	or     edx,ecx
  20f47b:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f480:	c1 e0 18             	shl    eax,0x18
  20f483:	09 d0                	or     eax,edx
  20f485:	eb 19                	jmp    20f4a0 <openSelfDebugInfo+0x3a70>
                result = (result << 8) | b;
  20f487:	c1 e0 08             	shl    eax,0x8
  20f48a:	09 c8                	or     eax,ecx
  20f48c:	c1 e0 08             	shl    eax,0x8
  20f48f:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f494:	09 c1                	or     ecx,eax
  20f496:	c1 e1 08             	shl    ecx,0x8
  20f499:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f49e:	09 c8                	or     eax,ecx
  20f4a0:	89 c0                	mov    eax,eax
  20f4a2:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f4a7:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f4ac:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = u64(try in.readInt(elf.endian, u32));
  20f4b1:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f4b6:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f4b9:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f4bd:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f4c2:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f4c7:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f4ce:	00 00 
            return self.readFn(self, buffer);
  20f4d0:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f4d7:	00 
  20f4d8:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f4dd:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f4e2:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f4e6:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f4ed:	00 
            const amt_read = try self.read(buf);
  20f4ee:	66 85 ed             	test   bp,bp
  20f4f1:	0f 85 e9 05 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20f4f7:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f4fe:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f4ff:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f504:	0f 82 d2 05 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20f50a:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f50f:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f514:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f519:	74 1b                	je     20f536 <openSelfDebugInfo+0x3b06>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f51b:	c1 e1 08             	shl    ecx,0x8
  20f51e:	09 c1                	or     ecx,eax
  20f520:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f525:	c1 e2 10             	shl    edx,0x10
  20f528:	09 ca                	or     edx,ecx
  20f52a:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f52f:	c1 e0 18             	shl    eax,0x18
  20f532:	09 d0                	or     eax,edx
  20f534:	eb 19                	jmp    20f54f <openSelfDebugInfo+0x3b1f>
                result = (result << 8) | b;
  20f536:	c1 e0 08             	shl    eax,0x8
  20f539:	09 c8                	or     eax,ecx
  20f53b:	c1 e0 08             	shl    eax,0x8
  20f53e:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f543:	09 c1                	or     ecx,eax
  20f545:	c1 e1 08             	shl    ecx,0x8
  20f548:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f54d:	09 c8                	or     eax,ecx
  20f54f:	89 c0                	mov    eax,eax
  20f551:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f556:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f55b:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  20f560:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f565:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f568:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f56c:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f571:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f576:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f57d:	00 00 
            return self.readFn(self, buffer);
  20f57f:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f586:	00 
  20f587:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f58c:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f591:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f595:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f59c:	00 
            const amt_read = try self.read(buf);
  20f59d:	66 85 ed             	test   bp,bp
  20f5a0:	0f 85 3a 05 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20f5a6:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f5ad:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f5ae:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f5b3:	0f 82 23 05 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20f5b9:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f5be:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f5c3:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f5c8:	74 1b                	je     20f5e5 <openSelfDebugInfo+0x3bb5>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f5ca:	c1 e1 08             	shl    ecx,0x8
  20f5cd:	09 c1                	or     ecx,eax
  20f5cf:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f5d4:	c1 e2 10             	shl    edx,0x10
  20f5d7:	09 ca                	or     edx,ecx
  20f5d9:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f5de:	c1 e0 18             	shl    eax,0x18
  20f5e1:	09 d0                	or     eax,edx
  20f5e3:	eb 19                	jmp    20f5fe <openSelfDebugInfo+0x3bce>
                result = (result << 8) | b;
  20f5e5:	c1 e0 08             	shl    eax,0x8
  20f5e8:	09 c8                	or     eax,ecx
  20f5ea:	c1 e0 08             	shl    eax,0x8
  20f5ed:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f5f2:	09 c1                	or     ecx,eax
  20f5f4:	c1 e1 08             	shl    ecx,0x8
  20f5f7:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f5fc:	09 c8                	or     eax,ecx
  20f5fe:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f603:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f608:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  20f60c:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f611:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f614:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f618:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f61d:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f622:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f629:	00 00 
            return self.readFn(self, buffer);
  20f62b:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f632:	00 
  20f633:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f638:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f63d:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f641:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f648:	00 
            const amt_read = try self.read(buf);
  20f649:	66 85 ed             	test   bp,bp
  20f64c:	0f 85 8e 04 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20f652:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f659:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f65a:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f65f:	0f 82 77 04 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20f665:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f66a:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f66f:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f674:	74 1b                	je     20f691 <openSelfDebugInfo+0x3c61>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f676:	c1 e1 08             	shl    ecx,0x8
  20f679:	09 c1                	or     ecx,eax
  20f67b:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f680:	c1 e2 10             	shl    edx,0x10
  20f683:	09 ca                	or     edx,ecx
  20f685:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f68a:	c1 e0 18             	shl    eax,0x18
  20f68d:	09 d0                	or     eax,edx
  20f68f:	eb 19                	jmp    20f6aa <openSelfDebugInfo+0x3c7a>
                result = (result << 8) | b;
  20f691:	c1 e0 08             	shl    eax,0x8
  20f694:	09 c8                	or     eax,ecx
  20f696:	c1 e0 08             	shl    eax,0x8
  20f699:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f69e:	09 c1                	or     ecx,eax
  20f6a0:	c1 e1 08             	shl    ecx,0x8
  20f6a3:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f6a8:	09 c8                	or     eax,ecx
  20f6aa:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f6af:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f6b4:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = u64(try in.readInt(elf.endian, u32));
  20f6b8:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f6bd:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f6c0:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f6c4:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f6c9:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f6ce:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f6d5:	00 00 
            return self.readFn(self, buffer);
  20f6d7:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f6de:	00 
  20f6df:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f6e4:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f6e9:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f6ed:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f6f4:	00 
            const amt_read = try self.read(buf);
  20f6f5:	66 85 ed             	test   bp,bp
  20f6f8:	0f 85 e2 03 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20f6fe:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f705:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f706:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f70b:	0f 82 cb 03 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20f711:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f716:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f71b:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f720:	74 1b                	je     20f73d <openSelfDebugInfo+0x3d0d>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f722:	c1 e1 08             	shl    ecx,0x8
  20f725:	09 c1                	or     ecx,eax
  20f727:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f72c:	c1 e2 10             	shl    edx,0x10
  20f72f:	09 ca                	or     edx,ecx
  20f731:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f736:	c1 e0 18             	shl    eax,0x18
  20f739:	09 d0                	or     eax,edx
  20f73b:	eb 19                	jmp    20f756 <openSelfDebugInfo+0x3d26>
                result = (result << 8) | b;
  20f73d:	c1 e0 08             	shl    eax,0x8
  20f740:	09 c8                	or     eax,ecx
  20f742:	c1 e0 08             	shl    eax,0x8
  20f745:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f74a:	09 c1                	or     ecx,eax
  20f74c:	c1 e1 08             	shl    ecx,0x8
  20f74f:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f754:	09 c8                	or     eax,ecx
  20f756:	89 c0                	mov    eax,eax
  20f758:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f75d:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f762:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = u64(try in.readInt(elf.endian, u32));
  20f767:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f76c:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f76f:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f773:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f778:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f77d:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f784:	00 00 
            return self.readFn(self, buffer);
  20f786:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f78d:	00 
  20f78e:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f793:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f798:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f79c:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f7a3:	00 
            const amt_read = try self.read(buf);
  20f7a4:	66 85 ed             	test   bp,bp
  20f7a7:	0f 85 33 03 00 00    	jne    20fae0 <openSelfDebugInfo+0x40b0>
  20f7ad:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f7b4:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f7b5:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f7ba:	0f 82 1c 03 00 00    	jb     20fadc <openSelfDebugInfo+0x40ac>
  20f7c0:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f7c5:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f7ca:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f7cf:	74 1b                	je     20f7ec <openSelfDebugInfo+0x3dbc>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f7d1:	c1 e1 08             	shl    ecx,0x8
  20f7d4:	09 c1                	or     ecx,eax
  20f7d6:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f7db:	c1 e2 10             	shl    edx,0x10
  20f7de:	09 ca                	or     edx,ecx
  20f7e0:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f7e5:	c1 e0 18             	shl    eax,0x18
  20f7e8:	09 d0                	or     eax,edx
  20f7ea:	eb 19                	jmp    20f805 <openSelfDebugInfo+0x3dd5>
                result = (result << 8) | b;
  20f7ec:	c1 e0 08             	shl    eax,0x8
  20f7ef:	09 c8                	or     eax,ecx
  20f7f1:	c1 e0 08             	shl    eax,0x8
  20f7f4:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f7f9:	09 c1                	or     ecx,eax
  20f7fb:	c1 e1 08             	shl    ecx,0x8
  20f7fe:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f803:	09 c8                	or     eax,ecx
  20f805:	89 c0                	mov    eax,eax
  20f807:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f80c:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f811:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  20f815:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  20f81c:	00 
  20f81d:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  20f820:	48 83 c1 01          	add    rcx,0x1
  20f824:	48 89 c8             	mov    rax,rcx
  20f827:	48 89 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rax
  20f82e:	00 
  20f82f:	48 3b 4c 24 38       	cmp    rcx,QWORD PTR [rsp+0x38]
  20f834:	0f 83 cd 02 00 00    	jae    20fb07 <openSelfDebugInfo+0x40d7>
  20f83a:	48 83 44 24 40 40    	add    QWORD PTR [rsp+0x40],0x40
  20f840:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  20f845:	48 8b 00             	mov    rax,QWORD PTR [rax]
                elf_section.name = try in.readInt(elf.endian, u32);
  20f848:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20f84d:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f852:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f855:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f859:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f85e:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f863:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f86a:	00 00 
            return self.readFn(self, buffer);
  20f86c:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f873:	00 
  20f874:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f879:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f87e:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f882:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f889:	00 
  20f88a:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f891:	00 
            const amt_read = try self.read(buf);
  20f892:	66 85 ed             	test   bp,bp
  20f895:	0f 84 ff f8 ff ff    	je     20f19a <openSelfDebugInfo+0x376a>
  20f89b:	e9 40 02 00 00       	jmp    20fae0 <openSelfDebugInfo+0x40b0>
        const bytes = @sliceToBytes(memory);
  20f8a0:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20f8a5:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f8a8:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f8ac:	0f 84 28 c4 ff ff    	je     20bcda <openSelfDebugInfo+0x2aa>
  20f8b2:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20f8b7:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20f8ba:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20f8bf:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f8c2:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20f8c6:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20f8cd:	00 
  20f8ce:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20f8d5:	00 
  20f8d6:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20f8dd:	00 
  20f8de:	ff d2                	call   rdx
                elf_section.flags = try in.readInt(elf.endian, u64);
  20f8e0:	0f b7 ac 24 48 03 00 	movzx  ebp,WORD PTR [rsp+0x348]
  20f8e7:	00 
  20f8e8:	66 85 ed             	test   bp,bp
  20f8eb:	0f 85 f2 c3 ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
  20f8f1:	e9 64 ca ff ff       	jmp    20c35a <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  20f8f6:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20f8fb:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f8fe:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f902:	0f 84 d2 c3 ff ff    	je     20bcda <openSelfDebugInfo+0x2aa>
  20f908:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20f90d:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20f910:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20f915:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f918:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20f91c:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20f923:	00 
  20f924:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20f92b:	00 
  20f92c:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20f933:	00 
  20f934:	ff d2                	call   rdx
                elf_section.addr = try in.readInt(elf.endian, u64);
  20f936:	0f b7 ac 24 10 03 00 	movzx  ebp,WORD PTR [rsp+0x310]
  20f93d:	00 
  20f93e:	66 85 ed             	test   bp,bp
  20f941:	0f 85 9c c3 ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
  20f947:	e9 0e ca ff ff       	jmp    20c35a <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  20f94c:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20f951:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f954:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f958:	0f 84 7c c3 ff ff    	je     20bcda <openSelfDebugInfo+0x2aa>
  20f95e:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20f963:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20f966:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20f96b:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f96e:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20f972:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20f979:	00 
  20f97a:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20f981:	00 
  20f982:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20f989:	00 
  20f98a:	ff d2                	call   rdx
                elf_section.offset = try in.readInt(elf.endian, u64);
  20f98c:	0f b7 ac 24 f0 02 00 	movzx  ebp,WORD PTR [rsp+0x2f0]
  20f993:	00 
  20f994:	66 85 ed             	test   bp,bp
  20f997:	0f 85 46 c3 ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
  20f99d:	e9 b8 c9 ff ff       	jmp    20c35a <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  20f9a2:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20f9a7:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f9aa:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f9ae:	0f 84 26 c3 ff ff    	je     20bcda <openSelfDebugInfo+0x2aa>
  20f9b4:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20f9b9:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20f9bc:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20f9c1:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f9c4:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20f9c8:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20f9cf:	00 
  20f9d0:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20f9d7:	00 
  20f9d8:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20f9df:	00 
  20f9e0:	ff d2                	call   rdx
                elf_section.size = try in.readInt(elf.endian, u64);
  20f9e2:	0f b7 ac 24 88 01 00 	movzx  ebp,WORD PTR [rsp+0x188]
  20f9e9:	00 
  20f9ea:	66 85 ed             	test   bp,bp
  20f9ed:	0f 85 f0 c2 ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
  20f9f3:	e9 62 c9 ff ff       	jmp    20c35a <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  20f9f8:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20f9fd:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20fa00:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20fa04:	0f 84 d0 c2 ff ff    	je     20bcda <openSelfDebugInfo+0x2aa>
  20fa0a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20fa0f:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20fa12:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20fa17:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20fa1a:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20fa1e:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20fa25:	00 
  20fa26:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20fa2d:	00 
  20fa2e:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20fa35:	00 
  20fa36:	ff d2                	call   rdx
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  20fa38:	0f b7 ac 24 c0 01 00 	movzx  ebp,WORD PTR [rsp+0x1c0]
  20fa3f:	00 
  20fa40:	66 85 ed             	test   bp,bp
  20fa43:	0f 85 9a c2 ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
  20fa49:	e9 0c c9 ff ff       	jmp    20c35a <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  20fa4e:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20fa53:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20fa56:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20fa5a:	0f 84 7a c2 ff ff    	je     20bcda <openSelfDebugInfo+0x2aa>
  20fa60:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20fa65:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20fa68:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20fa6d:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20fa70:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20fa74:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20fa7b:	00 
  20fa7c:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20fa83:	00 
  20fa84:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20fa8b:	00 
  20fa8c:	ff d2                	call   rdx
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  20fa8e:	0f b7 ac 24 a0 01 00 	movzx  ebp,WORD PTR [rsp+0x1a0]
  20fa95:	00 
  20fa96:	66 85 ed             	test   bp,bp
  20fa99:	0f 85 44 c2 ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
  20fa9f:	e9 b6 c8 ff ff       	jmp    20c35a <openSelfDebugInfo+0x92a>
  20faa4:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  20faa9:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  20faac:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20fab0:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20fab5:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20fabc:	00 
  20fabd:	48 8b 8c 24 38 01 00 	mov    rcx,QWORD PTR [rsp+0x138]
  20fac4:	00 
  20fac5:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  20facc:	00 
  20facd:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20fad4:	00 
  20fad5:	ff d0                	call   rax
  20fad7:	e9 2e 01 00 00       	jmp    20fc0a <openSelfDebugInfo+0x41da>
  20fadc:	66 bd 20 00          	mov    bp,0x20
        const bytes = @sliceToBytes(memory);
  20fae0:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20fae5:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20fae8:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20faec:	0f 84 f1 c1 ff ff    	je     20bce3 <openSelfDebugInfo+0x2b3>
  20faf2:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20faf7:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20fafa:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20faff:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
  20fb02:	e9 b4 00 00 00       	jmp    20fbbb <openSelfDebugInfo+0x418b>
        for (elf.section_headers) |*elf_section| {
  20fb07:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20fb0c:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20fb0f:	48 85 c0             	test   rax,rax
  20fb12:	74 66                	je     20fb7a <openSelfDebugInfo+0x414a>
  20fb14:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20fb19:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
  20fb1c:	48 8d 51 20          	lea    rdx,[rcx+0x20]
  20fb20:	31 f6                	xor    esi,esi
  20fb22:	4c 8d 05 a7 0c ff ff 	lea    r8,[rip+0xffffffffffff0ca7]        # 2007d0 <__unnamed_59>
            if (elf_section.sh_type != SHT_NOBITS) {
  20fb29:	83 7a e4 08          	cmp    DWORD PTR [rdx-0x1c],0x8
  20fb2d:	74 3c                	je     20fb6b <openSelfDebugInfo+0x413b>
                const file_end_offset = try math.add(u64, elf_section.offset, elf_section.size);
  20fb2f:	48 8b 6a f8          	mov    rbp,QWORD PTR [rdx-0x8]
  20fb33:	4c 89 c7             	mov    rdi,r8
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  20fb36:	48 03 2a             	add    rbp,QWORD PTR [rdx]
  20fb39:	72 1a                	jb     20fb55 <openSelfDebugInfo+0x4125>
  20fb3b:	66 c7 84 24 a0 00 00 	mov    WORD PTR [rsp+0xa0],0x0
  20fb42:	00 00 00 
  20fb45:	48 89 ac 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rbp
  20fb4c:	00 
  20fb4d:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20fb54:	00 
  20fb55:	0f b7 2f             	movzx  ebp,WORD PTR [rdi]
  20fb58:	66 85 ed             	test   bp,bp
  20fb5b:	75 4c                	jne    20fba9 <openSelfDebugInfo+0x4179>
                if (stream_end < file_end_offset) return error.InvalidFormat;
  20fb5d:	48 8b ac 24 60 01 00 	mov    rbp,QWORD PTR [rsp+0x160]
  20fb64:	00 
  20fb65:	48 3b 6f 08          	cmp    rbp,QWORD PTR [rdi+0x8]
  20fb69:	72 73                	jb     20fbde <openSelfDebugInfo+0x41ae>
        for (elf.section_headers) |*elf_section| {
  20fb6b:	48 83 c6 01          	add    rsi,0x1
  20fb6f:	48 83 c2 40          	add    rdx,0x40
  20fb73:	48 39 c6             	cmp    rsi,rax
  20fb76:	72 b1                	jb     20fb29 <openSelfDebugInfo+0x40f9>
  20fb78:	eb 08                	jmp    20fb82 <openSelfDebugInfo+0x4152>
        elf.string_section = &elf.section_headers[elf.string_section_index];
  20fb7a:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20fb7f:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
  20fb82:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  20fb86:	48 c1 e2 06          	shl    rdx,0x6
  20fb8a:	48 8d 34 11          	lea    rsi,[rcx+rdx*1]
  20fb8e:	48 89 73 38          	mov    QWORD PTR [rbx+0x38],rsi
        if (elf.string_section.sh_type != SHT_STRTAB) {
  20fb92:	83 7c 11 04 03       	cmp    DWORD PTR [rcx+rdx*1+0x4],0x3
  20fb97:	75 45                	jne    20fbde <openSelfDebugInfo+0x41ae>
  20fb99:	31 ed                	xor    ebp,ebp
  20fb9b:	66 85 ed             	test   bp,bp
  20fb9e:	0f 85 3f c1 ff ff    	jne    20bce3 <openSelfDebugInfo+0x2b3>
  20fba4:	e9 b1 c7 ff ff       	jmp    20c35a <openSelfDebugInfo+0x92a>
  20fba9:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20fbad:	0f 84 30 c1 ff ff    	je     20bce3 <openSelfDebugInfo+0x2b3>
  20fbb3:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20fbb8:	48 8b 3a             	mov    rdi,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20fbbb:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20fbbf:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20fbc6:	00 
  20fbc7:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20fbce:	00 
  20fbcf:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20fbd6:	00 
  20fbd7:	ff d2                	call   rdx
  20fbd9:	e9 05 c1 ff ff       	jmp    20bce3 <openSelfDebugInfo+0x2b3>
        const bytes = @sliceToBytes(memory);
  20fbde:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20fbe2:	74 26                	je     20fc0a <openSelfDebugInfo+0x41da>
  20fbe4:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20fbe9:	48 8b 3a             	mov    rdi,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20fbec:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20fbf0:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20fbf7:	00 
  20fbf8:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20fbff:	00 
  20fc00:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20fc07:	00 
  20fc08:	ff d2                	call   rdx
  20fc0a:	66 bd 21 00          	mov    bp,0x21
  20fc0e:	e9 d0 c0 ff ff       	jmp    20bce3 <openSelfDebugInfo+0x2b3>
  20fc13:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20fc1a:	84 00 00 00 00 00 

000000000020fc20 <Elf_findSection>:
    }

    pub fn findSection(elf: *Elf, name: []const u8) !?*SectionHeader {
  20fc20:	55                   	push   rbp
  20fc21:	41 57                	push   r15
  20fc23:	41 56                	push   r14
  20fc25:	41 55                	push   r13
  20fc27:	41 54                	push   r12
  20fc29:	53                   	push   rbx
  20fc2a:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  20fc31:	48 89 d3             	mov    rbx,rdx
  20fc34:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
        var file_stream = io.FileInStream.init(elf.in_file);
  20fc39:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  20fc3c:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20fc41:	48 8d 05 18 09 00 00 	lea    rax,[rip+0x918]        # 210560 <FileInStream_readFn>
  20fc48:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
        const in = &file_stream.stream;

        section_loop: for (elf.section_headers) |*elf_section| {
  20fc4d:	48 8b 46 40          	mov    rax,QWORD PTR [rsi+0x40]
  20fc51:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  20fc56:	48 85 c0             	test   rax,rax
  20fc59:	0f 84 37 01 00 00    	je     20fd96 <Elf_findSection+0x176>
  20fc5f:	45 31 e4             	xor    r12d,r12d
  20fc62:	48 89 74 24 20       	mov    QWORD PTR [rsp+0x20],rsi
  20fc67:	4c 8b 76 38          	mov    r14,QWORD PTR [rsi+0x38]
  20fc6b:	4c 89 e0             	mov    rax,r12
  20fc6e:	48 c1 e0 06          	shl    rax,0x6
            if (elf_section.sh_type == SHT_NULL) continue;
  20fc72:	41 83 7c 06 04 00    	cmp    DWORD PTR [r14+rax*1+0x4],0x0
  20fc78:	0f 84 04 01 00 00    	je     20fd82 <Elf_findSection+0x162>
  20fc7e:	49 01 c6             	add    r14,rax
  20fc81:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]

            const name_offset = elf.string_section.offset + elf_section.name;
  20fc86:	48 8b 41 30          	mov    rax,QWORD PTR [rcx+0x30]
  20fc8a:	41 8b 36             	mov    esi,DWORD PTR [r14]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  20fc8d:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  20fc91:	0f 88 3e 01 00 00    	js     20fdd5 <Elf_findSection+0x1b5>
            try elf.in_file.seekTo(name_offset);
  20fc97:	48 8b 01             	mov    rax,QWORD PTR [rcx]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20fc9a:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20fc9d:	b8 08 00 00 00       	mov    eax,0x8
  20fca2:	31 d2                	xor    edx,edx
  20fca4:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20fca6:	48 89 c1             	mov    rcx,rax
  20fca9:	48 f7 d9             	neg    rcx
  20fcac:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20fcb2:	b8 00 00 00 00       	mov    eax,0x0
  20fcb7:	48 0f 46 c8          	cmovbe rcx,rax
  20fcbb:	48 85 c9             	test   rcx,rcx
  20fcbe:	0f 85 1c 01 00 00    	jne    20fde0 <Elf_findSection+0x1c0>

            for (name) |expected_c| {
  20fcc4:	4c 8b 6b 08          	mov    r13,QWORD PTR [rbx+0x8]
  20fcc8:	4d 85 ed             	test   r13,r13
  20fccb:	74 66                	je     20fd33 <Elf_findSection+0x113>
  20fccd:	31 ed                	xor    ebp,ebp
  20fccf:	90                   	nop
  20fcd0:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  20fcd3:	44 0f b6 3c 28       	movzx  r15d,BYTE PTR [rax+rbp*1]
            try self.readNoEof(result[0..]);
  20fcd8:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20fcdd:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20fce2:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20fce9:	00 00 
            return self.readFn(self, buffer);
  20fceb:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  20fcf0:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20fcf5:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20fcfa:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  20fcfe:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  20fd03:	66 85 c0             	test   ax,ax
  20fd06:	0f 85 9d 00 00 00    	jne    20fda9 <Elf_findSection+0x189>
  20fd0c:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  20fd11:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  20fd16:	0f 82 89 00 00 00    	jb     20fda5 <Elf_findSection+0x185>
            return result[0];
  20fd1c:	0f b6 44 24 07       	movzx  eax,BYTE PTR [rsp+0x7]
                const target_c = try in.readByte();
                if (target_c == 0 or expected_c != target_c) continue :section_loop;
  20fd21:	84 c0                	test   al,al
  20fd23:	74 5d                	je     20fd82 <Elf_findSection+0x162>
  20fd25:	41 38 c7             	cmp    r15b,al
  20fd28:	75 58                	jne    20fd82 <Elf_findSection+0x162>
  20fd2a:	48 83 c5 01          	add    rbp,0x1
            for (name) |expected_c| {
  20fd2e:	4c 39 ed             	cmp    rbp,r13
  20fd31:	72 9d                	jb     20fcd0 <Elf_findSection+0xb0>
            try self.readNoEof(result[0..]);
  20fd33:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20fd38:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20fd3d:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20fd44:	00 00 
            return self.readFn(self, buffer);
  20fd46:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  20fd4b:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20fd50:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20fd55:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  20fd59:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  20fd5e:	66 85 c0             	test   ax,ax
  20fd61:	0f 85 a6 00 00 00    	jne    20fe0d <Elf_findSection+0x1ed>
  20fd67:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  20fd6c:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  20fd71:	0f 82 92 00 00 00    	jb     20fe09 <Elf_findSection+0x1e9>
            }

            {
                const null_byte = try in.readByte();
                if (null_byte == 0) return elf_section;
  20fd77:	80 7c 24 07 00       	cmp    BYTE PTR [rsp+0x7],0x0
  20fd7c:	0f 84 9f 00 00 00    	je     20fe21 <Elf_findSection+0x201>
        section_loop: for (elf.section_headers) |*elf_section| {
  20fd82:	49 83 c4 01          	add    r12,0x1
  20fd86:	4c 3b 64 24 50       	cmp    r12,QWORD PTR [rsp+0x50]
  20fd8b:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  20fd90:	0f 82 d1 fe ff ff    	jb     20fc67 <Elf_findSection+0x47>
            }
        }

        return null;
  20fd96:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  20fd9a:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  20fd9f:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  20fda3:	eb 1e                	jmp    20fdc3 <Elf_findSection+0x1a3>
  20fda5:	66 b8 20 00          	mov    ax,0x20
  20fda9:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const target_c = try in.readByte();
  20fdae:	66 89 02             	mov    WORD PTR [rdx],ax
  20fdb1:	48 8b 44 24 6c       	mov    rax,QWORD PTR [rsp+0x6c]
  20fdb6:	48 8b 4c 24 72       	mov    rcx,QWORD PTR [rsp+0x72]
  20fdbb:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  20fdbf:	48 89 42 02          	mov    QWORD PTR [rdx+0x2],rax
  20fdc3:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20fdca:	5b                   	pop    rbx
  20fdcb:	41 5c                	pop    r12
  20fdcd:	41 5d                	pop    r13
  20fdcf:	41 5e                	pop    r14
  20fdd1:	41 5f                	pop    r15
  20fdd3:	5d                   	pop    rbp
  20fdd4:	c3                   	ret    
  20fdd5:	66 b8 23 00          	mov    ax,0x23
  20fdd9:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  20fdde:	eb 72                	jmp    20fe52 <Elf_findSection+0x232>
  20fde0:	66 b8 02 00          	mov    ax,0x2
  20fde4:	48 8d 51 fa          	lea    rdx,[rcx-0x6]
  20fde8:	48 83 fa 17          	cmp    rdx,0x17
  20fdec:	77 53                	ja     20fe41 <Elf_findSection+0x221>
  20fdee:	48 8d 0d c7 14 ff ff 	lea    rcx,[rip+0xffffffffffff14c7]        # 2012bc <__unnamed_9+0x5dc>
  20fdf5:	48 63 14 91          	movsxd rdx,DWORD PTR [rcx+rdx*4]
  20fdf9:	48 01 ca             	add    rdx,rcx
  20fdfc:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  20fe01:	ff e2                	jmp    rdx
  20fe03:	66 b8 22 00          	mov    ax,0x22
  20fe07:	eb 49                	jmp    20fe52 <Elf_findSection+0x232>
  20fe09:	66 b8 20 00          	mov    ax,0x20
  20fe0d:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const null_byte = try in.readByte();
  20fe12:	66 89 02             	mov    WORD PTR [rdx],ax
  20fe15:	48 8b 44 24 5e       	mov    rax,QWORD PTR [rsp+0x5e]
  20fe1a:	48 8b 4c 24 64       	mov    rcx,QWORD PTR [rsp+0x64]
  20fe1f:	eb 9a                	jmp    20fdbb <Elf_findSection+0x19b>
  20fe21:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
                if (null_byte == 0) return elf_section;
  20fe26:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  20fe2b:	0f b7 44 24 4e       	movzx  eax,WORD PTR [rsp+0x4e]
  20fe30:	66 89 41 06          	mov    WORD PTR [rcx+0x6],ax
  20fe34:	8b 44 24 4a          	mov    eax,DWORD PTR [rsp+0x4a]
  20fe38:	89 41 02             	mov    DWORD PTR [rcx+0x2],eax
  20fe3b:	4c 89 71 08          	mov    QWORD PTR [rcx+0x8],r14
  20fe3f:	eb 82                	jmp    20fdc3 <Elf_findSection+0x1a3>
  20fe41:	48 83 f9 4b          	cmp    rcx,0x4b
  20fe45:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  20fe4a:	74 b7                	je     20fe03 <Elf_findSection+0x1e3>
  20fe4c:	eb 04                	jmp    20fe52 <Elf_findSection+0x232>
  20fe4e:	66 b8 1e 00          	mov    ax,0x1e
            try elf.in_file.seekTo(name_offset);
  20fe52:	66 89 06             	mov    WORD PTR [rsi],ax
  20fe55:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  20fe5a:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20fe61:	00 
  20fe62:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
  20fe66:	48 89 46 02          	mov    QWORD PTR [rsi+0x2],rax
  20fe6a:	e9 54 ff ff ff       	jmp    20fdc3 <Elf_findSection+0x1a3>
  20fe6f:	90                   	nop

000000000020fe70 <File_openRead>:
    pub fn openRead(allocator: *mem.Allocator, path: []const u8) OpenError!File {
  20fe70:	55                   	push   rbp
  20fe71:	41 57                	push   r15
  20fe73:	41 56                	push   r14
  20fe75:	41 54                	push   r12
  20fe77:	53                   	push   rbx
  20fe78:	48 83 ec 20          	sub    rsp,0x20
  20fe7c:	48 89 d3             	mov    rbx,rdx
  20fe7f:	49 89 f7             	mov    r15,rsi
  20fe82:	49 89 fe             	mov    r14,rdi
}

/// Returns a mutable slice with 1 more byte of length which is a null byte.
/// Caller owns the returned memory.
pub fn addNullByte(allocator: *mem.Allocator, slice: []const u8) ![]u8 {
    const result = try allocator.alloc(u8, slice.len + 1);
  20fe85:	4c 8b 63 08          	mov    r12,QWORD PTR [rbx+0x8]
  20fe89:	49 83 c4 01          	add    r12,0x1
  20fe8d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20fe92:	b9 01 00 00 00       	mov    ecx,0x1
  20fe97:	4c 89 e2             	mov    rdx,r12
  20fe9a:	41 ff 17             	call   QWORD PTR [r15]
  20fe9d:	0f b7 6c 24 08       	movzx  ebp,WORD PTR [rsp+0x8]
  20fea2:	66 85 ed             	test   bp,bp
  20fea5:	0f 85 95 01 00 00    	jne    210040 <File_openRead+0x1d0>
        assert(byte_slice.len == byte_count);
  20feab:	4c 39 64 24 18       	cmp    QWORD PTR [rsp+0x18],r12
    if (!ok) {
  20feb0:	0f 85 b9 01 00 00    	jne    21006f <File_openRead+0x1ff>
    assert(dest.len >= source.len);
  20feb6:	48 8b 6b 08          	mov    rbp,QWORD PTR [rbx+0x8]
  20feba:	49 39 ec             	cmp    r12,rbp
  20febd:	0f 82 ac 01 00 00    	jb     21006f <File_openRead+0x1ff>
  20fec3:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
    for (source) |s, i|
  20fec8:	48 85 ed             	test   rbp,rbp
  20fecb:	74 1f                	je     20feec <File_openRead+0x7c>
  20fecd:	48 8d 4d ff          	lea    rcx,[rbp-0x1]
  20fed1:	89 e8                	mov    eax,ebp
  20fed3:	83 e0 07             	and    eax,0x7
  20fed6:	48 83 f9 07          	cmp    rcx,0x7
  20feda:	73 17                	jae    20fef3 <File_openRead+0x83>
  20fedc:	31 c9                	xor    ecx,ecx
  20fede:	48 85 c0             	test   rax,rax
  20fee1:	0f 85 85 00 00 00    	jne    20ff6c <File_openRead+0xfc>
  20fee7:	e9 98 00 00 00       	jmp    20ff84 <File_openRead+0x114>
  20feec:	31 c0                	xor    eax,eax
  20feee:	e9 95 00 00 00       	jmp    20ff88 <File_openRead+0x118>
  20fef3:	48 29 c5             	sub    rbp,rax
  20fef6:	31 c9                	xor    ecx,ecx
  20fef8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20feff:	00 
  20ff00:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  20ff03:	0f b6 14 0e          	movzx  edx,BYTE PTR [rsi+rcx*1]
        dest[i] = s;
  20ff07:	88 14 0f             	mov    BYTE PTR [rdi+rcx*1],dl
    for (source) |s, i|
  20ff0a:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20ff0d:	0f b6 54 0a 01       	movzx  edx,BYTE PTR [rdx+rcx*1+0x1]
        dest[i] = s;
  20ff12:	88 54 0f 01          	mov    BYTE PTR [rdi+rcx*1+0x1],dl
    for (source) |s, i|
  20ff16:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20ff19:	0f b6 54 0a 02       	movzx  edx,BYTE PTR [rdx+rcx*1+0x2]
        dest[i] = s;
  20ff1e:	88 54 0f 02          	mov    BYTE PTR [rdi+rcx*1+0x2],dl
    for (source) |s, i|
  20ff22:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20ff25:	0f b6 54 0a 03       	movzx  edx,BYTE PTR [rdx+rcx*1+0x3]
        dest[i] = s;
  20ff2a:	88 54 0f 03          	mov    BYTE PTR [rdi+rcx*1+0x3],dl
    for (source) |s, i|
  20ff2e:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20ff31:	0f b6 54 0a 04       	movzx  edx,BYTE PTR [rdx+rcx*1+0x4]
        dest[i] = s;
  20ff36:	88 54 0f 04          	mov    BYTE PTR [rdi+rcx*1+0x4],dl
    for (source) |s, i|
  20ff3a:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20ff3d:	0f b6 54 0a 05       	movzx  edx,BYTE PTR [rdx+rcx*1+0x5]
        dest[i] = s;
  20ff42:	88 54 0f 05          	mov    BYTE PTR [rdi+rcx*1+0x5],dl
    for (source) |s, i|
  20ff46:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20ff49:	0f b6 54 0a 06       	movzx  edx,BYTE PTR [rdx+rcx*1+0x6]
        dest[i] = s;
  20ff4e:	88 54 0f 06          	mov    BYTE PTR [rdi+rcx*1+0x6],dl
    for (source) |s, i|
  20ff52:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20ff55:	0f b6 54 0a 07       	movzx  edx,BYTE PTR [rdx+rcx*1+0x7]
        dest[i] = s;
  20ff5a:	88 54 0f 07          	mov    BYTE PTR [rdi+rcx*1+0x7],dl
    for (source) |s, i|
  20ff5e:	48 83 c1 08          	add    rcx,0x8
  20ff62:	48 39 cd             	cmp    rbp,rcx
  20ff65:	75 99                	jne    20ff00 <File_openRead+0x90>
  20ff67:	48 85 c0             	test   rax,rax
  20ff6a:	74 18                	je     20ff84 <File_openRead+0x114>
  20ff6c:	48 f7 d8             	neg    rax
  20ff6f:	90                   	nop
  20ff70:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20ff73:	0f b6 14 0a          	movzx  edx,BYTE PTR [rdx+rcx*1]
        dest[i] = s;
  20ff77:	88 14 0f             	mov    BYTE PTR [rdi+rcx*1],dl
    for (source) |s, i|
  20ff7a:	48 83 c1 01          	add    rcx,0x1
  20ff7e:	48 83 c0 01          	add    rax,0x1
  20ff82:	75 ec                	jne    20ff70 <File_openRead+0x100>
    mem.copy(u8, result, slice);
    result[slice.len] = 0;
  20ff84:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]
  20ff88:	c6 04 07 00          	mov    BYTE PTR [rdi+rax*1],0x0
  20ff8c:	31 ed                	xor    ebp,ebp
  20ff8e:	66 90                	xchg   ax,ax
  20ff90:	b8 02 00 00 00       	mov    eax,0x2
  20ff95:	be 00 00 00 00       	mov    esi,0x0
  20ff9a:	31 d2                	xor    edx,edx
  20ff9c:	0f 05                	syscall 
  20ff9e:	48 89 c3             	mov    rbx,rax
  20ffa1:	48 f7 d8             	neg    rax
  20ffa4:	48 81 fb 00 f0 ff ff 	cmp    rbx,0xfffffffffffff000
  20ffab:	48 0f 46 c5          	cmovbe rax,rbp
        if (err > 0) {
  20ffaf:	48 83 f8 04          	cmp    rax,0x4
  20ffb3:	74 db                	je     20ff90 <File_openRead+0x120>
  20ffb5:	48 83 f8 4b          	cmp    rax,0x4b
  20ffb9:	77 62                	ja     21001d <File_openRead+0x1ad>
  20ffbb:	48 8d 0d 5a 13 ff ff 	lea    rcx,[rip+0xffffffffffff135a]        # 20131c <__unnamed_9+0x63c>
  20ffc2:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  20ffc6:	48 01 c8             	add    rax,rcx
  20ffc9:	ff e0                	jmp    rax
  20ffcb:	66 bd 10 00          	mov    bp,0x10
  20ffcf:	eb 50                	jmp    210021 <File_openRead+0x1b1>
  20ffd1:	66 bd 0d 00          	mov    bp,0xd
  20ffd5:	eb 4a                	jmp    210021 <File_openRead+0x1b1>
  20ffd7:	66 bd 13 00          	mov    bp,0x13
  20ffdb:	eb 44                	jmp    210021 <File_openRead+0x1b1>
  20ffdd:	66 bd 1a 00          	mov    bp,0x1a
  20ffe1:	eb 3e                	jmp    210021 <File_openRead+0x1b1>
  20ffe3:	66 bd 18 00          	mov    bp,0x18
  20ffe7:	eb 38                	jmp    210021 <File_openRead+0x1b1>
  20ffe9:	66 bd 0f 00          	mov    bp,0xf
  20ffed:	eb 32                	jmp    210021 <File_openRead+0x1b1>
  20ffef:	66 bd 17 00          	mov    bp,0x17
  20fff3:	eb 2c                	jmp    210021 <File_openRead+0x1b1>
  20fff5:	31 ed                	xor    ebp,ebp
  20fff7:	eb 2a                	jmp    210023 <File_openRead+0x1b3>
  20fff9:	66 bd 1c 00          	mov    bp,0x1c
  20fffd:	eb 22                	jmp    210021 <File_openRead+0x1b1>
  20ffff:	66 bd 04 00          	mov    bp,0x4
  210003:	eb 1c                	jmp    210021 <File_openRead+0x1b1>
  210005:	66 bd 1b 00          	mov    bp,0x1b
  210009:	eb 16                	jmp    210021 <File_openRead+0x1b1>
  21000b:	66 bd 1d 00          	mov    bp,0x1d
  21000f:	eb 10                	jmp    210021 <File_openRead+0x1b1>
  210011:	66 bd 19 00          	mov    bp,0x19
  210015:	eb 0a                	jmp    210021 <File_openRead+0x1b1>
  210017:	66 bd 16 00          	mov    bp,0x16
  21001b:	eb 04                	jmp    210021 <File_openRead+0x1b1>
  21001d:	66 bd 02 00          	mov    bp,0x2
  210021:	31 db                	xor    ebx,ebx
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  210023:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  210027:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  21002c:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  210031:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  210036:	4c 89 ff             	mov    rdi,r15
  210039:	ff d0                	call   rax
            const fd = try os.posixOpen(allocator, path, flags, 0);
  21003b:	66 85 ed             	test   bp,bp
  21003e:	74 23                	je     210063 <File_openRead+0x1f3>
  210040:	66 41 89 2e          	mov    WORD PTR [r14],bp
  210044:	0f b7 44 24 06       	movzx  eax,WORD PTR [rsp+0x6]
  210049:	66 41 89 46 06       	mov    WORD PTR [r14+0x6],ax
  21004e:	8b 44 24 02          	mov    eax,DWORD PTR [rsp+0x2]
  210052:	41 89 46 02          	mov    DWORD PTR [r14+0x2],eax
  210056:	48 83 c4 20          	add    rsp,0x20
  21005a:	5b                   	pop    rbx
  21005b:	41 5c                	pop    r12
  21005d:	41 5e                	pop    r14
  21005f:	41 5f                	pop    r15
  210061:	5d                   	pop    rbp
  210062:	c3                   	ret    
            return openHandle(fd);
  210063:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  210069:	41 89 5e 04          	mov    DWORD PTR [r14+0x4],ebx
  21006d:	eb e7                	jmp    210056 <File_openRead+0x1e6>
            @panic("assertion failure");
  21006f:	e8 3c 9c ff ff       	call   209cb0 <panic>
  210074:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21007b:	00 00 00 00 00 

0000000000210080 <FixedBufferAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  210080:	49 89 d0             	mov    r8,rdx
        const addr = @ptrToInt(self.buffer.ptr) + self.end_index;
  210083:	4c 8b 56 18          	mov    r10,QWORD PTR [rsi+0x18]
  210087:	4c 8b 4e 20          	mov    r9,QWORD PTR [rsi+0x20]
  21008b:	4b 8d 04 0a          	lea    rax,[r10+r9*1]
        const rem = @rem(addr, alignment);
  21008f:	81 e1 ff ff ff 1f    	and    ecx,0x1fffffff
  210095:	48 89 c2             	mov    rdx,rax
  210098:	48 c1 ea 20          	shr    rdx,0x20
  21009c:	74 07                	je     2100a5 <FixedBufferAllocator_alloc+0x25>
  21009e:	31 d2                	xor    edx,edx
  2100a0:	48 f7 f1             	div    rcx
  2100a3:	eb 04                	jmp    2100a9 <FixedBufferAllocator_alloc+0x29>
  2100a5:	31 d2                	xor    edx,edx
  2100a7:	f7 f1                	div    ecx
        const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  2100a9:	48 29 d1             	sub    rcx,rdx
  2100ac:	48 85 d2             	test   rdx,rdx
  2100af:	48 0f 44 ca          	cmove  rcx,rdx
        const adjusted_index = self.end_index + march_forward_bytes;
  2100b3:	4c 01 d1             	add    rcx,r10
        const new_end_index = adjusted_index + n;
  2100b6:	4a 8d 04 01          	lea    rax,[rcx+r8*1]
        if (new_end_index > self.buffer.len) {
  2100ba:	48 3b 46 28          	cmp    rax,QWORD PTR [rsi+0x28]
  2100be:	76 1b                	jbe    2100db <FixedBufferAllocator_alloc+0x5b>
            return error.OutOfMemory;
  2100c0:	48 8b 05 81 76 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff7681]        # 207748 <__unnamed_61+0x10>
  2100c7:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  2100cb:	c5 f8 10 05 65 76 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff7665]        # 207738 <__unnamed_61>
  2100d2:	ff 
  2100d3:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
  2100d7:	48 89 f8             	mov    rax,rdi
  2100da:	c3                   	ret    
        }
        const result = self.buffer[adjusted_index..new_end_index];
        self.end_index = new_end_index;
  2100db:	48 89 46 18          	mov    QWORD PTR [rsi+0x18],rax

        return result;
  2100df:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  2100e4:	0f b7 44 24 fe       	movzx  eax,WORD PTR [rsp-0x2]
  2100e9:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
        const result = self.buffer[adjusted_index..new_end_index];
  2100ed:	49 01 c9             	add    r9,rcx
        return result;
  2100f0:	8b 44 24 fa          	mov    eax,DWORD PTR [rsp-0x6]
  2100f4:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  2100f7:	4c 89 4f 08          	mov    QWORD PTR [rdi+0x8],r9
  2100fb:	4c 89 47 10          	mov    QWORD PTR [rdi+0x10],r8
  2100ff:	48 89 f8             	mov    rax,rdi
  210102:	c3                   	ret    
  210103:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21010a:	84 00 00 00 00 00 

0000000000210110 <FixedBufferAllocator_realloc>:
    }

    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  210110:	41 56                	push   r14
  210112:	53                   	push   rbx
  210113:	48 83 ec 28          	sub    rsp,0x28
  210117:	49 89 d1             	mov    r9,rdx
        const self = @fieldParentPtr(FixedBufferAllocator, "allocator", allocator);
        assert(old_mem.len <= self.end_index);
  21011a:	49 8b 59 08          	mov    rbx,QWORD PTR [r9+0x8]
  21011e:	4c 8b 5e 18          	mov    r11,QWORD PTR [rsi+0x18]
  210122:	4d 89 de             	mov    r14,r11
  210125:	49 29 de             	sub    r14,rbx
    if (!ok) {
  210128:	0f 82 de 01 00 00    	jb     21030c <FixedBufferAllocator_realloc+0x1fc>
        if (new_size <= old_mem.len) {
  21012e:	48 39 cb             	cmp    rbx,rcx
  210131:	73 2a                	jae    21015d <FixedBufferAllocator_realloc+0x4d>
            return old_mem[0..new_size];
        } else if (old_mem.ptr == self.buffer.ptr + self.end_index - old_mem.len) {
  210133:	4c 8b 56 20          	mov    r10,QWORD PTR [rsi+0x20]
  210137:	4b 8d 04 1a          	lea    rax,[r10+r11*1]
  21013b:	48 89 c2             	mov    rdx,rax
  21013e:	48 29 da             	sub    rdx,rbx
  210141:	49 39 11             	cmp    QWORD PTR [r9],rdx
  210144:	74 38                	je     21017e <FixedBufferAllocator_realloc+0x6e>
        const rem = @rem(addr, alignment);
  210146:	41 81 e0 ff ff ff 1f 	and    r8d,0x1fffffff
  21014d:	48 89 c2             	mov    rdx,rax
  210150:	48 c1 ea 20          	shr    rdx,0x20
  210154:	74 52                	je     2101a8 <FixedBufferAllocator_realloc+0x98>
  210156:	31 d2                	xor    edx,edx
  210158:	49 f7 f0             	div    r8
  21015b:	eb 50                	jmp    2101ad <FixedBufferAllocator_realloc+0x9d>
            return old_mem[0..new_size];
  21015d:	49 8b 01             	mov    rax,QWORD PTR [r9]
  210160:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  210165:	0f b7 54 24 10       	movzx  edx,WORD PTR [rsp+0x10]
  21016a:	66 89 57 06          	mov    WORD PTR [rdi+0x6],dx
  21016e:	8b 54 24 0c          	mov    edx,DWORD PTR [rsp+0xc]
  210172:	89 57 02             	mov    DWORD PTR [rdi+0x2],edx
  210175:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  210179:	e9 7f 01 00 00       	jmp    2102fd <FixedBufferAllocator_realloc+0x1ed>
            const start_index = self.end_index - old_mem.len;
            const new_end_index = start_index + new_size;
  21017e:	49 8d 04 0e          	lea    rax,[r14+rcx*1]
            if (new_end_index > self.buffer.len) return error.OutOfMemory;
  210182:	48 3b 46 28          	cmp    rax,QWORD PTR [rsi+0x28]
  210186:	0f 86 94 00 00 00    	jbe    210220 <FixedBufferAllocator_realloc+0x110>
  21018c:	48 8b 05 b5 75 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff75b5]        # 207748 <__unnamed_61+0x10>
  210193:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  210197:	c5 f8 10 05 99 75 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff7599]        # 207738 <__unnamed_61>
  21019e:	ff 
  21019f:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
  2101a3:	e9 59 01 00 00       	jmp    210301 <FixedBufferAllocator_realloc+0x1f1>
  2101a8:	31 d2                	xor    edx,edx
  2101aa:	41 f7 f0             	div    r8d
        const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  2101ad:	49 29 d0             	sub    r8,rdx
  2101b0:	48 85 d2             	test   rdx,rdx
  2101b3:	4c 0f 44 c2          	cmove  r8,rdx
        const adjusted_index = self.end_index + march_forward_bytes;
  2101b7:	4d 01 d8             	add    r8,r11
        const new_end_index = adjusted_index + n;
  2101ba:	49 8d 04 08          	lea    rax,[r8+rcx*1]
        if (new_end_index > self.buffer.len) {
  2101be:	48 3b 46 28          	cmp    rax,QWORD PTR [rsi+0x28]
  2101c2:	76 1e                	jbe    2101e2 <FixedBufferAllocator_realloc+0xd2>
            const result = self.buffer[start_index..new_end_index];
            self.end_index = new_end_index;
            return result;
        } else {
            const result = try alloc(allocator, new_size, alignment);
  2101c4:	66 c7 07 05 00       	mov    WORD PTR [rdi],0x5
  2101c9:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  2101ce:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  2101d2:	c5 f8 10 44 24 12    	vmovups xmm0,XMMWORD PTR [rsp+0x12]
  2101d8:	c5 f8 11 47 02       	vmovups XMMWORD PTR [rdi+0x2],xmm0
  2101dd:	e9 1f 01 00 00       	jmp    210301 <FixedBufferAllocator_realloc+0x1f1>
        self.end_index = new_end_index;
  2101e2:	48 89 46 18          	mov    QWORD PTR [rsi+0x18],rax
    assert(dest.len >= source.len);
  2101e6:	4d 8b 71 08          	mov    r14,QWORD PTR [r9+0x8]
  2101ea:	49 39 ce             	cmp    r14,rcx
  2101ed:	0f 87 19 01 00 00    	ja     21030c <FixedBufferAllocator_realloc+0x1fc>
  2101f3:	4f 8d 1c 02          	lea    r11,[r10+r8*1]
    for (source) |s, i|
  2101f7:	4d 85 f6             	test   r14,r14
  2101fa:	0f 84 e5 00 00 00    	je     2102e5 <FixedBufferAllocator_realloc+0x1d5>
  210200:	49 8d 46 ff          	lea    rax,[r14-0x1]
  210204:	44 89 f2             	mov    edx,r14d
  210207:	83 e2 07             	and    edx,0x7
  21020a:	48 83 f8 07          	cmp    rax,0x7
  21020e:	73 35                	jae    210245 <FixedBufferAllocator_realloc+0x135>
  210210:	31 f6                	xor    esi,esi
  210212:	48 85 d2             	test   rdx,rdx
  210215:	0f 85 b1 00 00 00    	jne    2102cc <FixedBufferAllocator_realloc+0x1bc>
  21021b:	e9 c5 00 00 00       	jmp    2102e5 <FixedBufferAllocator_realloc+0x1d5>
            self.end_index = new_end_index;
  210220:	48 89 46 18          	mov    QWORD PTR [rsi+0x18],rax
            return result;
  210224:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  210229:	0f b7 44 24 0a       	movzx  eax,WORD PTR [rsp+0xa]
  21022e:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
            const result = self.buffer[start_index..new_end_index];
  210232:	4d 01 f2             	add    r10,r14
            return result;
  210235:	8b 44 24 06          	mov    eax,DWORD PTR [rsp+0x6]
  210239:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  21023c:	4c 89 57 08          	mov    QWORD PTR [rdi+0x8],r10
  210240:	e9 b8 00 00 00       	jmp    2102fd <FixedBufferAllocator_realloc+0x1ed>
  210245:	49 29 d6             	sub    r14,rdx
  210248:	4b 8d 04 02          	lea    rax,[r10+r8*1]
  21024c:	48 83 c0 07          	add    rax,0x7
  210250:	31 f6                	xor    esi,esi
  210252:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210259:	1f 84 00 00 00 00 00 
  210260:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  210263:	0f b6 1c 33          	movzx  ebx,BYTE PTR [rbx+rsi*1]
        dest[i] = s;
  210267:	88 5c 30 f9          	mov    BYTE PTR [rax+rsi*1-0x7],bl
    for (source) |s, i|
  21026b:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  21026e:	0f b6 5c 33 01       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x1]
        dest[i] = s;
  210273:	88 5c 30 fa          	mov    BYTE PTR [rax+rsi*1-0x6],bl
    for (source) |s, i|
  210277:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  21027a:	0f b6 5c 33 02       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x2]
        dest[i] = s;
  21027f:	88 5c 30 fb          	mov    BYTE PTR [rax+rsi*1-0x5],bl
    for (source) |s, i|
  210283:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  210286:	0f b6 5c 33 03       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x3]
        dest[i] = s;
  21028b:	88 5c 30 fc          	mov    BYTE PTR [rax+rsi*1-0x4],bl
    for (source) |s, i|
  21028f:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  210292:	0f b6 5c 33 04       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x4]
        dest[i] = s;
  210297:	88 5c 30 fd          	mov    BYTE PTR [rax+rsi*1-0x3],bl
    for (source) |s, i|
  21029b:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  21029e:	0f b6 5c 33 05       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x5]
        dest[i] = s;
  2102a3:	88 5c 30 fe          	mov    BYTE PTR [rax+rsi*1-0x2],bl
    for (source) |s, i|
  2102a7:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  2102aa:	0f b6 5c 33 06       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x6]
        dest[i] = s;
  2102af:	88 5c 30 ff          	mov    BYTE PTR [rax+rsi*1-0x1],bl
    for (source) |s, i|
  2102b3:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  2102b6:	0f b6 5c 33 07       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x7]
        dest[i] = s;
  2102bb:	88 1c 30             	mov    BYTE PTR [rax+rsi*1],bl
    for (source) |s, i|
  2102be:	48 83 c6 08          	add    rsi,0x8
  2102c2:	49 39 f6             	cmp    r14,rsi
  2102c5:	75 99                	jne    210260 <FixedBufferAllocator_realloc+0x150>
  2102c7:	48 85 d2             	test   rdx,rdx
  2102ca:	74 19                	je     2102e5 <FixedBufferAllocator_realloc+0x1d5>
  2102cc:	48 f7 da             	neg    rdx
  2102cf:	90                   	nop
  2102d0:	49 8b 01             	mov    rax,QWORD PTR [r9]
  2102d3:	0f b6 04 30          	movzx  eax,BYTE PTR [rax+rsi*1]
        dest[i] = s;
  2102d7:	41 88 04 33          	mov    BYTE PTR [r11+rsi*1],al
    for (source) |s, i|
  2102db:	48 83 c6 01          	add    rsi,0x1
  2102df:	48 83 c2 01          	add    rdx,0x1
  2102e3:	75 eb                	jne    2102d0 <FixedBufferAllocator_realloc+0x1c0>
            mem.copy(u8, result, old_mem);
            return result;
  2102e5:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  2102ea:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  2102ef:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
  2102f3:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  2102f6:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  2102f9:	4c 89 5f 08          	mov    QWORD PTR [rdi+0x8],r11
  2102fd:	48 89 4f 10          	mov    QWORD PTR [rdi+0x10],rcx
  210301:	48 89 f8             	mov    rax,rdi
  210304:	48 83 c4 28          	add    rsp,0x28
  210308:	5b                   	pop    rbx
  210309:	41 5e                	pop    r14
  21030b:	c3                   	ret    
            @panic("assertion failure");
  21030c:	e8 9f 99 ff ff       	call   209cb0 <panic>
  210311:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210318:	0f 1f 84 00 00 00 00 
  21031f:	00 

0000000000210320 <InStream(ReadError)_readInt.33>:
        pub fn readInt(self: *Self, endian: builtin.Endian, comptime T: type) !T {
  210320:	55                   	push   rbp
  210321:	53                   	push   rbx
  210322:	48 83 ec 48          	sub    rsp,0x48
  210326:	89 d5                	mov    ebp,edx
  210328:	48 89 fb             	mov    rbx,rdi
  21032b:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            try self.readNoEof(bytes[0..]);
  210330:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  210335:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  21033c:	00 00 
  21033e:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  210343:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210348:	ff 16                	call   QWORD PTR [rsi]
  21034a:	0f b7 44 24 28       	movzx  eax,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  21034f:	66 85 c0             	test   ax,ax
  210352:	75 10                	jne    210364 <InStream(ReadError)_readInt.33+0x44>
  210354:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  210359:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  21035d:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  210362:	73 1c                	jae    210380 <InStream(ReadError)_readInt.33+0x60>
            try self.readNoEof(bytes[0..]);
  210364:	66 89 03             	mov    WORD PTR [rbx],ax
  210367:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  21036c:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  210371:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  210375:	48 89 43 02          	mov    QWORD PTR [rbx+0x2],rax
  210379:	48 83 c4 48          	add    rsp,0x48
  21037d:	5b                   	pop    rbx
  21037e:	5d                   	pop    rbp
  21037f:	c3                   	ret    
  210380:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  210385:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  21038a:	40 f6 c5 01          	test   bpl,0x1
  21038e:	74 51                	je     2103e1 <InStream(ReadError)_readInt.33+0xc1>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  210390:	48 c1 e1 08          	shl    rcx,0x8
  210394:	48 09 c1             	or     rcx,rax
  210397:	0f b6 44 24 0a       	movzx  eax,BYTE PTR [rsp+0xa]
  21039c:	48 c1 e0 10          	shl    rax,0x10
  2103a0:	48 09 c8             	or     rax,rcx
  2103a3:	0f b6 4c 24 0b       	movzx  ecx,BYTE PTR [rsp+0xb]
  2103a8:	48 c1 e1 18          	shl    rcx,0x18
  2103ac:	48 09 c1             	or     rcx,rax
  2103af:	0f b6 44 24 0c       	movzx  eax,BYTE PTR [rsp+0xc]
  2103b4:	48 c1 e0 20          	shl    rax,0x20
  2103b8:	48 09 c8             	or     rax,rcx
  2103bb:	0f b6 4c 24 0d       	movzx  ecx,BYTE PTR [rsp+0xd]
  2103c0:	48 c1 e1 28          	shl    rcx,0x28
  2103c4:	48 09 c1             	or     rcx,rax
  2103c7:	0f b6 54 24 0e       	movzx  edx,BYTE PTR [rsp+0xe]
  2103cc:	48 c1 e2 30          	shl    rdx,0x30
  2103d0:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  2103d5:	48 c1 e0 38          	shl    rax,0x38
  2103d9:	48 09 d0             	or     rax,rdx
  2103dc:	48 09 c8             	or     rax,rcx
  2103df:	eb 4f                	jmp    210430 <InStream(ReadError)_readInt.33+0x110>
                result = (result << 8) | b;
  2103e1:	48 c1 e0 08          	shl    rax,0x8
  2103e5:	48 09 c8             	or     rax,rcx
  2103e8:	48 c1 e0 08          	shl    rax,0x8
  2103ec:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  2103f1:	48 09 c1             	or     rcx,rax
  2103f4:	48 c1 e1 08          	shl    rcx,0x8
  2103f8:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  2103fd:	48 09 c8             	or     rax,rcx
  210400:	48 c1 e0 08          	shl    rax,0x8
  210404:	0f b6 4c 24 0c       	movzx  ecx,BYTE PTR [rsp+0xc]
  210409:	48 09 c1             	or     rcx,rax
  21040c:	48 c1 e1 08          	shl    rcx,0x8
  210410:	0f b6 44 24 0d       	movzx  eax,BYTE PTR [rsp+0xd]
  210415:	48 09 c8             	or     rax,rcx
  210418:	48 c1 e0 08          	shl    rax,0x8
  21041c:	0f b6 4c 24 0e       	movzx  ecx,BYTE PTR [rsp+0xe]
  210421:	48 09 c1             	or     rcx,rax
  210424:	48 c1 e1 08          	shl    rcx,0x8
  210428:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  21042d:	48 09 c8             	or     rax,rcx
            return mem.readInt(bytes, T, endian);
  210430:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  210435:	0f b7 4c 24 16       	movzx  ecx,WORD PTR [rsp+0x16]
  21043a:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21043e:	8b 4c 24 12          	mov    ecx,DWORD PTR [rsp+0x12]
  210442:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  210445:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  210449:	48 83 c4 48          	add    rsp,0x48
  21044d:	5b                   	pop    rbx
  21044e:	5d                   	pop    rbp
  21044f:	c3                   	ret    

0000000000210450 <File_read>:
        IsDir,

        Unexpected,
    };

    pub fn read(self: *File, buffer: []u8) ReadError!usize {
  210450:	41 57                	push   r15
  210452:	41 56                	push   r14
  210454:	53                   	push   rbx
  210455:	49 89 d1             	mov    r9,rdx
  210458:	49 89 f2             	mov    r10,rsi
  21045b:	49 89 f8             	mov    r8,rdi
        if (is_posix) {
            var index: usize = 0;
            while (index < buffer.len) {
  21045e:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  210462:	48 85 d2             	test   rdx,rdx
  210465:	74 6c                	je     2104d3 <File_read+0x83>
  210467:	45 31 f6             	xor    r14d,r14d
  21046a:	4c 8d 3d db 0f ff ff 	lea    r15,[rip+0xffffffffffff0fdb]        # 20144c <__unnamed_9+0x76c>
  210471:	31 db                	xor    ebx,ebx
  210473:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21047a:	84 00 00 00 00 00 
  210480:	49 8b 31             	mov    rsi,QWORD PTR [r9]
                const amt_read = posix.read(self.handle, buffer.ptr + index, buffer.len - index);
  210483:	48 01 de             	add    rsi,rbx
  210486:	48 29 da             	sub    rdx,rbx
    return syscall3(SYS_read, @intCast(usize, fd), @ptrToInt(buf), count);
  210489:	49 63 3a             	movsxd rdi,DWORD PTR [r10]
  21048c:	31 c0                	xor    eax,eax
  21048e:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  210490:	48 89 c1             	mov    rcx,rax
  210493:	48 f7 d9             	neg    rcx
  210496:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21049c:	49 0f 46 ce          	cmovbe rcx,r14
                const read_err = posix.getErrno(amt_read);
                if (read_err > 0) {
  2104a0:	48 83 f9 04          	cmp    rcx,0x4
  2104a4:	75 0b                	jne    2104b1 <File_read+0x61>
            while (index < buffer.len) {
  2104a6:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  2104aa:	48 39 da             	cmp    rdx,rbx
  2104ad:	77 d1                	ja     210480 <File_read+0x30>
  2104af:	eb 24                	jmp    2104d5 <File_read+0x85>
  2104b1:	48 83 f9 15          	cmp    rcx,0x15
  2104b5:	77 67                	ja     21051e <File_read+0xce>
  2104b7:	49 63 0c 8f          	movsxd rcx,DWORD PTR [r15+rcx*4]
  2104bb:	4c 01 f9             	add    rcx,r15
  2104be:	ff e1                	jmp    rcx
                        posix.EIO => return error.Io,
                        posix.EISDIR => return error.IsDir,
                        else => return os.unexpectedErrorPosix(read_err),
                    }
                }
                if (amt_read == 0) return index;
  2104c0:	48 85 c0             	test   rax,rax
  2104c3:	74 77                	je     21053c <File_read+0xec>
  2104c5:	48 01 c3             	add    rbx,rax
            while (index < buffer.len) {
  2104c8:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  2104cc:	48 39 da             	cmp    rdx,rbx
  2104cf:	77 af                	ja     210480 <File_read+0x30>
  2104d1:	eb 02                	jmp    2104d5 <File_read+0x85>
  2104d3:	31 db                	xor    ebx,ebx
                index += amt_read;
            }
            return index;
  2104d5:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  2104db:	0f b7 44 24 ea       	movzx  eax,WORD PTR [rsp-0x16]
  2104e0:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  2104e5:	8b 44 24 e6          	mov    eax,DWORD PTR [rsp-0x1a]
  2104e9:	41 89 40 02          	mov    DWORD PTR [r8+0x2],eax
  2104ed:	49 89 58 08          	mov    QWORD PTR [r8+0x8],rbx
  2104f1:	5b                   	pop    rbx
  2104f2:	41 5e                	pop    r14
  2104f4:	41 5f                	pop    r15
  2104f6:	c3                   	ret    
                        posix.EIO => return error.Io,
  2104f7:	c5 f8 10 05 c1 01 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff01c1]        # 2006c0 <__unnamed_62>
  2104fe:	ff 
  2104ff:	eb 12                	jmp    210513 <File_read+0xc3>
                        posix.EBADF => return error.BadFd,
  210501:	c5 f8 10 05 37 03 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff0337]        # 200840 <__unnamed_63>
  210508:	ff 
  210509:	eb 08                	jmp    210513 <File_read+0xc3>
                        posix.EISDIR => return error.IsDir,
  21050b:	c5 f8 10 05 ad 00 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff00ad]        # 2005c0 <__unnamed_64>
  210512:	ff 
  210513:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
  210518:	5b                   	pop    rbx
  210519:	41 5e                	pop    r14
  21051b:	41 5f                	pop    r15
  21051d:	c3                   	ret    
                        else => return os.unexpectedErrorPosix(read_err),
  21051e:	66 41 c7 00 02 00    	mov    WORD PTR [r8],0x2
  210524:	48 8b 44 24 f2       	mov    rax,QWORD PTR [rsp-0xe]
  210529:	48 8b 4c 24 f8       	mov    rcx,QWORD PTR [rsp-0x8]
  21052e:	49 89 48 08          	mov    QWORD PTR [r8+0x8],rcx
  210532:	49 89 40 02          	mov    QWORD PTR [r8+0x2],rax
  210536:	5b                   	pop    rbx
  210537:	41 5e                	pop    r14
  210539:	41 5f                	pop    r15
  21053b:	c3                   	ret    
                if (amt_read == 0) return index;
  21053c:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  210542:	0f b7 44 24 f0       	movzx  eax,WORD PTR [rsp-0x10]
  210547:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  21054c:	8b 44 24 ec          	mov    eax,DWORD PTR [rsp-0x14]
  210550:	eb 97                	jmp    2104e9 <File_read+0x99>
  210552:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210559:	1f 84 00 00 00 00 00 

0000000000210560 <FileInStream_readFn>:
    fn readFn(in_stream: *Stream, buffer: []u8) Error!usize {
  210560:	53                   	push   rbx
  210561:	48 83 ec 10          	sub    rsp,0x10
  210565:	48 89 fb             	mov    rbx,rdi
        return self.file.read(buffer);
  210568:	48 8b 76 f8          	mov    rsi,QWORD PTR [rsi-0x8]
  21056c:	48 89 e7             	mov    rdi,rsp
  21056f:	e8 dc fe ff ff       	call   210450 <File_read>
  210574:	c5 f8 10 04 24       	vmovups xmm0,XMMWORD PTR [rsp]
  210579:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21057d:	48 89 d8             	mov    rax,rbx
  210580:	48 83 c4 10          	add    rsp,0x10
  210584:	5b                   	pop    rbx
  210585:	c3                   	ret    
  210586:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21058d:	00 00 00 

0000000000210590 <parseAbbrevTable>:
fn parseAbbrevTable(st: *ElfStackTrace) !AbbrevTable {
  210590:	55                   	push   rbp
  210591:	41 57                	push   r15
  210593:	41 56                	push   r14
  210595:	41 55                	push   r13
  210597:	41 54                	push   r12
  210599:	53                   	push   rbx
  21059a:	48 81 ec f8 01 00 00 	sub    rsp,0x1f8
  2105a1:	49 89 f4             	mov    r12,rsi
    var in_file_stream = io.FileInStream.init(in_file);
  2105a4:	4c 89 64 24 28       	mov    QWORD PTR [rsp+0x28],r12
  2105a9:	48 89 fb             	mov    rbx,rdi
  2105ac:	48 8d 05 ad ff ff ff 	lea    rax,[rip+0xffffffffffffffad]        # 210560 <FileInStream_readFn>
  2105b3:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  2105b8:	4d 8b b4 24 a0 00 00 	mov    r14,QWORD PTR [r12+0xa0]
  2105bf:	00 
            return Self{
  2105c0:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2105c4:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2105cb:	00 00 
  2105cd:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x0
  2105d4:	00 00 00 00 00 
    var result = AbbrevTable.init(st.allocator());
  2105d9:	4c 89 b4 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],r14
  2105e0:	00 
  2105e1:	4c 8d 6c 24 0f       	lea    r13,[rsp+0xf]
            try self.readNoEof(result[0..]);
  2105e6:	4c 89 6c 24 60       	mov    QWORD PTR [rsp+0x60],r13
  2105eb:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  2105f2:	00 00 
        return self.file.read(buffer);
  2105f4:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  2105f9:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2105fe:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  210603:	e8 48 fe ff ff       	call   210450 <File_read>
  210608:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  21060e:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
            return self.readFn(self, buffer);
  210614:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
            const amt_read = try self.read(buf);
  210619:	66 85 c9             	test   cx,cx
  21061c:	74 32                	je     210650 <parseAbbrevTable+0xc0>
        const abbrev_code = try readULeb128(in_stream);
  21061e:	66 89 0b             	mov    WORD PTR [rbx],cx
  210621:	48 8b 84 24 f0 01 00 	mov    rax,QWORD PTR [rsp+0x1f0]
  210628:	00 
  210629:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
  21062d:	c5 fc 10 84 24 d2 01 	vmovups ymm0,YMMWORD PTR [rsp+0x1d2]
  210634:	00 00 
  210636:	c5 fc 11 43 02       	vmovups YMMWORD PTR [rbx+0x2],ymm0
  21063b:	48 81 c4 f8 01 00 00 	add    rsp,0x1f8
  210642:	5b                   	pop    rbx
  210643:	41 5c                	pop    r12
  210645:	41 5d                	pop    r13
  210647:	41 5e                	pop    r14
  210649:	41 5f                	pop    r15
  21064b:	5d                   	pop    rbp
  21064c:	c5 f8 77             	vzeroupper 
  21064f:	c3                   	ret    
  210650:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  210655:	31 c9                	xor    ecx,ecx
  210657:	48 89 4c 24 70       	mov    QWORD PTR [rsp+0x70],rcx
  21065c:	31 c9                	xor    ecx,ecx
  21065e:	48 89 4c 24 58       	mov    QWORD PTR [rsp+0x58],rcx
  210663:	45 31 ff             	xor    r15d,r15d
  210666:	31 ed                	xor    ebp,ebp
  210668:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21066f:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  210670:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  210675:	0f 82 f8 04 00 00    	jb     210b73 <parseAbbrevTable+0x5e3>
            return result[0];
  21067b:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  210680:	89 c2                	mov    edx,eax
  210682:	83 e2 7f             	and    edx,0x7f
  210685:	89 ee                	mov    esi,ebp
  210687:	83 e6 3f             	and    esi,0x3f
  21068a:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21068f:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  210694:	48 39 d6             	cmp    rsi,rdx
  210697:	0f 85 df 04 00 00    	jne    210b7c <parseAbbrevTable+0x5ec>
        result |= operand;
  21069d:	49 09 cf             	or     r15,rcx
        if ((byte & 0b10000000) == 0) return result;
  2106a0:	84 c0                	test   al,al
  2106a2:	79 39                	jns    2106dd <parseAbbrevTable+0x14d>
        shift += 7;
  2106a4:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2106a8:	4c 89 6c 24 60       	mov    QWORD PTR [rsp+0x60],r13
  2106ad:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  2106b4:	00 00 
            return self.readFn(self, buffer);
  2106b6:	48 8d 7c 24 10       	lea    rdi,[rsp+0x10]
  2106bb:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2106c0:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  2106c5:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  2106c9:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
  2106ce:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
            const amt_read = try self.read(buf);
  2106d3:	66 85 c9             	test   cx,cx
  2106d6:	74 98                	je     210670 <parseAbbrevTable+0xe0>
  2106d8:	e9 41 ff ff ff       	jmp    21061e <parseAbbrevTable+0x8e>
        if (abbrev_code == 0) return result;
  2106dd:	4d 85 ff             	test   r15,r15
  2106e0:	0f 84 01 05 00 00    	je     210be7 <parseAbbrevTable+0x657>
  2106e6:	48 89 5c 24 38       	mov    QWORD PTR [rsp+0x38],rbx
  2106eb:	4c 89 a4 24 88 00 00 	mov    QWORD PTR [rsp+0x88],r12
  2106f2:	00 
            try self.readNoEof(result[0..]);
  2106f3:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  2106f8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2106ff:	00 00 
  210701:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
            return self.readFn(self, buffer);
  210706:	48 89 df             	mov    rdi,rbx
  210709:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  21070e:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  210713:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210717:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21071c:	66 85 c0             	test   ax,ax
  21071f:	0f 85 6a 04 00 00    	jne    210b8f <parseAbbrevTable+0x5ff>
  210725:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21072a:	45 31 e4             	xor    r12d,r12d
  21072d:	31 ed                	xor    ebp,ebp
  21072f:	90                   	nop
            if (amt_read < buf.len) return error.EndOfStream;
  210730:	48 3b 4c 24 18       	cmp    rcx,QWORD PTR [rsp+0x18]
  210735:	0f 82 4a 04 00 00    	jb     210b85 <parseAbbrevTable+0x5f5>
            return result[0];
  21073b:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  210740:	89 c2                	mov    edx,eax
  210742:	83 e2 7f             	and    edx,0x7f
  210745:	89 ee                	mov    esi,ebp
  210747:	83 e6 3f             	and    esi,0x3f
  21074a:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21074f:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  210754:	48 39 d6             	cmp    rsi,rdx
  210757:	0f 85 2e 04 00 00    	jne    210b8b <parseAbbrevTable+0x5fb>
        result |= operand;
  21075d:	49 09 cc             	or     r12,rcx
        if ((byte & 0b10000000) == 0) return result;
  210760:	84 c0                	test   al,al
  210762:	79 3c                	jns    2107a0 <parseAbbrevTable+0x210>
        shift += 7;
  210764:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  210768:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  21076d:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  210772:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210779:	00 00 
            return self.readFn(self, buffer);
  21077b:	48 89 df             	mov    rdi,rbx
  21077e:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  210783:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  210788:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  21078c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210791:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  210796:	66 85 c0             	test   ax,ax
  210799:	74 95                	je     210730 <parseAbbrevTable+0x1a0>
  21079b:	e9 ef 03 00 00       	jmp    210b8f <parseAbbrevTable+0x5ff>
            try self.readNoEof(result[0..]);
  2107a0:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  2107a5:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2107aa:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2107b1:	00 00 
            return self.readFn(self, buffer);
  2107b3:	48 89 df             	mov    rdi,rbx
  2107b6:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2107bb:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2107c0:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  2107c4:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2107c9:	66 85 c0             	test   ax,ax
  2107cc:	0f 85 7b 04 00 00    	jne    210c4d <parseAbbrevTable+0x6bd>
  2107d2:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
            if (amt_read < buf.len) return error.EndOfStream;
  2107d7:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  2107dc:	0f 82 67 04 00 00    	jb     210c49 <parseAbbrevTable+0x6b9>
  2107e2:	4c 89 b4 24 80 00 00 	mov    QWORD PTR [rsp+0x80],r14
  2107e9:	00 
  2107ea:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  2107f1:	00 
  2107f2:	4c 8b a8 a0 00 00 00 	mov    r13,QWORD PTR [rax+0xa0]
  2107f9:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2107fd:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  210804:	00 00 
            return result[0];
  210806:	8a 5c 24 0f          	mov    bl,BYTE PTR [rsp+0xf]
  21080a:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x0
  210811:	00 00 00 00 00 
            var better_capacity = self.items.len;
  210816:	48 8b 8c 24 98 00 00 	mov    rcx,QWORD PTR [rsp+0x98]
  21081d:	00 
  21081e:	4c 8b 74 24 58       	mov    r14,QWORD PTR [rsp+0x58]
            if (better_capacity >= new_capacity) return;
  210823:	4c 39 f1             	cmp    rcx,r14
  210826:	76 08                	jbe    210830 <parseAbbrevTable+0x2a0>
  210828:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  21082d:	eb 55                	jmp    210884 <parseAbbrevTable+0x2f4>
  21082f:	90                   	nop
                better_capacity += better_capacity / 2 + 8;
  210830:	48 89 c8             	mov    rax,rcx
  210833:	48 d1 e8             	shr    rax,1
  210836:	48 01 c1             	add    rcx,rax
  210839:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  21083d:	4c 39 f1             	cmp    rcx,r14
  210840:	76 ee                	jbe    210830 <parseAbbrevTable+0x2a0>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  210842:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210847:	48 8b b4 24 80 00 00 	mov    rsi,QWORD PTR [rsp+0x80]
  21084e:	00 
  21084f:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  210856:	00 
  210857:	e8 74 04 00 00       	call   210cd0 <Allocator_alignedRealloc>
  21085c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210861:	66 85 c0             	test   ax,ax
  210864:	0f 85 0a 04 00 00    	jne    210c74 <parseAbbrevTable+0x6e4>
  21086a:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21086f:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  210873:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21087a:	00 00 
            const result = &self.items[self.len];
  21087c:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  210883:	00 
  210884:	49 6b ee 38          	imul   rbp,r14,0x38
  210888:	49 83 c6 01          	add    r14,0x1
            self.len = new_length;
  21088c:	4c 89 b4 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],r14
  210893:	00 
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  210894:	80 fb 01             	cmp    bl,0x1
            new_item_ptr.* = item;
  210897:	0f 94 04 29          	sete   BYTE PTR [rcx+rbp*1]
  21089b:	8a 44 24 7f          	mov    al,BYTE PTR [rsp+0x7f]
  21089f:	88 44 29 07          	mov    BYTE PTR [rcx+rbp*1+0x7],al
  2108a3:	0f b7 44 24 7d       	movzx  eax,WORD PTR [rsp+0x7d]
  2108a8:	66 89 44 29 05       	mov    WORD PTR [rcx+rbp*1+0x5],ax
  2108ad:	8b 44 24 79          	mov    eax,DWORD PTR [rsp+0x79]
  2108b1:	89 44 29 01          	mov    DWORD PTR [rcx+rbp*1+0x1],eax
  2108b5:	4c 89 7c 29 08       	mov    QWORD PTR [rcx+rbp*1+0x8],r15
  2108ba:	4c 89 64 29 10       	mov    QWORD PTR [rcx+rbp*1+0x10],r12
  2108bf:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  2108c6:	00 
  2108c7:	48 89 44 29 28       	mov    QWORD PTR [rcx+rbp*1+0x28],rax
  2108cc:	c5 f8 28 84 24 b0 00 	vmovaps xmm0,XMMWORD PTR [rsp+0xb0]
  2108d3:	00 00 
  2108d5:	c5 f8 11 44 29 18    	vmovups XMMWORD PTR [rcx+rbp*1+0x18],xmm0
  2108db:	48 89 c8             	mov    rax,rcx
  2108de:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  2108e3:	4c 89 6c 29 30       	mov    QWORD PTR [rcx+rbp*1+0x30],r13
  2108e8:	4c 8d 6c 24 0f       	lea    r13,[rsp+0xf]
            try self.readNoEof(result[0..]);
  2108ed:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  2108f2:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2108f9:	00 00 
  2108fb:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
            return self.readFn(self, buffer);
  210900:	48 89 df             	mov    rdi,rbx
  210903:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  210908:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  21090d:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210911:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210916:	66 85 c0             	test   ax,ax
  210919:	0f 85 fd 02 00 00    	jne    210c1c <parseAbbrevTable+0x68c>
  21091f:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  210924:	48 01 e8             	add    rax,rbp
  210927:	48 83 c0 18          	add    rax,0x18
  21092b:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  210930:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210935:	45 31 ff             	xor    r15d,r15d
  210938:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  21093a:	48 3b 4c 24 18       	cmp    rcx,QWORD PTR [rsp+0x18]
  21093f:	0f 82 d3 02 00 00    	jb     210c18 <parseAbbrevTable+0x688>
            return result[0];
  210945:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21094a:	89 c2                	mov    edx,eax
  21094c:	83 e2 7f             	and    edx,0x7f
  21094f:	89 ee                	mov    esi,ebp
  210951:	83 e6 3f             	and    esi,0x3f
  210954:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  210959:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21095e:	48 39 d6             	cmp    rsi,rdx
  210961:	48 8b 54 24 38       	mov    rdx,QWORD PTR [rsp+0x38]
  210966:	0f 85 b7 02 00 00    	jne    210c23 <parseAbbrevTable+0x693>
        result |= operand;
  21096c:	49 09 cf             	or     r15,rcx
        if ((byte & 0b10000000) == 0) return result;
  21096f:	84 c0                	test   al,al
  210971:	0f 88 a2 00 00 00    	js     210a19 <parseAbbrevTable+0x489>
            try self.readNoEof(result[0..]);
  210977:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  21097c:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210983:	00 00 
            return self.readFn(self, buffer);
  210985:	48 89 df             	mov    rdi,rbx
  210988:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  21098d:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  210992:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210996:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21099b:	66 85 c0             	test   ax,ax
  21099e:	0f 85 1c 02 00 00    	jne    210bc0 <parseAbbrevTable+0x630>
  2109a4:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2109a9:	45 31 e4             	xor    r12d,r12d
  2109ac:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  2109ae:	48 3b 4c 24 18       	cmp    rcx,QWORD PTR [rsp+0x18]
  2109b3:	0f 82 fd 01 00 00    	jb     210bb6 <parseAbbrevTable+0x626>
            return result[0];
  2109b9:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2109be:	89 c2                	mov    edx,eax
  2109c0:	83 e2 7f             	and    edx,0x7f
  2109c3:	89 ee                	mov    esi,ebp
  2109c5:	83 e6 3f             	and    esi,0x3f
  2109c8:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2109cd:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2109d2:	48 39 d6             	cmp    rsi,rdx
  2109d5:	0f 85 e1 01 00 00    	jne    210bbc <parseAbbrevTable+0x62c>
        result |= operand;
  2109db:	49 09 cc             	or     r12,rcx
        if ((byte & 0b10000000) == 0) return result;
  2109de:	84 c0                	test   al,al
  2109e0:	79 72                	jns    210a54 <parseAbbrevTable+0x4c4>
        shift += 7;
  2109e2:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2109e6:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  2109eb:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2109f2:	00 00 
            return self.readFn(self, buffer);
  2109f4:	48 89 df             	mov    rdi,rbx
  2109f7:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2109fc:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  210a01:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210a05:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210a0a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  210a0f:	66 85 c0             	test   ax,ax
  210a12:	74 9a                	je     2109ae <parseAbbrevTable+0x41e>
  210a14:	e9 a7 01 00 00       	jmp    210bc0 <parseAbbrevTable+0x630>
  210a19:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  210a1d:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  210a22:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210a29:	00 00 
            return self.readFn(self, buffer);
  210a2b:	48 89 df             	mov    rdi,rbx
  210a2e:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  210a33:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  210a38:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210a3c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210a41:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  210a46:	66 85 c0             	test   ax,ax
  210a49:	0f 84 eb fe ff ff    	je     21093a <parseAbbrevTable+0x3aa>
  210a4f:	e9 c8 01 00 00       	jmp    210c1c <parseAbbrevTable+0x68c>
            if (attr_id == 0 and form_id == 0) break;
  210a54:	4c 89 e0             	mov    rax,r12
  210a57:	4c 09 f8             	or     rax,r15
  210a5a:	0f 84 c0 00 00 00    	je     210b20 <parseAbbrevTable+0x590>
  210a60:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
            const new_length = self.len + 1;
  210a65:	48 8b 68 10          	mov    rbp,QWORD PTR [rax+0x10]
            var better_capacity = self.items.len;
  210a69:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
            if (better_capacity >= new_capacity) return;
  210a6d:	48 39 e9             	cmp    rcx,rbp
  210a70:	76 0a                	jbe    210a7c <parseAbbrevTable+0x4ec>
            const result = &self.items[self.len];
  210a72:	48 89 e8             	mov    rax,rbp
  210a75:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  210a7a:	eb 47                	jmp    210ac3 <parseAbbrevTable+0x533>
                better_capacity += better_capacity / 2 + 8;
  210a7c:	48 89 c8             	mov    rax,rcx
  210a7f:	48 d1 e8             	shr    rax,1
  210a82:	48 01 c1             	add    rcx,rax
  210a85:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  210a89:	48 39 e9             	cmp    rcx,rbp
  210a8c:	76 ee                	jbe    210a7c <parseAbbrevTable+0x4ec>
  210a8e:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  210a93:	48 8b 72 18          	mov    rsi,QWORD PTR [rdx+0x18]
  210a97:	48 89 df             	mov    rdi,rbx
  210a9a:	e8 c1 04 00 00       	call   210f60 <Allocator_alignedRealloc.41>
  210a9f:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210aa4:	66 85 c0             	test   ax,ax
  210aa7:	0f 85 ee 01 00 00    	jne    210c9b <parseAbbrevTable+0x70b>
  210aad:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  210ab2:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  210ab6:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  210abb:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
            const result = &self.items[self.len];
  210abf:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
  210ac3:	48 83 c5 01          	add    rbp,0x1
  210ac7:	48 89 ca             	mov    rdx,rcx
  210aca:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
            self.len = new_length;
  210acd:	48 89 6a 10          	mov    QWORD PTR [rdx+0x10],rbp
            new_item_ptr.* = item;
  210ad1:	48 c1 e0 04          	shl    rax,0x4
  210ad5:	4c 89 3c 01          	mov    QWORD PTR [rcx+rax*1],r15
  210ad9:	4c 89 64 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],r12
            try self.readNoEof(result[0..]);
  210ade:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  210ae3:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210aea:	00 00 
            return self.readFn(self, buffer);
  210aec:	48 89 df             	mov    rdi,rbx
  210aef:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  210af4:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  210af9:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210afd:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210b02:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210b07:	41 bf 00 00 00 00    	mov    r15d,0x0
  210b0d:	bd 00 00 00 00       	mov    ebp,0x0
            const amt_read = try self.read(buf);
  210b12:	66 85 c0             	test   ax,ax
  210b15:	0f 84 1f fe ff ff    	je     21093a <parseAbbrevTable+0x3aa>
  210b1b:	e9 fc 00 00 00       	jmp    210c1c <parseAbbrevTable+0x68c>
            try self.readNoEof(result[0..]);
  210b20:	4c 89 74 24 58       	mov    QWORD PTR [rsp+0x58],r14
  210b25:	4c 89 6c 24 60       	mov    QWORD PTR [rsp+0x60],r13
  210b2a:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  210b31:	00 00 
            return self.readFn(self, buffer);
  210b33:	48 8d 7c 24 10       	lea    rdi,[rsp+0x10]
  210b38:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  210b3d:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  210b42:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210b46:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
  210b4b:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
            const amt_read = try self.read(buf);
  210b50:	66 85 c9             	test   cx,cx
  210b53:	4c 8b b4 24 80 00 00 	mov    r14,QWORD PTR [rsp+0x80]
  210b5a:	00 
  210b5b:	4c 8b a4 24 88 00 00 	mov    r12,QWORD PTR [rsp+0x88]
  210b62:	00 
  210b63:	48 8b 5c 24 38       	mov    rbx,QWORD PTR [rsp+0x38]
  210b68:	0f 84 f5 fa ff ff    	je     210663 <parseAbbrevTable+0xd3>
  210b6e:	e9 ab fa ff ff       	jmp    21061e <parseAbbrevTable+0x8e>
  210b73:	66 b9 20 00          	mov    cx,0x20
  210b77:	e9 a2 fa ff ff       	jmp    21061e <parseAbbrevTable+0x8e>
  210b7c:	66 b9 25 00          	mov    cx,0x25
  210b80:	e9 99 fa ff ff       	jmp    21061e <parseAbbrevTable+0x8e>
  210b85:	66 b8 20 00          	mov    ax,0x20
  210b89:	eb 04                	jmp    210b8f <parseAbbrevTable+0x5ff>
  210b8b:	66 b8 25 00          	mov    ax,0x25
  210b8f:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
            .tag_id = try readULeb128(in_stream),
  210b94:	66 89 01             	mov    WORD PTR [rcx],ax
  210b97:	48 8b 84 24 ca 01 00 	mov    rax,QWORD PTR [rsp+0x1ca]
  210b9e:	00 
  210b9f:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210ba3:	c5 fc 10 84 24 ac 01 	vmovups ymm0,YMMWORD PTR [rsp+0x1ac]
  210baa:	00 00 
  210bac:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210bb1:	e9 85 fa ff ff       	jmp    21063b <parseAbbrevTable+0xab>
  210bb6:	66 b8 20 00          	mov    ax,0x20
  210bba:	eb 04                	jmp    210bc0 <parseAbbrevTable+0x630>
  210bbc:	66 b8 25 00          	mov    ax,0x25
  210bc0:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
            const form_id = try readULeb128(in_stream);
  210bc5:	66 89 01             	mov    WORD PTR [rcx],ax
  210bc8:	48 8b 84 24 32 01 00 	mov    rax,QWORD PTR [rsp+0x132]
  210bcf:	00 
  210bd0:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210bd4:	c5 fc 10 84 24 14 01 	vmovups ymm0,YMMWORD PTR [rsp+0x114]
  210bdb:	00 00 
  210bdd:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210be2:	e9 54 fa ff ff       	jmp    21063b <parseAbbrevTable+0xab>
        if (abbrev_code == 0) return result;
  210be7:	c5 fc 10 84 24 90 00 	vmovups ymm0,YMMWORD PTR [rsp+0x90]
  210bee:	00 00 
  210bf0:	c5 fc 11 84 24 ce 00 	vmovups YMMWORD PTR [rsp+0xce],ymm0
  210bf7:	00 00 
  210bf9:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  210bfe:	48 8b 84 24 e6 00 00 	mov    rax,QWORD PTR [rsp+0xe6]
  210c05:	00 
  210c06:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
  210c0a:	c5 fc 10 84 24 c8 00 	vmovups ymm0,YMMWORD PTR [rsp+0xc8]
  210c11:	00 00 
  210c13:	e9 1e fa ff ff       	jmp    210636 <parseAbbrevTable+0xa6>
  210c18:	66 b8 20 00          	mov    ax,0x20
  210c1c:	48 8b 54 24 38       	mov    rdx,QWORD PTR [rsp+0x38]
  210c21:	eb 04                	jmp    210c27 <parseAbbrevTable+0x697>
  210c23:	66 b8 25 00          	mov    ax,0x25
            const attr_id = try readULeb128(in_stream);
  210c27:	66 89 02             	mov    WORD PTR [rdx],ax
  210c2a:	48 8b 84 24 58 01 00 	mov    rax,QWORD PTR [rsp+0x158]
  210c31:	00 
  210c32:	48 89 42 20          	mov    QWORD PTR [rdx+0x20],rax
  210c36:	c5 fc 10 84 24 3a 01 	vmovups ymm0,YMMWORD PTR [rsp+0x13a]
  210c3d:	00 00 
  210c3f:	c5 fc 11 42 02       	vmovups YMMWORD PTR [rdx+0x2],ymm0
  210c44:	e9 f2 f9 ff ff       	jmp    21063b <parseAbbrevTable+0xab>
  210c49:	66 b8 20 00          	mov    ax,0x20
  210c4d:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  210c52:	66 89 01             	mov    WORD PTR [rcx],ax
  210c55:	48 8b 84 24 a4 01 00 	mov    rax,QWORD PTR [rsp+0x1a4]
  210c5c:	00 
  210c5d:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210c61:	c5 fc 10 84 24 86 01 	vmovups ymm0,YMMWORD PTR [rsp+0x186]
  210c68:	00 00 
  210c6a:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210c6f:	e9 c7 f9 ff ff       	jmp    21063b <parseAbbrevTable+0xab>
  210c74:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
        try result.append(AbbrevTableEntry{
  210c79:	66 89 01             	mov    WORD PTR [rcx],ax
  210c7c:	48 8b 84 24 7e 01 00 	mov    rax,QWORD PTR [rsp+0x17e]
  210c83:	00 
  210c84:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210c88:	c5 fc 10 84 24 60 01 	vmovups ymm0,YMMWORD PTR [rsp+0x160]
  210c8f:	00 00 
  210c91:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210c96:	e9 a0 f9 ff ff       	jmp    21063b <parseAbbrevTable+0xab>
  210c9b:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
            try attrs.append(AbbrevAttr{
  210ca0:	66 89 01             	mov    WORD PTR [rcx],ax
  210ca3:	48 8b 84 24 0c 01 00 	mov    rax,QWORD PTR [rsp+0x10c]
  210caa:	00 
  210cab:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210caf:	c5 fc 10 84 24 ee 00 	vmovups ymm0,YMMWORD PTR [rsp+0xee]
  210cb6:	00 00 
  210cb8:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210cbd:	e9 79 f9 ff ff       	jmp    21063b <parseAbbrevTable+0xab>
  210cc2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210cc9:	1f 84 00 00 00 00 00 

0000000000210cd0 <Allocator_alignedRealloc>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  210cd0:	41 56                	push   r14
  210cd2:	53                   	push   rbx
  210cd3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  210cda:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  210cdd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  210ce1:	48 85 c0             	test   rax,rax
  210ce4:	74 54                	je     210d3a <Allocator_alignedRealloc+0x6a>
        if (n == 0) {
  210ce6:	48 85 c9             	test   rcx,rcx
  210ce9:	0f 84 9b 00 00 00    	je     210d8a <Allocator_alignedRealloc+0xba>
        const old_byte_slice = @sliceToBytes(old_mem);
  210cef:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  210cf2:	48 6b c0 38          	imul   rax,rax,0x38
  210cf6:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  210cfb:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  210d00:	ba 38 00 00 00       	mov    edx,0x38
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  210d05:	48 89 c8             	mov    rax,rcx
  210d08:	48 f7 e2             	mul    rdx
  210d0b:	0f 81 c2 00 00 00    	jno    210dd3 <Allocator_alignedRealloc+0x103>
  210d11:	48 8d 0d b8 fa fe ff 	lea    rcx,[rip+0xfffffffffffefab8]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210d18:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210d1c:	0f 84 cc 00 00 00    	je     210dee <Allocator_alignedRealloc+0x11e>
  210d22:	48 8b 05 df 55 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff55df]        # 206308 <__unnamed_65+0x10>
  210d29:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  210d2d:	c5 f8 10 05 c3 55 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff55c3]        # 2062f8 <__unnamed_65>
  210d34:	ff 
  210d35:	e9 8a 00 00 00       	jmp    210dc4 <Allocator_alignedRealloc+0xf4>
        if (n == 0) {
  210d3a:	48 85 c9             	test   rcx,rcx
  210d3d:	0f 84 f8 00 00 00    	je     210e3b <Allocator_alignedRealloc+0x16b>
  210d43:	ba 38 00 00 00       	mov    edx,0x38
  210d48:	48 89 c8             	mov    rax,rcx
  210d4b:	48 f7 e2             	mul    rdx
  210d4e:	0f 81 08 01 00 00    	jno    210e5c <Allocator_alignedRealloc+0x18c>
  210d54:	48 8d 0d 75 fa fe ff 	lea    rcx,[rip+0xfffffffffffefa75]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210d5b:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210d5f:	0f 84 12 01 00 00    	je     210e77 <Allocator_alignedRealloc+0x1a7>
  210d65:	0f b7 05 92 55 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff5592]        # 2062fe <__unnamed_65+0x6>
  210d6c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  210d71:	8b 05 83 55 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff5583]        # 2062fa <__unnamed_65+0x2>
  210d77:	89 04 24             	mov    DWORD PTR [rsp],eax
  210d7a:	48 89 e0             	mov    rax,rsp
  210d7d:	66 b9 05 00          	mov    cx,0x5
  210d81:	31 f6                	xor    esi,esi
  210d83:	31 d2                	xor    edx,edx
  210d85:	e9 a9 01 00 00       	jmp    210f33 <Allocator_alignedRealloc+0x263>
        const bytes = @sliceToBytes(memory);
  210d8a:	48 6b c0 38          	imul   rax,rax,0x38
        if (bytes.len == 0) return;
  210d8e:	48 85 c0             	test   rax,rax
  210d91:	74 1e                	je     210db1 <Allocator_alignedRealloc+0xe1>
        const bytes = @sliceToBytes(memory);
  210d93:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  210d96:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  210d9a:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  210d9f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  210da4:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  210da9:	48 89 f7             	mov    rdi,rsi
  210dac:	48 89 c6             	mov    rsi,rax
  210daf:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  210db1:	48 8b 05 38 55 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff5538]        # 2062f0 <__unnamed_66+0x10>
  210db8:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  210dbc:	c5 f8 10 05 1c 55 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff551c]        # 2062e0 <__unnamed_66>
  210dc3:	ff 
  210dc4:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  210dc8:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210dcf:	5b                   	pop    rbx
  210dd0:	41 5e                	pop    r14
  210dd2:	c3                   	ret    
  210dd3:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  210dd8:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  210ddf:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210de4:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210de8:	0f 85 34 ff ff ff    	jne    210d22 <Allocator_alignedRealloc+0x52>
  210dee:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  210df2:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  210df7:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  210dfc:	41 b8 01 00 00 00    	mov    r8d,0x1
  210e02:	4c 89 f1             	mov    rcx,r14
  210e05:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  210e08:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  210e0d:	66 85 c0             	test   ax,ax
  210e10:	0f 84 97 00 00 00    	je     210ead <Allocator_alignedRealloc+0x1dd>
  210e16:	66 89 03             	mov    WORD PTR [rbx],ax
  210e19:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  210e20:	00 
  210e21:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  210e25:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  210e2b:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  210e30:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210e37:	5b                   	pop    rbx
  210e38:	41 5e                	pop    r14
  210e3a:	c3                   	ret    
  210e3b:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  210e3e:	0f b7 0d a1 54 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff54a1]        # 2062e6 <__unnamed_66+0x6>
  210e45:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  210e4a:	8b 0d 92 54 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff5492]        # 2062e2 <__unnamed_66+0x2>
  210e50:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  210e53:	31 c9                	xor    ecx,ecx
  210e55:	31 d2                	xor    edx,edx
  210e57:	e9 d7 00 00 00       	jmp    210f33 <Allocator_alignedRealloc+0x263>
  210e5c:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  210e61:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  210e68:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210e6d:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210e71:	0f 85 ee fe ff ff    	jne    210d65 <Allocator_alignedRealloc+0x95>
  210e77:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  210e7b:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  210e80:	b9 01 00 00 00       	mov    ecx,0x1
  210e85:	4c 89 f2             	mov    rdx,r14
  210e88:	ff 16                	call   QWORD PTR [rsi]
  210e8a:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  210e8f:	66 85 c9             	test   cx,cx
  210e92:	74 67                	je     210efb <Allocator_alignedRealloc+0x22b>
  210e94:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  210e99:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  210e9e:	48 89 e0             	mov    rax,rsp
  210ea1:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  210ea5:	89 14 24             	mov    DWORD PTR [rsp],edx
  210ea8:	e9 86 00 00 00       	jmp    210f33 <Allocator_alignedRealloc+0x263>
        assert(byte_slice.len == byte_count);
  210ead:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  210eb2:	0f 85 9e 00 00 00    	jne    210f56 <Allocator_alignedRealloc+0x286>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  210eb8:	49 c1 ee 03          	shr    r14,0x3
  210ebc:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  210ec3:	49 92 24 
  210ec6:	4c 89 f2             	mov    rdx,r14
  210ec9:	c4 e2 f3 f6 c0       	mulx   rax,rcx,rax
  210ece:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  210ed3:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  210ed8:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  210edc:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  210ee1:	8b 54 24 26          	mov    edx,DWORD PTR [rsp+0x26]
  210ee5:	89 53 02             	mov    DWORD PTR [rbx+0x2],edx
  210ee8:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  210eec:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  210ef0:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210ef7:	5b                   	pop    rbx
  210ef8:	41 5e                	pop    r14
  210efa:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  210efb:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  210f00:	75 54                	jne    210f56 <Allocator_alignedRealloc+0x286>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  210f02:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  210f07:	49 c1 ee 03          	shr    r14,0x3
  210f0b:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  210f12:	49 92 24 
  210f15:	4c 89 f2             	mov    rdx,r14
  210f18:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  210f1d:	48 89 e0             	mov    rax,rsp
  210f20:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  210f24:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  210f27:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  210f2c:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  210f31:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  210f33:	66 89 0b             	mov    WORD PTR [rbx],cx
  210f36:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  210f3a:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  210f3e:	8b 00                	mov    eax,DWORD PTR [rax]
  210f40:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  210f43:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  210f47:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  210f4b:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210f52:	5b                   	pop    rbx
  210f53:	41 5e                	pop    r14
  210f55:	c3                   	ret    
            @panic("assertion failure");
  210f56:	e8 55 8d ff ff       	call   209cb0 <panic>
  210f5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000210f60 <Allocator_alignedRealloc.41>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  210f60:	41 56                	push   r14
  210f62:	53                   	push   rbx
  210f63:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  210f6a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  210f6d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  210f71:	48 85 c0             	test   rax,rax
  210f74:	74 5e                	je     210fd4 <Allocator_alignedRealloc.41+0x74>
        if (n == 0) {
  210f76:	48 85 c9             	test   rcx,rcx
  210f79:	0f 84 a6 00 00 00    	je     211025 <Allocator_alignedRealloc.41+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  210f7f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  210f82:	48 c1 e0 04          	shl    rax,0x4
  210f86:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  210f8b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  210f90:	ba 10 00 00 00       	mov    edx,0x10
  210f95:	48 89 c8             	mov    rax,rcx
  210f98:	48 f7 e2             	mul    rdx
  210f9b:	0f 81 ca 00 00 00    	jno    21106b <Allocator_alignedRealloc.41+0x10b>
  210fa1:	48 8d 0d 28 f8 fe ff 	lea    rcx,[rip+0xfffffffffffef828]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210fa8:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210fac:	0f 84 d4 00 00 00    	je     211086 <Allocator_alignedRealloc.41+0x126>
  210fb2:	48 8b 05 7f 53 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff537f]        # 206338 <__unnamed_67+0x10>
  210fb9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  210fbd:	c5 f8 10 05 63 53 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff5363]        # 206328 <__unnamed_67>
  210fc4:	ff 
  210fc5:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  210fc9:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210fd0:	5b                   	pop    rbx
  210fd1:	41 5e                	pop    r14
  210fd3:	c3                   	ret    
        if (n == 0) {
  210fd4:	48 85 c9             	test   rcx,rcx
  210fd7:	0f 84 f6 00 00 00    	je     2110d3 <Allocator_alignedRealloc.41+0x173>
  210fdd:	ba 10 00 00 00       	mov    edx,0x10
  210fe2:	48 89 c8             	mov    rax,rcx
  210fe5:	48 f7 e2             	mul    rdx
  210fe8:	0f 81 07 01 00 00    	jno    2110f5 <Allocator_alignedRealloc.41+0x195>
  210fee:	48 8d 0d db f7 fe ff 	lea    rcx,[rip+0xfffffffffffef7db]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210ff5:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210ff9:	0f 84 11 01 00 00    	je     211110 <Allocator_alignedRealloc.41+0x1b0>
  210fff:	0f b7 05 28 53 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff5328]        # 20632e <__unnamed_67+0x6>
  211006:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21100b:	8b 05 19 53 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff5319]        # 20632a <__unnamed_67+0x2>
  211011:	89 04 24             	mov    DWORD PTR [rsp],eax
  211014:	48 89 e0             	mov    rax,rsp
  211017:	66 b9 05 00          	mov    cx,0x5
  21101b:	31 d2                	xor    edx,edx
  21101d:	45 31 f6             	xor    r14d,r14d
  211020:	e9 6f 01 00 00       	jmp    211194 <Allocator_alignedRealloc.41+0x234>
        const bytes = @sliceToBytes(memory);
  211025:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  211029:	74 1e                	je     211049 <Allocator_alignedRealloc.41+0xe9>
        const bytes = @sliceToBytes(memory);
  21102b:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21102e:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  211032:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  211037:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21103c:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  211041:	48 89 f7             	mov    rdi,rsi
  211044:	48 89 c6             	mov    rsi,rax
  211047:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  211049:	48 8b 05 d0 52 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff52d0]        # 206320 <__unnamed_68+0x10>
  211050:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  211054:	c5 f8 10 05 b4 52 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff52b4]        # 206310 <__unnamed_68>
  21105b:	ff 
  21105c:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  211060:	48 81 c4 88 00 00 00 	add    rsp,0x88
  211067:	5b                   	pop    rbx
  211068:	41 5e                	pop    r14
  21106a:	c3                   	ret    
  21106b:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  211070:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  211077:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21107c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  211080:	0f 85 2c ff ff ff    	jne    210fb2 <Allocator_alignedRealloc.41+0x52>
  211086:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21108a:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  21108f:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  211094:	41 b8 08 00 00 00    	mov    r8d,0x8
  21109a:	4c 89 f1             	mov    rcx,r14
  21109d:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  2110a0:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  2110a5:	66 85 c0             	test   ax,ax
  2110a8:	0f 84 95 00 00 00    	je     211143 <Allocator_alignedRealloc.41+0x1e3>
  2110ae:	66 89 03             	mov    WORD PTR [rbx],ax
  2110b1:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2110b8:	00 
  2110b9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2110bd:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  2110c3:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  2110c8:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2110cf:	5b                   	pop    rbx
  2110d0:	41 5e                	pop    r14
  2110d2:	c3                   	ret    
  2110d3:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  2110d6:	0f b7 0d 39 52 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff5239]        # 206316 <__unnamed_68+0x6>
  2110dd:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2110e2:	8b 0d 2a 52 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff522a]        # 206312 <__unnamed_68+0x2>
  2110e8:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2110eb:	31 c9                	xor    ecx,ecx
  2110ed:	45 31 f6             	xor    r14d,r14d
  2110f0:	e9 9f 00 00 00       	jmp    211194 <Allocator_alignedRealloc.41+0x234>
  2110f5:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  2110fa:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  211101:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  211106:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21110a:	0f 85 ef fe ff ff    	jne    210fff <Allocator_alignedRealloc.41+0x9f>
  211110:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  211114:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  211119:	b9 08 00 00 00       	mov    ecx,0x8
  21111e:	4c 89 f2             	mov    rdx,r14
  211121:	ff 16                	call   QWORD PTR [rsi]
  211123:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  211128:	66 85 c9             	test   cx,cx
  21112b:	74 41                	je     21116e <Allocator_alignedRealloc.41+0x20e>
  21112d:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  211132:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  211137:	48 89 e0             	mov    rax,rsp
  21113a:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  21113e:	89 14 24             	mov    DWORD PTR [rsp],edx
  211141:	eb 51                	jmp    211194 <Allocator_alignedRealloc.41+0x234>
        assert(byte_slice.len == byte_count);
  211143:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  211148:	75 6d                	jne    2111b7 <Allocator_alignedRealloc.41+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21114a:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21114f:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  211154:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  211159:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21115d:	49 c1 ee 04          	shr    r14,0x4
  211161:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  211165:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  211168:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21116c:	eb 3a                	jmp    2111a8 <Allocator_alignedRealloc.41+0x248>
        assert(byte_slice.len == byte_count);
  21116e:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  211173:	75 42                	jne    2111b7 <Allocator_alignedRealloc.41+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  211175:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21117a:	49 c1 ee 04          	shr    r14,0x4
  21117e:	48 89 e0             	mov    rax,rsp
  211181:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  211185:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  211188:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21118d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  211192:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  211194:	66 89 0b             	mov    WORD PTR [rbx],cx
  211197:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21119b:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21119f:	8b 00                	mov    eax,DWORD PTR [rax]
  2111a1:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  2111a4:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  2111a8:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  2111ac:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2111b3:	5b                   	pop    rbx
  2111b4:	41 5e                	pop    r14
  2111b6:	c3                   	ret    
            @panic("assertion failure");
  2111b7:	e8 f4 8a ff ff       	call   209cb0 <panic>
  2111bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000002111c0 <Allocator_alignedRealloc.44>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  2111c0:	41 56                	push   r14
  2111c2:	53                   	push   rbx
  2111c3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  2111ca:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  2111cd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  2111d1:	48 85 c0             	test   rax,rax
  2111d4:	74 62                	je     211238 <Allocator_alignedRealloc.44+0x78>
        if (n == 0) {
  2111d6:	48 85 c9             	test   rcx,rcx
  2111d9:	0f 84 a9 00 00 00    	je     211288 <Allocator_alignedRealloc.44+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  2111df:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  2111e2:	48 c1 e0 03          	shl    rax,0x3
  2111e6:	48 8d 04 80          	lea    rax,[rax+rax*4]
  2111ea:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  2111ef:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  2111f4:	ba 28 00 00 00       	mov    edx,0x28
  2111f9:	48 89 c8             	mov    rax,rcx
  2111fc:	48 f7 e2             	mul    rdx
  2111ff:	0f 81 d0 00 00 00    	jno    2112d5 <Allocator_alignedRealloc.44+0x115>
  211205:	48 8d 0d c4 f5 fe ff 	lea    rcx,[rip+0xfffffffffffef5c4]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21120c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  211210:	0f 84 da 00 00 00    	je     2112f0 <Allocator_alignedRealloc.44+0x130>
  211216:	48 8b 05 4b 51 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff514b]        # 206368 <__unnamed_69+0x10>
  21121d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  211221:	c5 f8 10 05 2f 51 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff512f]        # 206358 <__unnamed_69>
  211228:	ff 
  211229:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21122d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  211234:	5b                   	pop    rbx
  211235:	41 5e                	pop    r14
  211237:	c3                   	ret    
        if (n == 0) {
  211238:	48 85 c9             	test   rcx,rcx
  21123b:	0f 84 fc 00 00 00    	je     21133d <Allocator_alignedRealloc.44+0x17d>
  211241:	ba 28 00 00 00       	mov    edx,0x28
  211246:	48 89 c8             	mov    rax,rcx
  211249:	48 f7 e2             	mul    rdx
  21124c:	0f 81 0c 01 00 00    	jno    21135e <Allocator_alignedRealloc.44+0x19e>
  211252:	48 8d 0d 77 f5 fe ff 	lea    rcx,[rip+0xfffffffffffef577]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  211259:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21125d:	0f 84 16 01 00 00    	je     211379 <Allocator_alignedRealloc.44+0x1b9>
  211263:	0f b7 05 f4 50 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff50f4]        # 20635e <__unnamed_69+0x6>
  21126a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21126f:	8b 05 e5 50 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff50e5]        # 20635a <__unnamed_69+0x2>
  211275:	89 04 24             	mov    DWORD PTR [rsp],eax
  211278:	48 89 e0             	mov    rax,rsp
  21127b:	66 b9 05 00          	mov    cx,0x5
  21127f:	31 f6                	xor    esi,esi
  211281:	31 d2                	xor    edx,edx
  211283:	e9 9d 01 00 00       	jmp    211425 <Allocator_alignedRealloc.44+0x265>
        const bytes = @sliceToBytes(memory);
  211288:	48 c1 e0 03          	shl    rax,0x3
  21128c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  211290:	48 85 c0             	test   rax,rax
  211293:	74 1e                	je     2112b3 <Allocator_alignedRealloc.44+0xf3>
        const bytes = @sliceToBytes(memory);
  211295:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  211298:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  21129c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2112a1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2112a6:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2112ab:	48 89 f7             	mov    rdi,rsi
  2112ae:	48 89 c6             	mov    rsi,rax
  2112b1:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  2112b3:	48 8b 05 96 50 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff5096]        # 206350 <__unnamed_70+0x10>
  2112ba:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2112be:	c5 f8 10 05 7a 50 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff507a]        # 206340 <__unnamed_70>
  2112c5:	ff 
  2112c6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2112ca:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2112d1:	5b                   	pop    rbx
  2112d2:	41 5e                	pop    r14
  2112d4:	c3                   	ret    
  2112d5:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  2112da:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  2112e1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2112e6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2112ea:	0f 85 26 ff ff ff    	jne    211216 <Allocator_alignedRealloc.44+0x56>
  2112f0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2112f4:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  2112f9:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2112fe:	41 b8 08 00 00 00    	mov    r8d,0x8
  211304:	4c 89 f1             	mov    rcx,r14
  211307:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21130a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21130f:	66 85 c0             	test   ax,ax
  211312:	0f 84 94 00 00 00    	je     2113ac <Allocator_alignedRealloc.44+0x1ec>
  211318:	66 89 03             	mov    WORD PTR [rbx],ax
  21131b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  211322:	00 
  211323:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  211327:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  21132d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  211332:	48 81 c4 88 00 00 00 	add    rsp,0x88
  211339:	5b                   	pop    rbx
  21133a:	41 5e                	pop    r14
  21133c:	c3                   	ret    
  21133d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  211340:	0f b7 0d ff 4f ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff4fff]        # 206346 <__unnamed_70+0x6>
  211347:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21134c:	8b 0d f0 4f ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff4ff0]        # 206342 <__unnamed_70+0x2>
  211352:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  211355:	31 c9                	xor    ecx,ecx
  211357:	31 d2                	xor    edx,edx
  211359:	e9 c7 00 00 00       	jmp    211425 <Allocator_alignedRealloc.44+0x265>
  21135e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  211363:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  21136a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21136f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  211373:	0f 85 ea fe ff ff    	jne    211263 <Allocator_alignedRealloc.44+0xa3>
  211379:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21137d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  211382:	b9 08 00 00 00       	mov    ecx,0x8
  211387:	4c 89 f2             	mov    rdx,r14
  21138a:	ff 16                	call   QWORD PTR [rsi]
  21138c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  211391:	66 85 c9             	test   cx,cx
  211394:	74 57                	je     2113ed <Allocator_alignedRealloc.44+0x22d>
  211396:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  21139b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2113a0:	48 89 e0             	mov    rax,rsp
  2113a3:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  2113a7:	89 14 24             	mov    DWORD PTR [rsp],edx
  2113aa:	eb 79                	jmp    211425 <Allocator_alignedRealloc.44+0x265>
        assert(byte_slice.len == byte_count);
  2113ac:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  2113b1:	0f 85 91 00 00 00    	jne    211448 <Allocator_alignedRealloc.44+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2113b7:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2113bc:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  2113c3:	cc cc cc 
  2113c6:	4c 89 f2             	mov    rdx,r14
  2113c9:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  2113ce:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  2113d3:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  2113d8:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2113dc:	48 c1 ea 05          	shr    rdx,0x5
  2113e0:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  2113e4:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  2113e7:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  2113eb:	eb 4c                	jmp    211439 <Allocator_alignedRealloc.44+0x279>
        assert(byte_slice.len == byte_count);
  2113ed:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  2113f2:	75 54                	jne    211448 <Allocator_alignedRealloc.44+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2113f4:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2113f9:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  211400:	cc cc cc 
  211403:	4c 89 f2             	mov    rdx,r14
  211406:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  21140b:	48 c1 ea 05          	shr    rdx,0x5
  21140f:	48 89 e0             	mov    rax,rsp
  211412:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  211416:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  211419:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21141e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  211423:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  211425:	66 89 0b             	mov    WORD PTR [rbx],cx
  211428:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21142c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  211430:	8b 00                	mov    eax,DWORD PTR [rax]
  211432:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  211435:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  211439:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  21143d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  211444:	5b                   	pop    rbx
  211445:	41 5e                	pop    r14
  211447:	c3                   	ret    
            @panic("assertion failure");
  211448:	e8 63 88 ff ff       	call   209cb0 <panic>
  21144d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000211450 <parseFormValue>:
fn parseFormValue(allocator: *mem.Allocator, in_stream: var, form_id: u64, is_64: bool) ParseFormValueError!FormValue {
  211450:	55                   	push   rbp
  211451:	41 57                	push   r15
  211453:	41 56                	push   r14
  211455:	41 55                	push   r13
  211457:	41 54                	push   r12
  211459:	53                   	push   rbx
  21145a:	48 81 ec 08 07 00 00 	sub    rsp,0x708
  211461:	44 89 c5             	mov    ebp,r8d
  211464:	48 89 cb             	mov    rbx,rcx
  211467:	49 89 d4             	mov    r12,rdx
  21146a:	49 89 f7             	mov    r15,rsi
  21146d:	49 89 fe             	mov    r14,rdi
  211470:	48 8d 05 61 4f ff ff 	lea    rax,[rip+0xffffffffffff4f61]        # 2063d8 <__unnamed_71>
    return switch (form_id) {
  211477:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  21147b:	48 83 f9 1f          	cmp    rcx,0x1f
  21147f:	0f 87 d1 19 00 00    	ja     212e56 <parseFormValue+0x1a06>
  211485:	48 8d 15 18 00 ff ff 	lea    rdx,[rip+0xffffffffffff0018]        # 2014a4 <__unnamed_9+0x7c4>
  21148c:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  211490:	48 01 d1             	add    rcx,rdx
  211493:	ff e1                	jmp    rcx
  211495:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  21149c:	00 
  21149d:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  2114a2:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  2114a9:	00 
            try self.readNoEof(result[0..]);
  2114aa:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  2114af:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2114b6:	00 00 
  2114b8:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2114bd:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2114c2:	4c 89 e6             	mov    rsi,r12
  2114c5:	41 ff 14 24          	call   QWORD PTR [r12]
  2114c9:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2114ce:	66 85 c0             	test   ax,ax
  2114d1:	0f 84 f2 0b 00 00    	je     2120c9 <parseFormValue+0xc79>
  2114d7:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  2114dc:	66 89 01             	mov    WORD PTR [rcx],ax
  2114df:	48 8b 84 24 b4 06 00 	mov    rax,QWORD PTR [rsp+0x6b4]
  2114e6:	00 
  2114e7:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  2114eb:	c5 fc 10 84 24 96 06 	vmovups ymm0,YMMWORD PTR [rsp+0x696]
  2114f2:	00 00 
  2114f4:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  2114f9:	e9 69 19 00 00       	jmp    212e67 <parseFormValue+0x1a17>
  2114fe:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  211503:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211508:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  21150f:	00 00 
  211511:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211516:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21151b:	4c 89 e6             	mov    rsi,r12
  21151e:	41 ff 14 24          	call   QWORD PTR [r12]
  211522:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211527:	66 85 c0             	test   ax,ax
  21152a:	75 14                	jne    211540 <parseFormValue+0xf0>
  21152c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211531:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211535:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21153a:	0f 83 ce 12 00 00    	jae    21280e <parseFormValue+0x13be>
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  211540:	66 41 89 06          	mov    WORD PTR [r14],ax
  211544:	48 8b 84 24 00 07 00 	mov    rax,QWORD PTR [rsp+0x700]
  21154b:	00 
  21154c:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  211550:	c5 fc 10 84 24 e2 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6e2]
  211557:	00 00 
  211559:	e9 0b 0d 00 00       	jmp    212269 <parseFormValue+0xe19>
  21155e:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  211563:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211568:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  21156f:	00 00 
  211571:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211576:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21157b:	4c 89 e6             	mov    rsi,r12
  21157e:	41 ff 14 24          	call   QWORD PTR [r12]
  211582:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211587:	66 85 c9             	test   cx,cx
  21158a:	75 14                	jne    2115a0 <parseFormValue+0x150>
            if (amt_read < buf.len) return error.EndOfStream;
  21158c:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  211591:	66 b9 20 00          	mov    cx,0x20
  211595:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  21159a:	0f 83 d8 12 00 00    	jae    212878 <parseFormValue+0x1428>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  2115a0:	66 89 8c 24 90 02 00 	mov    WORD PTR [rsp+0x290],cx
  2115a7:	00 
  2115a8:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2115ac:	89 84 24 92 02 00 00 	mov    DWORD PTR [rsp+0x292],eax
  2115b3:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2115b8:	66 89 84 24 96 02 00 	mov    WORD PTR [rsp+0x296],ax
  2115bf:	00 
  2115c0:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  2115c4:	89 84 24 a9 02 00 00 	mov    DWORD PTR [rsp+0x2a9],eax
  2115cb:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  2115d0:	66 89 84 24 ad 02 00 	mov    WORD PTR [rsp+0x2ad],ax
  2115d7:	00 
  2115d8:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  2115dc:	88 84 24 af 02 00 00 	mov    BYTE PTR [rsp+0x2af],al
  2115e3:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  2115e7:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  2115ee:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  2115f3:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  2115fa:	00 
  2115fb:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  2115ff:	88 84 24 b7 02 00 00 	mov    BYTE PTR [rsp+0x2b7],al
  211606:	48 8d 84 24 90 02 00 	lea    rax,[rsp+0x290]
  21160d:	00 
  21160e:	e9 43 18 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  211613:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  211618:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21161d:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  211624:	00 00 
  211626:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21162b:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211630:	4c 89 e6             	mov    rsi,r12
  211633:	41 ff 14 24          	call   QWORD PTR [r12]
  211637:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21163c:	66 85 c9             	test   cx,cx
  21163f:	75 14                	jne    211655 <parseFormValue+0x205>
            if (amt_read < buf.len) return error.EndOfStream;
  211641:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  211646:	66 b9 20 00          	mov    cx,0x20
  21164a:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  21164f:	0f 83 44 12 00 00    	jae    212899 <parseFormValue+0x1449>
  211655:	66 89 8c 24 68 02 00 	mov    WORD PTR [rsp+0x268],cx
  21165c:	00 
  21165d:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211661:	89 84 24 6a 02 00 00 	mov    DWORD PTR [rsp+0x26a],eax
  211668:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21166d:	66 89 84 24 6e 02 00 	mov    WORD PTR [rsp+0x26e],ax
  211674:	00 
  211675:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211679:	89 84 24 81 02 00 00 	mov    DWORD PTR [rsp+0x281],eax
  211680:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211685:	66 89 84 24 85 02 00 	mov    WORD PTR [rsp+0x285],ax
  21168c:	00 
  21168d:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211691:	88 84 24 87 02 00 00 	mov    BYTE PTR [rsp+0x287],al
  211698:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21169c:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  2116a3:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  2116a8:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  2116af:	00 
  2116b0:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  2116b4:	88 84 24 8f 02 00 00 	mov    BYTE PTR [rsp+0x28f],al
  2116bb:	48 8d 84 24 68 02 00 	lea    rax,[rsp+0x268]
  2116c2:	00 
  2116c3:	e9 8e 17 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  2116c8:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  2116cd:	b9 02 00 00 00       	mov    ecx,0x2
  2116d2:	4c 89 fe             	mov    rsi,r15
  2116d5:	4c 89 e2             	mov    rdx,r12
  2116d8:	e8 03 2b 00 00       	call   2141e0 <readAllocBytes>
  2116dd:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2116e2:	66 85 c0             	test   ax,ax
  2116e5:	0f 84 89 0b 00 00    	je     212274 <parseFormValue+0xe24>
  2116eb:	66 89 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],ax
  2116f2:	00 
  2116f3:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2116f7:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
  2116fe:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211703:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  21170a:	00 
  21170b:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21170f:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  211716:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  21171b:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  211722:	00 
  211723:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211727:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  21172e:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211732:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  211739:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21173e:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  211745:	00 
  211746:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21174a:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  211751:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  211758:	00 
  211759:	e9 f8 16 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  21175e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211763:	b9 04 00 00 00       	mov    ecx,0x4
  211768:	4c 89 fe             	mov    rsi,r15
  21176b:	4c 89 e2             	mov    rdx,r12
  21176e:	e8 6d 2a 00 00       	call   2141e0 <readAllocBytes>
  211773:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  211778:	66 85 c0             	test   ax,ax
  21177b:	0f 84 9d 0b 00 00    	je     21231e <parseFormValue+0xece>
  211781:	66 89 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],ax
  211788:	00 
  211789:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21178d:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
  211794:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211799:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  2117a0:	00 
  2117a1:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  2117a5:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  2117ac:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  2117b1:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  2117b8:	00 
  2117b9:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  2117bd:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  2117c4:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  2117c8:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  2117cf:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  2117d4:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  2117db:	00 
  2117dc:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  2117e0:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  2117e7:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  2117ee:	00 
  2117ef:	e9 62 16 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  2117f4:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2117f9:	b9 08 00 00 00       	mov    ecx,0x8
  2117fe:	4c 89 fe             	mov    rsi,r15
  211801:	4c 89 e2             	mov    rdx,r12
  211804:	e8 d7 29 00 00       	call   2141e0 <readAllocBytes>
  211809:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21180e:	66 85 c0             	test   ax,ax
  211811:	0f 84 b1 0b 00 00    	je     2123c8 <parseFormValue+0xf78>
  211817:	66 89 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],ax
  21181e:	00 
  21181f:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211823:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
  21182a:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21182f:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  211836:	00 
  211837:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21183b:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  211842:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211847:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  21184e:	00 
  21184f:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211853:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  21185a:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21185e:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  211865:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21186a:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  211871:	00 
  211872:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211876:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  21187d:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  211884:	00 
  211885:	e9 cc 15 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  21188a:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
            return Self{
  21188f:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  211893:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  211899:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  2118a0:	00 00 
  2118a2:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  2118a9:	00 
    var buf = ArrayList(u8).init(allocator);
  2118aa:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  2118af:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  2118b6:	00 
            try self.readNoEof(result[0..]);
  2118b7:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  2118be:	00 
  2118bf:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  2118c6:	00 01 00 00 00 
  2118cb:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  2118d0:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  2118d7:	00 
            return self.readFn(self, buffer);
  2118d8:	4c 89 e6             	mov    rsi,r12
  2118db:	41 ff 14 24          	call   QWORD PTR [r12]
  2118df:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
            const amt_read = try self.read(buf);
  2118e4:	66 85 c0             	test   ax,ax
  2118e7:	0f 84 85 0b 00 00    	je     212472 <parseFormValue+0x1022>
  2118ed:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  2118f2:	66 89 01             	mov    WORD PTR [rcx],ax
  2118f5:	48 8b 84 24 84 05 00 	mov    rax,QWORD PTR [rsp+0x584]
  2118fc:	00 
  2118fd:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  211901:	c5 fc 10 84 24 66 05 	vmovups ymm0,YMMWORD PTR [rsp+0x566]
  211908:	00 00 
  21190a:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  21190f:	e9 53 15 00 00       	jmp    212e67 <parseFormValue+0x1a17>
  211914:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  21191b:	00 
  21191c:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  211921:	4c 8d ac 24 b0 00 00 	lea    r13,[rsp+0xb0]
  211928:	00 
            try self.readNoEof(result[0..]);
  211929:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  21192e:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  211935:	00 00 
  211937:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21193c:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211941:	4c 89 e6             	mov    rsi,r12
  211944:	41 ff 14 24          	call   QWORD PTR [r12]
  211948:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21194d:	66 85 c0             	test   ax,ax
  211950:	0f 84 fa 0b 00 00    	je     212550 <parseFormValue+0x1100>
  211956:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  21195b:	66 89 01             	mov    WORD PTR [rcx],ax
  21195e:	48 8b 84 24 da 06 00 	mov    rax,QWORD PTR [rsp+0x6da]
  211965:	00 
  211966:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21196a:	c5 fc 10 84 24 bc 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6bc]
  211971:	00 00 
  211973:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  211978:	e9 ea 14 00 00       	jmp    212e67 <parseFormValue+0x1a17>
  21197d:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  211982:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211987:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21198e:	00 00 
  211990:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211995:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21199a:	4c 89 e6             	mov    rsi,r12
  21199d:	41 ff 14 24          	call   QWORD PTR [r12]
  2119a1:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2119a6:	66 85 c9             	test   cx,cx
  2119a9:	75 14                	jne    2119bf <parseFormValue+0x56f>
            if (amt_read < buf.len) return error.EndOfStream;
  2119ab:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  2119b0:	66 b9 20 00          	mov    cx,0x20
  2119b4:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  2119b9:	0f 83 fb 0e 00 00    	jae    2128ba <parseFormValue+0x146a>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  2119bf:	66 89 8c 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],cx
  2119c6:	00 
  2119c7:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2119cb:	89 84 24 ba 02 00 00 	mov    DWORD PTR [rsp+0x2ba],eax
  2119d2:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2119d7:	66 89 84 24 be 02 00 	mov    WORD PTR [rsp+0x2be],ax
  2119de:	00 
  2119df:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  2119e3:	89 84 24 d1 02 00 00 	mov    DWORD PTR [rsp+0x2d1],eax
  2119ea:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  2119ef:	66 89 84 24 d5 02 00 	mov    WORD PTR [rsp+0x2d5],ax
  2119f6:	00 
  2119f7:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  2119fb:	88 84 24 d7 02 00 00 	mov    BYTE PTR [rsp+0x2d7],al
  211a02:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211a06:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  211a0d:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  211a12:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  211a19:	00 
  211a1a:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211a1e:	88 84 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],al
  211a25:	48 8d 84 24 b8 02 00 	lea    rax,[rsp+0x2b8]
  211a2c:	00 
  211a2d:	e9 24 14 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  211a32:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  211a37:	b9 01 00 00 00       	mov    ecx,0x1
  211a3c:	4c 89 fe             	mov    rsi,r15
  211a3f:	4c 89 e2             	mov    rdx,r12
  211a42:	e8 99 27 00 00       	call   2141e0 <readAllocBytes>
  211a47:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  211a4c:	66 85 c0             	test   ax,ax
  211a4f:	0f 84 7c 0b 00 00    	je     2125d1 <parseFormValue+0x1181>
  211a55:	66 89 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],ax
  211a5c:	00 
  211a5d:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211a61:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
  211a68:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211a6d:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  211a74:	00 
  211a75:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211a79:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  211a80:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211a85:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  211a8c:	00 
  211a8d:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211a91:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  211a98:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211a9c:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  211aa3:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  211aa8:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  211aaf:	00 
  211ab0:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211ab4:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  211abb:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  211ac2:	00 
  211ac3:	e9 8e 13 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  211ac8:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  211acf:	00 
            try self.readNoEof(result[0..]);
  211ad0:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211ad5:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  211adc:	00 00 
  211ade:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211ae3:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211ae8:	4c 89 e6             	mov    rsi,r12
  211aeb:	41 ff 14 24          	call   QWORD PTR [r12]
  211aef:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211af4:	66 85 c0             	test   ax,ax
  211af7:	75 14                	jne    211b0d <parseFormValue+0x6bd>
  211af9:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211afe:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211b02:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211b07:	0f 83 ce 0d 00 00    	jae    2128db <parseFormValue+0x148b>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  211b0d:	66 41 89 06          	mov    WORD PTR [r14],ax
  211b11:	48 8b 84 24 42 06 00 	mov    rax,QWORD PTR [rsp+0x642]
  211b18:	00 
  211b19:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  211b1d:	c5 fc 10 84 24 24 06 	vmovups ymm0,YMMWORD PTR [rsp+0x624]
  211b24:	00 00 
  211b26:	e9 3e 07 00 00       	jmp    212269 <parseFormValue+0xe19>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  211b2b:	40 f6 c5 01          	test   bpl,0x1
  211b2f:	0f 84 1c 06 00 00    	je     212151 <parseFormValue+0xd01>
  211b35:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  211b3c:	00 
            try self.readNoEof(bytes[0..]);
  211b3d:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211b42:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  211b49:	00 00 
  211b4b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211b50:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211b55:	4c 89 e6             	mov    rsi,r12
  211b58:	41 ff 14 24          	call   QWORD PTR [r12]
  211b5c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211b61:	66 85 c0             	test   ax,ax
  211b64:	0f 85 29 06 00 00    	jne    212193 <parseFormValue+0xd43>
  211b6a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211b6f:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211b73:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211b78:	0f 82 15 06 00 00    	jb     212193 <parseFormValue+0xd43>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  211b7e:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  211b85:	00 
  211b86:	e9 4f 11 00 00       	jmp    212cda <parseFormValue+0x188a>
  211b8b:	40 f6 c5 01          	test   bpl,0x1
  211b8f:	0f 84 1c 06 00 00    	je     2121b1 <parseFormValue+0xd61>
  211b95:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  211b9c:	00 
            try self.readNoEof(bytes[0..]);
  211b9d:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211ba2:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  211ba9:	00 00 
  211bab:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211bb0:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211bb5:	4c 89 e6             	mov    rsi,r12
  211bb8:	41 ff 14 24          	call   QWORD PTR [r12]
  211bbc:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211bc1:	66 85 c0             	test   ax,ax
  211bc4:	0f 85 29 06 00 00    	jne    2121f3 <parseFormValue+0xda3>
  211bca:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211bcf:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211bd3:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211bd8:	0f 82 15 06 00 00    	jb     2121f3 <parseFormValue+0xda3>
  211bde:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  211be5:	00 
  211be6:	e9 7d 11 00 00       	jmp    212d68 <parseFormValue+0x1918>
  211beb:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  211bf2:	00 
            try self.readNoEof(bytes[0..]);
  211bf3:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211bf8:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  211bff:	00 00 
  211c01:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211c06:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211c0b:	4c 89 e6             	mov    rsi,r12
  211c0e:	41 ff 14 24          	call   QWORD PTR [r12]
  211c12:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211c17:	66 85 c0             	test   ax,ax
  211c1a:	75 14                	jne    211c30 <parseFormValue+0x7e0>
  211c1c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211c21:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211c25:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211c2a:	0f 83 30 0d 00 00    	jae    212960 <parseFormValue+0x1510>
    const block_len = try in_stream.readIntLe(T);
  211c30:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  211c37:	00 
  211c38:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211c3c:	89 84 24 42 02 00 00 	mov    DWORD PTR [rsp+0x242],eax
  211c43:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211c48:	66 89 84 24 46 02 00 	mov    WORD PTR [rsp+0x246],ax
  211c4f:	00 
  211c50:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211c54:	89 84 24 59 02 00 00 	mov    DWORD PTR [rsp+0x259],eax
  211c5b:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211c60:	66 89 84 24 5d 02 00 	mov    WORD PTR [rsp+0x25d],ax
  211c67:	00 
  211c68:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211c6c:	88 84 24 5f 02 00 00 	mov    BYTE PTR [rsp+0x25f],al
  211c73:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211c77:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  211c7e:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  211c83:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  211c8a:	00 
  211c8b:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211c8f:	88 84 24 67 02 00 00 	mov    BYTE PTR [rsp+0x267],al
  211c96:	48 8d 84 24 40 02 00 	lea    rax,[rsp+0x240]
  211c9d:	00 
  211c9e:	e9 b3 11 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  211ca3:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  211ca8:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211cad:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  211cb4:	00 00 
  211cb6:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211cbb:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211cc0:	4c 89 e6             	mov    rsi,r12
  211cc3:	41 ff 14 24          	call   QWORD PTR [r12]
  211cc7:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211ccc:	66 85 c0             	test   ax,ax
  211ccf:	75 14                	jne    211ce5 <parseFormValue+0x895>
  211cd1:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211cd6:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211cda:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211cdf:	0f 83 dd 0c 00 00    	jae    2129c2 <parseFormValue+0x1572>
  211ce5:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  211cec:	00 
  211ced:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211cf1:	89 84 24 1a 02 00 00 	mov    DWORD PTR [rsp+0x21a],eax
  211cf8:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211cfd:	66 89 84 24 1e 02 00 	mov    WORD PTR [rsp+0x21e],ax
  211d04:	00 
  211d05:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211d09:	89 84 24 31 02 00 00 	mov    DWORD PTR [rsp+0x231],eax
  211d10:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211d15:	66 89 84 24 35 02 00 	mov    WORD PTR [rsp+0x235],ax
  211d1c:	00 
  211d1d:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211d21:	88 84 24 37 02 00 00 	mov    BYTE PTR [rsp+0x237],al
  211d28:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211d2c:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  211d33:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  211d38:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  211d3f:	00 
  211d40:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211d44:	88 84 24 3f 02 00 00 	mov    BYTE PTR [rsp+0x23f],al
  211d4b:	48 8d 84 24 18 02 00 	lea    rax,[rsp+0x218]
  211d52:	00 
  211d53:	e9 fe 10 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  211d58:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  211d5d:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211d62:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  211d69:	00 00 
  211d6b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211d70:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211d75:	4c 89 e6             	mov    rsi,r12
  211d78:	41 ff 14 24          	call   QWORD PTR [r12]
  211d7c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211d81:	66 85 c0             	test   ax,ax
  211d84:	75 14                	jne    211d9a <parseFormValue+0x94a>
  211d86:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211d8b:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211d8f:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211d94:	0f 83 93 0c 00 00    	jae    212a2d <parseFormValue+0x15dd>
  211d9a:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  211da1:	00 
  211da2:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211da6:	89 84 24 f2 01 00 00 	mov    DWORD PTR [rsp+0x1f2],eax
  211dad:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211db2:	66 89 84 24 f6 01 00 	mov    WORD PTR [rsp+0x1f6],ax
  211db9:	00 
  211dba:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211dbe:	89 84 24 09 02 00 00 	mov    DWORD PTR [rsp+0x209],eax
  211dc5:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211dca:	66 89 84 24 0d 02 00 	mov    WORD PTR [rsp+0x20d],ax
  211dd1:	00 
  211dd2:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211dd6:	88 84 24 0f 02 00 00 	mov    BYTE PTR [rsp+0x20f],al
  211ddd:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211de1:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  211de8:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  211ded:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  211df4:	00 
  211df5:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211df9:	88 84 24 17 02 00 00 	mov    BYTE PTR [rsp+0x217],al
  211e00:	48 8d 84 24 f0 01 00 	lea    rax,[rsp+0x1f0]
  211e07:	00 
  211e08:	e9 49 10 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  211e0d:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  211e12:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211e17:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  211e1e:	00 00 
  211e20:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211e25:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211e2a:	4c 89 e6             	mov    rsi,r12
  211e2d:	41 ff 14 24          	call   QWORD PTR [r12]
  211e31:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211e36:	66 85 c0             	test   ax,ax
  211e39:	75 14                	jne    211e4f <parseFormValue+0x9ff>
  211e3b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211e40:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211e44:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211e49:	0f 83 61 0c 00 00    	jae    212ab0 <parseFormValue+0x1660>
  211e4f:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  211e56:	00 
  211e57:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211e5b:	89 84 24 ca 01 00 00 	mov    DWORD PTR [rsp+0x1ca],eax
  211e62:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211e67:	66 89 84 24 ce 01 00 	mov    WORD PTR [rsp+0x1ce],ax
  211e6e:	00 
  211e6f:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211e73:	89 84 24 e1 01 00 00 	mov    DWORD PTR [rsp+0x1e1],eax
  211e7a:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211e7f:	66 89 84 24 e5 01 00 	mov    WORD PTR [rsp+0x1e5],ax
  211e86:	00 
  211e87:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211e8b:	88 84 24 e7 01 00 00 	mov    BYTE PTR [rsp+0x1e7],al
  211e92:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211e96:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  211e9d:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  211ea2:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  211ea9:	00 
  211eaa:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211eae:	88 84 24 ef 01 00 00 	mov    BYTE PTR [rsp+0x1ef],al
  211eb5:	48 8d 84 24 c8 01 00 	lea    rax,[rsp+0x1c8]
  211ebc:	00 
  211ebd:	e9 94 0f 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  211ec2:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  211ec9:	00 
  211eca:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  211ecf:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  211ed6:	00 
            try self.readNoEof(result[0..]);
  211ed7:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  211edc:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  211ee3:	00 00 
  211ee5:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211eea:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211eef:	4c 89 e6             	mov    rsi,r12
  211ef2:	41 ff 14 24          	call   QWORD PTR [r12]
  211ef6:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211efb:	66 85 c0             	test   ax,ax
  211efe:	0f 84 77 07 00 00    	je     21267b <parseFormValue+0x122b>
  211f04:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const ref_len = try readULeb128(in_stream);
  211f09:	66 89 01             	mov    WORD PTR [rcx],ax
  211f0c:	48 8b 84 24 f6 05 00 	mov    rax,QWORD PTR [rsp+0x5f6]
  211f13:	00 
  211f14:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  211f18:	c5 fc 10 84 24 d8 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5d8]
  211f1f:	00 00 
  211f21:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  211f26:	e9 3c 0f 00 00       	jmp    212e67 <parseFormValue+0x1a17>
  211f2b:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  211f32:	00 
  211f33:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  211f38:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  211f3f:	00 
            try self.readNoEof(result[0..]);
  211f40:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  211f45:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  211f4c:	00 00 
  211f4e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211f53:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211f58:	4c 89 e6             	mov    rsi,r12
  211f5b:	41 ff 14 24          	call   QWORD PTR [r12]
  211f5f:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211f64:	66 85 c0             	test   ax,ax
  211f67:	0f 84 8f 07 00 00    	je     2126fc <parseFormValue+0x12ac>
  211f6d:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const child_form_id = try readULeb128(in_stream);
  211f72:	66 89 01             	mov    WORD PTR [rcx],ax
  211f75:	48 8b 84 24 38 05 00 	mov    rax,QWORD PTR [rsp+0x538]
  211f7c:	00 
  211f7d:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  211f81:	c5 fc 10 84 24 1a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x51a]
  211f88:	00 00 
  211f8a:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  211f8f:	e9 d3 0e 00 00       	jmp    212e67 <parseFormValue+0x1a17>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  211f94:	40 f6 c5 01          	test   bpl,0x1
  211f98:	0f 84 70 02 00 00    	je     21220e <parseFormValue+0xdbe>
  211f9e:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  211fa5:	00 
            try self.readNoEof(bytes[0..]);
  211fa6:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211fab:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  211fb2:	00 00 
  211fb4:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211fb9:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211fbe:	4c 89 e6             	mov    rsi,r12
  211fc1:	41 ff 14 24          	call   QWORD PTR [r12]
  211fc5:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211fca:	66 85 c0             	test   ax,ax
  211fcd:	0f 85 7d 02 00 00    	jne    212250 <parseFormValue+0xe00>
  211fd3:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211fd8:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211fdc:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211fe1:	0f 82 69 02 00 00    	jb     212250 <parseFormValue+0xe00>
  211fe7:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  211fee:	00 
  211fef:	e9 02 0e 00 00       	jmp    212df6 <parseFormValue+0x19a6>
  211ff4:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  211ffb:	00 
  211ffc:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  212001:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  212008:	00 
            try self.readNoEof(result[0..]);
  212009:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  21200e:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  212015:	00 00 
  212017:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21201c:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  212021:	4c 89 e6             	mov    rsi,r12
  212024:	41 ff 14 24          	call   QWORD PTR [r12]
  212028:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21202d:	66 85 c0             	test   ax,ax
  212030:	0f 84 45 07 00 00    	je     21277b <parseFormValue+0x132b>
  212036:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const size = try readULeb128(in_stream);
  21203b:	66 89 01             	mov    WORD PTR [rcx],ax
  21203e:	48 8b 84 24 8e 06 00 	mov    rax,QWORD PTR [rsp+0x68e]
  212045:	00 
  212046:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21204a:	c5 fc 10 84 24 70 06 	vmovups ymm0,YMMWORD PTR [rsp+0x670]
  212051:	00 00 
  212053:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  212058:	e9 0a 0e 00 00       	jmp    212e67 <parseFormValue+0x1a17>
  21205d:	48 8d 05 9c 43 ff ff 	lea    rax,[rip+0xffffffffffff439c]        # 206400 <__unnamed_72>
  212064:	e9 ed 0d 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  212069:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  21206e:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  212073:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  21207a:	00 00 
  21207c:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  212081:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  212086:	4c 89 e6             	mov    rsi,r12
  212089:	41 ff 14 24          	call   QWORD PTR [r12]
  21208d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  212092:	66 85 c0             	test   ax,ax
  212095:	75 14                	jne    2120ab <parseFormValue+0xc5b>
  212097:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21209c:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  2120a0:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2120a5:	0f 83 64 0a 00 00    	jae    212b0f <parseFormValue+0x16bf>
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  2120ab:	66 41 89 06          	mov    WORD PTR [r14],ax
  2120af:	48 8b 84 24 aa 05 00 	mov    rax,QWORD PTR [rsp+0x5aa]
  2120b6:	00 
  2120b7:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  2120bb:	c5 fc 10 84 24 8c 05 	vmovups ymm0,YMMWORD PTR [rsp+0x58c]
  2120c2:	00 00 
  2120c4:	e9 a0 01 00 00       	jmp    212269 <parseFormValue+0xe19>
  2120c9:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2120ce:	31 ed                	xor    ebp,ebp
  2120d0:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  2120d5:	45 31 ed             	xor    r13d,r13d
  2120d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2120df:	00 
  2120e0:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2120e5:	0f 82 11 07 00 00    	jb     2127fc <parseFormValue+0x13ac>
            return result[0];
  2120eb:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  2120f2:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2120f3:	89 c2                	mov    edx,eax
  2120f5:	83 e2 7f             	and    edx,0x7f
  2120f8:	44 89 ee             	mov    esi,r13d
  2120fb:	83 e6 3f             	and    esi,0x3f
  2120fe:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  212103:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  212108:	48 39 d6             	cmp    rsi,rdx
  21210b:	0f 85 f4 06 00 00    	jne    212805 <parseFormValue+0x13b5>
        result |= operand;
  212111:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  212114:	84 c0                	test   al,al
  212116:	0f 89 5d 0a 00 00    	jns    212b79 <parseFormValue+0x1729>
        shift += 7;
  21211c:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  212120:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  212125:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21212c:	00 00 
            return self.readFn(self, buffer);
  21212e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  212133:	4c 89 e6             	mov    rsi,r12
  212136:	4c 89 fa             	mov    rdx,r15
  212139:	41 ff 14 24          	call   QWORD PTR [r12]
  21213d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  212142:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  212147:	66 85 c0             	test   ax,ax
  21214a:	74 94                	je     2120e0 <parseFormValue+0xc90>
  21214c:	e9 86 f3 ff ff       	jmp    2114d7 <parseFormValue+0x87>
  212151:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  212156:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21215b:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  212162:	00 00 
  212164:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  212169:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21216e:	4c 89 e6             	mov    rsi,r12
  212171:	41 ff 14 24          	call   QWORD PTR [r12]
  212175:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21217a:	66 85 c0             	test   ax,ax
  21217d:	75 14                	jne    212193 <parseFormValue+0xd43>
  21217f:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  212184:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  212188:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21218d:	0f 83 1e 0b 00 00    	jae    212cb1 <parseFormValue+0x1861>
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  212193:	66 41 89 06          	mov    WORD PTR [r14],ax
  212197:	48 8b 84 24 5e 05 00 	mov    rax,QWORD PTR [rsp+0x55e]
  21219e:	00 
  21219f:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  2121a3:	c5 fc 10 84 24 40 05 	vmovups ymm0,YMMWORD PTR [rsp+0x540]
  2121aa:	00 00 
  2121ac:	e9 b8 00 00 00       	jmp    212269 <parseFormValue+0xe19>
  2121b1:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  2121b6:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2121bb:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  2121c2:	00 00 
  2121c4:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2121c9:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2121ce:	4c 89 e6             	mov    rsi,r12
  2121d1:	41 ff 14 24          	call   QWORD PTR [r12]
  2121d5:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2121da:	66 85 c0             	test   ax,ax
  2121dd:	75 14                	jne    2121f3 <parseFormValue+0xda3>
  2121df:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2121e4:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  2121e8:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2121ed:	0f 83 4c 0b 00 00    	jae    212d3f <parseFormValue+0x18ef>
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  2121f3:	66 41 89 06          	mov    WORD PTR [r14],ax
  2121f7:	48 8b 84 24 d0 05 00 	mov    rax,QWORD PTR [rsp+0x5d0]
  2121fe:	00 
  2121ff:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  212203:	c5 fc 10 84 24 b2 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5b2]
  21220a:	00 00 
  21220c:	eb 5b                	jmp    212269 <parseFormValue+0xe19>
  21220e:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  212213:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  212218:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  21221f:	00 00 
  212221:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  212226:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21222b:	4c 89 e6             	mov    rsi,r12
  21222e:	41 ff 14 24          	call   QWORD PTR [r12]
  212232:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  212237:	66 85 c0             	test   ax,ax
  21223a:	75 14                	jne    212250 <parseFormValue+0xe00>
  21223c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  212241:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  212245:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21224a:	0f 83 7d 0b 00 00    	jae    212dcd <parseFormValue+0x197d>
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  212250:	66 41 89 06          	mov    WORD PTR [r14],ax
  212254:	48 8b 84 24 1c 06 00 	mov    rax,QWORD PTR [rsp+0x61c]
  21225b:	00 
  21225c:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  212260:	c5 fc 10 84 24 fe 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5fe]
  212267:	00 00 
  212269:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  21226f:	e9 f3 0b 00 00       	jmp    212e67 <parseFormValue+0x1a17>
    return FormValue{
  212274:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  21227b:	00 
  21227c:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  212281:	66 c7 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],0x0
  212288:	00 00 00 
  21228b:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  21228f:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
        .Const = Constant{
  212296:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  21229c:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  2122a1:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  2122a8:	00 
  2122a9:	c5 f8 11 84 24 80 01 	vmovups XMMWORD PTR [rsp+0x180],xmm0
  2122b0:	00 00 
  2122b2:	c6 84 24 90 01 00 00 	mov    BYTE PTR [rsp+0x190],0x0
  2122b9:	00 
  2122ba:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  2122c1:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  2122c8:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  2122cf:	00 
  2122d0:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  2122d7:	00 
  2122d8:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  2122df:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  2122e6:	c6 84 24 98 01 00 00 	mov    BYTE PTR [rsp+0x198],0x2
  2122ed:	02 
  2122ee:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  2122f2:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  2122f9:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  2122fe:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  212305:	00 
  212306:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  21230a:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  212311:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  212318:	00 
  212319:	e9 38 0b 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  21231e:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  212325:	00 
  212326:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  21232b:	66 c7 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],0x0
  212332:	00 00 00 
  212335:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  212339:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
        .Const = Constant{
  212340:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  212346:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21234b:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  212352:	00 
  212353:	c5 f8 11 84 24 58 01 	vmovups XMMWORD PTR [rsp+0x158],xmm0
  21235a:	00 00 
  21235c:	c6 84 24 68 01 00 00 	mov    BYTE PTR [rsp+0x168],0x0
  212363:	00 
  212364:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  21236b:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  212372:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  212379:	00 
  21237a:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  212381:	00 
  212382:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  212389:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  212390:	c6 84 24 70 01 00 00 	mov    BYTE PTR [rsp+0x170],0x2
  212397:	02 
  212398:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  21239c:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  2123a3:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  2123a8:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  2123af:	00 
  2123b0:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  2123b4:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  2123bb:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  2123c2:	00 
  2123c3:	e9 8e 0a 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  2123c8:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  2123cf:	00 
  2123d0:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  2123d5:	66 c7 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],0x0
  2123dc:	00 00 00 
  2123df:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  2123e3:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
        .Const = Constant{
  2123ea:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  2123f0:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  2123f5:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  2123fc:	00 
  2123fd:	c5 f8 11 84 24 30 01 	vmovups XMMWORD PTR [rsp+0x130],xmm0
  212404:	00 00 
  212406:	c6 84 24 40 01 00 00 	mov    BYTE PTR [rsp+0x140],0x0
  21240d:	00 
  21240e:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  212415:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  21241c:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  212423:	00 
  212424:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  21242b:	00 
  21242c:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  212433:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  21243a:	c6 84 24 48 01 00 00 	mov    BYTE PTR [rsp+0x148],0x2
  212441:	02 
  212442:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  212446:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  21244d:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  212452:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  212459:	00 
  21245a:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  21245e:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  212465:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  21246c:	00 
  21246d:	e9 e4 09 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  212472:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  212477:	45 31 ed             	xor    r13d,r13d
  21247a:	48 8d 5c 24 18       	lea    rbx,[rsp+0x18]
  21247f:	31 ed                	xor    ebp,ebp
  212481:	48 3b 8c 24 98 00 00 	cmp    rcx,QWORD PTR [rsp+0x98]
  212488:	00 
  212489:	0f 82 90 07 00 00    	jb     212c1f <parseFormValue+0x17cf>
            return result[0];
  21248f:	44 8a bc 24 b0 00 00 	mov    r15b,BYTE PTR [rsp+0xb0]
  212496:	00 
        if (byte == 0) break;
  212497:	45 84 ff             	test   r15b,r15b
  21249a:	0f 84 88 07 00 00    	je     212c28 <parseFormValue+0x17d8>
            var better_capacity = self.items.len;
  2124a0:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  2124a5:	48 39 e9             	cmp    rcx,rbp
  2124a8:	77 4f                	ja     2124f9 <parseFormValue+0x10a9>
  2124aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                better_capacity += better_capacity / 2 + 8;
  2124b0:	48 89 c8             	mov    rax,rcx
  2124b3:	48 d1 e8             	shr    rax,1
  2124b6:	48 01 c1             	add    rcx,rax
  2124b9:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2124bd:	48 39 e9             	cmp    rcx,rbp
  2124c0:	76 ee                	jbe    2124b0 <parseFormValue+0x1060>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2124c2:	48 89 df             	mov    rdi,rbx
  2124c5:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  2124cc:	00 
  2124cd:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  2124d2:	e8 f9 46 00 00       	call   216bd0 <Allocator_alignedRealloc.71>
  2124d7:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  2124dc:	66 85 c0             	test   ax,ax
  2124df:	0f 85 08 f4 ff ff    	jne    2118ed <parseFormValue+0x49d>
  2124e5:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  2124ea:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2124ee:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  2124f4:	4c 8b 6c 24 40       	mov    r13,QWORD PTR [rsp+0x40]
  2124f9:	4c 8d 75 01          	lea    r14,[rbp+0x1]
            self.len = new_length;
  2124fd:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  212502:	45 88 7c 2d 00       	mov    BYTE PTR [r13+rbp*1+0x0],r15b
            try self.readNoEof(result[0..]);
  212507:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  21250e:	00 
  21250f:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  212516:	00 
  212517:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  21251e:	00 01 00 00 00 
            return self.readFn(self, buffer);
  212523:	48 89 df             	mov    rdi,rbx
  212526:	4c 89 e6             	mov    rsi,r12
  212529:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  212530:	00 
  212531:	41 ff 14 24          	call   QWORD PTR [r12]
  212535:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  21253a:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  21253f:	4c 89 f5             	mov    rbp,r14
            const amt_read = try self.read(buf);
  212542:	66 85 c0             	test   ax,ax
  212545:	0f 84 36 ff ff ff    	je     212481 <parseFormValue+0x1031>
  21254b:	e9 9d f3 ff ff       	jmp    2118ed <parseFormValue+0x49d>
  212550:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  212555:	31 db                	xor    ebx,ebx
  212557:	4c 8d 7c 24 40       	lea    r15,[rsp+0x40]
  21255c:	4c 8d 74 24 18       	lea    r14,[rsp+0x18]
  212561:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  212563:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  212568:	0f 82 1f 07 00 00    	jb     212c8d <parseFormValue+0x183d>
            return result[0];
  21256e:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  212575:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  212576:	89 c2                	mov    edx,eax
  212578:	83 e2 7f             	and    edx,0x7f
  21257b:	89 ee                	mov    esi,ebp
  21257d:	83 e6 3f             	and    esi,0x3f
  212580:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  212585:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21258a:	48 39 d6             	cmp    rsi,rdx
  21258d:	0f 85 e9 08 00 00    	jne    212e7c <parseFormValue+0x1a2c>
        result |= operand;
  212593:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  212596:	84 c0                	test   al,al
  212598:	0f 89 02 09 00 00    	jns    212ea0 <parseFormValue+0x1a50>
        shift += 7;
  21259e:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2125a2:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  2125a7:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2125ae:	00 00 
            return self.readFn(self, buffer);
  2125b0:	4c 89 ff             	mov    rdi,r15
  2125b3:	4c 89 e6             	mov    rsi,r12
  2125b6:	4c 89 f2             	mov    rdx,r14
  2125b9:	41 ff 14 24          	call   QWORD PTR [r12]
  2125bd:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2125c2:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  2125c7:	66 85 c0             	test   ax,ax
  2125ca:	74 97                	je     212563 <parseFormValue+0x1113>
  2125cc:	e9 85 f3 ff ff       	jmp    211956 <parseFormValue+0x506>
    return FormValue{
  2125d1:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  2125d8:	00 
  2125d9:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  2125de:	66 c7 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],0x0
  2125e5:	00 00 00 
  2125e8:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  2125ec:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
        .Const = Constant{
  2125f3:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  2125f9:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  2125fe:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  212605:	00 
  212606:	c5 f8 11 84 24 a8 01 	vmovups XMMWORD PTR [rsp+0x1a8],xmm0
  21260d:	00 00 
  21260f:	c6 84 24 b8 01 00 00 	mov    BYTE PTR [rsp+0x1b8],0x0
  212616:	00 
  212617:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  21261e:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  212625:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  21262c:	00 
  21262d:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  212634:	00 
  212635:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  21263c:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  212643:	c6 84 24 c0 01 00 00 	mov    BYTE PTR [rsp+0x1c0],0x2
  21264a:	02 
  21264b:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  21264f:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  212656:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  21265b:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  212662:	00 
  212663:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  212667:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  21266e:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  212675:	00 
  212676:	e9 db 07 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  21267b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  212680:	31 db                	xor    ebx,ebx
  212682:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  212687:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  21268c:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  21268e:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  212693:	0f 82 fd 05 00 00    	jb     212c96 <parseFormValue+0x1846>
            return result[0];
  212699:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  2126a0:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2126a1:	89 c2                	mov    edx,eax
  2126a3:	83 e2 7f             	and    edx,0x7f
  2126a6:	89 ee                	mov    esi,ebp
  2126a8:	83 e6 3f             	and    esi,0x3f
  2126ab:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2126b0:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2126b5:	48 39 d6             	cmp    rsi,rdx
  2126b8:	0f 85 c7 07 00 00    	jne    212e85 <parseFormValue+0x1a35>
        result |= operand;
  2126be:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  2126c1:	84 c0                	test   al,al
  2126c3:	0f 89 7d 08 00 00    	jns    212f46 <parseFormValue+0x1af6>
        shift += 7;
  2126c9:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2126cd:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  2126d2:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2126d9:	00 00 
            return self.readFn(self, buffer);
  2126db:	4c 89 ef             	mov    rdi,r13
  2126de:	4c 89 e6             	mov    rsi,r12
  2126e1:	4c 89 fa             	mov    rdx,r15
  2126e4:	41 ff 14 24          	call   QWORD PTR [r12]
  2126e8:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2126ed:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  2126f2:	66 85 c0             	test   ax,ax
  2126f5:	74 97                	je     21268e <parseFormValue+0x123e>
  2126f7:	e9 08 f8 ff ff       	jmp    211f04 <parseFormValue+0xab4>
  2126fc:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  212701:	45 31 f6             	xor    r14d,r14d
  212704:	4c 8d 6c 24 18       	lea    r13,[rsp+0x18]
  212709:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  21270b:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  212710:	0f 82 89 05 00 00    	jb     212c9f <parseFormValue+0x184f>
            return result[0];
  212716:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  21271d:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21271e:	89 c2                	mov    edx,eax
  212720:	83 e2 7f             	and    edx,0x7f
  212723:	89 de                	mov    esi,ebx
  212725:	83 e6 3f             	and    esi,0x3f
  212728:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21272d:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  212732:	48 39 d6             	cmp    rsi,rdx
  212735:	0f 85 53 07 00 00    	jne    212e8e <parseFormValue+0x1a3e>
        result |= operand;
  21273b:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  21273e:	84 c0                	test   al,al
  212740:	0f 89 a6 08 00 00    	jns    212fec <parseFormValue+0x1b9c>
        shift += 7;
  212746:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  21274a:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  21274f:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  212756:	00 00 
            return self.readFn(self, buffer);
  212758:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21275d:	4c 89 e6             	mov    rsi,r12
  212760:	4c 89 ea             	mov    rdx,r13
  212763:	41 ff 14 24          	call   QWORD PTR [r12]
  212767:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21276c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  212771:	66 85 c0             	test   ax,ax
  212774:	74 95                	je     21270b <parseFormValue+0x12bb>
  212776:	e9 f2 f7 ff ff       	jmp    211f6d <parseFormValue+0xb1d>
  21277b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  212780:	31 db                	xor    ebx,ebx
  212782:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  212787:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  21278c:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  21278e:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  212793:	0f 82 0f 05 00 00    	jb     212ca8 <parseFormValue+0x1858>
            return result[0];
  212799:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  2127a0:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2127a1:	89 c2                	mov    edx,eax
  2127a3:	83 e2 7f             	and    edx,0x7f
  2127a6:	89 ee                	mov    esi,ebp
  2127a8:	83 e6 3f             	and    esi,0x3f
  2127ab:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2127b0:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2127b5:	48 39 d6             	cmp    rsi,rdx
  2127b8:	0f 85 d9 06 00 00    	jne    212e97 <parseFormValue+0x1a47>
        result |= operand;
  2127be:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  2127c1:	84 c0                	test   al,al
  2127c3:	0f 89 65 08 00 00    	jns    21302e <parseFormValue+0x1bde>
        shift += 7;
  2127c9:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2127cd:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  2127d2:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2127d9:	00 00 
            return self.readFn(self, buffer);
  2127db:	4c 89 ef             	mov    rdi,r13
  2127de:	4c 89 e6             	mov    rsi,r12
  2127e1:	4c 89 fa             	mov    rdx,r15
  2127e4:	41 ff 14 24          	call   QWORD PTR [r12]
  2127e8:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2127ed:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  2127f2:	66 85 c0             	test   ax,ax
  2127f5:	74 97                	je     21278e <parseFormValue+0x133e>
  2127f7:	e9 3a f8 ff ff       	jmp    212036 <parseFormValue+0xbe6>
  2127fc:	66 b8 20 00          	mov    ax,0x20
  212800:	e9 d2 ec ff ff       	jmp    2114d7 <parseFormValue+0x87>
  212805:	66 b8 25 00          	mov    ax,0x25
  212809:	e9 c9 ec ff ff       	jmp    2114d7 <parseFormValue+0x87>
  21280e:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  212813:	66 c7 84 24 08 04 00 	mov    WORD PTR [rsp+0x408],0x0
  21281a:	00 00 00 
  21281d:	48 89 84 24 10 04 00 	mov    QWORD PTR [rsp+0x410],rax
  212824:	00 
  212825:	c5 f8 10 84 24 08 05 	vmovups xmm0,XMMWORD PTR [rsp+0x508]
  21282c:	00 00 
  21282e:	c5 f8 11 84 24 18 04 	vmovups XMMWORD PTR [rsp+0x418],xmm0
  212835:	00 00 
  212837:	c6 84 24 28 04 00 00 	mov    BYTE PTR [rsp+0x428],0x0
  21283e:	00 
  21283f:	8b 84 24 11 03 00 00 	mov    eax,DWORD PTR [rsp+0x311]
  212846:	89 84 24 29 04 00 00 	mov    DWORD PTR [rsp+0x429],eax
  21284d:	0f b7 84 24 15 03 00 	movzx  eax,WORD PTR [rsp+0x315]
  212854:	00 
  212855:	66 89 84 24 2d 04 00 	mov    WORD PTR [rsp+0x42d],ax
  21285c:	00 
  21285d:	8a 84 24 17 03 00 00 	mov    al,BYTE PTR [rsp+0x317]
  212864:	88 84 24 2f 04 00 00 	mov    BYTE PTR [rsp+0x42f],al
  21286b:	48 8d 84 24 08 04 00 	lea    rax,[rsp+0x408]
  212872:	00 
  212873:	e9 de 05 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  212878:	48 85 c0             	test   rax,rax
            for (bytes) |b, index| {
  21287b:	0f 84 00 08 00 00    	je     213081 <parseFormValue+0x1c31>
  212881:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  212886:	48 83 f8 10          	cmp    rax,0x10
  21288a:	0f 83 cc 0b 00 00    	jae    21345c <parseFormValue+0x200c>
  212890:	31 db                	xor    ebx,ebx
  212892:	31 c9                	xor    ecx,ecx
  212894:	e9 b7 11 00 00       	jmp    213a50 <parseFormValue+0x2600>
  212899:	48 85 c0             	test   rax,rax
  21289c:	0f 84 e6 07 00 00    	je     213088 <parseFormValue+0x1c38>
  2128a2:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  2128a7:	48 83 f8 10          	cmp    rax,0x10
  2128ab:	0f 83 c9 0c 00 00    	jae    21357a <parseFormValue+0x212a>
  2128b1:	31 db                	xor    ebx,ebx
  2128b3:	31 c9                	xor    ecx,ecx
  2128b5:	e9 77 13 00 00       	jmp    213c31 <parseFormValue+0x27e1>
  2128ba:	48 85 c0             	test   rax,rax
  2128bd:	0f 84 cc 07 00 00    	je     21308f <parseFormValue+0x1c3f>
  2128c3:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  2128c8:	48 83 f8 10          	cmp    rax,0x10
  2128cc:	0f 83 c6 0d 00 00    	jae    213698 <parseFormValue+0x2248>
  2128d2:	31 db                	xor    ebx,ebx
  2128d4:	31 c9                	xor    ecx,ecx
  2128d6:	e9 37 15 00 00       	jmp    213e12 <parseFormValue+0x29c2>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  2128db:	80 bc 24 b0 00 00 00 	cmp    BYTE PTR [rsp+0xb0],0x0
  2128e2:	00 
  2128e3:	0f 95 84 24 08 01 00 	setne  BYTE PTR [rsp+0x108]
  2128ea:	00 
  2128eb:	66 c7 84 24 18 03 00 	mov    WORD PTR [rsp+0x318],0x0
  2128f2:	00 00 00 
  2128f5:	0f 95 84 24 20 03 00 	setne  BYTE PTR [rsp+0x320]
  2128fc:	00 
  2128fd:	c5 f8 10 84 24 69 04 	vmovups xmm0,XMMWORD PTR [rsp+0x469]
  212904:	00 00 
  212906:	c5 f8 11 84 24 21 03 	vmovups XMMWORD PTR [rsp+0x321],xmm0
  21290d:	00 00 
  21290f:	48 8b 84 24 78 04 00 	mov    rax,QWORD PTR [rsp+0x478]
  212916:	00 
  212917:	48 89 84 24 30 03 00 	mov    QWORD PTR [rsp+0x330],rax
  21291e:	00 
  21291f:	c6 84 24 38 03 00 00 	mov    BYTE PTR [rsp+0x338],0x4
  212926:	04 
  212927:	8b 84 24 03 03 00 00 	mov    eax,DWORD PTR [rsp+0x303]
  21292e:	89 84 24 39 03 00 00 	mov    DWORD PTR [rsp+0x339],eax
  212935:	0f b7 84 24 07 03 00 	movzx  eax,WORD PTR [rsp+0x307]
  21293c:	00 
  21293d:	66 89 84 24 3d 03 00 	mov    WORD PTR [rsp+0x33d],ax
  212944:	00 
  212945:	8a 84 24 09 03 00 00 	mov    al,BYTE PTR [rsp+0x309]
  21294c:	88 84 24 3f 03 00 00 	mov    BYTE PTR [rsp+0x33f],al
  212953:	48 8d 84 24 18 03 00 	lea    rax,[rsp+0x318]
  21295a:	00 
  21295b:	e9 f6 04 00 00       	jmp    212e56 <parseFormValue+0x1a06>
            return mem.readInt(bytes, T, endian);
  212960:	0f b6 8c 24 b0 00 00 	movzx  ecx,BYTE PTR [rsp+0xb0]
  212967:	00 
  212968:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  21296d:	4c 89 fe             	mov    rsi,r15
  212970:	4c 89 e2             	mov    rdx,r12
  212973:	e8 68 18 00 00       	call   2141e0 <readAllocBytes>
  212978:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  21297d:	66 85 c0             	test   ax,ax
  212980:	0f 84 10 07 00 00    	je     213096 <parseFormValue+0x1c46>
  212986:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  21298c:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  212992:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  212999:	00 00 
  21299b:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2129a2:	00 00 
  2129a4:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  2129a8:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2129ab:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  2129b0:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2129b5:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  2129b9:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  2129bd:	e9 39 07 00 00       	jmp    2130fb <parseFormValue+0x1cab>
  2129c2:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2129c7:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  2129cc:	48 c1 e1 08          	shl    rcx,0x8
  2129d0:	48 09 c1             	or     rcx,rax
  2129d3:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  2129d8:	4c 89 fe             	mov    rsi,r15
  2129db:	4c 89 e2             	mov    rdx,r12
  2129de:	e8 fd 17 00 00       	call   2141e0 <readAllocBytes>
  2129e3:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  2129e8:	66 85 c0             	test   ax,ax
  2129eb:	0f 84 5d 07 00 00    	je     21314e <parseFormValue+0x1cfe>
  2129f1:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  2129f7:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  2129fd:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  212a04:	00 00 
  212a06:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  212a0d:	00 00 
  212a0f:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  212a13:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  212a16:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  212a1b:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  212a20:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  212a24:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  212a28:	e9 86 07 00 00       	jmp    2131b3 <parseFormValue+0x1d63>
  212a2d:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  212a32:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  212a37:	48 c1 e1 08          	shl    rcx,0x8
  212a3b:	48 09 c1             	or     rcx,rax
  212a3e:	0f b6 44 24 7a       	movzx  eax,BYTE PTR [rsp+0x7a]
  212a43:	48 c1 e0 10          	shl    rax,0x10
  212a47:	48 09 c8             	or     rax,rcx
  212a4a:	0f b6 4c 24 7b       	movzx  ecx,BYTE PTR [rsp+0x7b]
  212a4f:	48 c1 e1 18          	shl    rcx,0x18
  212a53:	48 09 c1             	or     rcx,rax
  212a56:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  212a5b:	4c 89 fe             	mov    rsi,r15
  212a5e:	4c 89 e2             	mov    rdx,r12
  212a61:	e8 7a 17 00 00       	call   2141e0 <readAllocBytes>
  212a66:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  212a6b:	66 85 c0             	test   ax,ax
  212a6e:	0f 84 92 07 00 00    	je     213206 <parseFormValue+0x1db6>
  212a74:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  212a7a:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  212a80:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  212a87:	00 00 
  212a89:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  212a90:	00 00 
  212a92:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  212a96:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  212a99:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  212a9e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  212aa3:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  212aa7:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  212aab:	e9 bb 07 00 00       	jmp    21326b <parseFormValue+0x1e1b>
  212ab0:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  212ab5:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  212aba:	4c 89 fe             	mov    rsi,r15
  212abd:	4c 89 e2             	mov    rdx,r12
  212ac0:	e8 1b 17 00 00       	call   2141e0 <readAllocBytes>
  212ac5:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  212aca:	66 85 c0             	test   ax,ax
  212acd:	0f 84 eb 07 00 00    	je     2132be <parseFormValue+0x1e6e>
  212ad3:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  212ad9:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  212adf:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  212ae6:	00 00 
  212ae8:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  212aef:	00 00 
  212af1:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  212af5:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  212af8:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  212afd:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  212b02:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  212b06:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  212b0a:	e9 14 08 00 00       	jmp    213323 <parseFormValue+0x1ed3>
  212b0f:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  212b14:	66 c7 84 24 90 03 00 	mov    WORD PTR [rsp+0x390],0x0
  212b1b:	00 00 00 
  212b1e:	48 89 84 24 98 03 00 	mov    QWORD PTR [rsp+0x398],rax
  212b25:	00 
  212b26:	c5 f8 10 84 24 d8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4d8]
  212b2d:	00 00 
  212b2f:	c5 f8 11 84 24 a0 03 	vmovups XMMWORD PTR [rsp+0x3a0],xmm0
  212b36:	00 00 
  212b38:	c6 84 24 b0 03 00 00 	mov    BYTE PTR [rsp+0x3b0],0x8
  212b3f:	08 
  212b40:	8b 84 24 ee 02 00 00 	mov    eax,DWORD PTR [rsp+0x2ee]
  212b47:	89 84 24 b1 03 00 00 	mov    DWORD PTR [rsp+0x3b1],eax
  212b4e:	0f b7 84 24 f2 02 00 	movzx  eax,WORD PTR [rsp+0x2f2]
  212b55:	00 
  212b56:	66 89 84 24 b5 03 00 	mov    WORD PTR [rsp+0x3b5],ax
  212b5d:	00 
  212b5e:	8a 84 24 f4 02 00 00 	mov    al,BYTE PTR [rsp+0x2f4]
  212b65:	88 84 24 b7 03 00 00 	mov    BYTE PTR [rsp+0x3b7],al
  212b6c:	48 8d 84 24 90 03 00 	lea    rax,[rsp+0x390]
  212b73:	00 
  212b74:	e9 dd 02 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  212b79:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  212b7e:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  212b85:	00 
  212b86:	4c 89 e2             	mov    rdx,r12
  212b89:	48 89 e9             	mov    rcx,rbp
  212b8c:	e8 4f 16 00 00       	call   2141e0 <readAllocBytes>
  212b91:	0f b7 54 24 40       	movzx  edx,WORD PTR [rsp+0x40]
  212b96:	66 85 d2             	test   dx,dx
  212b99:	48 8b 6c 24 68       	mov    rbp,QWORD PTR [rsp+0x68]
  212b9e:	0f 84 d2 07 00 00    	je     213376 <parseFormValue+0x1f26>
  212ba4:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  212ba9:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  212bb0:	00 
  212bb1:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  212bb5:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
  212bbc:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  212bc0:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  212bc7:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  212bcc:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  212bd3:	00 
  212bd4:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  212bd8:	88 84 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],al
  212bdf:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  212be6:	00 
  212be7:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  212beb:	89 84 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],eax
  212bf2:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  212bf9:	00 
  212bfa:	0f b7 4c 24 0e       	movzx  ecx,WORD PTR [rsp+0xe]
  212bff:	66 89 8c 24 ec 00 00 	mov    WORD PTR [rsp+0xec],cx
  212c06:	00 
  212c07:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  212c0e:	00 
  212c0f:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  212c13:	88 9c 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],bl
  212c1a:	e9 f5 07 00 00       	jmp    213414 <parseFormValue+0x1fc4>
  212c1f:	66 b8 20 00          	mov    ax,0x20
  212c23:	e9 c5 ec ff ff       	jmp    2118ed <parseFormValue+0x49d>
            return self.items[0..self.len];
  212c28:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  212c2d:	66 c7 84 24 68 03 00 	mov    WORD PTR [rsp+0x368],0x0
  212c34:	00 00 00 
  212c37:	48 89 84 24 70 03 00 	mov    QWORD PTR [rsp+0x370],rax
  212c3e:	00 
  212c3f:	48 89 ac 24 78 03 00 	mov    QWORD PTR [rsp+0x378],rbp
  212c46:	00 
  212c47:	c6 84 24 88 03 00 00 	mov    BYTE PTR [rsp+0x388],0x9
  212c4e:	09 
  212c4f:	8b 84 24 e7 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e7]
  212c56:	89 84 24 89 03 00 00 	mov    DWORD PTR [rsp+0x389],eax
  212c5d:	0f b7 84 24 eb 02 00 	movzx  eax,WORD PTR [rsp+0x2eb]
  212c64:	00 
  212c65:	66 89 84 24 8d 03 00 	mov    WORD PTR [rsp+0x38d],ax
  212c6c:	00 
  212c6d:	8a 84 24 ed 02 00 00 	mov    al,BYTE PTR [rsp+0x2ed]
  212c74:	88 84 24 8f 03 00 00 	mov    BYTE PTR [rsp+0x38f],al
  212c7b:	48 8d 84 24 68 03 00 	lea    rax,[rsp+0x368]
  212c82:	00 
  212c83:	4c 8b 74 24 68       	mov    r14,QWORD PTR [rsp+0x68]
  212c88:	e9 c9 01 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  212c8d:	66 b8 20 00          	mov    ax,0x20
  212c91:	e9 c0 ec ff ff       	jmp    211956 <parseFormValue+0x506>
  212c96:	66 b8 20 00          	mov    ax,0x20
  212c9a:	e9 65 f2 ff ff       	jmp    211f04 <parseFormValue+0xab4>
  212c9f:	66 b8 20 00          	mov    ax,0x20
  212ca3:	e9 c5 f2 ff ff       	jmp    211f6d <parseFormValue+0xb1d>
  212ca8:	66 b8 20 00          	mov    ax,0x20
  212cac:	e9 85 f3 ff ff       	jmp    212036 <parseFormValue+0xbe6>
  212cb1:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  212cb6:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  212cbb:	48 c1 e1 08          	shl    rcx,0x8
  212cbf:	48 09 c1             	or     rcx,rax
  212cc2:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  212cc7:	48 c1 e2 10          	shl    rdx,0x10
  212ccb:	48 09 ca             	or     rdx,rcx
  212cce:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  212cd3:	48 c1 e0 18          	shl    rax,0x18
  212cd7:	48 09 d0             	or     rax,rdx
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  212cda:	66 c7 84 24 40 03 00 	mov    WORD PTR [rsp+0x340],0x0
  212ce1:	00 00 00 
  212ce4:	48 89 84 24 48 03 00 	mov    QWORD PTR [rsp+0x348],rax
  212ceb:	00 
  212cec:	c5 f8 10 84 24 c8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4c8]
  212cf3:	00 00 
  212cf5:	c5 f8 11 84 24 50 03 	vmovups XMMWORD PTR [rsp+0x350],xmm0
  212cfc:	00 00 
  212cfe:	c6 84 24 60 03 00 00 	mov    BYTE PTR [rsp+0x360],0xa
  212d05:	0a 
  212d06:	8b 84 24 e0 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e0]
  212d0d:	89 84 24 61 03 00 00 	mov    DWORD PTR [rsp+0x361],eax
  212d14:	0f b7 84 24 e4 02 00 	movzx  eax,WORD PTR [rsp+0x2e4]
  212d1b:	00 
  212d1c:	66 89 84 24 65 03 00 	mov    WORD PTR [rsp+0x365],ax
  212d23:	00 
  212d24:	8a 84 24 e6 02 00 00 	mov    al,BYTE PTR [rsp+0x2e6]
  212d2b:	88 84 24 67 03 00 00 	mov    BYTE PTR [rsp+0x367],al
  212d32:	48 8d 84 24 40 03 00 	lea    rax,[rsp+0x340]
  212d39:	00 
  212d3a:	e9 17 01 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  212d3f:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  212d44:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  212d49:	48 c1 e1 08          	shl    rcx,0x8
  212d4d:	48 09 c1             	or     rcx,rax
  212d50:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  212d55:	48 c1 e2 10          	shl    rdx,0x10
  212d59:	48 09 ca             	or     rdx,rcx
  212d5c:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  212d61:	48 c1 e0 18          	shl    rax,0x18
  212d65:	48 09 d0             	or     rax,rdx
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  212d68:	66 c7 84 24 b8 03 00 	mov    WORD PTR [rsp+0x3b8],0x0
  212d6f:	00 00 00 
  212d72:	48 89 84 24 c0 03 00 	mov    QWORD PTR [rsp+0x3c0],rax
  212d79:	00 
  212d7a:	c5 f8 10 84 24 e8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4e8]
  212d81:	00 00 
  212d83:	c5 f8 11 84 24 c8 03 	vmovups XMMWORD PTR [rsp+0x3c8],xmm0
  212d8a:	00 00 
  212d8c:	c6 84 24 d8 03 00 00 	mov    BYTE PTR [rsp+0x3d8],0x7
  212d93:	07 
  212d94:	8b 84 24 f5 02 00 00 	mov    eax,DWORD PTR [rsp+0x2f5]
  212d9b:	89 84 24 d9 03 00 00 	mov    DWORD PTR [rsp+0x3d9],eax
  212da2:	0f b7 84 24 f9 02 00 	movzx  eax,WORD PTR [rsp+0x2f9]
  212da9:	00 
  212daa:	66 89 84 24 dd 03 00 	mov    WORD PTR [rsp+0x3dd],ax
  212db1:	00 
  212db2:	8a 84 24 fb 02 00 00 	mov    al,BYTE PTR [rsp+0x2fb]
  212db9:	88 84 24 df 03 00 00 	mov    BYTE PTR [rsp+0x3df],al
  212dc0:	48 8d 84 24 b8 03 00 	lea    rax,[rsp+0x3b8]
  212dc7:	00 
  212dc8:	e9 89 00 00 00       	jmp    212e56 <parseFormValue+0x1a06>
  212dcd:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  212dd2:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  212dd7:	48 c1 e1 08          	shl    rcx,0x8
  212ddb:	48 09 c1             	or     rcx,rax
  212dde:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  212de3:	48 c1 e2 10          	shl    rdx,0x10
  212de7:	48 09 ca             	or     rdx,rcx
  212dea:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  212def:	48 c1 e0 18          	shl    rax,0x18
  212df3:	48 09 d0             	or     rax,rdx
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  212df6:	66 c7 84 24 e0 03 00 	mov    WORD PTR [rsp+0x3e0],0x0
  212dfd:	00 00 00 
  212e00:	48 89 84 24 e8 03 00 	mov    QWORD PTR [rsp+0x3e8],rax
  212e07:	00 
  212e08:	c5 f8 10 84 24 f8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4f8]
  212e0f:	00 00 
  212e11:	c5 f8 11 84 24 f0 03 	vmovups XMMWORD PTR [rsp+0x3f0],xmm0
  212e18:	00 00 
  212e1a:	c6 84 24 00 04 00 00 	mov    BYTE PTR [rsp+0x400],0x5
  212e21:	05 
  212e22:	8b 84 24 fc 02 00 00 	mov    eax,DWORD PTR [rsp+0x2fc]
  212e29:	89 84 24 01 04 00 00 	mov    DWORD PTR [rsp+0x401],eax
  212e30:	0f b7 84 24 00 03 00 	movzx  eax,WORD PTR [rsp+0x300]
  212e37:	00 
  212e38:	66 89 84 24 05 04 00 	mov    WORD PTR [rsp+0x405],ax
  212e3f:	00 
  212e40:	8a 84 24 02 03 00 00 	mov    al,BYTE PTR [rsp+0x302]
  212e47:	88 84 24 07 04 00 00 	mov    BYTE PTR [rsp+0x407],al
  212e4e:	48 8d 84 24 e0 03 00 	lea    rax,[rsp+0x3e0]
  212e55:	00 
    return switch (form_id) {
  212e56:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
  212e5a:	49 89 4e 20          	mov    QWORD PTR [r14+0x20],rcx
  212e5e:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  212e62:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  212e67:	48 81 c4 08 07 00 00 	add    rsp,0x708
  212e6e:	5b                   	pop    rbx
  212e6f:	41 5c                	pop    r12
  212e71:	41 5d                	pop    r13
  212e73:	41 5e                	pop    r14
  212e75:	41 5f                	pop    r15
  212e77:	5d                   	pop    rbp
  212e78:	c5 f8 77             	vzeroupper 
  212e7b:	c3                   	ret    
  212e7c:	66 b8 25 00          	mov    ax,0x25
  212e80:	e9 d1 ea ff ff       	jmp    211956 <parseFormValue+0x506>
  212e85:	66 b8 25 00          	mov    ax,0x25
  212e89:	e9 76 f0 ff ff       	jmp    211f04 <parseFormValue+0xab4>
  212e8e:	66 b8 25 00          	mov    ax,0x25
  212e92:	e9 d6 f0 ff ff       	jmp    211f6d <parseFormValue+0xb1d>
  212e97:	66 b8 25 00          	mov    ax,0x25
  212e9b:	e9 96 f1 ff ff       	jmp    212036 <parseFormValue+0xbe6>
  212ea0:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  212ea5:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  212eac:	00 
  212ead:	4c 89 e2             	mov    rdx,r12
  212eb0:	48 89 d9             	mov    rcx,rbx
  212eb3:	e8 28 13 00 00       	call   2141e0 <readAllocBytes>
  212eb8:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  212ebd:	66 85 c9             	test   cx,cx
  212ec0:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  212ec5:	0f 84 eb 08 00 00    	je     2137b6 <parseFormValue+0x2366>
  212ecb:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  212ed0:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  212ed7:	00 
  212ed8:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  212edc:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  212ee3:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  212ee7:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  212eee:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  212ef3:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  212efa:	00 
  212efb:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  212eff:	88 84 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],al
  212f06:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  212f0d:	00 
  212f0e:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  212f12:	89 84 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],eax
  212f19:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  212f20:	00 
  212f21:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  212f26:	66 89 94 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],dx
  212f2d:	00 
  212f2e:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  212f35:	00 
  212f36:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  212f3a:	88 9c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],bl
  212f41:	e9 a1 00 00 00       	jmp    212fe7 <parseFormValue+0x1b97>
  212f46:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  212f4b:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  212f52:	00 
  212f53:	4c 89 e2             	mov    rdx,r12
  212f56:	48 89 d9             	mov    rcx,rbx
  212f59:	e8 82 12 00 00       	call   2141e0 <readAllocBytes>
  212f5e:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  212f63:	66 85 c9             	test   cx,cx
  212f66:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  212f6b:	0f 84 d9 08 00 00    	je     21384a <parseFormValue+0x23fa>
  212f71:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  212f76:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  212f7d:	00 
  212f7e:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  212f82:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  212f89:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  212f8d:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  212f94:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  212f99:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  212fa0:	00 
  212fa1:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  212fa5:	88 84 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],al
  212fac:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  212fb3:	00 
  212fb4:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  212fb8:	89 84 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],eax
  212fbf:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  212fc6:	00 
  212fc7:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  212fcc:	66 89 94 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],dx
  212fd3:	00 
  212fd4:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  212fdb:	00 
  212fdc:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  212fe0:	88 9c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],bl
  212fe7:	e9 ef 08 00 00       	jmp    2138db <parseFormValue+0x248b>
            return parseFormValue(allocator, in_stream, child_form_id, is_64);
  212fec:	44 0f b6 c5          	movzx  r8d,bpl
  212ff0:	48 8d bc 24 a0 04 00 	lea    rdi,[rsp+0x4a0]
  212ff7:	00 
  212ff8:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  212fff:	00 
  213000:	4c 89 e2             	mov    rdx,r12
  213003:	4c 89 f1             	mov    rcx,r14
  213006:	e8 45 e4 ff ff       	call   211450 <parseFormValue>
  21300b:	48 8b 84 24 c0 04 00 	mov    rax,QWORD PTR [rsp+0x4c0]
  213012:	00 
  213013:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  213018:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21301c:	c5 fc 10 84 24 a0 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4a0]
  213023:	00 00 
  213025:	c5 fc 11 01          	vmovups YMMWORD PTR [rcx],ymm0
  213029:	e9 39 fe ff ff       	jmp    212e67 <parseFormValue+0x1a17>
  21302e:	48 8d bc 24 50 04 00 	lea    rdi,[rsp+0x450]
  213035:	00 
            const buf = try readAllocBytes(allocator, in_stream, size);
  213036:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  21303d:	00 
  21303e:	4c 89 e2             	mov    rdx,r12
  213041:	48 89 d9             	mov    rcx,rbx
  213044:	e8 97 11 00 00       	call   2141e0 <readAllocBytes>
  213049:	0f b7 84 24 50 04 00 	movzx  eax,WORD PTR [rsp+0x450]
  213050:	00 
  213051:	66 85 c0             	test   ax,ax
  213054:	0f 84 c4 08 00 00    	je     21391e <parseFormValue+0x24ce>
  21305a:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  21305f:	66 89 01             	mov    WORD PTR [rcx],ax
  213062:	48 8b 84 24 68 06 00 	mov    rax,QWORD PTR [rsp+0x668]
  213069:	00 
  21306a:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21306e:	c5 fc 10 84 24 4a 06 	vmovups ymm0,YMMWORD PTR [rsp+0x64a]
  213075:	00 00 
  213077:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  21307c:	e9 e6 fd ff ff       	jmp    212e67 <parseFormValue+0x1a17>
  213081:	31 c9                	xor    ecx,ecx
  213083:	e9 f1 09 00 00       	jmp    213a79 <parseFormValue+0x2629>
  213088:	31 c9                	xor    ecx,ecx
  21308a:	e9 cb 0b 00 00       	jmp    213c5a <parseFormValue+0x280a>
  21308f:	31 c9                	xor    ecx,ecx
  213091:	e9 a5 0d 00 00       	jmp    213e3b <parseFormValue+0x29eb>
    const buf = try readAllocBytes(allocator, in_stream, size);
  213096:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  21309d:	00 00 
  21309f:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  2130a6:	00 00 
    return FormValue{ .Ref = buf };
  2130a8:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  2130ae:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  2130b5:	00 
  2130b6:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  2130bb:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  2130c0:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  2130c4:	89 04 24             	mov    DWORD PTR [rsp],eax
  2130c7:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  2130cc:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2130d1:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  2130d5:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  2130d9:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  2130df:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2130e6:	00 00 
  2130e8:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  2130ee:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  2130f5:	00 00 
  2130f7:	b1 06                	mov    cl,0x6
  2130f9:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  2130fb:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  213102:	00 
  213103:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  21310a:	00 00 
  21310c:	c5 f8 11 84 24 42 02 	vmovups XMMWORD PTR [rsp+0x242],xmm0
  213113:	00 00 
  213115:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  21311c:	00 00 
  21311e:	c5 f8 11 84 24 50 02 	vmovups XMMWORD PTR [rsp+0x250],xmm0
  213125:	00 00 
  213127:	88 8c 24 60 02 00 00 	mov    BYTE PTR [rsp+0x260],cl
  21312e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  213131:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  213138:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  21313d:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  213144:	00 
  213145:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  213149:	e9 41 eb ff ff       	jmp    211c8f <parseFormValue+0x83f>
    const buf = try readAllocBytes(allocator, in_stream, size);
  21314e:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  213155:	00 00 
  213157:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  21315e:	00 00 
    return FormValue{ .Ref = buf };
  213160:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  213166:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  21316d:	00 
  21316e:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  213173:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  213178:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  21317c:	89 04 24             	mov    DWORD PTR [rsp],eax
  21317f:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  213184:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  213189:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  21318d:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  213191:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  213197:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21319e:	00 00 
  2131a0:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  2131a6:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  2131ad:	00 00 
  2131af:	b1 06                	mov    cl,0x6
  2131b1:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  2131b3:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  2131ba:	00 
  2131bb:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  2131c2:	00 00 
  2131c4:	c5 f8 11 84 24 1a 02 	vmovups XMMWORD PTR [rsp+0x21a],xmm0
  2131cb:	00 00 
  2131cd:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  2131d4:	00 00 
  2131d6:	c5 f8 11 84 24 28 02 	vmovups XMMWORD PTR [rsp+0x228],xmm0
  2131dd:	00 00 
  2131df:	88 8c 24 38 02 00 00 	mov    BYTE PTR [rsp+0x238],cl
  2131e6:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  2131e9:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  2131f0:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  2131f5:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  2131fc:	00 
  2131fd:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  213201:	e9 3e eb ff ff       	jmp    211d44 <parseFormValue+0x8f4>
    const buf = try readAllocBytes(allocator, in_stream, size);
  213206:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  21320d:	00 00 
  21320f:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  213216:	00 00 
    return FormValue{ .Ref = buf };
  213218:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  21321e:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  213225:	00 
  213226:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  21322b:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  213230:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  213234:	89 04 24             	mov    DWORD PTR [rsp],eax
  213237:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  21323c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  213241:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  213245:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  213249:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  21324f:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213256:	00 00 
  213258:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  21325e:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  213265:	00 00 
  213267:	b1 06                	mov    cl,0x6
  213269:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  21326b:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  213272:	00 
  213273:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  21327a:	00 00 
  21327c:	c5 f8 11 84 24 f2 01 	vmovups XMMWORD PTR [rsp+0x1f2],xmm0
  213283:	00 00 
  213285:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  21328c:	00 00 
  21328e:	c5 f8 11 84 24 00 02 	vmovups XMMWORD PTR [rsp+0x200],xmm0
  213295:	00 00 
  213297:	88 8c 24 10 02 00 00 	mov    BYTE PTR [rsp+0x210],cl
  21329e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  2132a1:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  2132a8:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  2132ad:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  2132b4:	00 
  2132b5:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  2132b9:	e9 3b eb ff ff       	jmp    211df9 <parseFormValue+0x9a9>
    const buf = try readAllocBytes(allocator, in_stream, size);
  2132be:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  2132c5:	00 00 
  2132c7:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  2132ce:	00 00 
    return FormValue{ .Ref = buf };
  2132d0:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  2132d6:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  2132dd:	00 
  2132de:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  2132e3:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  2132e8:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  2132ec:	89 04 24             	mov    DWORD PTR [rsp],eax
  2132ef:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  2132f4:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2132f9:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  2132fd:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  213301:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  213307:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21330e:	00 00 
  213310:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  213316:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  21331d:	00 00 
  21331f:	b1 06                	mov    cl,0x6
  213321:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  213323:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  21332a:	00 
  21332b:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  213332:	00 00 
  213334:	c5 f8 11 84 24 ca 01 	vmovups XMMWORD PTR [rsp+0x1ca],xmm0
  21333b:	00 00 
  21333d:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  213344:	00 00 
  213346:	c5 f8 11 84 24 d8 01 	vmovups XMMWORD PTR [rsp+0x1d8],xmm0
  21334d:	00 00 
  21334f:	88 8c 24 e8 01 00 00 	mov    BYTE PTR [rsp+0x1e8],cl
  213356:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  213359:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  213360:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  213365:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  21336c:	00 
  21336d:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  213371:	e9 38 eb ff ff       	jmp    211eae <parseFormValue+0xa5e>
            const signed = form_id == DW.FORM_sdata;
  213376:	48 83 fb 0d          	cmp    rbx,0xd
    return FormValue{
  21337a:	0f 94 84 24 b0 00 00 	sete   BYTE PTR [rsp+0xb0]
  213381:	00 
  213382:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  213387:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  21338b:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
            const signed = form_id == DW.FORM_sdata;
  213392:	40 0f 94 c7          	sete   dil
    return FormValue{
  213396:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21339b:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  2133a2:	00 
        .Const = Constant{
  2133a3:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  2133a9:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  2133b0:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  2133b7:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  2133be:	00 
  2133bf:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  2133c6:	00 
  2133c7:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  2133ce:	00 
  2133cf:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  2133d6:	00 
  2133d7:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  2133de:	88 8c 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],cl
  2133e5:	b3 02                	mov    bl,0x2
  2133e7:	8b 4c 24 18          	mov    ecx,DWORD PTR [rsp+0x18]
  2133eb:	89 8c 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],ecx
  2133f2:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  2133f9:	00 
  2133fa:	0f b7 54 24 1c       	movzx  edx,WORD PTR [rsp+0x1c]
  2133ff:	66 89 94 24 ec 00 00 	mov    WORD PTR [rsp+0xec],dx
  213406:	00 
  213407:	8a 54 24 1e          	mov    dl,BYTE PTR [rsp+0x1e]
  21340b:	88 94 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],dl
  213412:	31 d2                	xor    edx,edx
            return parseFormValueConstant(allocator, in_stream, signed, block_len);
  213414:	66 89 55 00          	mov    WORD PTR [rbp+0x0],dx
  213418:	0f b7 56 04          	movzx  edx,WORD PTR [rsi+0x4]
  21341c:	66 89 55 06          	mov    WORD PTR [rbp+0x6],dx
  213420:	8b 16                	mov    edx,DWORD PTR [rsi]
  213422:	89 55 02             	mov    DWORD PTR [rbp+0x2],edx
  213425:	c5 f8 11 45 08       	vmovups XMMWORD PTR [rbp+0x8],xmm0
  21342a:	40 88 7d 18          	mov    BYTE PTR [rbp+0x18],dil
  21342e:	8a 50 06             	mov    dl,BYTE PTR [rax+0x6]
  213431:	88 55 1f             	mov    BYTE PTR [rbp+0x1f],dl
  213434:	0f b7 50 04          	movzx  edx,WORD PTR [rax+0x4]
  213438:	66 89 55 1d          	mov    WORD PTR [rbp+0x1d],dx
  21343c:	8b 00                	mov    eax,DWORD PTR [rax]
  21343e:	89 45 19             	mov    DWORD PTR [rbp+0x19],eax
  213441:	88 5d 20             	mov    BYTE PTR [rbp+0x20],bl
  213444:	0f b7 41 04          	movzx  eax,WORD PTR [rcx+0x4]
  213448:	66 89 45 25          	mov    WORD PTR [rbp+0x25],ax
  21344c:	8b 01                	mov    eax,DWORD PTR [rcx]
  21344e:	89 45 21             	mov    DWORD PTR [rbp+0x21],eax
  213451:	8a 41 06             	mov    al,BYTE PTR [rcx+0x6]
  213454:	88 45 27             	mov    BYTE PTR [rbp+0x27],al
  213457:	e9 0b fa ff ff       	jmp    212e67 <parseFormValue+0x1a17>
            for (bytes) |b, index| {
  21345c:	48 89 c3             	mov    rbx,rax
  21345f:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  213463:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  213467:	48 89 e9             	mov    rcx,rbp
  21346a:	48 c1 e9 04          	shr    rcx,0x4
  21346e:	8d 79 01             	lea    edi,[rcx+0x1]
  213471:	83 e7 01             	and    edi,0x1
  213474:	48 85 ed             	test   rbp,rbp
  213477:	0f 84 29 05 00 00    	je     2139a6 <parseFormValue+0x2556>
  21347d:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  213481:	48 29 cd             	sub    rbp,rcx
  213484:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  213488:	c5 fd 6f 0d 10 d8 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffed810]        # 200ca0 <app_mask+0x68>
  21348f:	ff 
  213490:	31 c9                	xor    ecx,ecx
  213492:	c4 e2 7d 59 2d 8d d7 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffed78d]        # 200c28 <__unnamed_441+0x88>
  213499:	fe ff 
  21349b:	c4 e2 7d 59 35 dc d7 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffed7dc]        # 200c80 <app_mask+0x48>
  2134a2:	fe ff 
  2134a4:	c4 e2 7d 59 3d cb d7 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffed7cb]        # 200c78 <app_mask+0x40>
  2134ab:	fe ff 
  2134ad:	c4 62 7d 59 05 02 d7 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffed702]        # 200bb8 <__unnamed_441+0x18>
  2134b4:	fe ff 
  2134b6:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2134ba:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  2134be:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2134c2:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  2134c8:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  2134cf:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  2134d6:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  2134dd:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  2134e2:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  2134e6:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  2134ea:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  2134ee:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  2134f3:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  2134f7:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  2134fc:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  213500:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  213505:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  213509:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  21350e:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  213515:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  21351c:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  213523:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  21352a:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  21352e:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  213532:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  213537:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  21353b:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  21353f:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  213544:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  213548:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  21354d:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  213551:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  213556:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  21355a:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  21355f:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  213563:	48 83 c1 20          	add    rcx,0x20
  213567:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  21356b:	48 83 c5 02          	add    rbp,0x2
  21356f:	0f 85 4d ff ff ff    	jne    2134c2 <parseFormValue+0x2072>
  213575:	e9 46 04 00 00       	jmp    2139c0 <parseFormValue+0x2570>
  21357a:	48 89 c3             	mov    rbx,rax
  21357d:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  213581:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  213585:	48 89 e9             	mov    rcx,rbp
  213588:	48 c1 e9 04          	shr    rcx,0x4
  21358c:	8d 79 01             	lea    edi,[rcx+0x1]
  21358f:	83 e7 01             	and    edi,0x1
  213592:	48 85 ed             	test   rbp,rbp
  213595:	0f 84 ec 05 00 00    	je     213b87 <parseFormValue+0x2737>
  21359b:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  21359f:	48 29 cd             	sub    rbp,rcx
  2135a2:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2135a6:	c5 fd 6f 0d f2 d6 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffed6f2]        # 200ca0 <app_mask+0x68>
  2135ad:	ff 
  2135ae:	31 c9                	xor    ecx,ecx
  2135b0:	c4 e2 7d 59 2d 6f d6 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffed66f]        # 200c28 <__unnamed_441+0x88>
  2135b7:	fe ff 
  2135b9:	c4 e2 7d 59 35 be d6 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffed6be]        # 200c80 <app_mask+0x48>
  2135c0:	fe ff 
  2135c2:	c4 e2 7d 59 3d ad d6 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffed6ad]        # 200c78 <app_mask+0x40>
  2135c9:	fe ff 
  2135cb:	c4 62 7d 59 05 e4 d5 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffed5e4]        # 200bb8 <__unnamed_441+0x18>
  2135d2:	fe ff 
  2135d4:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2135d8:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  2135dc:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2135e0:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  2135e6:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  2135ed:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  2135f4:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  2135fb:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  213600:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  213604:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  213608:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  21360c:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  213611:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  213615:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  21361a:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  21361e:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  213623:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  213627:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  21362c:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  213633:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  21363a:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  213641:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  213648:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  21364c:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  213650:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  213655:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  213659:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  21365d:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  213662:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  213666:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  21366b:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  21366f:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  213674:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  213678:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  21367d:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  213681:	48 83 c1 20          	add    rcx,0x20
  213685:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  213689:	48 83 c5 02          	add    rbp,0x2
  21368d:	0f 85 4d ff ff ff    	jne    2135e0 <parseFormValue+0x2190>
  213693:	e9 09 05 00 00       	jmp    213ba1 <parseFormValue+0x2751>
  213698:	48 89 c3             	mov    rbx,rax
  21369b:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  21369f:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  2136a3:	48 89 e9             	mov    rcx,rbp
  2136a6:	48 c1 e9 04          	shr    rcx,0x4
  2136aa:	8d 79 01             	lea    edi,[rcx+0x1]
  2136ad:	83 e7 01             	and    edi,0x1
  2136b0:	48 85 ed             	test   rbp,rbp
  2136b3:	0f 84 af 06 00 00    	je     213d68 <parseFormValue+0x2918>
  2136b9:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  2136bd:	48 29 cd             	sub    rbp,rcx
  2136c0:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2136c4:	c5 fd 6f 0d d4 d5 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffed5d4]        # 200ca0 <app_mask+0x68>
  2136cb:	ff 
  2136cc:	31 c9                	xor    ecx,ecx
  2136ce:	c4 e2 7d 59 2d 51 d5 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffed551]        # 200c28 <__unnamed_441+0x88>
  2136d5:	fe ff 
  2136d7:	c4 e2 7d 59 35 a0 d5 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffed5a0]        # 200c80 <app_mask+0x48>
  2136de:	fe ff 
  2136e0:	c4 e2 7d 59 3d 8f d5 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffed58f]        # 200c78 <app_mask+0x40>
  2136e7:	fe ff 
  2136e9:	c4 62 7d 59 05 c6 d4 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffed4c6]        # 200bb8 <__unnamed_441+0x18>
  2136f0:	fe ff 
  2136f2:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2136f6:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  2136fa:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2136fe:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  213704:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  21370b:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  213712:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  213719:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  21371e:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  213722:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  213726:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  21372a:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  21372f:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  213733:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  213738:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  21373c:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  213741:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  213745:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  21374a:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  213751:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  213758:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  21375f:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  213766:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  21376a:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  21376e:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  213773:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  213777:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  21377b:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  213780:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  213784:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  213789:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  21378d:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  213792:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  213796:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  21379b:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  21379f:	48 83 c1 20          	add    rcx,0x20
  2137a3:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  2137a7:	48 83 c5 02          	add    rbp,0x2
  2137ab:	0f 85 4d ff ff ff    	jne    2136fe <parseFormValue+0x22ae>
  2137b1:	e9 cc 05 00 00       	jmp    213d82 <parseFormValue+0x2932>
    return FormValue{ .Block = buf };
  2137b6:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x1
  2137bd:	01 
  2137be:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  2137c2:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  2137c9:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  2137ce:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  2137d5:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  2137d6:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Block = buf };
  2137dc:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  2137e0:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  2137e7:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  2137ee:	00 
  2137ef:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  2137f4:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  2137fb:	00 
  2137fc:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  213803:	00 
  213804:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  213808:	88 8c 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],cl
  21380f:	b3 01                	mov    bl,0x1
  213811:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  213818:	89 8c 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],ecx
  21381f:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  213826:	00 
  213827:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  21382e:	00 
  21382f:	66 89 8c 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],cx
  213836:	00 
  213837:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  21383e:	88 8c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],cl
  213845:	e9 8f 00 00 00       	jmp    2138d9 <parseFormValue+0x2489>
    return FormValue{ .Ref = buf };
  21384a:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x6
  213851:	06 
  213852:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  213856:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  21385d:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  213862:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  213869:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  21386a:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Ref = buf };
  213870:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  213874:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  21387b:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  213882:	00 
  213883:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  213888:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  21388f:	00 
  213890:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  213897:	00 
  213898:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  21389c:	88 8c 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],cl
  2138a3:	b3 06                	mov    bl,0x6
  2138a5:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  2138ac:	89 8c 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],ecx
  2138b3:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  2138ba:	00 
  2138bb:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  2138c2:	00 
  2138c3:	66 89 8c 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],cx
  2138ca:	00 
  2138cb:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  2138d2:	88 8c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],cl
  2138d9:	31 c9                	xor    ecx,ecx
  2138db:	66 89 0f             	mov    WORD PTR [rdi],cx
  2138de:	0f b7 4e 04          	movzx  ecx,WORD PTR [rsi+0x4]
  2138e2:	66 89 4f 06          	mov    WORD PTR [rdi+0x6],cx
  2138e6:	8b 0e                	mov    ecx,DWORD PTR [rsi]
  2138e8:	89 4f 02             	mov    DWORD PTR [rdi+0x2],ecx
  2138eb:	c5 f8 11 47 08       	vmovups XMMWORD PTR [rdi+0x8],xmm0
  2138f0:	8a 48 06             	mov    cl,BYTE PTR [rax+0x6]
  2138f3:	88 4f 1f             	mov    BYTE PTR [rdi+0x1f],cl
  2138f6:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  2138fa:	66 89 4f 1d          	mov    WORD PTR [rdi+0x1d],cx
  2138fe:	8b 00                	mov    eax,DWORD PTR [rax]
  213900:	89 47 19             	mov    DWORD PTR [rdi+0x19],eax
  213903:	88 5f 20             	mov    BYTE PTR [rdi+0x20],bl
  213906:	0f b7 42 04          	movzx  eax,WORD PTR [rdx+0x4]
  21390a:	66 89 47 25          	mov    WORD PTR [rdi+0x25],ax
  21390e:	8b 02                	mov    eax,DWORD PTR [rdx]
  213910:	89 47 21             	mov    DWORD PTR [rdi+0x21],eax
  213913:	8a 42 06             	mov    al,BYTE PTR [rdx+0x6]
  213916:	88 47 27             	mov    BYTE PTR [rdi+0x27],al
  213919:	e9 49 f5 ff ff       	jmp    212e67 <parseFormValue+0x1a17>
            const buf = try readAllocBytes(allocator, in_stream, size);
  21391e:	c5 f8 10 84 24 58 04 	vmovups xmm0,XMMWORD PTR [rsp+0x458]
  213925:	00 00 
  213927:	c5 f8 29 84 24 80 04 	vmovaps XMMWORD PTR [rsp+0x480],xmm0
  21392e:	00 00 
            return FormValue{ .ExprLoc = buf };
  213930:	c5 f8 11 84 24 38 04 	vmovups XMMWORD PTR [rsp+0x438],xmm0
  213937:	00 00 
  213939:	48 8b 84 24 90 04 00 	mov    rax,QWORD PTR [rsp+0x490]
  213940:	00 
  213941:	48 89 84 24 48 04 00 	mov    QWORD PTR [rsp+0x448],rax
  213948:	00 
  213949:	c6 84 24 ae 00 00 00 	mov    BYTE PTR [rsp+0xae],0x3
  213950:	03 
  213951:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  213956:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  21395b:	c5 f8 10 84 24 32 04 	vmovups xmm0,XMMWORD PTR [rsp+0x432]
  213962:	00 00 
  213964:	c5 fa 6f 8c 24 40 04 	vmovdqu xmm1,XMMWORD PTR [rsp+0x440]
  21396b:	00 00 
  21396d:	c5 fa 7f 49 10       	vmovdqu XMMWORD PTR [rcx+0x10],xmm1
  213972:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  213977:	8a 84 24 ae 00 00 00 	mov    al,BYTE PTR [rsp+0xae]
  21397e:	88 41 20             	mov    BYTE PTR [rcx+0x20],al
  213981:	8a 84 24 10 03 00 00 	mov    al,BYTE PTR [rsp+0x310]
  213988:	88 41 27             	mov    BYTE PTR [rcx+0x27],al
  21398b:	0f b7 84 24 0e 03 00 	movzx  eax,WORD PTR [rsp+0x30e]
  213992:	00 
  213993:	66 89 41 25          	mov    WORD PTR [rcx+0x25],ax
  213997:	8b 84 24 0a 03 00 00 	mov    eax,DWORD PTR [rsp+0x30a]
  21399e:	89 41 21             	mov    DWORD PTR [rcx+0x21],eax
  2139a1:	e9 c1 f4 ff ff       	jmp    212e67 <parseFormValue+0x1a17>
  2139a6:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  2139aa:	c5 fd 6f 0d ee d2 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffed2ee]        # 200ca0 <app_mask+0x68>
  2139b1:	ff 
  2139b2:	31 c9                	xor    ecx,ecx
  2139b4:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2139b8:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  2139bc:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  2139c0:	48 85 ff             	test   rdi,rdi
  2139c3:	74 62                	je     213a27 <parseFormValue+0x25d7>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2139c5:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  2139cc:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  2139d1:	c4 e2 7d 59 35 4e d2 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffed24e]        # 200c28 <__unnamed_441+0x88>
  2139d8:	fe ff 
  2139da:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  2139de:	c4 e2 7d 59 3d 99 d2 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffed299]        # 200c80 <app_mask+0x48>
  2139e5:	fe ff 
  2139e7:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  2139eb:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  2139f0:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  2139f7:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  2139fb:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  2139ff:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  213a04:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  213a08:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  213a0f:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  213a14:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  213a18:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  213a1e:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  213a23:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  213a27:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  213a2b:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  213a2f:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213a33:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  213a39:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213a3d:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  213a42:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213a46:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  213a4b:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  213a4e:	74 29                	je     213a79 <parseFormValue+0x2629>
  213a50:	48 29 d8             	sub    rax,rbx
  213a53:	48 01 da             	add    rdx,rbx
  213a56:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  213a5a:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  213a5d:	89 de                	mov    esi,ebx
  213a5f:	40 80 e6 38          	and    sil,0x38
  213a63:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  213a68:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  213a6b:	48 83 c3 08          	add    rbx,0x8
  213a6f:	48 83 c2 01          	add    rdx,0x1
  213a73:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  213a77:	75 e1                	jne    213a5a <parseFormValue+0x260a>
  213a79:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  213a7e:	4c 89 fe             	mov    rsi,r15
  213a81:	4c 89 e2             	mov    rdx,r12
  213a84:	c5 f8 77             	vzeroupper 
  213a87:	e8 54 07 00 00       	call   2141e0 <readAllocBytes>
  213a8c:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  213a91:	66 85 c0             	test   ax,ax
  213a94:	74 39                	je     213acf <parseFormValue+0x267f>
  213a96:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  213a9c:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  213aa2:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  213aa9:	00 00 
  213aab:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213ab2:	00 00 
  213ab4:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  213ab8:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  213abb:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  213ac0:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  213ac5:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  213ac9:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  213acd:	eb 65                	jmp    213b34 <parseFormValue+0x26e4>
  213acf:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  213ad6:	00 00 
  213ad8:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  213adf:	00 00 
    return FormValue{ .Block = buf };
  213ae1:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  213ae7:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  213aee:	00 
  213aef:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  213af4:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  213af9:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  213afd:	89 04 24             	mov    DWORD PTR [rsp],eax
  213b00:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  213b05:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  213b0a:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  213b0e:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  213b12:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  213b18:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213b1f:	00 00 
  213b21:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  213b27:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  213b2e:	00 00 
  213b30:	b1 01                	mov    cl,0x1
  213b32:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  213b34:	66 89 84 24 90 02 00 	mov    WORD PTR [rsp+0x290],ax
  213b3b:	00 
  213b3c:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  213b43:	00 00 
  213b45:	c5 f8 11 84 24 92 02 	vmovups XMMWORD PTR [rsp+0x292],xmm0
  213b4c:	00 00 
  213b4e:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  213b55:	00 00 
  213b57:	c5 f8 11 84 24 a0 02 	vmovups XMMWORD PTR [rsp+0x2a0],xmm0
  213b5e:	00 00 
  213b60:	88 8c 24 b0 02 00 00 	mov    BYTE PTR [rsp+0x2b0],cl
  213b67:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  213b6a:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  213b71:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  213b76:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  213b7d:	00 
  213b7e:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  213b82:	e9 78 da ff ff       	jmp    2115ff <parseFormValue+0x1af>
  213b87:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  213b8b:	c5 fd 6f 0d 0d d1 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffed10d]        # 200ca0 <app_mask+0x68>
  213b92:	ff 
  213b93:	31 c9                	xor    ecx,ecx
  213b95:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  213b99:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  213b9d:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  213ba1:	48 85 ff             	test   rdi,rdi
  213ba4:	74 62                	je     213c08 <parseFormValue+0x27b8>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  213ba6:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  213bad:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  213bb2:	c4 e2 7d 59 35 6d d0 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffed06d]        # 200c28 <__unnamed_441+0x88>
  213bb9:	fe ff 
  213bbb:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  213bbf:	c4 e2 7d 59 3d b8 d0 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffed0b8]        # 200c80 <app_mask+0x48>
  213bc6:	fe ff 
  213bc8:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  213bcc:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  213bd1:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  213bd8:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  213bdc:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  213be0:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  213be5:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  213be9:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  213bf0:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  213bf5:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  213bf9:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  213bff:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  213c04:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  213c08:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  213c0c:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  213c10:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213c14:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  213c1a:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213c1e:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  213c23:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213c27:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  213c2c:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  213c2f:	74 29                	je     213c5a <parseFormValue+0x280a>
  213c31:	48 29 d8             	sub    rax,rbx
  213c34:	48 01 da             	add    rdx,rbx
  213c37:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  213c3b:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  213c3e:	89 de                	mov    esi,ebx
  213c40:	40 80 e6 38          	and    sil,0x38
  213c44:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  213c49:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  213c4c:	48 83 c3 08          	add    rbx,0x8
  213c50:	48 83 c2 01          	add    rdx,0x1
  213c54:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  213c58:	75 e1                	jne    213c3b <parseFormValue+0x27eb>
  213c5a:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  213c5f:	4c 89 fe             	mov    rsi,r15
  213c62:	4c 89 e2             	mov    rdx,r12
  213c65:	c5 f8 77             	vzeroupper 
  213c68:	e8 73 05 00 00       	call   2141e0 <readAllocBytes>
  213c6d:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  213c72:	66 85 c0             	test   ax,ax
  213c75:	74 39                	je     213cb0 <parseFormValue+0x2860>
  213c77:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  213c7d:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  213c83:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  213c8a:	00 00 
  213c8c:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213c93:	00 00 
  213c95:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  213c99:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  213c9c:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  213ca1:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  213ca6:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  213caa:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  213cae:	eb 65                	jmp    213d15 <parseFormValue+0x28c5>
  213cb0:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  213cb7:	00 00 
  213cb9:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  213cc0:	00 00 
    return FormValue{ .Block = buf };
  213cc2:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  213cc8:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  213ccf:	00 
  213cd0:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  213cd5:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  213cda:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  213cde:	89 04 24             	mov    DWORD PTR [rsp],eax
  213ce1:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  213ce6:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  213ceb:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  213cef:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  213cf3:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  213cf9:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213d00:	00 00 
  213d02:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  213d08:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  213d0f:	00 00 
  213d11:	b1 01                	mov    cl,0x1
  213d13:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  213d15:	66 89 84 24 68 02 00 	mov    WORD PTR [rsp+0x268],ax
  213d1c:	00 
  213d1d:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  213d24:	00 00 
  213d26:	c5 f8 11 84 24 6a 02 	vmovups XMMWORD PTR [rsp+0x26a],xmm0
  213d2d:	00 00 
  213d2f:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  213d36:	00 00 
  213d38:	c5 f8 11 84 24 78 02 	vmovups XMMWORD PTR [rsp+0x278],xmm0
  213d3f:	00 00 
  213d41:	88 8c 24 88 02 00 00 	mov    BYTE PTR [rsp+0x288],cl
  213d48:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  213d4b:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  213d52:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  213d57:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  213d5e:	00 
  213d5f:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  213d63:	e9 4c d9 ff ff       	jmp    2116b4 <parseFormValue+0x264>
  213d68:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  213d6c:	c5 fd 6f 0d 2c cf fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffecf2c]        # 200ca0 <app_mask+0x68>
  213d73:	ff 
  213d74:	31 c9                	xor    ecx,ecx
  213d76:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  213d7a:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  213d7e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  213d82:	48 85 ff             	test   rdi,rdi
  213d85:	74 62                	je     213de9 <parseFormValue+0x2999>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  213d87:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  213d8e:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  213d93:	c4 e2 7d 59 35 8c ce 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffece8c]        # 200c28 <__unnamed_441+0x88>
  213d9a:	fe ff 
  213d9c:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  213da0:	c4 e2 7d 59 3d d7 ce 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffeced7]        # 200c80 <app_mask+0x48>
  213da7:	fe ff 
  213da9:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  213dad:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  213db2:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  213db9:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  213dbd:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  213dc1:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  213dc6:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  213dca:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  213dd1:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  213dd6:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  213dda:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  213de0:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  213de5:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  213de9:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  213ded:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  213df1:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213df5:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  213dfb:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213dff:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  213e04:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213e08:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  213e0d:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  213e10:	74 29                	je     213e3b <parseFormValue+0x29eb>
  213e12:	48 29 d8             	sub    rax,rbx
  213e15:	48 01 da             	add    rdx,rbx
  213e18:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  213e1c:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  213e1f:	89 de                	mov    esi,ebx
  213e21:	40 80 e6 38          	and    sil,0x38
  213e25:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  213e2a:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  213e2d:	48 83 c3 08          	add    rbx,0x8
  213e31:	48 83 c2 01          	add    rdx,0x1
  213e35:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  213e39:	75 e1                	jne    213e1c <parseFormValue+0x29cc>
  213e3b:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  213e40:	4c 89 fe             	mov    rsi,r15
  213e43:	4c 89 e2             	mov    rdx,r12
  213e46:	c5 f8 77             	vzeroupper 
  213e49:	e8 92 03 00 00       	call   2141e0 <readAllocBytes>
  213e4e:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  213e53:	66 85 c0             	test   ax,ax
  213e56:	74 39                	je     213e91 <parseFormValue+0x2a41>
  213e58:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  213e5e:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  213e64:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  213e6b:	00 00 
  213e6d:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213e74:	00 00 
  213e76:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  213e7a:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  213e7d:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  213e82:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  213e87:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  213e8b:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  213e8f:	eb 65                	jmp    213ef6 <parseFormValue+0x2aa6>
  213e91:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  213e98:	00 00 
  213e9a:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  213ea1:	00 00 
    return FormValue{ .Block = buf };
  213ea3:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  213ea9:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  213eb0:	00 
  213eb1:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  213eb6:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  213ebb:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  213ebf:	89 04 24             	mov    DWORD PTR [rsp],eax
  213ec2:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  213ec7:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  213ecc:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  213ed0:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  213ed4:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  213eda:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213ee1:	00 00 
  213ee3:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  213ee9:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  213ef0:	00 00 
  213ef2:	b1 01                	mov    cl,0x1
  213ef4:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  213ef6:	66 89 84 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],ax
  213efd:	00 
  213efe:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  213f05:	00 00 
  213f07:	c5 f8 11 84 24 ba 02 	vmovups XMMWORD PTR [rsp+0x2ba],xmm0
  213f0e:	00 00 
  213f10:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  213f17:	00 00 
  213f19:	c5 f8 11 84 24 c8 02 	vmovups XMMWORD PTR [rsp+0x2c8],xmm0
  213f20:	00 00 
  213f22:	88 8c 24 d8 02 00 00 	mov    BYTE PTR [rsp+0x2d8],cl
  213f29:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  213f2c:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  213f33:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  213f38:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  213f3f:	00 
  213f40:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  213f44:	e9 d5 da ff ff       	jmp    211a1e <parseFormValue+0x5ce>
  213f49:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000213f50 <Allocator_alignedRealloc.47>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  213f50:	41 56                	push   r14
  213f52:	53                   	push   rbx
  213f53:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  213f5a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  213f5d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  213f61:	48 85 c0             	test   rax,rax
  213f64:	74 62                	je     213fc8 <Allocator_alignedRealloc.47+0x78>
        if (n == 0) {
  213f66:	48 85 c9             	test   rcx,rcx
  213f69:	0f 84 a9 00 00 00    	je     214018 <Allocator_alignedRealloc.47+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  213f6f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  213f72:	48 c1 e0 03          	shl    rax,0x3
  213f76:	48 8d 04 80          	lea    rax,[rax+rax*4]
  213f7a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  213f7f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  213f84:	ba 28 00 00 00       	mov    edx,0x28
  213f89:	48 89 c8             	mov    rax,rcx
  213f8c:	48 f7 e2             	mul    rdx
  213f8f:	0f 81 d0 00 00 00    	jno    214065 <Allocator_alignedRealloc.47+0x115>
  213f95:	48 8d 0d 34 c8 fe ff 	lea    rcx,[rip+0xfffffffffffec834]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  213f9c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  213fa0:	0f 84 da 00 00 00    	je     214080 <Allocator_alignedRealloc.47+0x130>
  213fa6:	48 8b 05 23 24 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff2423]        # 2063d0 <__unnamed_73+0x10>
  213fad:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  213fb1:	c5 f8 10 05 07 24 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff2407]        # 2063c0 <__unnamed_73>
  213fb8:	ff 
  213fb9:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  213fbd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  213fc4:	5b                   	pop    rbx
  213fc5:	41 5e                	pop    r14
  213fc7:	c3                   	ret    
        if (n == 0) {
  213fc8:	48 85 c9             	test   rcx,rcx
  213fcb:	0f 84 fc 00 00 00    	je     2140cd <Allocator_alignedRealloc.47+0x17d>
  213fd1:	ba 28 00 00 00       	mov    edx,0x28
  213fd6:	48 89 c8             	mov    rax,rcx
  213fd9:	48 f7 e2             	mul    rdx
  213fdc:	0f 81 0c 01 00 00    	jno    2140ee <Allocator_alignedRealloc.47+0x19e>
  213fe2:	48 8d 0d e7 c7 fe ff 	lea    rcx,[rip+0xfffffffffffec7e7]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  213fe9:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  213fed:	0f 84 16 01 00 00    	je     214109 <Allocator_alignedRealloc.47+0x1b9>
  213ff3:	0f b7 05 cc 23 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff23cc]        # 2063c6 <__unnamed_73+0x6>
  213ffa:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  213fff:	8b 05 bd 23 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff23bd]        # 2063c2 <__unnamed_73+0x2>
  214005:	89 04 24             	mov    DWORD PTR [rsp],eax
  214008:	48 89 e0             	mov    rax,rsp
  21400b:	66 b9 05 00          	mov    cx,0x5
  21400f:	31 f6                	xor    esi,esi
  214011:	31 d2                	xor    edx,edx
  214013:	e9 9d 01 00 00       	jmp    2141b5 <Allocator_alignedRealloc.47+0x265>
        const bytes = @sliceToBytes(memory);
  214018:	48 c1 e0 03          	shl    rax,0x3
  21401c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  214020:	48 85 c0             	test   rax,rax
  214023:	74 1e                	je     214043 <Allocator_alignedRealloc.47+0xf3>
        const bytes = @sliceToBytes(memory);
  214025:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  214028:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  21402c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  214031:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  214036:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  21403b:	48 89 f7             	mov    rdi,rsi
  21403e:	48 89 c6             	mov    rsi,rax
  214041:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  214043:	48 8b 05 6e 23 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff236e]        # 2063b8 <__unnamed_74+0x10>
  21404a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21404e:	c5 f8 10 05 52 23 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff2352]        # 2063a8 <__unnamed_74>
  214055:	ff 
  214056:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21405a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  214061:	5b                   	pop    rbx
  214062:	41 5e                	pop    r14
  214064:	c3                   	ret    
  214065:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  21406a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  214071:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  214076:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21407a:	0f 85 26 ff ff ff    	jne    213fa6 <Allocator_alignedRealloc.47+0x56>
  214080:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  214084:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  214089:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21408e:	41 b8 08 00 00 00    	mov    r8d,0x8
  214094:	4c 89 f1             	mov    rcx,r14
  214097:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21409a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21409f:	66 85 c0             	test   ax,ax
  2140a2:	0f 84 94 00 00 00    	je     21413c <Allocator_alignedRealloc.47+0x1ec>
  2140a8:	66 89 03             	mov    WORD PTR [rbx],ax
  2140ab:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2140b2:	00 
  2140b3:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2140b7:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  2140bd:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  2140c2:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2140c9:	5b                   	pop    rbx
  2140ca:	41 5e                	pop    r14
  2140cc:	c3                   	ret    
  2140cd:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  2140d0:	0f b7 0d d7 22 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff22d7]        # 2063ae <__unnamed_74+0x6>
  2140d7:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2140dc:	8b 0d c8 22 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff22c8]        # 2063aa <__unnamed_74+0x2>
  2140e2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2140e5:	31 c9                	xor    ecx,ecx
  2140e7:	31 d2                	xor    edx,edx
  2140e9:	e9 c7 00 00 00       	jmp    2141b5 <Allocator_alignedRealloc.47+0x265>
  2140ee:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  2140f3:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  2140fa:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2140ff:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  214103:	0f 85 ea fe ff ff    	jne    213ff3 <Allocator_alignedRealloc.47+0xa3>
  214109:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21410d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  214112:	b9 08 00 00 00       	mov    ecx,0x8
  214117:	4c 89 f2             	mov    rdx,r14
  21411a:	ff 16                	call   QWORD PTR [rsi]
  21411c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  214121:	66 85 c9             	test   cx,cx
  214124:	74 57                	je     21417d <Allocator_alignedRealloc.47+0x22d>
  214126:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  21412b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  214130:	48 89 e0             	mov    rax,rsp
  214133:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  214137:	89 14 24             	mov    DWORD PTR [rsp],edx
  21413a:	eb 79                	jmp    2141b5 <Allocator_alignedRealloc.47+0x265>
        assert(byte_slice.len == byte_count);
  21413c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  214141:	0f 85 91 00 00 00    	jne    2141d8 <Allocator_alignedRealloc.47+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  214147:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21414c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  214153:	cc cc cc 
  214156:	4c 89 f2             	mov    rdx,r14
  214159:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  21415e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  214163:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  214168:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21416c:	48 c1 ea 05          	shr    rdx,0x5
  214170:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  214174:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  214177:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21417b:	eb 4c                	jmp    2141c9 <Allocator_alignedRealloc.47+0x279>
        assert(byte_slice.len == byte_count);
  21417d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  214182:	75 54                	jne    2141d8 <Allocator_alignedRealloc.47+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  214184:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  214189:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  214190:	cc cc cc 
  214193:	4c 89 f2             	mov    rdx,r14
  214196:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  21419b:	48 c1 ea 05          	shr    rdx,0x5
  21419f:	48 89 e0             	mov    rax,rsp
  2141a2:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  2141a6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2141a9:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  2141ae:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2141b3:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  2141b5:	66 89 0b             	mov    WORD PTR [rbx],cx
  2141b8:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  2141bc:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2141c0:	8b 00                	mov    eax,DWORD PTR [rax]
  2141c2:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  2141c5:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  2141c9:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  2141cd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2141d4:	5b                   	pop    rbx
  2141d5:	41 5e                	pop    r14
  2141d7:	c3                   	ret    
            @panic("assertion failure");
  2141d8:	e8 d3 5a ff ff       	call   209cb0 <panic>
  2141dd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000002141e0 <readAllocBytes>:
fn readAllocBytes(allocator: *mem.Allocator, in_stream: var, size: usize) ![]u8 {
  2141e0:	55                   	push   rbp
  2141e1:	41 57                	push   r15
  2141e3:	41 56                	push   r14
  2141e5:	41 54                	push   r12
  2141e7:	53                   	push   rbx
  2141e8:	48 83 ec 70          	sub    rsp,0x70
  2141ec:	48 89 cb             	mov    rbx,rcx
  2141ef:	49 89 d4             	mov    r12,rdx
  2141f2:	49 89 f6             	mov    r14,rsi
  2141f5:	49 89 ff             	mov    r15,rdi
        if (n == 0) {
  2141f8:	48 85 db             	test   rbx,rbx
  2141fb:	74 32                	je     21422f <readAllocBytes+0x4f>
  2141fd:	48 89 e7             	mov    rdi,rsp
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  214200:	b9 01 00 00 00       	mov    ecx,0x1
  214205:	4c 89 f6             	mov    rsi,r14
  214208:	48 89 da             	mov    rdx,rbx
  21420b:	41 ff 16             	call   QWORD PTR [r14]
  21420e:	0f b7 04 24          	movzx  eax,WORD PTR [rsp]
  214212:	66 85 c0             	test   ax,ax
  214215:	74 1c                	je     214233 <readAllocBytes+0x53>
    const buf = try allocator.alloc(u8, size);
  214217:	66 41 89 07          	mov    WORD PTR [r15],ax
  21421b:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  214220:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  214224:	c5 f8 10 44 24 5a    	vmovups xmm0,XMMWORD PTR [rsp+0x5a]
  21422a:	e9 d8 00 00 00       	jmp    214307 <readAllocBytes+0x127>
  21422f:	31 c0                	xor    eax,eax
  214231:	eb 13                	jmp    214246 <readAllocBytes+0x66>
        assert(byte_slice.len == byte_count);
  214233:	48 39 5c 24 10       	cmp    QWORD PTR [rsp+0x10],rbx
    if (!ok) {
  214238:	0f 85 dc 00 00 00    	jne    21431a <readAllocBytes+0x13a>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21423e:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  214243:	48 89 d8             	mov    rax,rbx
    const buf = try allocator.alloc(u8, size);
  214246:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  21424b:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  214250:	48 89 e7             	mov    rdi,rsp
  214253:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  214258:	4c 89 e6             	mov    rsi,r12
  21425b:	41 ff 14 24          	call   QWORD PTR [r12]
  21425f:	0f b7 2c 24          	movzx  ebp,WORD PTR [rsp]
    if ((try in_stream.read(buf)) < size) return error.EndOfFile;
  214263:	66 85 ed             	test   bp,bp
  214266:	74 39                	je     2142a1 <readAllocBytes+0xc1>
        const bytes = @sliceToBytes(memory);
  214268:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  21426d:	48 85 c0             	test   rax,rax
  214270:	74 1a                	je     21428c <readAllocBytes+0xac>
        const bytes = @sliceToBytes(memory);
  214272:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  214277:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  21427b:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  21427f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214284:	48 89 e6             	mov    rsi,rsp
  214287:	4c 89 f7             	mov    rdi,r14
  21428a:	ff d2                	call   rdx
  21428c:	66 41 89 2f          	mov    WORD PTR [r15],bp
  214290:	48 8b 44 24 52       	mov    rax,QWORD PTR [rsp+0x52]
  214295:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  214299:	c5 f8 10 44 24 44    	vmovups xmm0,XMMWORD PTR [rsp+0x44]
  21429f:	eb 66                	jmp    214307 <readAllocBytes+0x127>
  2142a1:	48 39 5c 24 08       	cmp    QWORD PTR [rsp+0x8],rbx
  2142a6:	73 3e                	jae    2142e6 <readAllocBytes+0x106>
        const bytes = @sliceToBytes(memory);
  2142a8:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  2142ad:	48 85 c0             	test   rax,rax
  2142b0:	74 1a                	je     2142cc <readAllocBytes+0xec>
        const bytes = @sliceToBytes(memory);
  2142b2:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2142b7:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  2142bb:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  2142bf:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2142c4:	48 89 e6             	mov    rsi,rsp
  2142c7:	4c 89 f7             	mov    rdi,r14
  2142ca:	ff d2                	call   rdx
  2142cc:	48 8b 05 5d 34 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff345d]        # 207730 <__unnamed_75+0x10>
  2142d3:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  2142d7:	c5 f8 10 05 41 34 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff3441]        # 207720 <__unnamed_75>
  2142de:	ff 
  2142df:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  2142e4:	eb 27                	jmp    21430d <readAllocBytes+0x12d>
    return buf;
  2142e6:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  2142ec:	c5 f8 11 44 24 34    	vmovups XMMWORD PTR [rsp+0x34],xmm0
  2142f2:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  2142f8:	48 8b 44 24 3c       	mov    rax,QWORD PTR [rsp+0x3c]
  2142fd:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  214301:	c5 f8 10 44 24 2e    	vmovups xmm0,XMMWORD PTR [rsp+0x2e]
  214307:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  21430d:	48 83 c4 70          	add    rsp,0x70
  214311:	5b                   	pop    rbx
  214312:	41 5c                	pop    r12
  214314:	41 5e                	pop    r14
  214316:	41 5f                	pop    r15
  214318:	5d                   	pop    rbp
  214319:	c3                   	ret    
            @panic("assertion failure");
  21431a:	e8 91 59 ff ff       	call   209cb0 <panic>
  21431f:	90                   	nop

0000000000214320 <readStringRaw>:
            return Self{
  214320:	55                   	push   rbp
  214321:	41 57                	push   r15
  214323:	41 56                	push   r14
  214325:	41 55                	push   r13
  214327:	41 54                	push   r12
  214329:	53                   	push   rbx
  21432a:	48 81 ec 98 00 00 00 	sub    rsp,0x98
  214331:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  214335:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  21433b:	48 89 d3             	mov    rbx,rdx
  21433e:	49 89 f7             	mov    r15,rsi
  214341:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  214346:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  21434d:	00 00 
    var buf = ArrayList(u8).init(allocator);
  21434f:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  214354:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
            try self.readNoEof(result[0..]);
  214359:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21435e:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  214365:	00 00 
  214367:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21436c:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  214371:	48 89 de             	mov    rsi,rbx
  214374:	ff 13                	call   QWORD PTR [rbx]
  214376:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21437b:	66 85 c9             	test   cx,cx
  21437e:	74 34                	je     2143b4 <readStringRaw+0x94>
  214380:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
        const byte = try in_stream.readByte();
  214385:	66 89 0a             	mov    WORD PTR [rdx],cx
  214388:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  21438f:	00 
  214390:	48 89 42 10          	mov    QWORD PTR [rdx+0x10],rax
  214394:	c5 f8 10 84 24 82 00 	vmovups xmm0,XMMWORD PTR [rsp+0x82]
  21439b:	00 00 
  21439d:	c5 f8 11 42 02       	vmovups XMMWORD PTR [rdx+0x2],xmm0
  2143a2:	48 81 c4 98 00 00 00 	add    rsp,0x98
  2143a9:	5b                   	pop    rbx
  2143aa:	41 5c                	pop    r12
  2143ac:	41 5d                	pop    r13
  2143ae:	41 5e                	pop    r14
  2143b0:	41 5f                	pop    r15
  2143b2:	5d                   	pop    rbp
  2143b3:	c3                   	ret    
  2143b4:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  2143b9:	31 ed                	xor    ebp,ebp
  2143bb:	45 31 ed             	xor    r13d,r13d
  2143be:	66 90                	xchg   ax,ax
            if (amt_read < buf.len) return error.EndOfStream;
  2143c0:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  2143c5:	0f 82 b6 00 00 00    	jb     214481 <readStringRaw+0x161>
            return result[0];
  2143cb:	44 8a 64 24 07       	mov    r12b,BYTE PTR [rsp+0x7]
        if (byte == 0) break;
  2143d0:	45 84 e4             	test   r12b,r12b
  2143d3:	0f 84 b1 00 00 00    	je     21448a <readStringRaw+0x16a>
            var better_capacity = self.items.len;
  2143d9:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  2143de:	4c 39 e9             	cmp    rcx,r13
  2143e1:	77 53                	ja     214436 <readStringRaw+0x116>
  2143e3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2143ea:	84 00 00 00 00 00 
                better_capacity += better_capacity / 2 + 8;
  2143f0:	48 89 c8             	mov    rax,rcx
  2143f3:	48 d1 e8             	shr    rax,1
  2143f6:	48 01 c1             	add    rcx,rax
  2143f9:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2143fd:	4c 39 e9             	cmp    rcx,r13
  214400:	76 ee                	jbe    2143f0 <readStringRaw+0xd0>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  214402:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214407:	4c 89 fe             	mov    rsi,r15
  21440a:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  21440f:	e8 bc 27 00 00       	call   216bd0 <Allocator_alignedRealloc.71>
  214414:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  214419:	66 85 c0             	test   ax,ax
  21441c:	0f 85 94 00 00 00    	jne    2144b6 <readStringRaw+0x196>
  214422:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  214427:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  21442b:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  214431:	48 8b 6c 24 40       	mov    rbp,QWORD PTR [rsp+0x40]
  214436:	4d 8d 75 01          	lea    r14,[r13+0x1]
            self.len = new_length;
  21443a:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  21443f:	46 88 64 2d 00       	mov    BYTE PTR [rbp+r13*1+0x0],r12b
            try self.readNoEof(result[0..]);
  214444:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  214449:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21444e:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  214455:	00 00 
            return self.readFn(self, buffer);
  214457:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21445c:	48 89 de             	mov    rsi,rbx
  21445f:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  214464:	ff 13                	call   QWORD PTR [rbx]
  214466:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  21446b:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  214470:	4d 89 f5             	mov    r13,r14
            const amt_read = try self.read(buf);
  214473:	66 85 c9             	test   cx,cx
  214476:	0f 84 44 ff ff ff    	je     2143c0 <readStringRaw+0xa0>
  21447c:	e9 ff fe ff ff       	jmp    214380 <readStringRaw+0x60>
  214481:	66 b9 20 00          	mov    cx,0x20
  214485:	e9 f6 fe ff ff       	jmp    214380 <readStringRaw+0x60>
  21448a:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
    return buf.toSlice();
  21448f:	66 c7 02 00 00       	mov    WORD PTR [rdx],0x0
  214494:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  214499:	66 89 42 06          	mov    WORD PTR [rdx+0x6],ax
            return self.items[0..self.len];
  21449d:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  2144a2:	8b 4c 24 3a          	mov    ecx,DWORD PTR [rsp+0x3a]
  2144a6:	89 4a 02             	mov    DWORD PTR [rdx+0x2],ecx
  2144a9:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
  2144ad:	4c 89 6a 10          	mov    QWORD PTR [rdx+0x10],r13
  2144b1:	e9 ec fe ff ff       	jmp    2143a2 <readStringRaw+0x82>
  2144b6:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
        try buf.append(byte);
  2144bb:	66 89 01             	mov    WORD PTR [rcx],ax
  2144be:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  2144c3:	48 89 41 10          	mov    QWORD PTR [rcx+0x10],rax
  2144c7:	c5 f8 10 44 24 6c    	vmovups xmm0,XMMWORD PTR [rsp+0x6c]
  2144cd:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  2144d2:	e9 cb fe ff ff       	jmp    2143a2 <readStringRaw+0x82>
  2144d7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2144de:	00 00 

00000000002144e0 <Allocator_alignedRealloc.54>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  2144e0:	41 56                	push   r14
  2144e2:	53                   	push   rbx
  2144e3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  2144ea:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  2144ed:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  2144f1:	48 85 c0             	test   rax,rax
  2144f4:	74 62                	je     214558 <Allocator_alignedRealloc.54+0x78>
        if (n == 0) {
  2144f6:	48 85 c9             	test   rcx,rcx
  2144f9:	0f 84 a9 00 00 00    	je     2145a8 <Allocator_alignedRealloc.54+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  2144ff:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  214502:	48 c1 e0 04          	shl    rax,0x4
  214506:	48 8d 04 40          	lea    rax,[rax+rax*2]
  21450a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21450f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  214514:	ba 30 00 00 00       	mov    edx,0x30
  214519:	48 89 c8             	mov    rax,rcx
  21451c:	48 f7 e2             	mul    rdx
  21451f:	0f 81 d0 00 00 00    	jno    2145f5 <Allocator_alignedRealloc.54+0x115>
  214525:	48 8d 0d a4 c2 fe ff 	lea    rcx,[rip+0xfffffffffffec2a4]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21452c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  214530:	0f 84 da 00 00 00    	je     214610 <Allocator_alignedRealloc.54+0x130>
  214536:	48 8b 05 0b 1f ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff1f0b]        # 206448 <__unnamed_76+0x10>
  21453d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  214541:	c5 f8 10 05 ef 1e ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff1eef]        # 206438 <__unnamed_76>
  214548:	ff 
  214549:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21454d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  214554:	5b                   	pop    rbx
  214555:	41 5e                	pop    r14
  214557:	c3                   	ret    
        if (n == 0) {
  214558:	48 85 c9             	test   rcx,rcx
  21455b:	0f 84 fc 00 00 00    	je     21465d <Allocator_alignedRealloc.54+0x17d>
  214561:	ba 30 00 00 00       	mov    edx,0x30
  214566:	48 89 c8             	mov    rax,rcx
  214569:	48 f7 e2             	mul    rdx
  21456c:	0f 81 0c 01 00 00    	jno    21467e <Allocator_alignedRealloc.54+0x19e>
  214572:	48 8d 0d 57 c2 fe ff 	lea    rcx,[rip+0xfffffffffffec257]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  214579:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21457d:	0f 84 16 01 00 00    	je     214699 <Allocator_alignedRealloc.54+0x1b9>
  214583:	0f b7 05 b4 1e ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff1eb4]        # 20643e <__unnamed_76+0x6>
  21458a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21458f:	8b 05 a5 1e ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff1ea5]        # 20643a <__unnamed_76+0x2>
  214595:	89 04 24             	mov    DWORD PTR [rsp],eax
  214598:	48 89 e0             	mov    rax,rsp
  21459b:	66 b9 05 00          	mov    cx,0x5
  21459f:	31 f6                	xor    esi,esi
  2145a1:	31 d2                	xor    edx,edx
  2145a3:	e9 9d 01 00 00       	jmp    214745 <Allocator_alignedRealloc.54+0x265>
        const bytes = @sliceToBytes(memory);
  2145a8:	48 c1 e0 04          	shl    rax,0x4
  2145ac:	48 8d 04 40          	lea    rax,[rax+rax*2]
        if (bytes.len == 0) return;
  2145b0:	48 85 c0             	test   rax,rax
  2145b3:	74 1e                	je     2145d3 <Allocator_alignedRealloc.54+0xf3>
        const bytes = @sliceToBytes(memory);
  2145b5:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2145b8:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  2145bc:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2145c1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2145c6:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2145cb:	48 89 f7             	mov    rdi,rsi
  2145ce:	48 89 c6             	mov    rsi,rax
  2145d1:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  2145d3:	48 8b 05 56 1e ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff1e56]        # 206430 <__unnamed_77+0x10>
  2145da:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2145de:	c5 f8 10 05 3a 1e ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff1e3a]        # 206420 <__unnamed_77>
  2145e5:	ff 
  2145e6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2145ea:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2145f1:	5b                   	pop    rbx
  2145f2:	41 5e                	pop    r14
  2145f4:	c3                   	ret    
  2145f5:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  2145fa:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  214601:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  214606:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21460a:	0f 85 26 ff ff ff    	jne    214536 <Allocator_alignedRealloc.54+0x56>
  214610:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  214614:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  214619:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21461e:	41 b8 02 00 00 00    	mov    r8d,0x2
  214624:	4c 89 f1             	mov    rcx,r14
  214627:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21462a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21462f:	66 85 c0             	test   ax,ax
  214632:	0f 84 94 00 00 00    	je     2146cc <Allocator_alignedRealloc.54+0x1ec>
  214638:	66 89 03             	mov    WORD PTR [rbx],ax
  21463b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  214642:	00 
  214643:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  214647:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  21464d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  214652:	48 81 c4 88 00 00 00 	add    rsp,0x88
  214659:	5b                   	pop    rbx
  21465a:	41 5e                	pop    r14
  21465c:	c3                   	ret    
  21465d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  214660:	0f b7 0d bf 1d ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff1dbf]        # 206426 <__unnamed_77+0x6>
  214667:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21466c:	8b 0d b0 1d ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff1db0]        # 206422 <__unnamed_77+0x2>
  214672:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  214675:	31 c9                	xor    ecx,ecx
  214677:	31 d2                	xor    edx,edx
  214679:	e9 c7 00 00 00       	jmp    214745 <Allocator_alignedRealloc.54+0x265>
  21467e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  214683:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  21468a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21468f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  214693:	0f 85 ea fe ff ff    	jne    214583 <Allocator_alignedRealloc.54+0xa3>
  214699:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21469d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2146a2:	b9 02 00 00 00       	mov    ecx,0x2
  2146a7:	4c 89 f2             	mov    rdx,r14
  2146aa:	ff 16                	call   QWORD PTR [rsi]
  2146ac:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  2146b1:	66 85 c9             	test   cx,cx
  2146b4:	74 57                	je     21470d <Allocator_alignedRealloc.54+0x22d>
  2146b6:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  2146bb:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2146c0:	48 89 e0             	mov    rax,rsp
  2146c3:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  2146c7:	89 14 24             	mov    DWORD PTR [rsp],edx
  2146ca:	eb 79                	jmp    214745 <Allocator_alignedRealloc.54+0x265>
        assert(byte_slice.len == byte_count);
  2146cc:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  2146d1:	0f 85 91 00 00 00    	jne    214768 <Allocator_alignedRealloc.54+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2146d7:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2146dc:	48 b9 ab aa aa aa aa 	movabs rcx,0xaaaaaaaaaaaaaaab
  2146e3:	aa aa aa 
  2146e6:	4c 89 f2             	mov    rdx,r14
  2146e9:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  2146ee:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  2146f3:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  2146f8:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2146fc:	48 c1 ea 05          	shr    rdx,0x5
  214700:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  214704:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  214707:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21470b:	eb 4c                	jmp    214759 <Allocator_alignedRealloc.54+0x279>
        assert(byte_slice.len == byte_count);
  21470d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  214712:	75 54                	jne    214768 <Allocator_alignedRealloc.54+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  214714:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  214719:	48 b8 ab aa aa aa aa 	movabs rax,0xaaaaaaaaaaaaaaab
  214720:	aa aa aa 
  214723:	4c 89 f2             	mov    rdx,r14
  214726:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  21472b:	48 c1 ea 05          	shr    rdx,0x5
  21472f:	48 89 e0             	mov    rax,rsp
  214732:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  214736:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  214739:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21473e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  214743:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  214745:	66 89 0b             	mov    WORD PTR [rbx],cx
  214748:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21474c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  214750:	8b 00                	mov    eax,DWORD PTR [rax]
  214752:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  214755:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  214759:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  21475d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  214764:	5b                   	pop    rbx
  214765:	41 5e                	pop    r14
  214767:	c3                   	ret    
            @panic("assertion failure");
  214768:	e8 43 55 ff ff       	call   209cb0 <panic>
  21476d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000214770 <getLineNumberInfo>:
fn getLineNumberInfo(st: *ElfStackTrace, compile_unit: *const CompileUnit, target_address: usize) !LineInfo {
  214770:	55                   	push   rbp
  214771:	41 57                	push   r15
  214773:	41 56                	push   r14
  214775:	41 55                	push   r13
  214777:	41 54                	push   r12
  214779:	53                   	push   rbx
  21477a:	48 81 ec 18 0b 00 00 	sub    rsp,0xb18
  214781:	49 89 cc             	mov    r12,rcx
  214784:	49 89 d6             	mov    r14,rdx
  214787:	49 89 f7             	mov    r15,rsi
  21478a:	48 89 fd             	mov    rbp,rdi
    const compile_unit_cwd = try compile_unit.die.getAttrString(st, DW.AT_comp_dir);
  21478d:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
            return self.items[0..self.len];
  214791:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  214795:	48 85 c9             	test   rcx,rcx
  214798:	74 19                	je     2147b3 <getLineNumberInfo+0x43>
  21479a:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  21479e:	31 d2                	xor    edx,edx
            if (attr.id == id) return &attr.value;
  2147a0:	48 83 38 1b          	cmp    QWORD PTR [rax],0x1b
  2147a4:	74 36                	je     2147dc <getLineNumberInfo+0x6c>
        for (self.attrs.toSliceConst()) |*attr| {
  2147a6:	48 83 c2 01          	add    rdx,0x1
  2147aa:	48 83 c0 28          	add    rax,0x28
  2147ae:	48 39 ca             	cmp    rdx,rcx
  2147b1:	72 ed                	jb     2147a0 <getLineNumberInfo+0x30>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  2147b3:	48 8b 05 46 1d ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff1d46]        # 206500 <__unnamed_43+0x10>
  2147ba:	48 89 84 24 7e 01 00 	mov    QWORD PTR [rsp+0x17e],rax
  2147c1:	00 
  2147c2:	c5 f8 10 05 28 1d ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff1d28]        # 2064f2 <__unnamed_43+0x2>
  2147c9:	ff 
  2147ca:	c5 f8 29 84 24 70 01 	vmovaps XMMWORD PTR [rsp+0x170],xmm0
  2147d1:	00 00 
  2147d3:	66 b8 24 00          	mov    ax,0x24
  2147d7:	e9 c5 00 00 00       	jmp    2148a1 <getLineNumberInfo+0x131>
  2147dc:	8a 48 20             	mov    cl,BYTE PTR [rax+0x20]
  2147df:	80 f9 0a             	cmp    cl,0xa
        return switch (form_value.*) {
  2147e2:	74 1e                	je     214802 <getLineNumberInfo+0x92>
  2147e4:	80 f9 09             	cmp    cl,0x9
  2147e7:	75 69                	jne    214852 <getLineNumberInfo+0xe2>
            FormValue.String => |value| value,
  2147e9:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  2147f0:	c5 f8 10 40 08       	vmovups xmm0,XMMWORD PTR [rax+0x8]
  2147f5:	c5 f8 11 44 24 10    	vmovups XMMWORD PTR [rsp+0x10],xmm0
  2147fb:	48 8d 5c 24 08       	lea    rbx,[rsp+0x8]
  214800:	eb 7d                	jmp    21487f <getLineNumberInfo+0x10f>
            FormValue.StrPtr => |offset| getString(st, offset),
  214802:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
    const pos = st.debug_str.offset + offset;
  214806:	49 8b 47 70          	mov    rax,QWORD PTR [r15+0x70]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  21480a:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  21480e:	78 4b                	js     21485b <getLineNumberInfo+0xeb>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  214810:	49 63 3f             	movsxd rdi,DWORD PTR [r15]
  214813:	31 db                	xor    ebx,ebx
  214815:	b8 08 00 00 00       	mov    eax,0x8
  21481a:	31 d2                	xor    edx,edx
  21481c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  21481e:	48 89 c1             	mov    rcx,rax
  214821:	48 f7 d9             	neg    rcx
  214824:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21482a:	48 0f 46 cb          	cmovbe rcx,rbx
  21482e:	66 b8 02 00          	mov    ax,0x2
                if (err > 0) {
  214832:	48 83 f9 1d          	cmp    rcx,0x1d
  214836:	0f 87 44 02 00 00    	ja     214a80 <getLineNumberInfo+0x310>
  21483c:	48 8d 15 e1 cc fe ff 	lea    rdx,[rip+0xfffffffffffecce1]        # 201524 <__unnamed_9+0x844>
  214843:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  214847:	48 01 d1             	add    rcx,rdx
  21484a:	ff e1                	jmp    rcx
  21484c:	66 b8 22 00          	mov    ax,0x22
  214850:	eb 0d                	jmp    21485f <getLineNumberInfo+0xef>
  214852:	48 8d 1d af 1c ff ff 	lea    rbx,[rip+0xffffffffffff1caf]        # 206508 <__unnamed_26>
  214859:	eb 24                	jmp    21487f <getLineNumberInfo+0x10f>
  21485b:	66 b8 23 00          	mov    ax,0x23
    try st.self_exe_file.seekTo(pos);
  21485f:	66 89 44 24 20       	mov    WORD PTR [rsp+0x20],ax
  214864:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
  21486a:	c5 f8 11 44 24 22    	vmovups XMMWORD PTR [rsp+0x22],xmm0
  214870:	48 8b 44 24 56       	mov    rax,QWORD PTR [rsp+0x56]
  214875:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  21487a:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
        return switch (form_value.*) {
  21487f:	0f b7 03             	movzx  eax,WORD PTR [rbx]
  214882:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  214886:	48 89 8c 24 7e 01 00 	mov    QWORD PTR [rsp+0x17e],rcx
  21488d:	00 
  21488e:	c5 f8 10 43 02       	vmovups xmm0,XMMWORD PTR [rbx+0x2]
  214893:	c5 f8 29 84 24 70 01 	vmovaps XMMWORD PTR [rsp+0x170],xmm0
  21489a:	00 00 
    const compile_unit_cwd = try compile_unit.die.getAttrString(st, DW.AT_comp_dir);
  21489c:	66 85 c0             	test   ax,ax
  21489f:	74 35                	je     2148d6 <getLineNumberInfo+0x166>
  2148a1:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  2148a5:	c5 fe 6f 84 24 ca 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xaca]
  2148ac:	00 00 
  2148ae:	c5 fc 10 8c 24 d8 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xad8]
  2148b5:	00 00 
  2148b7:	c5 fc 11 4d 10       	vmovups YMMWORD PTR [rbp+0x10],ymm1
  2148bc:	c5 fe 7f 45 02       	vmovdqu YMMWORD PTR [rbp+0x2],ymm0
  2148c1:	48 81 c4 18 0b 00 00 	add    rsp,0xb18
  2148c8:	5b                   	pop    rbx
  2148c9:	41 5c                	pop    r12
  2148cb:	41 5d                	pop    r13
  2148cd:	41 5e                	pop    r14
  2148cf:	41 5f                	pop    r15
  2148d1:	5d                   	pop    rbp
  2148d2:	c5 f8 77             	vzeroupper 
  2148d5:	c3                   	ret    
  2148d6:	4c 89 a4 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],r12
  2148dd:	00 
  2148de:	48 89 2c 24          	mov    QWORD PTR [rsp],rbp
  2148e2:	c5 fa 6f 84 24 76 01 	vmovdqu xmm0,XMMWORD PTR [rsp+0x176]
  2148e9:	00 00 
  2148eb:	c5 f9 7f 84 24 e0 01 	vmovdqa XMMWORD PTR [rsp+0x1e0],xmm0
  2148f2:	00 00 
    const debug_line_end = st.debug_line.offset + st.debug_line.size;
  2148f4:	49 8b 47 78          	mov    rax,QWORD PTR [r15+0x78]
  2148f8:	48 8b 58 18          	mov    rbx,QWORD PTR [rax+0x18]
  2148fc:	4c 8b 60 20          	mov    r12,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(in_file);
  214900:	4c 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],r15
  214905:	48 8d 05 54 bc ff ff 	lea    rax,[rip+0xffffffffffffbc54]        # 210560 <FileInStream_readFn>
  21490c:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
    while (this_offset < debug_line_end) : (this_index += 1) {
  214911:	4d 85 e4             	test   r12,r12
  214914:	0f 84 44 01 00 00    	je     214a5e <getLineNumberInfo+0x2ee>
  21491a:	49 01 dc             	add    r12,rbx
  21491d:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  214924:	4c 89 7c 24 60       	mov    QWORD PTR [rsp+0x60],r15
  214929:	48 85 db             	test   rbx,rbx
  21492c:	0f 88 66 01 00 00    	js     214a98 <getLineNumberInfo+0x328>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  214932:	49 63 3f             	movsxd rdi,DWORD PTR [r15]
  214935:	b8 08 00 00 00       	mov    eax,0x8
  21493a:	31 d2                	xor    edx,edx
  21493c:	48 89 de             	mov    rsi,rbx
  21493f:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  214941:	48 89 c1             	mov    rcx,rax
  214944:	48 f7 d9             	neg    rcx
  214947:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21494d:	b8 00 00 00 00       	mov    eax,0x0
  214952:	48 0f 46 c8          	cmovbe rcx,rax
  214956:	48 85 c9             	test   rcx,rcx
  214959:	0f 85 46 01 00 00    	jne    214aa5 <getLineNumberInfo+0x335>
            try self.readNoEof(bytes[0..]);
  21495f:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214964:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214969:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  214970:	00 00 
            return self.readFn(self, buffer);
  214972:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214977:	48 8d 6c 24 40       	lea    rbp,[rsp+0x40]
  21497c:	48 89 ee             	mov    rsi,rbp
  21497f:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  214984:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214988:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21498d:	66 85 c0             	test   ax,ax
  214990:	0f 85 e6 01 00 00    	jne    214b7c <getLineNumberInfo+0x40c>
  214996:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  21499b:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  2149a0:	0f 82 e9 00 00 00    	jb     214a8f <getLineNumberInfo+0x31f>
  2149a6:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2149ab:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  2149b0:	48 c1 e1 08          	shl    rcx,0x8
  2149b4:	48 09 c1             	or     rcx,rax
  2149b7:	0f b6 54 24 4a       	movzx  edx,BYTE PTR [rsp+0x4a]
  2149bc:	48 c1 e2 10          	shl    rdx,0x10
  2149c0:	48 09 ca             	or     rdx,rcx
  2149c3:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  2149c8:	48 c1 e0 18          	shl    rax,0x18
  2149cc:	48 09 d0             	or     rax,rdx
    is_64.* = (first_32_bits == 0xffffffff);
  2149cf:	83 f8 ff             	cmp    eax,0xffffffff
    if (is_64.*) {
  2149d2:	74 3f                	je     214a13 <getLineNumberInfo+0x2a3>
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  2149d4:	83 f8 ef             	cmp    eax,0xffffffef
  2149d7:	0f 87 9b 01 00 00    	ja     214b78 <getLineNumberInfo+0x408>
  2149dd:	45 31 ff             	xor    r15d,r15d
        if (unit_length == 0) return error.MissingDebugInfo;
  2149e0:	48 85 c0             	test   rax,rax
  2149e3:	74 79                	je     214a5e <getLineNumberInfo+0x2ee>
        if (compile_unit.index != this_index) {
  2149e5:	49 83 c5 01          	add    r13,0x1
  2149e9:	4d 3b 6e 10          	cmp    r13,QWORD PTR [r14+0x10]
  2149ed:	0f 84 22 01 00 00    	je     214b15 <getLineNumberInfo+0x3a5>
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  2149f3:	41 0f b6 cf          	movzx  ecx,r15b
  2149f7:	48 8d 0c cb          	lea    rcx,[rbx+rcx*8]
            this_offset += next_offset;
  2149fb:	48 8d 1c 08          	lea    rbx,[rax+rcx*1]
  2149ff:	48 83 c3 04          	add    rbx,0x4
    while (this_offset < debug_line_end) : (this_index += 1) {
  214a03:	4c 39 e3             	cmp    rbx,r12
  214a06:	4c 8b 7c 24 60       	mov    r15,QWORD PTR [rsp+0x60]
  214a0b:	0f 82 18 ff ff ff    	jb     214929 <getLineNumberInfo+0x1b9>
  214a11:	eb 4b                	jmp    214a5e <getLineNumberInfo+0x2ee>
            try self.readNoEof(bytes[0..]);
  214a13:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214a18:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214a1d:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  214a24:	00 00 
            return self.readFn(self, buffer);
  214a26:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214a2b:	48 89 ee             	mov    rsi,rbp
  214a2e:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  214a33:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214a37:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214a3c:	66 85 c0             	test   ax,ax
  214a3f:	0f 85 37 01 00 00    	jne    214b7c <getLineNumberInfo+0x40c>
  214a45:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  214a4a:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  214a4f:	72 3e                	jb     214a8f <getLineNumberInfo+0x31f>
  214a51:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  214a56:	41 b7 01             	mov    r15b,0x1
        if (unit_length == 0) return error.MissingDebugInfo;
  214a59:	48 85 c0             	test   rax,rax
  214a5c:	75 87                	jne    2149e5 <getLineNumberInfo+0x275>
  214a5e:	c5 fc 10 05 12 1b ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff1b12]        # 206578 <__unnamed_78+0x10>
  214a65:	ff 
  214a66:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  214a6a:	c5 fc 11 40 10       	vmovups YMMWORD PTR [rax+0x10],ymm0
  214a6f:	c5 fe 6f 05 f1 1a ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff1af1]        # 206568 <__unnamed_78>
  214a76:	ff 
  214a77:	c5 fe 7f 00          	vmovdqu YMMWORD PTR [rax],ymm0
  214a7b:	e9 41 fe ff ff       	jmp    2148c1 <getLineNumberInfo+0x151>
  214a80:	48 83 f9 4b          	cmp    rcx,0x4b
  214a84:	0f 85 d5 fd ff ff    	jne    21485f <getLineNumberInfo+0xef>
  214a8a:	e9 bd fd ff ff       	jmp    21484c <getLineNumberInfo+0xdc>
  214a8f:	66 b8 20 00          	mov    ax,0x20
  214a93:	e9 e4 00 00 00       	jmp    214b7c <getLineNumberInfo+0x40c>
  214a98:	66 b8 23 00          	mov    ax,0x23
  214a9c:	48 8b 34 24          	mov    rsi,QWORD PTR [rsp]
  214aa0:	e9 0e 01 00 00       	jmp    214bb3 <getLineNumberInfo+0x443>
  214aa5:	66 b8 02 00          	mov    ax,0x2
  214aa9:	48 8d 51 fa          	lea    rdx,[rcx-0x6]
  214aad:	48 83 fa 17          	cmp    rdx,0x17
  214ab1:	48 8b 34 24          	mov    rsi,QWORD PTR [rsp]
  214ab5:	0f 87 e9 00 00 00    	ja     214ba4 <getLineNumberInfo+0x434>
  214abb:	48 8d 0d da ca fe ff 	lea    rcx,[rip+0xfffffffffffecada]        # 20159c <__unnamed_9+0x8bc>
  214ac2:	48 63 14 91          	movsxd rdx,DWORD PTR [rcx+rdx*4]
  214ac6:	48 01 ca             	add    rdx,rcx
  214ac9:	ff e2                	jmp    rdx
  214acb:	66 b8 22 00          	mov    ax,0x22
  214acf:	e9 df 00 00 00       	jmp    214bb3 <getLineNumberInfo+0x443>
  214ad4:	66 b8 1e 00          	mov    ax,0x1e
  214ad8:	e9 82 fd ff ff       	jmp    21485f <getLineNumberInfo+0xef>
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  214add:	4c 89 bc 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],r15
  214ae4:	00 
  214ae5:	48 8d 94 24 a8 01 00 	lea    rdx,[rsp+0x1a8]
  214aec:	00 
  214aed:	48 8d 05 6c ba ff ff 	lea    rax,[rip+0xffffffffffffba6c]        # 210560 <FileInStream_readFn>
  214af4:	48 89 84 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rax
  214afb:	00 
  214afc:	49 8b b7 a0 00 00 00 	mov    rsi,QWORD PTR [r15+0xa0]
  214b03:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  214b08:	48 89 df             	mov    rdi,rbx
  214b0b:	e8 10 f8 ff ff       	call   214320 <readStringRaw>
  214b10:	e9 6a fd ff ff       	jmp    21487f <getLineNumberInfo+0x10f>
        const version = try in_stream.readInt(st.elf.endian, u16);
  214b15:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  214b1a:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  214b1d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214b22:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214b27:	48 c7 44 24 10 02 00 	mov    QWORD PTR [rsp+0x10],0x2
  214b2e:	00 00 
  214b30:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214b35:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214b3a:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214b3f:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214b43:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214b48:	66 85 c0             	test   ax,ax
  214b4b:	75 10                	jne    214b5d <getLineNumberInfo+0x3ed>
  214b4d:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214b52:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214b56:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214b5b:	73 7a                	jae    214bd7 <getLineNumberInfo+0x467>
  214b5d:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  214b61:	66 89 01             	mov    WORD PTR [rcx],ax
  214b64:	c5 fe 6f 84 24 40 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa40]
  214b6b:	00 00 
  214b6d:	c5 fc 10 8c 24 4e 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa4e]
  214b74:	00 00 
  214b76:	eb 1d                	jmp    214b95 <getLineNumberInfo+0x425>
  214b78:	66 b8 25 00          	mov    ax,0x25
  214b7c:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  214b80:	66 89 01             	mov    WORD PTR [rcx],ax
  214b83:	c5 fe 6f 84 24 6e 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa6e]
  214b8a:	00 00 
  214b8c:	c5 fc 10 8c 24 7c 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa7c]
  214b93:	00 00 
  214b95:	c5 fc 11 49 10       	vmovups YMMWORD PTR [rcx+0x10],ymm1
  214b9a:	c5 fe 7f 41 02       	vmovdqu YMMWORD PTR [rcx+0x2],ymm0
  214b9f:	e9 1d fd ff ff       	jmp    2148c1 <getLineNumberInfo+0x151>
  214ba4:	48 83 f9 4b          	cmp    rcx,0x4b
  214ba8:	75 09                	jne    214bb3 <getLineNumberInfo+0x443>
  214baa:	e9 1c ff ff ff       	jmp    214acb <getLineNumberInfo+0x35b>
  214baf:	66 b8 1e 00          	mov    ax,0x1e
        try in_file.seekTo(this_offset);
  214bb3:	66 89 06             	mov    WORD PTR [rsi],ax
  214bb6:	c5 fe 6f 84 24 9c 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa9c]
  214bbd:	00 00 
  214bbf:	c5 fc 10 8c 24 aa 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xaaa]
  214bc6:	00 00 
  214bc8:	c5 fc 11 4e 10       	vmovups YMMWORD PTR [rsi+0x10],ymm1
  214bcd:	c5 fe 7f 46 02       	vmovdqu YMMWORD PTR [rsi+0x2],ymm0
  214bd2:	e9 ea fc ff ff       	jmp    2148c1 <getLineNumberInfo+0x151>
  214bd7:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  214bdc:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  214be1:	89 ca                	mov    edx,ecx
  214be3:	c1 e2 08             	shl    edx,0x8
  214be6:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  214be8:	c1 e0 08             	shl    eax,0x8
  214beb:	09 c8                	or     eax,ecx
    switch (endian) {
  214bed:	f6 c3 01             	test   bl,0x1
  214bf0:	66 0f 45 c2          	cmovne ax,dx
        if (version != 2 and version != 4) return error.InvalidDebugInfo;
  214bf4:	44 0f b7 e0          	movzx  r12d,ax
  214bf8:	41 83 fc 02          	cmp    r12d,0x2
  214bfc:	48 8b 2c 24          	mov    rbp,QWORD PTR [rsp]
  214c00:	74 0a                	je     214c0c <getLineNumberInfo+0x49c>
  214c02:	41 83 fc 04          	cmp    r12d,0x4
  214c06:	0f 85 ac 00 00 00    	jne    214cb8 <getLineNumberInfo+0x548>
  214c0c:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  214c11:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
        const prologue_length = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  214c14:	45 84 ff             	test   r15b,r15b
  214c17:	74 44                	je     214c5d <getLineNumberInfo+0x4ed>
  214c19:	0f b6 d3             	movzx  edx,bl
  214c1c:	48 8d bc 24 90 01 00 	lea    rdi,[rsp+0x190]
  214c23:	00 
  214c24:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
  214c29:	48 89 de             	mov    rsi,rbx
  214c2c:	e8 ef b6 ff ff       	call   210320 <InStream(ReadError)_readInt.33>
  214c31:	0f b7 84 24 90 01 00 	movzx  eax,WORD PTR [rsp+0x190]
  214c38:	00 
  214c39:	66 85 c0             	test   ax,ax
  214c3c:	0f 84 95 00 00 00    	je     214cd7 <getLineNumberInfo+0x567>
  214c42:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  214c46:	c5 fe 6f 84 24 12 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa12]
  214c4d:	00 00 
  214c4f:	c5 fc 10 8c 24 20 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa20]
  214c56:	00 00 
  214c58:	e9 5a fc ff ff       	jmp    2148b7 <getLineNumberInfo+0x147>
            try self.readNoEof(bytes[0..]);
  214c5d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214c62:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214c67:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  214c6e:	00 00 
  214c70:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214c75:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214c7a:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214c7f:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214c83:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214c88:	66 85 c0             	test   ax,ax
  214c8b:	75 10                	jne    214c9d <getLineNumberInfo+0x52d>
  214c8d:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214c92:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214c96:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214c9b:	73 44                	jae    214ce1 <getLineNumberInfo+0x571>
  214c9d:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  214ca1:	c5 fe 6f 84 24 e4 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x9e4]
  214ca8:	00 00 
  214caa:	c5 fc 10 8c 24 f2 09 	vmovups ymm1,YMMWORD PTR [rsp+0x9f2]
  214cb1:	00 00 
  214cb3:	e9 ff fb ff ff       	jmp    2148b7 <getLineNumberInfo+0x147>
        if (version != 2 and version != 4) return error.InvalidDebugInfo;
  214cb8:	c5 fc 10 05 88 18 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff1888]        # 206548 <__unnamed_79+0x10>
  214cbf:	ff 
  214cc0:	c5 fc 11 45 10       	vmovups YMMWORD PTR [rbp+0x10],ymm0
  214cc5:	c5 fe 6f 05 6b 18 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff186b]        # 206538 <__unnamed_79>
  214ccc:	ff 
  214ccd:	c5 fe 7f 45 00       	vmovdqu YMMWORD PTR [rbp+0x0],ymm0
  214cd2:	e9 ea fb ff ff       	jmp    2148c1 <getLineNumberInfo+0x151>
        const prologue_length = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  214cd7:	4c 8b b4 24 98 01 00 	mov    r14,QWORD PTR [rsp+0x198]
  214cde:	00 
  214cdf:	eb 4f                	jmp    214d30 <getLineNumberInfo+0x5c0>
  214ce1:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  214ce6:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  214ceb:	f6 c3 01             	test   bl,0x1
  214cee:	74 1b                	je     214d0b <getLineNumberInfo+0x59b>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  214cf0:	c1 e1 08             	shl    ecx,0x8
  214cf3:	09 c1                	or     ecx,eax
  214cf5:	0f b6 54 24 4a       	movzx  edx,BYTE PTR [rsp+0x4a]
  214cfa:	c1 e2 10             	shl    edx,0x10
  214cfd:	09 ca                	or     edx,ecx
  214cff:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  214d04:	c1 e0 18             	shl    eax,0x18
  214d07:	09 d0                	or     eax,edx
  214d09:	eb 19                	jmp    214d24 <getLineNumberInfo+0x5b4>
                result = (result << 8) | b;
  214d0b:	c1 e0 08             	shl    eax,0x8
  214d0e:	09 c8                	or     eax,ecx
  214d10:	c1 e0 08             	shl    eax,0x8
  214d13:	0f b6 4c 24 4a       	movzx  ecx,BYTE PTR [rsp+0x4a]
  214d18:	09 c1                	or     ecx,eax
  214d1a:	c1 e1 08             	shl    ecx,0x8
  214d1d:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  214d22:	09 c8                	or     eax,ecx
  214d24:	41 89 c6             	mov    r14d,eax
  214d27:	48 8b 2c 24          	mov    rbp,QWORD PTR [rsp]
  214d2b:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  214d30:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  214d35:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  214d38:	45 31 c0             	xor    r8d,r8d
  214d3b:	b8 08 00 00 00       	mov    eax,0x8
  214d40:	be 00 00 00 00       	mov    esi,0x0
  214d45:	ba 01 00 00 00       	mov    edx,0x1
  214d4a:	0f 05                	syscall 
  214d4c:	49 89 c5             	mov    r13,rax
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  214d4f:	4c 89 e9             	mov    rcx,r13
  214d52:	48 f7 d9             	neg    rcx
  214d55:	49 81 fd 00 f0 ff ff 	cmp    r13,0xfffffffffffff000
  214d5c:	49 0f 46 c8          	cmovbe rcx,r8
                if (err > 0) {
  214d60:	48 83 f9 1d          	cmp    rcx,0x1d
  214d64:	77 1a                	ja     214d80 <getLineNumberInfo+0x610>
  214d66:	66 b8 1e 00          	mov    ax,0x1e
  214d6a:	48 8d 15 8b c8 fe ff 	lea    rdx,[rip+0xfffffffffffec88b]        # 2015fc <__unnamed_9+0x91c>
  214d71:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  214d75:	48 01 d1             	add    rcx,rdx
  214d78:	ff e1                	jmp    rcx
  214d7a:	66 b8 22 00          	mov    ax,0x22
  214d7e:	eb 0a                	jmp    214d8a <getLineNumberInfo+0x61a>
  214d80:	48 83 f9 4b          	cmp    rcx,0x4b
  214d84:	74 f4                	je     214d7a <getLineNumberInfo+0x60a>
  214d86:	66 b8 02 00          	mov    ax,0x2
        const prog_start_offset = (try in_file.getPos()) + prologue_length;
  214d8a:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  214d8e:	c5 fe 6f 84 24 b6 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x9b6]
  214d95:	00 00 
  214d97:	c5 fc 10 8c 24 c4 09 	vmovups ymm1,YMMWORD PTR [rsp+0x9c4]
  214d9e:	00 00 
  214da0:	e9 12 fb ff ff       	jmp    2148b7 <getLineNumberInfo+0x147>
            try self.readNoEof(result[0..]);
  214da5:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214daa:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214daf:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214db6:	00 00 
  214db8:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214dbd:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214dc2:	48 89 de             	mov    rsi,rbx
  214dc5:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214dc9:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214dce:	66 85 c0             	test   ax,ax
  214dd1:	75 10                	jne    214de3 <getLineNumberInfo+0x673>
  214dd3:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214dd8:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214ddc:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214de1:	73 1e                	jae    214e01 <getLineNumberInfo+0x691>
  214de3:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const minimum_instruction_length = try in_stream.readByte();
  214de7:	66 89 01             	mov    WORD PTR [rcx],ax
  214dea:	c5 fe 6f 84 24 88 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x988]
  214df1:	00 00 
  214df3:	c5 fc 10 8c 24 96 09 	vmovups ymm1,YMMWORD PTR [rsp+0x996]
  214dfa:	00 00 
  214dfc:	e9 94 fd ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
            return result[0];
  214e01:	44 0f b6 7c 24 48    	movzx  r15d,BYTE PTR [rsp+0x48]
  214e07:	4d 85 ff             	test   r15,r15
        if (minimum_instruction_length == 0) return error.InvalidDebugInfo;
  214e0a:	0f 84 62 15 00 00    	je     216372 <getLineNumberInfo+0x1c02>
        if (version >= 4) {
  214e10:	41 83 fc 04          	cmp    r12d,0x4
  214e14:	72 5e                	jb     214e74 <getLineNumberInfo+0x704>
            try self.readNoEof(result[0..]);
  214e16:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214e1b:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214e20:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214e27:	00 00 
  214e29:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214e2e:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214e33:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214e38:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214e3c:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214e41:	66 85 c0             	test   ax,ax
  214e44:	75 10                	jne    214e56 <getLineNumberInfo+0x6e6>
  214e46:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214e4b:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214e4f:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214e54:	73 1e                	jae    214e74 <getLineNumberInfo+0x704>
  214e56:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            _ = try in_stream.readByte();
  214e5a:	66 89 01             	mov    WORD PTR [rcx],ax
  214e5d:	c5 fe 6f 84 24 5a 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x95a]
  214e64:	00 00 
  214e66:	c5 fc 10 8c 24 68 09 	vmovups ymm1,YMMWORD PTR [rsp+0x968]
  214e6d:	00 00 
  214e6f:	e9 21 fd ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
            try self.readNoEof(result[0..]);
  214e74:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214e79:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214e7e:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214e85:	00 00 
  214e87:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214e8c:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214e91:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214e96:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214e9a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214e9f:	66 85 c0             	test   ax,ax
  214ea2:	75 10                	jne    214eb4 <getLineNumberInfo+0x744>
  214ea4:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214ea9:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214ead:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214eb2:	73 1e                	jae    214ed2 <getLineNumberInfo+0x762>
  214eb4:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const default_is_stmt = (try in_stream.readByte()) != 0;
  214eb8:	66 89 01             	mov    WORD PTR [rcx],ax
  214ebb:	c5 fe 6f 84 24 2c 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x92c]
  214ec2:	00 00 
  214ec4:	c5 fc 10 8c 24 3a 09 	vmovups ymm1,YMMWORD PTR [rsp+0x93a]
  214ecb:	00 00 
  214ecd:	e9 c3 fc ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
            return result[0];
  214ed2:	40 8a 6c 24 48       	mov    bpl,BYTE PTR [rsp+0x48]
            try self.readNoEof(result[0..]);
  214ed7:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214edc:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214ee1:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214ee8:	00 00 
  214eea:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214eef:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214ef4:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214ef9:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214efd:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214f02:	66 85 c0             	test   ax,ax
  214f05:	75 10                	jne    214f17 <getLineNumberInfo+0x7a7>
  214f07:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214f0c:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214f10:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214f15:	73 1e                	jae    214f35 <getLineNumberInfo+0x7c5>
  214f17:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const line_base = try in_stream.readByteSigned();
  214f1b:	66 89 01             	mov    WORD PTR [rcx],ax
  214f1e:	c5 fe 6f 84 24 fe 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8fe]
  214f25:	00 00 
  214f27:	c5 fc 10 8c 24 0c 09 	vmovups ymm1,YMMWORD PTR [rsp+0x90c]
  214f2e:	00 00 
  214f30:	e9 60 fc ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
            return result[0];
  214f35:	48 0f be 44 24 48    	movsx  rax,BYTE PTR [rsp+0x48]
            try self.readNoEof(result[0..]);
  214f3b:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  214f42:	00 
  214f43:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214f48:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214f4d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214f54:	00 00 
  214f56:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214f5b:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214f60:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214f65:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214f69:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214f6e:	66 85 c0             	test   ax,ax
  214f71:	75 10                	jne    214f83 <getLineNumberInfo+0x813>
  214f73:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214f78:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214f7c:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214f81:	73 1e                	jae    214fa1 <getLineNumberInfo+0x831>
  214f83:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const line_range = try in_stream.readByte();
  214f87:	66 89 01             	mov    WORD PTR [rcx],ax
  214f8a:	c5 fe 6f 84 24 d0 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8d0]
  214f91:	00 00 
  214f93:	c5 fc 10 8c 24 de 08 	vmovups ymm1,YMMWORD PTR [rsp+0x8de]
  214f9a:	00 00 
  214f9c:	e9 f4 fb ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
            return result[0];
  214fa1:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
  214fa5:	88 44 24 5f          	mov    BYTE PTR [rsp+0x5f],al
        if (line_range == 0) return error.InvalidDebugInfo;
  214fa9:	84 c0                	test   al,al
  214fab:	0f 84 c1 13 00 00    	je     216372 <getLineNumberInfo+0x1c02>
            try self.readNoEof(result[0..]);
  214fb1:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214fb6:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214fbb:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214fc2:	00 00 
  214fc4:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214fc9:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214fce:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214fd3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214fd7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214fdc:	66 85 c0             	test   ax,ax
  214fdf:	75 10                	jne    214ff1 <getLineNumberInfo+0x881>
  214fe1:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214fe6:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214fea:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214fef:	73 1e                	jae    21500f <getLineNumberInfo+0x89f>
  214ff1:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const opcode_base = try in_stream.readByte();
  214ff5:	66 89 01             	mov    WORD PTR [rcx],ax
  214ff8:	c5 fe 6f 84 24 a2 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8a2]
  214fff:	00 00 
  215001:	c5 fc 10 8c 24 b0 08 	vmovups ymm1,YMMWORD PTR [rsp+0x8b0]
  215008:	00 00 
  21500a:	e9 86 fb ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
            return result[0];
  21500f:	8a 4c 24 48          	mov    cl,BYTE PTR [rsp+0x48]
  215013:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  215018:	48 8b 80 a0 00 00 00 	mov    rax,QWORD PTR [rax+0xa0]
  21501f:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  215024:	88 4c 24 5e          	mov    BYTE PTR [rsp+0x5e],cl
        const standard_opcode_lengths = try st.allocator().alloc(u8, opcode_base - 1);
  215028:	89 c8                	mov    eax,ecx
  21502a:	04 ff                	add    al,0xff
        if (n == 0) {
  21502c:	74 48                	je     215076 <getLineNumberInfo+0x906>
  21502e:	0f b6 d0             	movzx  edx,al
  215031:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  215036:	b9 01 00 00 00       	mov    ecx,0x1
  21503b:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  215040:	48 89 94 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rdx
  215047:	00 
  215048:	ff 16                	call   QWORD PTR [rsi]
  21504a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21504f:	66 85 c0             	test   ax,ax
  215052:	0f 84 91 00 00 00    	je     2150e9 <getLineNumberInfo+0x979>
  215058:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  21505c:	66 89 01             	mov    WORD PTR [rcx],ax
  21505f:	c5 fe 6f 84 24 74 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x874]
  215066:	00 00 
  215068:	c5 fc 10 8c 24 82 08 	vmovups ymm1,YMMWORD PTR [rsp+0x882]
  21506f:	00 00 
  215071:	e9 1f fb ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  215076:	31 c0                	xor    eax,eax
  215078:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21507f:	00 
            return Self{
  215080:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  215084:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  21508b:	00 00 
  21508d:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x0
  215094:	00 00 00 00 00 
  215099:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
        var include_directories = ArrayList([]u8).init(st.allocator());
  21509e:	48 89 b4 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rsi
  2150a5:	00 
  2150a6:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2150ab:	48 8d 94 24 b0 00 00 	lea    rdx,[rsp+0xb0]
  2150b2:	00 
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2150b3:	b9 08 00 00 00       	mov    ecx,0x8
  2150b8:	e8 d3 23 00 00       	call   217490 <Allocator_alignedRealloc.76>
  2150bd:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2150c2:	66 85 c0             	test   ax,ax
  2150c5:	0f 84 bd 00 00 00    	je     215188 <getLineNumberInfo+0xa18>
  2150cb:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try include_directories.append(compile_unit_cwd);
  2150cf:	66 89 01             	mov    WORD PTR [rcx],ax
  2150d2:	c5 fe 6f 84 24 18 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x818]
  2150d9:	00 00 
  2150db:	c5 fc 10 8c 24 26 08 	vmovups ymm1,YMMWORD PTR [rsp+0x826]
  2150e2:	00 00 
  2150e4:	e9 ac fa ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
        assert(byte_slice.len == byte_count);
  2150e9:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  2150f0:	00 
  2150f1:	48 39 44 24 30       	cmp    QWORD PTR [rsp+0x30],rax
    if (!ok) {
  2150f6:	0f 85 7d 16 00 00    	jne    216779 <getLineNumberInfo+0x2009>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2150fc:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  215101:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  215108:	00 
  215109:	45 31 e4             	xor    r12d,r12d
  21510c:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
            try self.readNoEof(result[0..]);
  215111:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215116:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21511b:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215122:	00 00 
            return self.readFn(self, buffer);
  215124:	48 89 df             	mov    rdi,rbx
  215127:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21512c:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  215131:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215135:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21513a:	66 85 c0             	test   ax,ax
  21513d:	0f 85 cf 00 00 00    	jne    215212 <getLineNumberInfo+0xaa2>
  215143:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  215148:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  21514d:	0f 82 bb 00 00 00    	jb     21520e <getLineNumberInfo+0xa9e>
            return result[0];
  215153:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                standard_opcode_lengths[i] = try in_stream.readByte();
  215158:	48 8b 8c 24 d8 00 00 	mov    rcx,QWORD PTR [rsp+0xd8]
  21515f:	00 
  215160:	42 88 04 21          	mov    BYTE PTR [rcx+r12*1],al
            while (i < opcode_base - 1) : (i += 1) {
  215164:	49 83 c4 01          	add    r12,0x1
  215168:	4c 3b a4 24 98 00 00 	cmp    r12,QWORD PTR [rsp+0x98]
  21516f:	00 
  215170:	72 9f                	jb     215111 <getLineNumberInfo+0x9a1>
  215172:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  215177:	48 8b 80 a0 00 00 00 	mov    rax,QWORD PTR [rax+0xa0]
  21517e:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  215183:	e9 f8 fe ff ff       	jmp    215080 <getLineNumberInfo+0x910>
  215188:	c5 f8 10 44 24 28    	vmovups xmm0,XMMWORD PTR [rsp+0x28]
  21518e:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  215195:	00 00 
            const result = &self.items[self.len];
  215197:	4c 8b a4 24 b0 00 00 	mov    r12,QWORD PTR [rsp+0xb0]
  21519e:	00 
            self.len = new_length;
  21519f:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x1
  2151a6:	00 01 00 00 00 
            new_item_ptr.* = item;
  2151ab:	c5 f9 6f 84 24 e0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1e0]
  2151b2:	00 00 
  2151b4:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
  2151ba:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  2151bf:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2151c4:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2151c9:	48 8d 0d 90 b3 ff ff 	lea    rcx,[rip+0xffffffffffffb390]        # 210560 <FileInStream_readFn>
  2151d0:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  2151d5:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
  2151dc:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  2151e1:	e8 3a f1 ff ff       	call   214320 <readStringRaw>
  2151e6:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const dir = try st.readString();
  2151eb:	66 85 c0             	test   ax,ax
  2151ee:	74 40                	je     215230 <getLineNumberInfo+0xac0>
  2151f0:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  2151f4:	66 89 01             	mov    WORD PTR [rcx],ax
  2151f7:	c5 fe 6f 84 24 ea 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x7ea]
  2151fe:	00 00 
  215200:	c5 fc 10 8c 24 f8 07 	vmovups ymm1,YMMWORD PTR [rsp+0x7f8]
  215207:	00 00 
  215209:	e9 87 f9 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  21520e:	66 b8 20 00          	mov    ax,0x20
  215212:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                standard_opcode_lengths[i] = try in_stream.readByte();
  215216:	66 89 01             	mov    WORD PTR [rcx],ax
  215219:	c5 fe 6f 84 24 46 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x846]
  215220:	00 00 
  215222:	c5 fc 10 8c 24 54 08 	vmovups ymm1,YMMWORD PTR [rsp+0x854]
  215229:	00 00 
  21522b:	e9 65 f9 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  215230:	4d 01 f5             	add    r13,r14
  215233:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  215239:	c5 f9 7f 84 24 50 01 	vmovdqa XMMWORD PTR [rsp+0x150],xmm0
  215240:	00 00 
  215242:	41 be 01 00 00 00    	mov    r14d,0x1
            if (dir.len == 0) break;
  215248:	c5 f9 6f 84 24 50 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x150]
  21524f:	00 00 
  215251:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  215257:	48 85 c0             	test   rax,rax
  21525a:	0f 84 ce 00 00 00    	je     21532e <getLineNumberInfo+0xbbe>
            var better_capacity = self.items.len;
  215260:	48 8b 8c 24 b8 00 00 	mov    rcx,QWORD PTR [rsp+0xb8]
  215267:	00 
            if (better_capacity >= new_capacity) return;
  215268:	4c 39 f1             	cmp    rcx,r14
  21526b:	77 51                	ja     2152be <getLineNumberInfo+0xb4e>
                better_capacity += better_capacity / 2 + 8;
  21526d:	48 89 c8             	mov    rax,rcx
  215270:	48 d1 e8             	shr    rax,1
  215273:	48 01 c1             	add    rcx,rax
  215276:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  21527a:	4c 39 f1             	cmp    rcx,r14
  21527d:	76 ee                	jbe    21526d <getLineNumberInfo+0xafd>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  21527f:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  215284:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  215289:	48 8d 94 24 b0 00 00 	lea    rdx,[rsp+0xb0]
  215290:	00 
  215291:	e8 fa 21 00 00       	call   217490 <Allocator_alignedRealloc.76>
  215296:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21529b:	66 85 c0             	test   ax,ax
  21529e:	0f 85 94 01 00 00    	jne    215438 <getLineNumberInfo+0xcc8>
  2152a4:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  2152a9:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2152ad:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  2152b4:	00 00 
            const result = &self.items[self.len];
  2152b6:	4c 8b a4 24 b0 00 00 	mov    r12,QWORD PTR [rsp+0xb0]
  2152bd:	00 
  2152be:	49 8d 5e 01          	lea    rbx,[r14+0x1]
  2152c2:	49 c1 e6 04          	shl    r14,0x4
            self.len = new_length;
  2152c6:	48 89 9c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rbx
  2152cd:	00 
            new_item_ptr.* = item;
  2152ce:	c5 f8 28 84 24 50 01 	vmovaps xmm0,XMMWORD PTR [rsp+0x150]
  2152d5:	00 00 
  2152d7:	c4 81 78 11 04 34    	vmovups XMMWORD PTR [r12+r14*1],xmm0
  2152dd:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  2152e2:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2152e7:	48 8d 0d 72 b2 ff ff 	lea    rcx,[rip+0xffffffffffffb272]        # 210560 <FileInStream_readFn>
  2152ee:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  2152f3:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  2152fa:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2152ff:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  215304:	e8 17 f0 ff ff       	call   214320 <readStringRaw>
  215309:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21530e:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  215314:	c5 f9 7f 84 24 50 01 	vmovdqa XMMWORD PTR [rsp+0x150],xmm0
  21531b:	00 00 
  21531d:	49 89 de             	mov    r14,rbx
            const dir = try st.readString();
  215320:	66 85 c0             	test   ax,ax
  215323:	0f 84 1f ff ff ff    	je     215248 <getLineNumberInfo+0xad8>
  215329:	e9 c2 fe ff ff       	jmp    2151f0 <getLineNumberInfo+0xa80>
  21532e:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  215333:	48 8b b2 a0 00 00 00 	mov    rsi,QWORD PTR [rdx+0xa0]
            return Self{
  21533a:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21533e:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
  215344:	48 c7 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],0x0
  21534b:	00 00 00 00 00 
        var file_entries = ArrayList(FileEntry).init(st.allocator());
  215350:	48 89 b4 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rsi
  215357:	00 
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  215358:	c5 fc 28 05 60 b9 fe 	vmovaps ymm0,YMMWORD PTR [rip+0xfffffffffffeb960]        # 200cc0 <app_mask+0x88>
  21535f:	ff 
  215360:	c5 fc 11 84 24 e0 00 	vmovups YMMWORD PTR [rsp+0xe0],ymm0
  215367:	00 00 
        const default_is_stmt = (try in_stream.readByte()) != 0;
  215369:	40 84 ed             	test   bpl,bpl
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  21536c:	0f 95 84 24 00 01 00 	setne  BYTE PTR [rsp+0x100]
  215373:	00 
  215374:	66 c7 84 24 01 01 00 	mov    WORD PTR [rsp+0x101],0x0
  21537b:	00 00 00 
  21537e:	8b 84 24 d3 00 00 00 	mov    eax,DWORD PTR [rsp+0xd3]
  215385:	89 84 24 03 01 00 00 	mov    DWORD PTR [rsp+0x103],eax
            return self.items[0..self.len];
  21538c:	48 8b 84 24 b0 00 00 	mov    rax,QWORD PTR [rsp+0xb0]
  215393:	00 
  215394:	8a 8c 24 d7 00 00 00 	mov    cl,BYTE PTR [rsp+0xd7]
  21539b:	88 8c 24 07 01 00 00 	mov    BYTE PTR [rsp+0x107],cl
  2153a2:	48 8b 8c 24 a0 00 00 	mov    rcx,QWORD PTR [rsp+0xa0]
  2153a9:	00 
  2153aa:	48 89 8c 24 08 01 00 	mov    QWORD PTR [rsp+0x108],rcx
  2153b1:	00 
  2153b2:	48 89 84 24 10 01 00 	mov    QWORD PTR [rsp+0x110],rax
  2153b9:	00 
  2153ba:	4c 89 b4 24 18 01 00 	mov    QWORD PTR [rsp+0x118],r14
  2153c1:	00 
  2153c2:	48 8d 44 24 70       	lea    rax,[rsp+0x70]
  2153c7:	48 89 84 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rax
  2153ce:	00 
  2153cf:	48 c7 84 24 28 01 00 	mov    QWORD PTR [rsp+0x128],0x0
  2153d6:	00 00 00 00 00 
  2153db:	c5 fe 6f 84 24 f8 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xaf8]
  2153e2:	00 00 
  2153e4:	c5 fe 7f 84 24 30 01 	vmovdqu YMMWORD PTR [rsp+0x130],ymm0
  2153eb:	00 00 
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  2153ed:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  2153f2:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2153f7:	48 8d 05 62 b1 ff ff 	lea    rax,[rip+0xffffffffffffb162]        # 210560 <FileInStream_readFn>
  2153fe:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  215403:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  215408:	c5 f8 77             	vzeroupper 
  21540b:	e8 10 ef ff ff       	call   214320 <readStringRaw>
  215410:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const file_name = try st.readString();
  215415:	66 85 c0             	test   ax,ax
  215418:	74 3c                	je     215456 <getLineNumberInfo+0xce6>
  21541a:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  21541e:	66 89 01             	mov    WORD PTR [rcx],ax
  215421:	c5 fe 6f 84 24 8e 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x78e]
  215428:	00 00 
  21542a:	c5 fc 10 8c 24 9c 07 	vmovups ymm1,YMMWORD PTR [rsp+0x79c]
  215431:	00 00 
  215433:	e9 5d f7 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  215438:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            try include_directories.append(dir);
  21543c:	66 89 01             	mov    WORD PTR [rcx],ax
  21543f:	c5 fc 10 84 24 bc 07 	vmovups ymm0,YMMWORD PTR [rsp+0x7bc]
  215446:	00 00 
  215448:	c5 fc 10 8c 24 ca 07 	vmovups ymm1,YMMWORD PTR [rsp+0x7ca]
  21544f:	00 00 
  215451:	e9 3f f7 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  215456:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  21545c:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  215463:	00 00 
            if (file_name.len == 0) break;
  215465:	c5 f9 6f 84 24 a0 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0xa0]
  21546c:	00 00 
  21546e:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  215474:	48 85 c0             	test   rax,rax
  215477:	0f 84 44 03 00 00    	je     2157c1 <getLineNumberInfo+0x1051>
            try self.readNoEof(result[0..]);
  21547d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215482:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215487:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21548e:	00 00 
            return self.readFn(self, buffer);
  215490:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  215495:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21549a:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  21549f:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2154a3:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2154a8:	66 85 c0             	test   ax,ax
  2154ab:	0f 85 ca 02 00 00    	jne    21577b <getLineNumberInfo+0x100b>
  2154b1:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2154b6:	45 31 e4             	xor    r12d,r12d
  2154b9:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  2154bb:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  2154c0:	0f 82 ab 02 00 00    	jb     215771 <getLineNumberInfo+0x1001>
            return result[0];
  2154c6:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2154cb:	89 c2                	mov    edx,eax
  2154cd:	83 e2 7f             	and    edx,0x7f
  2154d0:	89 ee                	mov    esi,ebp
  2154d2:	83 e6 3f             	and    esi,0x3f
  2154d5:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2154da:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2154df:	48 39 d6             	cmp    rsi,rdx
  2154e2:	0f 85 8f 02 00 00    	jne    215777 <getLineNumberInfo+0x1007>
        result |= operand;
  2154e8:	49 09 cc             	or     r12,rcx
        if ((byte & 0b10000000) == 0) return result;
  2154eb:	84 c0                	test   al,al
  2154ed:	79 3e                	jns    21552d <getLineNumberInfo+0xdbd>
        shift += 7;
  2154ef:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2154f3:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2154f8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2154fd:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215504:	00 00 
            return self.readFn(self, buffer);
  215506:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21550b:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215510:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  215515:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215519:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21551e:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215523:	66 85 c0             	test   ax,ax
  215526:	74 93                	je     2154bb <getLineNumberInfo+0xd4b>
  215528:	e9 4e 02 00 00       	jmp    21577b <getLineNumberInfo+0x100b>
            try self.readNoEof(result[0..]);
  21552d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215532:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215537:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21553e:	00 00 
            return self.readFn(self, buffer);
  215540:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  215545:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21554a:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  21554f:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215553:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215558:	66 85 c0             	test   ax,ax
  21555b:	0f 85 42 02 00 00    	jne    2157a3 <getLineNumberInfo+0x1033>
  215561:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215566:	45 31 f6             	xor    r14d,r14d
  215569:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  21556b:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  215570:	0f 82 23 02 00 00    	jb     215799 <getLineNumberInfo+0x1029>
            return result[0];
  215576:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21557b:	89 c2                	mov    edx,eax
  21557d:	83 e2 7f             	and    edx,0x7f
  215580:	89 ee                	mov    esi,ebp
  215582:	83 e6 3f             	and    esi,0x3f
  215585:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21558a:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21558f:	48 39 d6             	cmp    rsi,rdx
  215592:	0f 85 07 02 00 00    	jne    21579f <getLineNumberInfo+0x102f>
        result |= operand;
  215598:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  21559b:	84 c0                	test   al,al
  21559d:	79 3e                	jns    2155dd <getLineNumberInfo+0xe6d>
        shift += 7;
  21559f:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2155a3:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2155a8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2155ad:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2155b4:	00 00 
            return self.readFn(self, buffer);
  2155b6:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2155bb:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2155c0:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2155c5:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2155c9:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2155ce:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2155d3:	66 85 c0             	test   ax,ax
  2155d6:	74 93                	je     21556b <getLineNumberInfo+0xdfb>
  2155d8:	e9 c6 01 00 00       	jmp    2157a3 <getLineNumberInfo+0x1033>
            try self.readNoEof(result[0..]);
  2155dd:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2155e2:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2155e7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2155ee:	00 00 
            return self.readFn(self, buffer);
  2155f0:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2155f5:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2155fa:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2155ff:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215603:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215608:	66 85 c0             	test   ax,ax
  21560b:	0f 85 05 02 00 00    	jne    215816 <getLineNumberInfo+0x10a6>
  215611:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215616:	31 db                	xor    ebx,ebx
  215618:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  21561a:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21561f:	0f 82 e7 01 00 00    	jb     21580c <getLineNumberInfo+0x109c>
            return result[0];
  215625:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21562a:	89 c2                	mov    edx,eax
  21562c:	83 e2 7f             	and    edx,0x7f
  21562f:	89 ee                	mov    esi,ebp
  215631:	83 e6 3f             	and    esi,0x3f
  215634:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  215639:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21563e:	48 39 d6             	cmp    rsi,rdx
  215641:	0f 85 cb 01 00 00    	jne    215812 <getLineNumberInfo+0x10a2>
        result |= operand;
  215647:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  21564a:	84 c0                	test   al,al
  21564c:	79 3e                	jns    21568c <getLineNumberInfo+0xf1c>
        shift += 7;
  21564e:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  215652:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215657:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21565c:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215663:	00 00 
            return self.readFn(self, buffer);
  215665:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21566a:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21566f:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  215674:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215678:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21567d:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215682:	66 85 c0             	test   ax,ax
  215685:	74 93                	je     21561a <getLineNumberInfo+0xeaa>
  215687:	e9 8a 01 00 00       	jmp    215816 <getLineNumberInfo+0x10a6>
            const new_length = self.len + 1;
  21568c:	48 8b ac 24 80 00 00 	mov    rbp,QWORD PTR [rsp+0x80]
  215693:	00 
            var better_capacity = self.items.len;
  215694:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
            if (better_capacity >= new_capacity) return;
  215699:	48 39 e9             	cmp    rcx,rbp
  21569c:	76 05                	jbe    2156a3 <getLineNumberInfo+0xf33>
            const result = &self.items[self.len];
  21569e:	48 89 e8             	mov    rax,rbp
  2156a1:	eb 4e                	jmp    2156f1 <getLineNumberInfo+0xf81>
                better_capacity += better_capacity / 2 + 8;
  2156a3:	48 89 c8             	mov    rax,rcx
  2156a6:	48 d1 e8             	shr    rax,1
  2156a9:	48 01 c1             	add    rcx,rax
  2156ac:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2156b0:	48 39 e9             	cmp    rcx,rbp
  2156b3:	76 ee                	jbe    2156a3 <getLineNumberInfo+0xf33>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2156b5:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  2156bc:	00 
  2156bd:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2156c2:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  2156c7:	e8 24 20 00 00       	call   2176f0 <Allocator_alignedRealloc.79>
  2156cc:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2156d1:	66 85 c0             	test   ax,ax
  2156d4:	0f 85 bc 0c 00 00    	jne    216396 <getLineNumberInfo+0x1c26>
  2156da:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  2156df:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2156e3:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
            const result = &self.items[self.len];
  2156e9:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2156f0:	00 
  2156f1:	48 83 c5 01          	add    rbp,0x1
  2156f5:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  2156fa:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  2156fe:	48 89 ac 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rbp
  215705:	00 
            new_item_ptr.* = item;
  215706:	c5 f8 28 84 24 a0 00 	vmovaps xmm0,XMMWORD PTR [rsp+0xa0]
  21570d:	00 00 
  21570f:	c5 f8 11 04 c1       	vmovups XMMWORD PTR [rcx+rax*8],xmm0
  215714:	4c 89 64 c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],r12
  215719:	4c 89 74 c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],r14
  21571e:	48 89 5c c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rbx
  215723:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  215728:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21572d:	48 8d 0d 2c ae ff ff 	lea    rcx,[rip+0xffffffffffffae2c]        # 210560 <FileInStream_readFn>
  215734:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  215739:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  215740:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  215745:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  21574a:	e8 d1 eb ff ff       	call   214320 <readStringRaw>
  21574f:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215754:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
            const file_name = try st.readString();
  21575a:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  215761:	00 00 
  215763:	66 85 c0             	test   ax,ax
  215766:	0f 84 f9 fc ff ff    	je     215465 <getLineNumberInfo+0xcf5>
  21576c:	e9 a9 fc ff ff       	jmp    21541a <getLineNumberInfo+0xcaa>
  215771:	66 b8 20 00          	mov    ax,0x20
  215775:	eb 04                	jmp    21577b <getLineNumberInfo+0x100b>
  215777:	66 b8 25 00          	mov    ax,0x25
  21577b:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const dir_index = try readULeb128(in_stream);
  21577f:	66 89 01             	mov    WORD PTR [rcx],ax
  215782:	c5 fe 6f 84 24 60 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x760]
  215789:	00 00 
  21578b:	c5 fc 10 8c 24 6e 07 	vmovups ymm1,YMMWORD PTR [rsp+0x76e]
  215792:	00 00 
  215794:	e9 fc f3 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  215799:	66 b8 20 00          	mov    ax,0x20
  21579d:	eb 04                	jmp    2157a3 <getLineNumberInfo+0x1033>
  21579f:	66 b8 25 00          	mov    ax,0x25
  2157a3:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const mtime = try readULeb128(in_stream);
  2157a7:	66 89 01             	mov    WORD PTR [rcx],ax
  2157aa:	c5 fe 6f 84 24 32 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x732]
  2157b1:	00 00 
  2157b3:	c5 fc 10 8c 24 40 07 	vmovups ymm1,YMMWORD PTR [rsp+0x740]
  2157ba:	00 00 
  2157bc:	e9 d4 f3 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  2157c1:	4d 85 ed             	test   r13,r13
  2157c4:	78 6e                	js     215834 <getLineNumberInfo+0x10c4>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2157c6:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  2157cb:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  2157ce:	31 ed                	xor    ebp,ebp
  2157d0:	b8 08 00 00 00       	mov    eax,0x8
  2157d5:	31 d2                	xor    edx,edx
  2157d7:	4c 89 ee             	mov    rsi,r13
  2157da:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2157dc:	48 89 c1             	mov    rcx,rax
  2157df:	48 f7 d9             	neg    rcx
  2157e2:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2157e8:	48 0f 46 cd          	cmovbe rcx,rbp
  2157ec:	66 b8 02 00          	mov    ax,0x2
                if (err > 0) {
  2157f0:	48 83 f9 1d          	cmp    rcx,0x1d
  2157f4:	77 60                	ja     215856 <getLineNumberInfo+0x10e6>
  2157f6:	48 8d 15 77 be fe ff 	lea    rdx,[rip+0xfffffffffffebe77]        # 201674 <__unnamed_9+0x994>
  2157fd:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  215801:	48 01 d1             	add    rcx,rdx
  215804:	ff e1                	jmp    rcx
  215806:	66 b8 22 00          	mov    ax,0x22
  21580a:	eb 2c                	jmp    215838 <getLineNumberInfo+0x10c8>
  21580c:	66 b8 20 00          	mov    ax,0x20
  215810:	eb 04                	jmp    215816 <getLineNumberInfo+0x10a6>
  215812:	66 b8 25 00          	mov    ax,0x25
  215816:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const len_bytes = try readULeb128(in_stream);
  21581a:	66 89 01             	mov    WORD PTR [rcx],ax
  21581d:	c5 fe 6f 84 24 04 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x704]
  215824:	00 00 
  215826:	c5 fc 10 8c 24 12 07 	vmovups ymm1,YMMWORD PTR [rsp+0x712]
  21582d:	00 00 
  21582f:	e9 61 f3 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  215834:	66 b8 23 00          	mov    ax,0x23
  215838:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try in_file.seekTo(prog_start_offset);
  21583c:	66 89 01             	mov    WORD PTR [rcx],ax
  21583f:	c5 fe 6f 84 24 a8 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x6a8]
  215846:	00 00 
  215848:	c5 fc 10 8c 24 b6 06 	vmovups ymm1,YMMWORD PTR [rsp+0x6b6]
  21584f:	00 00 
  215851:	e9 3f f3 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  215856:	48 83 f9 4b          	cmp    rcx,0x4b
  21585a:	75 dc                	jne    215838 <getLineNumberInfo+0x10c8>
  21585c:	eb a8                	jmp    215806 <getLineNumberInfo+0x1096>
            try self.readNoEof(result[0..]);
  21585e:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215863:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215868:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21586f:	00 00 
  215871:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  215876:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  21587b:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215880:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215884:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215889:	66 85 c9             	test   cx,cx
  21588c:	74 31                	je     2158bf <getLineNumberInfo+0x114f>
  21588e:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
            const opcode = try in_stream.readByte();
  215892:	66 89 08             	mov    WORD PTR [rax],cx
  215895:	c5 fe 6f 84 24 7a 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x67a]
  21589c:	00 00 
  21589e:	c5 fc 10 8c 24 88 06 	vmovups ymm1,YMMWORD PTR [rsp+0x688]
  2158a5:	00 00 
  2158a7:	c5 fc 11 48 10       	vmovups YMMWORD PTR [rax+0x10],ymm1
  2158ac:	c5 fe 7f 40 02       	vmovdqu YMMWORD PTR [rax+0x2],ymm0
  2158b1:	e9 0b f0 ff ff       	jmp    2148c1 <getLineNumberInfo+0x151>
  2158b6:	66 b8 1e 00          	mov    ax,0x1e
  2158ba:	e9 79 ff ff ff       	jmp    215838 <getLineNumberInfo+0x10c8>
  2158bf:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  2158c4:	8a 4c 24 5e          	mov    cl,BYTE PTR [rsp+0x5e]
  2158c8:	f6 d1                	not    cl
  2158ca:	88 8c 24 a0 00 00 00 	mov    BYTE PTR [rsp+0xa0],cl
  2158d1:	4c 8d 64 24 20       	lea    r12,[rsp+0x20]
  2158d6:	4c 8d 6c 24 08       	lea    r13,[rsp+0x8]
            if (amt_read < buf.len) return error.EndOfStream;
  2158db:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  2158e0:	0f 82 f0 0a 00 00    	jb     2163d6 <getLineNumberInfo+0x1c66>
            return result[0];
  2158e6:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
            if (opcode == DW.LNS_extended_op) {
  2158ea:	84 c0                	test   al,al
  2158ec:	74 62                	je     215950 <getLineNumberInfo+0x11e0>
            } else if (opcode >= opcode_base) {
  2158ee:	89 c1                	mov    ecx,eax
  2158f0:	2a 4c 24 5e          	sub    cl,BYTE PTR [rsp+0x5e]
  2158f4:	0f 83 01 01 00 00    	jae    2159fb <getLineNumberInfo+0x128b>
                switch (opcode) {
  2158fa:	04 ff                	add    al,0xff
  2158fc:	0f b6 c0             	movzx  eax,al
  2158ff:	3c 09                	cmp    al,0x9
  215901:	0f 87 3b 02 00 00    	ja     215b42 <getLineNumberInfo+0x13d2>
  215907:	48 8d 0d de bd fe ff 	lea    rcx,[rip+0xfffffffffffebdde]        # 2016ec <__unnamed_9+0xa0c>
  21590e:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  215912:	48 01 c8             	add    rax,rcx
  215915:	ff e0                	jmp    rax
                        if (try prog.checkLineMatch()) |info| return info;
  215917:	48 8d bc 24 08 02 00 	lea    rdi,[rsp+0x208]
  21591e:	00 
  21591f:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  215926:	00 
  215927:	e8 34 14 00 00       	call   216d60 <LineNumberProgram_checkLineMatch>
  21592c:	0f b7 84 24 08 02 00 	movzx  eax,WORD PTR [rsp+0x208]
  215933:	00 
  215934:	66 85 c0             	test   ax,ax
  215937:	0f 85 ac 0c 00 00    	jne    2165e9 <getLineNumberInfo+0x1e79>
  21593d:	80 bc 24 38 02 00 00 	cmp    BYTE PTR [rsp+0x238],0x1
  215944:	01 
  215945:	0f 85 0c 01 00 00    	jne    215a57 <getLineNumberInfo+0x12e7>
  21594b:	e9 b7 0c 00 00       	jmp    216607 <getLineNumberInfo+0x1e97>
            try self.readNoEof(result[0..]);
  215950:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215955:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21595a:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215961:	00 00 
            return self.readFn(self, buffer);
  215963:	4c 89 e7             	mov    rdi,r12
  215966:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21596b:	4c 89 ea             	mov    rdx,r13
  21596e:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215972:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215977:	66 85 c0             	test   ax,ax
  21597a:	0f 85 38 0a 00 00    	jne    2163b8 <getLineNumberInfo+0x1c48>
  215980:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215985:	31 ed                	xor    ebp,ebp
  215987:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  215989:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21598e:	0f 82 fc 09 00 00    	jb     216390 <getLineNumberInfo+0x1c20>
            return result[0];
  215994:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  215999:	89 c2                	mov    edx,eax
  21599b:	83 e2 7f             	and    edx,0x7f
  21599e:	89 de                	mov    esi,ebx
  2159a0:	83 e6 3f             	and    esi,0x3f
  2159a3:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2159a8:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2159ad:	48 39 d6             	cmp    rsi,rdx
  2159b0:	0f 85 fe 09 00 00    	jne    2163b4 <getLineNumberInfo+0x1c44>
        result |= operand;
  2159b6:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  2159b9:	84 c0                	test   al,al
  2159bb:	0f 89 d8 00 00 00    	jns    215a99 <getLineNumberInfo+0x1329>
        shift += 7;
  2159c1:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  2159c5:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2159ca:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2159cf:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2159d6:	00 00 
            return self.readFn(self, buffer);
  2159d8:	4c 89 e7             	mov    rdi,r12
  2159db:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2159e0:	4c 89 ea             	mov    rdx,r13
  2159e3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2159e7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2159ec:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2159f1:	66 85 c0             	test   ax,ax
  2159f4:	74 93                	je     215989 <getLineNumberInfo+0x1219>
  2159f6:	e9 bd 09 00 00       	jmp    2163b8 <getLineNumberInfo+0x1c48>
                const inc_line = i32(line_base) + i32(adjusted_opcode % line_range);
  2159fb:	0f b6 c1             	movzx  eax,cl
  2159fe:	f6 74 24 5f          	div    BYTE PTR [rsp+0x5f]
  215a02:	0f b6 cc             	movzx  ecx,ah
  215a05:	48 03 8c 24 68 01 00 	add    rcx,QWORD PTR [rsp+0x168]
  215a0c:	00 
                prog.line += inc_line;
  215a0d:	48 01 8c 24 f0 00 00 	add    QWORD PTR [rsp+0xf0],rcx
  215a14:	00 
                const inc_addr = minimum_instruction_length * (adjusted_opcode / line_range);
  215a15:	41 f6 e7             	mul    r15b
                prog.address += inc_addr;
  215a18:	0f b6 c0             	movzx  eax,al
  215a1b:	48 01 84 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rax
  215a22:	00 
                if (try prog.checkLineMatch()) |info| return info;
  215a23:	48 8d bc 24 40 02 00 	lea    rdi,[rsp+0x240]
  215a2a:	00 
  215a2b:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  215a32:	00 
  215a33:	e8 28 13 00 00       	call   216d60 <LineNumberProgram_checkLineMatch>
  215a38:	0f b7 84 24 40 02 00 	movzx  eax,WORD PTR [rsp+0x240]
  215a3f:	00 
  215a40:	66 85 c0             	test   ax,ax
  215a43:	0f 85 96 09 00 00    	jne    2163df <getLineNumberInfo+0x1c6f>
  215a49:	80 bc 24 70 02 00 00 	cmp    BYTE PTR [rsp+0x270],0x1
  215a50:	01 
  215a51:	0f 84 a6 09 00 00    	je     2163fd <getLineNumberInfo+0x1c8d>
  215a57:	c6 84 24 01 01 00 00 	mov    BYTE PTR [rsp+0x101],0x0
  215a5e:	00 
            try self.readNoEof(result[0..]);
  215a5f:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215a64:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215a69:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215a70:	00 00 
            return self.readFn(self, buffer);
  215a72:	4c 89 e7             	mov    rdi,r12
  215a75:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215a7a:	4c 89 ea             	mov    rdx,r13
  215a7d:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215a81:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  215a86:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215a8b:	66 85 c9             	test   cx,cx
  215a8e:	0f 84 47 fe ff ff    	je     2158db <getLineNumberInfo+0x116b>
  215a94:	e9 f5 fd ff ff       	jmp    21588e <getLineNumberInfo+0x111e>
                if (op_size < 1) return error.InvalidDebugInfo;
  215a99:	48 85 ed             	test   rbp,rbp
  215a9c:	0f 84 d0 08 00 00    	je     216372 <getLineNumberInfo+0x1c02>
            try self.readNoEof(result[0..]);
  215aa2:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215aa7:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215aac:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215ab3:	00 00 
            return self.readFn(self, buffer);
  215ab5:	4c 89 e7             	mov    rdi,r12
  215ab8:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215abd:	4c 89 ea             	mov    rdx,r13
  215ac0:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215ac4:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215ac9:	66 85 c0             	test   ax,ax
  215acc:	0f 85 39 0a 00 00    	jne    21650b <getLineNumberInfo+0x1d9b>
  215ad2:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  215ad7:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  215adc:	0f 82 25 0a 00 00    	jb     216507 <getLineNumberInfo+0x1d97>
            return result[0];
  215ae2:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
                switch (sub_op) {
  215ae6:	3c 02                	cmp    al,0x2
  215ae8:	0f 84 03 04 00 00    	je     215ef1 <getLineNumberInfo+0x1781>
  215aee:	3c 03                	cmp    al,0x3
  215af0:	0f 84 b2 04 00 00    	je     215fa8 <getLineNumberInfo+0x1838>
  215af6:	3c 01                	cmp    al,0x1
  215af8:	0f 84 2b 0a 00 00    	je     216529 <getLineNumberInfo+0x1db9>
  215afe:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
  215b02:	0f 88 6a 08 00 00    	js     216372 <getLineNumberInfo+0x1c02>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  215b08:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  215b0d:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  215b10:	b8 08 00 00 00       	mov    eax,0x8
  215b15:	ba 01 00 00 00       	mov    edx,0x1
  215b1a:	48 89 ee             	mov    rsi,rbp
  215b1d:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  215b1f:	48 89 c1             	mov    rcx,rax
  215b22:	48 f7 d9             	neg    rcx
  215b25:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  215b2b:	b8 00 00 00 00       	mov    eax,0x0
  215b30:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  215b34:	48 85 c9             	test   rcx,rcx
  215b37:	0f 84 22 ff ff ff    	je     215a5f <getLineNumberInfo+0x12ef>
  215b3d:	e9 6e 0b 00 00       	jmp    2166b0 <getLineNumberInfo+0x1f40>
                        if (opcode - 1 >= standard_opcode_lengths.len) return error.InvalidDebugInfo;
  215b42:	48 39 84 24 98 00 00 	cmp    QWORD PTR [rsp+0x98],rax
  215b49:	00 
  215b4a:	0f 86 22 08 00 00    	jbe    216372 <getLineNumberInfo+0x1c02>
                        try in_file.seekForward(len_bytes);
  215b50:	48 8b 8c 24 d8 00 00 	mov    rcx,QWORD PTR [rsp+0xd8]
  215b57:	00 
  215b58:	0f b6 34 01          	movzx  esi,BYTE PTR [rcx+rax*1]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  215b5c:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  215b61:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  215b64:	b8 08 00 00 00       	mov    eax,0x8
  215b69:	ba 01 00 00 00       	mov    edx,0x1
  215b6e:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  215b70:	48 89 c1             	mov    rcx,rax
  215b73:	48 f7 d9             	neg    rcx
  215b76:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  215b7c:	b8 00 00 00 00       	mov    eax,0x0
  215b81:	48 0f 46 c8          	cmovbe rcx,rax
  215b85:	48 85 c9             	test   rcx,rcx
  215b88:	0f 84 d1 fe ff ff    	je     215a5f <getLineNumberInfo+0x12ef>
  215b8e:	e9 b6 0a 00 00       	jmp    216649 <getLineNumberInfo+0x1ed9>
            try self.readNoEof(result[0..]);
  215b93:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215b98:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215b9d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215ba4:	00 00 
            return self.readFn(self, buffer);
  215ba6:	4c 89 e7             	mov    rdi,r12
  215ba9:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215bae:	4c 89 ea             	mov    rdx,r13
  215bb1:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215bb5:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215bba:	66 85 c0             	test   ax,ax
  215bbd:	0f 85 98 08 00 00    	jne    21645b <getLineNumberInfo+0x1ceb>
  215bc3:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215bc8:	31 db                	xor    ebx,ebx
  215bca:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  215bcc:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  215bd1:	0f 82 68 08 00 00    	jb     21643f <getLineNumberInfo+0x1ccf>
            return result[0];
  215bd7:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  215bdc:	89 c2                	mov    edx,eax
  215bde:	83 e2 7f             	and    edx,0x7f
  215be1:	89 ee                	mov    esi,ebp
  215be3:	83 e6 3f             	and    esi,0x3f
  215be6:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  215beb:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  215bf0:	48 39 d6             	cmp    rsi,rdx
  215bf3:	0f 85 5e 08 00 00    	jne    216457 <getLineNumberInfo+0x1ce7>
        result |= operand;
  215bf9:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  215bfc:	84 c0                	test   al,al
  215bfe:	0f 89 16 05 00 00    	jns    21611a <getLineNumberInfo+0x19aa>
        shift += 7;
  215c04:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  215c08:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215c0d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215c12:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215c19:	00 00 
            return self.readFn(self, buffer);
  215c1b:	4c 89 e7             	mov    rdi,r12
  215c1e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215c23:	4c 89 ea             	mov    rdx,r13
  215c26:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215c2a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215c2f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215c34:	66 85 c0             	test   ax,ax
  215c37:	74 93                	je     215bcc <getLineNumberInfo+0x145c>
  215c39:	e9 1d 08 00 00       	jmp    21645b <getLineNumberInfo+0x1ceb>
            try self.readNoEof(result[0..]);
  215c3e:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215c43:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215c48:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215c4f:	00 00 
            return self.readFn(self, buffer);
  215c51:	4c 89 e7             	mov    rdi,r12
  215c54:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215c59:	4c 89 ea             	mov    rdx,r13
  215c5c:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215c60:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215c65:	66 85 c0             	test   ax,ax
  215c68:	0f 85 0f 08 00 00    	jne    21647d <getLineNumberInfo+0x1d0d>
  215c6e:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215c73:	bb 07 00 00 00       	mov    ebx,0x7
  215c78:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  215c7a:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  215c7f:	0f 82 c0 07 00 00    	jb     216445 <getLineNumberInfo+0x1cd5>
  215c85:	48 8d 53 f9          	lea    rdx,[rbx-0x7]
            return result[0];
  215c89:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(i64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  215c8e:	89 c6                	mov    esi,eax
  215c90:	83 e6 7f             	and    esi,0x7f
  215c93:	83 e2 3f             	and    edx,0x3f
  215c96:	c4 e2 e9 f7 ce       	shlx   rcx,rsi,rdx
  215c9b:	c4 e2 ea f7 d1       	sarx   rdx,rcx,rdx
  215ca0:	48 39 f2             	cmp    rdx,rsi
  215ca3:	0f 85 d0 07 00 00    	jne    216479 <getLineNumberInfo+0x1d09>
        result |= operand;
  215ca9:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) {
  215cac:	84 c0                	test   al,al
  215cae:	0f 89 77 04 00 00    	jns    21612b <getLineNumberInfo+0x19bb>
            try self.readNoEof(result[0..]);
  215cb4:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215cb9:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215cbe:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215cc5:	00 00 
            return self.readFn(self, buffer);
  215cc7:	4c 89 e7             	mov    rdi,r12
  215cca:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215ccf:	4c 89 ea             	mov    rdx,r13
  215cd2:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215cd6:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215cdb:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215ce0:	48 83 c3 07          	add    rbx,0x7
  215ce4:	66 85 c0             	test   ax,ax
  215ce7:	74 91                	je     215c7a <getLineNumberInfo+0x150a>
  215ce9:	e9 8f 07 00 00       	jmp    21647d <getLineNumberInfo+0x1d0d>
            try self.readNoEof(result[0..]);
  215cee:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215cf3:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215cf8:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215cff:	00 00 
            return self.readFn(self, buffer);
  215d01:	4c 89 e7             	mov    rdi,r12
  215d04:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215d09:	4c 89 ea             	mov    rdx,r13
  215d0c:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215d10:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215d15:	66 85 c0             	test   ax,ax
  215d18:	0f 85 81 07 00 00    	jne    21649f <getLineNumberInfo+0x1d2f>
  215d1e:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215d23:	31 db                	xor    ebx,ebx
  215d25:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  215d27:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  215d2c:	0f 82 19 07 00 00    	jb     21644b <getLineNumberInfo+0x1cdb>
            return result[0];
  215d32:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  215d37:	89 c2                	mov    edx,eax
  215d39:	83 e2 7f             	and    edx,0x7f
  215d3c:	89 ee                	mov    esi,ebp
  215d3e:	83 e6 3f             	and    esi,0x3f
  215d41:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  215d46:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  215d4b:	48 39 d6             	cmp    rsi,rdx
  215d4e:	0f 85 47 07 00 00    	jne    21649b <getLineNumberInfo+0x1d2b>
        result |= operand;
  215d54:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  215d57:	84 c0                	test   al,al
  215d59:	0f 89 f2 03 00 00    	jns    216151 <getLineNumberInfo+0x19e1>
        shift += 7;
  215d5f:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  215d63:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215d68:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215d6d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215d74:	00 00 
            return self.readFn(self, buffer);
  215d76:	4c 89 e7             	mov    rdi,r12
  215d79:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215d7e:	4c 89 ea             	mov    rdx,r13
  215d81:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215d85:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215d8a:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215d8f:	66 85 c0             	test   ax,ax
  215d92:	74 93                	je     215d27 <getLineNumberInfo+0x15b7>
  215d94:	e9 06 07 00 00       	jmp    21649f <getLineNumberInfo+0x1d2f>
            try self.readNoEof(result[0..]);
  215d99:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215d9e:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215da3:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215daa:	00 00 
            return self.readFn(self, buffer);
  215dac:	4c 89 e7             	mov    rdi,r12
  215daf:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215db4:	4c 89 ea             	mov    rdx,r13
  215db7:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215dbb:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215dc0:	66 85 c0             	test   ax,ax
  215dc3:	0f 85 f8 06 00 00    	jne    2164c1 <getLineNumberInfo+0x1d51>
  215dc9:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215dce:	31 db                	xor    ebx,ebx
  215dd0:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  215dd2:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  215dd7:	0f 82 74 06 00 00    	jb     216451 <getLineNumberInfo+0x1ce1>
            return result[0];
  215ddd:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  215de2:	89 c2                	mov    edx,eax
  215de4:	83 e2 7f             	and    edx,0x7f
  215de7:	89 ee                	mov    esi,ebp
  215de9:	83 e6 3f             	and    esi,0x3f
  215dec:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  215df1:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  215df6:	48 39 d6             	cmp    rsi,rdx
  215df9:	0f 85 be 06 00 00    	jne    2164bd <getLineNumberInfo+0x1d4d>
        result |= operand;
  215dff:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  215e02:	84 c0                	test   al,al
  215e04:	0f 89 54 03 00 00    	jns    21615e <getLineNumberInfo+0x19ee>
        shift += 7;
  215e0a:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  215e0e:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215e13:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215e18:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215e1f:	00 00 
            return self.readFn(self, buffer);
  215e21:	4c 89 e7             	mov    rdi,r12
  215e24:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215e29:	4c 89 ea             	mov    rdx,r13
  215e2c:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215e30:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215e35:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215e3a:	66 85 c0             	test   ax,ax
  215e3d:	74 93                	je     215dd2 <getLineNumberInfo+0x1662>
  215e3f:	e9 7d 06 00 00       	jmp    2164c1 <getLineNumberInfo+0x1d51>
                        prog.is_stmt = !prog.is_stmt;
  215e44:	8a 84 24 00 01 00 00 	mov    al,BYTE PTR [rsp+0x100]
  215e4b:	f6 d0                	not    al
  215e4d:	24 01                	and    al,0x1
  215e4f:	88 84 24 00 01 00 00 	mov    BYTE PTR [rsp+0x100],al
  215e56:	e9 04 fc ff ff       	jmp    215a5f <getLineNumberInfo+0x12ef>
                        prog.basic_block = true;
  215e5b:	c6 84 24 01 01 00 00 	mov    BYTE PTR [rsp+0x101],0x1
  215e62:	01 
  215e63:	e9 f7 fb ff ff       	jmp    215a5f <getLineNumberInfo+0x12ef>
                        const inc_addr = minimum_instruction_length * ((255 - opcode_base) / line_range);
  215e68:	0f b6 84 24 a0 00 00 	movzx  eax,BYTE PTR [rsp+0xa0]
  215e6f:	00 
  215e70:	f6 74 24 5f          	div    BYTE PTR [rsp+0x5f]
  215e74:	41 f6 e7             	mul    r15b
                        prog.address += inc_addr;
  215e77:	0f b6 c0             	movzx  eax,al
  215e7a:	eb 68                	jmp    215ee4 <getLineNumberInfo+0x1774>
                        const arg = try in_stream.readInt(st.elf.endian, u16);
  215e7c:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  215e81:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  215e84:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215e89:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215e8e:	48 c7 44 24 10 02 00 	mov    QWORD PTR [rsp+0x10],0x2
  215e95:	00 00 
            return self.readFn(self, buffer);
  215e97:	4c 89 e7             	mov    rdi,r12
  215e9a:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215e9f:	4c 89 ea             	mov    rdx,r13
  215ea2:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215ea6:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215eab:	66 85 c0             	test   ax,ax
  215eae:	0f 85 c0 07 00 00    	jne    216674 <getLineNumberInfo+0x1f04>
  215eb4:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  215eb9:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  215ebe:	0f 82 ac 07 00 00    	jb     216670 <getLineNumberInfo+0x1f00>
  215ec4:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  215ec9:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  215ece:	89 ca                	mov    edx,ecx
  215ed0:	c1 e2 08             	shl    edx,0x8
  215ed3:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  215ed5:	c1 e0 08             	shl    eax,0x8
  215ed8:	09 c8                	or     eax,ecx
    switch (endian) {
  215eda:	f6 c3 01             	test   bl,0x1
  215edd:	66 0f 45 c2          	cmovne ax,dx
                        prog.address += arg;
  215ee1:	0f b7 c0             	movzx  eax,ax
  215ee4:	48 01 84 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rax
  215eeb:	00 
  215eec:	e9 6e fb ff ff       	jmp    215a5f <getLineNumberInfo+0x12ef>
                        const addr = try in_stream.readInt(st.elf.endian, usize);
  215ef1:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  215ef6:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  215ef9:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215efe:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215f03:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  215f0a:	00 00 
            return self.readFn(self, buffer);
  215f0c:	4c 89 e7             	mov    rdi,r12
  215f0f:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215f14:	4c 89 ea             	mov    rdx,r13
  215f17:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215f1b:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215f20:	66 85 c0             	test   ax,ax
  215f23:	0f 85 ae 07 00 00    	jne    2166d7 <getLineNumberInfo+0x1f67>
  215f29:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  215f2e:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  215f33:	0f 82 9a 07 00 00    	jb     2166d3 <getLineNumberInfo+0x1f63>
  215f39:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  215f3e:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  215f43:	f6 c3 01             	test   bl,0x1
  215f46:	0f 84 72 01 00 00    	je     2160be <getLineNumberInfo+0x194e>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  215f4c:	48 c1 e1 08          	shl    rcx,0x8
  215f50:	48 09 c1             	or     rcx,rax
  215f53:	0f b6 44 24 4a       	movzx  eax,BYTE PTR [rsp+0x4a]
  215f58:	48 c1 e0 10          	shl    rax,0x10
  215f5c:	48 09 c8             	or     rax,rcx
  215f5f:	0f b6 4c 24 4b       	movzx  ecx,BYTE PTR [rsp+0x4b]
  215f64:	48 c1 e1 18          	shl    rcx,0x18
  215f68:	48 09 c1             	or     rcx,rax
  215f6b:	0f b6 44 24 4c       	movzx  eax,BYTE PTR [rsp+0x4c]
  215f70:	48 c1 e0 20          	shl    rax,0x20
  215f74:	48 09 c8             	or     rax,rcx
  215f77:	0f b6 4c 24 4d       	movzx  ecx,BYTE PTR [rsp+0x4d]
  215f7c:	48 c1 e1 28          	shl    rcx,0x28
  215f80:	48 09 c1             	or     rcx,rax
  215f83:	0f b6 54 24 4e       	movzx  edx,BYTE PTR [rsp+0x4e]
  215f88:	48 c1 e2 30          	shl    rdx,0x30
  215f8c:	0f b6 44 24 4f       	movzx  eax,BYTE PTR [rsp+0x4f]
  215f91:	48 c1 e0 38          	shl    rax,0x38
  215f95:	48 09 d0             	or     rax,rdx
  215f98:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  215f9b:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  215fa2:	00 
  215fa3:	e9 b7 fa ff ff       	jmp    215a5f <getLineNumberInfo+0x12ef>
  215fa8:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  215fad:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215fb2:	48 8d 0d a7 a5 ff ff 	lea    rcx,[rip+0xffffffffffffa5a7]        # 210560 <FileInStream_readFn>
  215fb9:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  215fbe:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  215fc5:	4c 89 e7             	mov    rdi,r12
  215fc8:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  215fcd:	e8 4e e3 ff ff       	call   214320 <readStringRaw>
  215fd2:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215fd7:	48 8d 4c 24 22       	lea    rcx,[rsp+0x22]
  215fdc:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  215fe0:	c5 f8 29 84 24 b0 01 	vmovaps XMMWORD PTR [rsp+0x1b0],xmm0
  215fe7:	00 00 
  215fe9:	48 8b 49 0e          	mov    rcx,QWORD PTR [rcx+0xe]
  215fed:	48 89 8c 24 be 01 00 	mov    QWORD PTR [rsp+0x1be],rcx
  215ff4:	00 
                        const file_name = try st.readString();
  215ff5:	66 85 c0             	test   ax,ax
  215ff8:	0f 85 94 06 00 00    	jne    216692 <getLineNumberInfo+0x1f22>
  215ffe:	48 8d 84 24 b6 01 00 	lea    rax,[rsp+0x1b6]
  216005:	00 
  216006:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  21600a:	c5 f9 7f 84 24 d0 01 	vmovdqa XMMWORD PTR [rsp+0x1d0],xmm0
  216011:	00 00 
            try self.readNoEof(result[0..]);
  216013:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  216018:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21601d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  216024:	00 00 
            return self.readFn(self, buffer);
  216026:	4c 89 e7             	mov    rdi,r12
  216029:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21602e:	4c 89 ea             	mov    rdx,r13
  216031:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  216035:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21603a:	66 85 c0             	test   ax,ax
  21603d:	0f 85 a6 04 00 00    	jne    2164e9 <getLineNumberInfo+0x1d79>
  216043:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  216048:	31 ed                	xor    ebp,ebp
  21604a:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  21604c:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  216051:	0f 82 88 04 00 00    	jb     2164df <getLineNumberInfo+0x1d6f>
            return result[0];
  216057:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21605c:	89 c2                	mov    edx,eax
  21605e:	83 e2 7f             	and    edx,0x7f
  216061:	89 de                	mov    esi,ebx
  216063:	83 e6 3f             	and    esi,0x3f
  216066:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21606b:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  216070:	48 39 d6             	cmp    rsi,rdx
  216073:	0f 85 6c 04 00 00    	jne    2164e5 <getLineNumberInfo+0x1d75>
        result |= operand;
  216079:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  21607c:	84 c0                	test   al,al
  21607e:	0f 89 e7 00 00 00    	jns    21616b <getLineNumberInfo+0x19fb>
        shift += 7;
  216084:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  216088:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21608d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  216092:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  216099:	00 00 
            return self.readFn(self, buffer);
  21609b:	4c 89 e7             	mov    rdi,r12
  21609e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2160a3:	4c 89 ea             	mov    rdx,r13
  2160a6:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2160aa:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2160af:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2160b4:	66 85 c0             	test   ax,ax
  2160b7:	74 93                	je     21604c <getLineNumberInfo+0x18dc>
  2160b9:	e9 2b 04 00 00       	jmp    2164e9 <getLineNumberInfo+0x1d79>
                result = (result << 8) | b;
  2160be:	48 c1 e0 08          	shl    rax,0x8
  2160c2:	48 09 c8             	or     rax,rcx
  2160c5:	48 c1 e0 08          	shl    rax,0x8
  2160c9:	0f b6 4c 24 4a       	movzx  ecx,BYTE PTR [rsp+0x4a]
  2160ce:	48 09 c1             	or     rcx,rax
  2160d1:	48 c1 e1 08          	shl    rcx,0x8
  2160d5:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  2160da:	48 09 c8             	or     rax,rcx
  2160dd:	48 c1 e0 08          	shl    rax,0x8
  2160e1:	0f b6 4c 24 4c       	movzx  ecx,BYTE PTR [rsp+0x4c]
  2160e6:	48 09 c1             	or     rcx,rax
  2160e9:	48 c1 e1 08          	shl    rcx,0x8
  2160ed:	0f b6 44 24 4d       	movzx  eax,BYTE PTR [rsp+0x4d]
  2160f2:	48 09 c8             	or     rax,rcx
  2160f5:	48 c1 e0 08          	shl    rax,0x8
  2160f9:	0f b6 4c 24 4e       	movzx  ecx,BYTE PTR [rsp+0x4e]
  2160fe:	48 09 c1             	or     rcx,rax
  216101:	48 c1 e1 08          	shl    rcx,0x8
  216105:	0f b6 44 24 4f       	movzx  eax,BYTE PTR [rsp+0x4f]
  21610a:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  21610d:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  216114:	00 
  216115:	e9 45 f9 ff ff       	jmp    215a5f <getLineNumberInfo+0x12ef>
                        prog.address += arg * minimum_instruction_length;
  21611a:	49 0f af df          	imul   rbx,r15
  21611e:	48 01 9c 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rbx
  216125:	00 
  216126:	e9 34 f9 ff ff       	jmp    215a5f <getLineNumberInfo+0x12ef>
            if (shift < @sizeOf(i64) * 8 and (byte & 0b01000000) != 0) result |= -(i64(1) << @intCast(u6, shift));
  21612b:	48 83 fb 3f          	cmp    rbx,0x3f
  21612f:	77 13                	ja     216144 <getLineNumberInfo+0x19d4>
  216131:	24 40                	and    al,0x40
  216133:	74 0f                	je     216144 <getLineNumberInfo+0x19d4>
  216135:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  21613c:	c4 e2 e1 f7 c0       	shlx   rax,rax,rbx
  216141:	48 09 c5             	or     rbp,rax
                        prog.line += arg;
  216144:	48 01 ac 24 f0 00 00 	add    QWORD PTR [rsp+0xf0],rbp
  21614b:	00 
  21614c:	e9 0e f9 ff ff       	jmp    215a5f <getLineNumberInfo+0x12ef>
                        prog.file = arg;
  216151:	48 89 9c 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbx
  216158:	00 
  216159:	e9 01 f9 ff ff       	jmp    215a5f <getLineNumberInfo+0x12ef>
                        prog.column = arg;
  21615e:	48 89 9c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rbx
  216165:	00 
  216166:	e9 f4 f8 ff ff       	jmp    215a5f <getLineNumberInfo+0x12ef>
            try self.readNoEof(result[0..]);
  21616b:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  216170:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  216175:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21617c:	00 00 
            return self.readFn(self, buffer);
  21617e:	4c 89 e7             	mov    rdi,r12
  216181:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  216186:	4c 89 ea             	mov    rdx,r13
  216189:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21618d:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  216192:	66 85 c0             	test   ax,ax
  216195:	0f 85 e0 03 00 00    	jne    21657b <getLineNumberInfo+0x1e0b>
  21619b:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2161a0:	45 31 f6             	xor    r14d,r14d
  2161a3:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  2161a5:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  2161aa:	0f 82 c1 03 00 00    	jb     216571 <getLineNumberInfo+0x1e01>
            return result[0];
  2161b0:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2161b5:	89 c2                	mov    edx,eax
  2161b7:	83 e2 7f             	and    edx,0x7f
  2161ba:	89 de                	mov    esi,ebx
  2161bc:	83 e6 3f             	and    esi,0x3f
  2161bf:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2161c4:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2161c9:	48 39 d6             	cmp    rsi,rdx
  2161cc:	0f 85 a5 03 00 00    	jne    216577 <getLineNumberInfo+0x1e07>
        result |= operand;
  2161d2:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  2161d5:	84 c0                	test   al,al
  2161d7:	79 3a                	jns    216213 <getLineNumberInfo+0x1aa3>
        shift += 7;
  2161d9:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  2161dd:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2161e2:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2161e7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2161ee:	00 00 
            return self.readFn(self, buffer);
  2161f0:	4c 89 e7             	mov    rdi,r12
  2161f3:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2161f8:	4c 89 ea             	mov    rdx,r13
  2161fb:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2161ff:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  216204:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  216209:	66 85 c0             	test   ax,ax
  21620c:	74 97                	je     2161a5 <getLineNumberInfo+0x1a35>
  21620e:	e9 68 03 00 00       	jmp    21657b <getLineNumberInfo+0x1e0b>
            try self.readNoEof(result[0..]);
  216213:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  216218:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21621d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  216224:	00 00 
            return self.readFn(self, buffer);
  216226:	4c 89 e7             	mov    rdi,r12
  216229:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21622e:	4c 89 ea             	mov    rdx,r13
  216231:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  216235:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21623a:	66 85 c0             	test   ax,ax
  21623d:	0f 85 bc 04 00 00    	jne    2166ff <getLineNumberInfo+0x1f8f>
  216243:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  216248:	31 c0                	xor    eax,eax
  21624a:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21624f:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  216251:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  216256:	0f 82 99 04 00 00    	jb     2166f5 <getLineNumberInfo+0x1f85>
            return result[0];
  21625c:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  216261:	89 c2                	mov    edx,eax
  216263:	83 e2 7f             	and    edx,0x7f
  216266:	89 de                	mov    esi,ebx
  216268:	83 e6 3f             	and    esi,0x3f
  21626b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  216270:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  216275:	48 39 d6             	cmp    rsi,rdx
  216278:	0f 85 7d 04 00 00    	jne    2166fb <getLineNumberInfo+0x1f8b>
        result |= operand;
  21627e:	48 09 4c 24 68       	or     QWORD PTR [rsp+0x68],rcx
        if ((byte & 0b10000000) == 0) return result;
  216283:	84 c0                	test   al,al
  216285:	79 3a                	jns    2162c1 <getLineNumberInfo+0x1b51>
        shift += 7;
  216287:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  21628b:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  216290:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  216295:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21629c:	00 00 
            return self.readFn(self, buffer);
  21629e:	4c 89 e7             	mov    rdi,r12
  2162a1:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2162a6:	4c 89 ea             	mov    rdx,r13
  2162a9:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2162ad:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2162b2:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2162b7:	66 85 c0             	test   ax,ax
  2162ba:	74 95                	je     216251 <getLineNumberInfo+0x1ae1>
  2162bc:	e9 3e 04 00 00       	jmp    2166ff <getLineNumberInfo+0x1f8f>
                        try file_entries.append(FileEntry{
  2162c1:	c5 f9 6f 84 24 d0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1d0]
  2162c8:	00 00 
  2162ca:	c5 f9 7f 84 24 f0 01 	vmovdqa XMMWORD PTR [rsp+0x1f0],xmm0
  2162d1:	00 00 
            const new_length = self.len + 1;
  2162d3:	48 8b 9c 24 80 00 00 	mov    rbx,QWORD PTR [rsp+0x80]
  2162da:	00 
            var better_capacity = self.items.len;
  2162db:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
            if (better_capacity >= new_capacity) return;
  2162e0:	48 39 d9             	cmp    rcx,rbx
  2162e3:	76 05                	jbe    2162ea <getLineNumberInfo+0x1b7a>
            const result = &self.items[self.len];
  2162e5:	48 89 d8             	mov    rax,rbx
  2162e8:	eb 4c                	jmp    216336 <getLineNumberInfo+0x1bc6>
                better_capacity += better_capacity / 2 + 8;
  2162ea:	48 89 c8             	mov    rax,rcx
  2162ed:	48 d1 e8             	shr    rax,1
  2162f0:	48 01 c1             	add    rcx,rax
  2162f3:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2162f7:	48 39 d9             	cmp    rcx,rbx
  2162fa:	76 ee                	jbe    2162ea <getLineNumberInfo+0x1b7a>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2162fc:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  216303:	00 
  216304:	4c 89 e7             	mov    rdi,r12
  216307:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  21630c:	e8 df 13 00 00       	call   2176f0 <Allocator_alignedRealloc.79>
  216311:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  216316:	66 85 c0             	test   ax,ax
  216319:	0f 85 5f 04 00 00    	jne    21677e <getLineNumberInfo+0x200e>
  21631f:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  216324:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  216328:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
            const result = &self.items[self.len];
  21632e:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  216335:	00 
  216336:	48 83 c3 01          	add    rbx,0x1
  21633a:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  21633f:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  216343:	48 89 9c 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rbx
  21634a:	00 
            new_item_ptr.* = item;
  21634b:	c5 f9 6f 84 24 f0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1f0]
  216352:	00 00 
  216354:	c5 fa 7f 04 c1       	vmovdqu XMMWORD PTR [rcx+rax*8],xmm0
  216359:	48 89 6c c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],rbp
  21635e:	4c 89 74 c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],r14
  216363:	48 8b 54 24 68       	mov    rdx,QWORD PTR [rsp+0x68]
  216368:	48 89 54 c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rdx
  21636d:	e9 ed f6 ff ff       	jmp    215a5f <getLineNumberInfo+0x12ef>
  216372:	c5 fc 10 05 ce 01 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff01ce]        # 206548 <__unnamed_79+0x10>
  216379:	ff 
  21637a:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  21637e:	c5 fc 11 40 10       	vmovups YMMWORD PTR [rax+0x10],ymm0
  216383:	c5 fe 6f 05 ad 01 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff01ad]        # 206538 <__unnamed_79>
  21638a:	ff 
  21638b:	e9 e7 e6 ff ff       	jmp    214a77 <getLineNumberInfo+0x307>
  216390:	66 b8 20 00          	mov    ax,0x20
  216394:	eb 22                	jmp    2163b8 <getLineNumberInfo+0x1c48>
  216396:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            try file_entries.append(FileEntry{
  21639a:	66 89 01             	mov    WORD PTR [rcx],ax
  21639d:	c5 fc 10 84 24 d6 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6d6]
  2163a4:	00 00 
  2163a6:	c5 fc 10 8c 24 e4 06 	vmovups ymm1,YMMWORD PTR [rsp+0x6e4]
  2163ad:	00 00 
  2163af:	e9 e1 e7 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  2163b4:	66 b8 25 00          	mov    ax,0x25
  2163b8:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                const op_size = try readULeb128(in_stream);
  2163bc:	66 89 01             	mov    WORD PTR [rcx],ax
  2163bf:	c5 fe 6f 84 24 4c 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x64c]
  2163c6:	00 00 
  2163c8:	c5 fc 10 8c 24 5a 06 	vmovups ymm1,YMMWORD PTR [rsp+0x65a]
  2163cf:	00 00 
  2163d1:	e9 bf e7 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  2163d6:	66 b9 20 00          	mov    cx,0x20
  2163da:	e9 af f4 ff ff       	jmp    21588e <getLineNumberInfo+0x111e>
  2163df:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                if (try prog.checkLineMatch()) |info| return info;
  2163e3:	66 89 01             	mov    WORD PTR [rcx],ax
  2163e6:	c5 fc 10 84 24 80 04 	vmovups ymm0,YMMWORD PTR [rsp+0x480]
  2163ed:	00 00 
  2163ef:	c5 fc 10 8c 24 8e 04 	vmovups ymm1,YMMWORD PTR [rsp+0x48e]
  2163f6:	00 00 
  2163f8:	e9 98 e7 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  2163fd:	48 8b 84 24 68 02 00 	mov    rax,QWORD PTR [rsp+0x268]
  216404:	00 
  216405:	48 89 84 24 08 03 00 	mov    QWORD PTR [rsp+0x308],rax
  21640c:	00 
  21640d:	c5 fc 10 84 24 48 02 	vmovups ymm0,YMMWORD PTR [rsp+0x248]
  216414:	00 00 
  216416:	c5 fc 11 84 24 e8 02 	vmovups YMMWORD PTR [rsp+0x2e8],ymm0
  21641d:	00 00 
  21641f:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  216423:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  216428:	c5 fc 10 84 24 e2 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2e2]
  21642f:	00 00 
  216431:	c5 fc 10 8c 24 f0 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2f0]
  216438:	00 00 
  21643a:	e9 68 f4 ff ff       	jmp    2158a7 <getLineNumberInfo+0x1137>
  21643f:	66 b8 20 00          	mov    ax,0x20
  216443:	eb 16                	jmp    21645b <getLineNumberInfo+0x1ceb>
  216445:	66 b8 20 00          	mov    ax,0x20
  216449:	eb 32                	jmp    21647d <getLineNumberInfo+0x1d0d>
  21644b:	66 b8 20 00          	mov    ax,0x20
  21644f:	eb 4e                	jmp    21649f <getLineNumberInfo+0x1d2f>
  216451:	66 b8 20 00          	mov    ax,0x20
  216455:	eb 6a                	jmp    2164c1 <getLineNumberInfo+0x1d51>
  216457:	66 b8 25 00          	mov    ax,0x25
  21645b:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  21645f:	66 89 01             	mov    WORD PTR [rcx],ax
  216462:	c5 fc 10 84 24 f6 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3f6]
  216469:	00 00 
  21646b:	c5 fc 10 8c 24 04 04 	vmovups ymm1,YMMWORD PTR [rsp+0x404]
  216472:	00 00 
  216474:	e9 1c e7 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  216479:	66 b8 25 00          	mov    ax,0x25
  21647d:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readILeb128(in_stream);
  216481:	66 89 01             	mov    WORD PTR [rcx],ax
  216484:	c5 fc 10 84 24 c8 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3c8]
  21648b:	00 00 
  21648d:	c5 fc 10 8c 24 d6 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3d6]
  216494:	00 00 
  216496:	e9 fa e6 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  21649b:	66 b8 25 00          	mov    ax,0x25
  21649f:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  2164a3:	66 89 01             	mov    WORD PTR [rcx],ax
  2164a6:	c5 fc 10 84 24 9a 03 	vmovups ymm0,YMMWORD PTR [rsp+0x39a]
  2164ad:	00 00 
  2164af:	c5 fc 10 8c 24 a8 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3a8]
  2164b6:	00 00 
  2164b8:	e9 d8 e6 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  2164bd:	66 b8 25 00          	mov    ax,0x25
  2164c1:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  2164c5:	66 89 01             	mov    WORD PTR [rcx],ax
  2164c8:	c5 fc 10 84 24 6c 03 	vmovups ymm0,YMMWORD PTR [rsp+0x36c]
  2164cf:	00 00 
  2164d1:	c5 fc 10 8c 24 7a 03 	vmovups ymm1,YMMWORD PTR [rsp+0x37a]
  2164d8:	00 00 
  2164da:	e9 b6 e6 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  2164df:	66 b8 20 00          	mov    ax,0x20
  2164e3:	eb 04                	jmp    2164e9 <getLineNumberInfo+0x1d79>
  2164e5:	66 b8 25 00          	mov    ax,0x25
  2164e9:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const dir_index = try readULeb128(in_stream);
  2164ed:	66 89 01             	mov    WORD PTR [rcx],ax
  2164f0:	c5 fc 10 84 24 38 05 	vmovups ymm0,YMMWORD PTR [rsp+0x538]
  2164f7:	00 00 
  2164f9:	c5 fc 10 8c 24 46 05 	vmovups ymm1,YMMWORD PTR [rsp+0x546]
  216500:	00 00 
  216502:	e9 8e e6 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  216507:	66 b8 20 00          	mov    ax,0x20
  21650b:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                sub_op = try in_stream.readByte();
  21650f:	66 89 01             	mov    WORD PTR [rcx],ax
  216512:	c5 fe 6f 84 24 1e 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x61e]
  216519:	00 00 
  21651b:	c5 fc 10 8c 24 2c 06 	vmovups ymm1,YMMWORD PTR [rsp+0x62c]
  216522:	00 00 
  216524:	e9 6c e6 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
                        prog.end_sequence = true;
  216529:	c6 84 24 02 01 00 00 	mov    BYTE PTR [rsp+0x102],0x1
  216530:	01 
  216531:	48 8d bc 24 78 02 00 	lea    rdi,[rsp+0x278]
  216538:	00 
  216539:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  216540:	00 
                        if (try prog.checkLineMatch()) |info| return info;
  216541:	e8 1a 08 00 00       	call   216d60 <LineNumberProgram_checkLineMatch>
  216546:	0f b7 84 24 78 02 00 	movzx  eax,WORD PTR [rsp+0x278]
  21654d:	00 
  21654e:	66 85 c0             	test   ax,ax
  216551:	74 46                	je     216599 <getLineNumberInfo+0x1e29>
  216553:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  216557:	66 89 01             	mov    WORD PTR [rcx],ax
  21655a:	c5 fc 10 84 24 c2 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5c2]
  216561:	00 00 
  216563:	c5 fc 10 8c 24 d0 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5d0]
  21656a:	00 00 
  21656c:	e9 24 e6 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  216571:	66 b8 20 00          	mov    ax,0x20
  216575:	eb 04                	jmp    21657b <getLineNumberInfo+0x1e0b>
  216577:	66 b8 25 00          	mov    ax,0x25
  21657b:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const mtime = try readULeb128(in_stream);
  21657f:	66 89 01             	mov    WORD PTR [rcx],ax
  216582:	c5 fc 10 84 24 0a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x50a]
  216589:	00 00 
  21658b:	c5 fc 10 8c 24 18 05 	vmovups ymm1,YMMWORD PTR [rsp+0x518]
  216592:	00 00 
  216594:	e9 fc e5 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
                        if (try prog.checkLineMatch()) |info| return info;
  216599:	80 bc 24 a8 02 00 00 	cmp    BYTE PTR [rsp+0x2a8],0x1
  2165a0:	01 
  2165a1:	0f 85 b7 e4 ff ff    	jne    214a5e <getLineNumberInfo+0x2ee>
  2165a7:	48 8b 84 24 a0 02 00 	mov    rax,QWORD PTR [rsp+0x2a0]
  2165ae:	00 
  2165af:	48 89 84 24 36 03 00 	mov    QWORD PTR [rsp+0x336],rax
  2165b6:	00 
  2165b7:	c5 fc 10 84 24 80 02 	vmovups ymm0,YMMWORD PTR [rsp+0x280]
  2165be:	00 00 
  2165c0:	c5 fc 11 84 24 16 03 	vmovups YMMWORD PTR [rsp+0x316],ymm0
  2165c7:	00 00 
  2165c9:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  2165cd:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  2165d2:	c5 fc 10 84 24 10 03 	vmovups ymm0,YMMWORD PTR [rsp+0x310]
  2165d9:	00 00 
  2165db:	c5 fc 10 8c 24 1e 03 	vmovups ymm1,YMMWORD PTR [rsp+0x31e]
  2165e2:	00 00 
  2165e4:	e9 be f2 ff ff       	jmp    2158a7 <getLineNumberInfo+0x1137>
  2165e9:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        if (try prog.checkLineMatch()) |info| return info;
  2165ed:	66 89 01             	mov    WORD PTR [rcx],ax
  2165f0:	c5 fc 10 84 24 24 04 	vmovups ymm0,YMMWORD PTR [rsp+0x424]
  2165f7:	00 00 
  2165f9:	c5 fc 10 8c 24 32 04 	vmovups ymm1,YMMWORD PTR [rsp+0x432]
  216600:	00 00 
  216602:	e9 8e e5 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  216607:	48 8b 84 24 30 02 00 	mov    rax,QWORD PTR [rsp+0x230]
  21660e:	00 
  21660f:	48 89 84 24 da 02 00 	mov    QWORD PTR [rsp+0x2da],rax
  216616:	00 
  216617:	c5 fc 10 84 24 10 02 	vmovups ymm0,YMMWORD PTR [rsp+0x210]
  21661e:	00 00 
  216620:	c5 fc 11 84 24 ba 02 	vmovups YMMWORD PTR [rsp+0x2ba],ymm0
  216627:	00 00 
  216629:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  21662d:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  216632:	c5 fc 10 84 24 b4 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2b4]
  216639:	00 00 
  21663b:	c5 fc 10 8c 24 c2 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2c2]
  216642:	00 00 
  216644:	e9 5e f2 ff ff       	jmp    2158a7 <getLineNumberInfo+0x1137>
  216649:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  21664d:	48 83 f8 17          	cmp    rax,0x17
  216651:	0f 87 c6 00 00 00    	ja     21671d <getLineNumberInfo+0x1fad>
  216657:	48 8d 0d b6 b0 fe ff 	lea    rcx,[rip+0xfffffffffffeb0b6]        # 201714 <__unnamed_9+0xa34>
  21665e:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  216662:	48 01 c8             	add    rax,rcx
  216665:	ff e0                	jmp    rax
  216667:	66 b8 1e 00          	mov    ax,0x1e
  21666b:	e9 c9 00 00 00       	jmp    216739 <getLineNumberInfo+0x1fc9>
  216670:	66 b8 20 00          	mov    ax,0x20
  216674:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try in_stream.readInt(st.elf.endian, u16);
  216678:	66 89 01             	mov    WORD PTR [rcx],ax
  21667b:	c5 fc 10 84 24 3e 03 	vmovups ymm0,YMMWORD PTR [rsp+0x33e]
  216682:	00 00 
  216684:	c5 fc 10 8c 24 4c 03 	vmovups ymm1,YMMWORD PTR [rsp+0x34c]
  21668b:	00 00 
  21668d:	e9 03 e5 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  216692:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const file_name = try st.readString();
  216696:	66 89 01             	mov    WORD PTR [rcx],ax
  216699:	c5 fc 10 84 24 66 05 	vmovups ymm0,YMMWORD PTR [rsp+0x566]
  2166a0:	00 00 
  2166a2:	c5 fc 10 8c 24 74 05 	vmovups ymm1,YMMWORD PTR [rsp+0x574]
  2166a9:	00 00 
  2166ab:	e9 e5 e4 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  2166b0:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  2166b4:	48 83 f8 17          	cmp    rax,0x17
  2166b8:	77 6f                	ja     216729 <getLineNumberInfo+0x1fb9>
  2166ba:	48 8d 0d b3 b0 fe ff 	lea    rcx,[rip+0xfffffffffffeb0b3]        # 201774 <__unnamed_9+0xa94>
  2166c1:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  2166c5:	48 01 c8             	add    rax,rcx
  2166c8:	ff e0                	jmp    rax
  2166ca:	66 b8 22 00          	mov    ax,0x22
  2166ce:	e9 88 00 00 00       	jmp    21675b <getLineNumberInfo+0x1feb>
  2166d3:	66 b8 20 00          	mov    ax,0x20
  2166d7:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const addr = try in_stream.readInt(st.elf.endian, usize);
  2166db:	66 89 01             	mov    WORD PTR [rcx],ax
  2166de:	c5 fe 6f 84 24 94 05 	vmovdqu ymm0,YMMWORD PTR [rsp+0x594]
  2166e5:	00 00 
  2166e7:	c5 fc 10 8c 24 a2 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5a2]
  2166ee:	00 00 
  2166f0:	e9 a0 e4 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  2166f5:	66 b8 20 00          	mov    ax,0x20
  2166f9:	eb 04                	jmp    2166ff <getLineNumberInfo+0x1f8f>
  2166fb:	66 b8 25 00          	mov    ax,0x25
  2166ff:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const len_bytes = try readULeb128(in_stream);
  216703:	66 89 01             	mov    WORD PTR [rcx],ax
  216706:	c5 fc 10 84 24 dc 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4dc]
  21670d:	00 00 
  21670f:	c5 fc 10 8c 24 ea 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4ea]
  216716:	00 00 
  216718:	e9 78 e4 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  21671d:	48 83 f9 4b          	cmp    rcx,0x4b
  216721:	75 12                	jne    216735 <getLineNumberInfo+0x1fc5>
  216723:	66 b8 22 00          	mov    ax,0x22
  216727:	eb 10                	jmp    216739 <getLineNumberInfo+0x1fc9>
  216729:	48 83 f9 4b          	cmp    rcx,0x4b
  21672d:	74 9b                	je     2166ca <getLineNumberInfo+0x1f5a>
  21672f:	66 b8 02 00          	mov    ax,0x2
  216733:	eb 26                	jmp    21675b <getLineNumberInfo+0x1feb>
  216735:	66 b8 02 00          	mov    ax,0x2
  216739:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try in_file.seekForward(len_bytes);
  21673d:	66 89 01             	mov    WORD PTR [rcx],ax
  216740:	c5 fc 10 84 24 52 04 	vmovups ymm0,YMMWORD PTR [rsp+0x452]
  216747:	00 00 
  216749:	c5 fc 10 8c 24 60 04 	vmovups ymm1,YMMWORD PTR [rsp+0x460]
  216750:	00 00 
  216752:	e9 3e e4 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  216757:	66 b8 1e 00          	mov    ax,0x1e
  21675b:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try in_file.seekForward(fwd_amt);
  21675f:	66 89 01             	mov    WORD PTR [rcx],ax
  216762:	c5 fc 10 84 24 f0 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5f0]
  216769:	00 00 
  21676b:	c5 fc 10 8c 24 fe 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5fe]
  216772:	00 00 
  216774:	e9 1c e4 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
            @panic("assertion failure");
  216779:	e8 32 35 ff ff       	call   209cb0 <panic>
  21677e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try file_entries.append(FileEntry{
  216782:	66 89 01             	mov    WORD PTR [rcx],ax
  216785:	c5 fc 10 84 24 ae 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4ae]
  21678c:	00 00 
  21678e:	c5 fc 10 8c 24 bc 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4bc]
  216795:	00 00 
  216797:	e9 f9 e3 ff ff       	jmp    214b95 <getLineNumberInfo+0x425>
  21679c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000002167a0 <printLineFromFile>:
fn printLineFromFile(allocator: *mem.Allocator, out_stream: var, line_info: *const LineInfo) !void {
  2167a0:	55                   	push   rbp
  2167a1:	41 57                	push   r15
  2167a3:	41 56                	push   r14
  2167a5:	41 55                	push   r13
  2167a7:	41 54                	push   r12
  2167a9:	53                   	push   rbx
  2167aa:	48 81 ec 58 10 00 00 	sub    rsp,0x1058
  2167b1:	48 89 d3             	mov    rbx,rdx
  2167b4:	49 89 f6             	mov    r14,rsi
  2167b7:	48 89 f8             	mov    rax,rdi
    var f = try os.File.openRead(allocator, line_info.file_name);
  2167ba:	48 8d 53 10          	lea    rdx,[rbx+0x10]
  2167be:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  2167c3:	48 89 c6             	mov    rsi,rax
  2167c6:	e8 a5 96 ff ff       	call   20fe70 <File_openRead>
  2167cb:	0f b7 6c 24 38       	movzx  ebp,WORD PTR [rsp+0x38]
  2167d0:	66 85 ed             	test   bp,bp
  2167d3:	74 07                	je     2167dc <printLineFromFile+0x3c>
  2167d5:	89 e8                	mov    eax,ebp
  2167d7:	e9 8e 02 00 00       	jmp    216a6a <printLineFromFile+0x2ca>
  2167dc:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  2167e1:	48 63 5c 24 3c       	movsxd rbx,DWORD PTR [rsp+0x3c]
  2167e6:	89 5c 24 08          	mov    DWORD PTR [rsp+0x8],ebx
    var buf: [os.page_size]u8 = undefined;
  2167ea:	48 8d 35 de fe fe ff 	lea    rsi,[rip+0xfffffffffffefede]        # 2066cf <__unnamed_80>
  2167f1:	48 8d 6c 24 58       	lea    rbp,[rsp+0x58]
  2167f6:	ba 00 10 00 00       	mov    edx,0x1000
  2167fb:	48 89 ef             	mov    rdi,rbp
  2167fe:	e8 6d 28 00 00       	call   219070 <memcpy>
        const amt_read = try f.read(buf[0..]);
  216803:	48 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],rbp
  216808:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  21680f:	00 00 
  216811:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  216816:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  21681b:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  216820:	e8 2b 9c ff ff       	call   210450 <File_read>
  216825:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  21682b:	74 40                	je     21686d <printLineFromFile+0xcd>
  21682d:	0f 1f 00             	nop    DWORD PTR [rax]
    return asm volatile ("syscall"
  216830:	b8 03 00 00 00       	mov    eax,0x3
  216835:	48 89 df             	mov    rdi,rbx
  216838:	0f 05                	syscall 
            switch (err) {
  21683a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21683e:	74 f0                	je     216830 <printLineFromFile+0x90>
            const first = list.first orelse return null;
  216840:	48 8b 05 09 a8 00 00 	mov    rax,QWORD PTR [rip+0xa809]        # 221050 <emfile_promise_queue>
  216847:	48 85 c0             	test   rax,rax
  21684a:	0f 84 15 02 00 00    	je     216a65 <printLineFromFile+0x2c5>
            if (node.prev) |prev_node| {
  216850:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  216853:	48 85 c9             	test   rcx,rcx
  216856:	0f 84 a5 01 00 00    	je     216a01 <printLineFromFile+0x261>
                prev_node.next = node.next;
  21685c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  216860:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  216864:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216868:	e9 9f 01 00 00       	jmp    216a0c <printLineFromFile+0x26c>
  21686d:	41 bc 01 00 00 00    	mov    r12d,0x1
  216873:	4c 89 74 24 40       	mov    QWORD PTR [rsp+0x40],r14
  216878:	4c 8b 6c 24 20       	mov    r13,QWORD PTR [rsp+0x20]
        for (slice) |byte| {
  21687d:	4d 85 ed             	test   r13,r13
  216880:	0f 84 3a 01 00 00    	je     2169c0 <printLineFromFile+0x220>
  216886:	45 31 ff             	xor    r15d,r15d
  216889:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  21688e:	66 90                	xchg   ax,ax
  216890:	46 0f b6 74 3c 58    	movzx  r14d,BYTE PTR [rsp+r15*1+0x58]
            if (line == line_info.line) {
  216896:	4c 3b 21             	cmp    r12,QWORD PTR [rcx]
  216899:	75 45                	jne    2168e0 <printLineFromFile+0x140>
  21689b:	44 88 74 24 07       	mov    BYTE PTR [rsp+0x7],r14b
            const slice = (*[1]u8)(&byte)[0..];
  2168a0:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  2168a5:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  2168aa:	48 c7 44 24 50 01 00 	mov    QWORD PTR [rsp+0x50],0x1
  2168b1:	00 00 
  2168b3:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
            return self.writeFn(self, slice);
  2168b8:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  2168bd:	ff 17                	call   QWORD PTR [rdi]
  2168bf:	89 c5                	mov    ebp,eax
                try out_stream.writeByte(byte);
  2168c1:	66 85 ed             	test   bp,bp
  2168c4:	75 7a                	jne    216940 <printLineFromFile+0x1a0>
                if (byte == '\n') {
  2168c6:	41 80 fe 0a          	cmp    r14b,0xa
  2168ca:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  2168cf:	0f 84 ab 00 00 00    	je     216980 <printLineFromFile+0x1e0>
        for (slice) |byte| {
  2168d5:	49 83 c7 01          	add    r15,0x1
  2168d9:	4d 39 ef             	cmp    r15,r13
  2168dc:	72 b2                	jb     216890 <printLineFromFile+0xf0>
  2168de:	eb 15                	jmp    2168f5 <printLineFromFile+0x155>
            if (byte == '\n') {
  2168e0:	31 c0                	xor    eax,eax
  2168e2:	41 80 fe 0a          	cmp    r14b,0xa
  2168e6:	0f 94 c0             	sete   al
  2168e9:	49 01 c4             	add    r12,rax
        for (slice) |byte| {
  2168ec:	49 83 c7 01          	add    r15,0x1
  2168f0:	4d 39 ef             	cmp    r15,r13
  2168f3:	72 9b                	jb     216890 <printLineFromFile+0xf0>
        if (amt_read < buf.len) return error.EndOfFile;
  2168f5:	49 81 fd ff 0f 00 00 	cmp    r13,0xfff
  2168fc:	48 8d 44 24 58       	lea    rax,[rsp+0x58]
  216901:	0f 86 b9 00 00 00    	jbe    2169c0 <printLineFromFile+0x220>
        const amt_read = try f.read(buf[0..]);
  216907:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  21690c:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  216913:	00 00 
  216915:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  21691a:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  21691f:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  216924:	e8 27 9b ff ff       	call   210450 <File_read>
  216929:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  21692f:	0f 84 43 ff ff ff    	je     216878 <printLineFromFile+0xd8>
  216935:	e9 f6 fe ff ff       	jmp    216830 <printLineFromFile+0x90>
  21693a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  216940:	b8 03 00 00 00       	mov    eax,0x3
  216945:	48 89 df             	mov    rdi,rbx
  216948:	0f 05                	syscall 
  21694a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21694e:	74 f0                	je     216940 <printLineFromFile+0x1a0>
            const first = list.first orelse return null;
  216950:	48 8b 05 f9 a6 00 00 	mov    rax,QWORD PTR [rip+0xa6f9]        # 221050 <emfile_promise_queue>
  216957:	48 85 c0             	test   rax,rax
  21695a:	0f 84 75 fe ff ff    	je     2167d5 <printLineFromFile+0x35>
            if (node.prev) |prev_node| {
  216960:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  216963:	48 85 c9             	test   rcx,rcx
  216966:	0f 84 10 01 00 00    	je     216a7c <printLineFromFile+0x2dc>
                prev_node.next = node.next;
  21696c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  216970:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  216974:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216978:	e9 0a 01 00 00       	jmp    216a87 <printLineFromFile+0x2e7>
  21697d:	0f 1f 00             	nop    DWORD PTR [rax]
  216980:	b8 03 00 00 00       	mov    eax,0x3
  216985:	48 89 df             	mov    rdi,rbx
  216988:	0f 05                	syscall 
  21698a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21698e:	74 f0                	je     216980 <printLineFromFile+0x1e0>
            const first = list.first orelse return null;
  216990:	48 8b 05 b9 a6 00 00 	mov    rax,QWORD PTR [rip+0xa6b9]        # 221050 <emfile_promise_queue>
  216997:	48 85 c0             	test   rax,rax
  21699a:	0f 84 b5 01 00 00    	je     216b55 <printLineFromFile+0x3b5>
            if (node.prev) |prev_node| {
  2169a0:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2169a3:	48 85 c9             	test   rcx,rcx
  2169a6:	0f 84 42 01 00 00    	je     216aee <printLineFromFile+0x34e>
                prev_node.next = node.next;
  2169ac:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2169b0:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2169b4:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2169b8:	e9 3c 01 00 00       	jmp    216af9 <printLineFromFile+0x359>
  2169bd:	0f 1f 00             	nop    DWORD PTR [rax]
  2169c0:	b8 03 00 00 00       	mov    eax,0x3
  2169c5:	48 89 df             	mov    rdi,rbx
  2169c8:	0f 05                	syscall 
  2169ca:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  2169ce:	74 f0                	je     2169c0 <printLineFromFile+0x220>
            const first = list.first orelse return null;
  2169d0:	48 8b 05 79 a6 00 00 	mov    rax,QWORD PTR [rip+0xa679]        # 221050 <emfile_promise_queue>
  2169d7:	66 bd 26 00          	mov    bp,0x26
  2169db:	48 85 c0             	test   rax,rax
  2169de:	0f 84 f1 fd ff ff    	je     2167d5 <printLineFromFile+0x35>
            if (node.prev) |prev_node| {
  2169e4:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  2169e7:	48 85 c9             	test   rcx,rcx
  2169ea:	0f 84 6c 01 00 00    	je     216b5c <printLineFromFile+0x3bc>
                prev_node.next = node.next;
  2169f0:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  2169f4:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  2169f8:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  2169fc:	e9 66 01 00 00       	jmp    216b67 <printLineFromFile+0x3c7>
                list.first = node.next;
  216a01:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216a05:	48 89 0d 44 a6 00 00 	mov    QWORD PTR [rip+0xa644],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  216a0c:	48 85 c9             	test   rcx,rcx
  216a0f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  216a12:	48 8d 35 3f a6 00 00 	lea    rsi,[rip+0xa63f]        # 221058 <emfile_promise_queue+0x8>
  216a19:	48 0f 45 f1          	cmovne rsi,rcx
  216a1d:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  216a20:	48 83 05 38 a6 00 00 	add    QWORD PTR [rip+0xa638],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  216a27:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  216a28:	74 1e                	je     216a48 <printLineFromFile+0x2a8>
  216a2a:	48 83 3d 1e a6 00 00 	cmp    QWORD PTR [rip+0xa61e],0x0        # 221050 <emfile_promise_queue>
  216a31:	00 
  216a32:	0f 84 8c 01 00 00    	je     216bc4 <printLineFromFile+0x424>
  216a38:	48 8b 0d 19 a6 00 00 	mov    rcx,QWORD PTR [rip+0xa619]        # 221058 <emfile_promise_queue+0x8>
  216a3f:	48 85 c9             	test   rcx,rcx
  216a42:	0f 84 7c 01 00 00    	je     216bc4 <printLineFromFile+0x424>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  216a48:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  216a4c:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  216a50:	48 89 c1             	mov    rcx,rax
  216a53:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  216a57:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  216a5d:	75 f1                	jne    216a50 <printLineFromFile+0x2b0>
  216a5f:	a8 01                	test   al,0x1
  216a61:	75 02                	jne    216a65 <printLineFromFile+0x2c5>
  216a63:	ff 17                	call   QWORD PTR [rdi]
  216a65:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  216a6a:	48 81 c4 58 10 00 00 	add    rsp,0x1058
  216a71:	5b                   	pop    rbx
  216a72:	41 5c                	pop    r12
  216a74:	41 5d                	pop    r13
  216a76:	41 5e                	pop    r14
  216a78:	41 5f                	pop    r15
  216a7a:	5d                   	pop    rbp
  216a7b:	c3                   	ret    
                list.first = node.next;
  216a7c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216a80:	48 89 0d c9 a5 00 00 	mov    QWORD PTR [rip+0xa5c9],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  216a87:	48 85 c9             	test   rcx,rcx
  216a8a:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  216a8d:	48 8d 35 c4 a5 00 00 	lea    rsi,[rip+0xa5c4]        # 221058 <emfile_promise_queue+0x8>
  216a94:	48 0f 45 f1          	cmovne rsi,rcx
  216a98:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  216a9b:	48 83 05 bd a5 00 00 	add    QWORD PTR [rip+0xa5bd],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  216aa2:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  216aa3:	74 1e                	je     216ac3 <printLineFromFile+0x323>
  216aa5:	48 83 3d a3 a5 00 00 	cmp    QWORD PTR [rip+0xa5a3],0x0        # 221050 <emfile_promise_queue>
  216aac:	00 
  216aad:	0f 84 11 01 00 00    	je     216bc4 <printLineFromFile+0x424>
  216ab3:	48 8b 0d 9e a5 00 00 	mov    rcx,QWORD PTR [rip+0xa59e]        # 221058 <emfile_promise_queue+0x8>
  216aba:	48 85 c9             	test   rcx,rcx
  216abd:	0f 84 01 01 00 00    	je     216bc4 <printLineFromFile+0x424>
  216ac3:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  216ac7:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  216acb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  216ad0:	48 89 c1             	mov    rcx,rax
  216ad3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  216ad7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  216add:	75 f1                	jne    216ad0 <printLineFromFile+0x330>
  216adf:	a8 01                	test   al,0x1
  216ae1:	0f 85 ee fc ff ff    	jne    2167d5 <printLineFromFile+0x35>
  216ae7:	ff 17                	call   QWORD PTR [rdi]
  216ae9:	e9 e7 fc ff ff       	jmp    2167d5 <printLineFromFile+0x35>
                list.first = node.next;
  216aee:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216af2:	48 89 0d 57 a5 00 00 	mov    QWORD PTR [rip+0xa557],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  216af9:	48 85 c9             	test   rcx,rcx
  216afc:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  216aff:	48 8d 35 52 a5 00 00 	lea    rsi,[rip+0xa552]        # 221058 <emfile_promise_queue+0x8>
  216b06:	48 0f 45 f1          	cmovne rsi,rcx
  216b0a:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  216b0d:	48 83 05 4b a5 00 00 	add    QWORD PTR [rip+0xa54b],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  216b14:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  216b15:	74 1e                	je     216b35 <printLineFromFile+0x395>
  216b17:	48 83 3d 31 a5 00 00 	cmp    QWORD PTR [rip+0xa531],0x0        # 221050 <emfile_promise_queue>
  216b1e:	00 
  216b1f:	0f 84 9f 00 00 00    	je     216bc4 <printLineFromFile+0x424>
  216b25:	48 8b 0d 2c a5 00 00 	mov    rcx,QWORD PTR [rip+0xa52c]        # 221058 <emfile_promise_queue+0x8>
  216b2c:	48 85 c9             	test   rcx,rcx
  216b2f:	0f 84 8f 00 00 00    	je     216bc4 <printLineFromFile+0x424>
  216b35:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  216b39:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  216b3d:	0f 1f 00             	nop    DWORD PTR [rax]
  216b40:	48 89 c1             	mov    rcx,rax
  216b43:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  216b47:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  216b4d:	75 f1                	jne    216b40 <printLineFromFile+0x3a0>
  216b4f:	a8 01                	test   al,0x1
  216b51:	75 02                	jne    216b55 <printLineFromFile+0x3b5>
  216b53:	ff 17                	call   QWORD PTR [rdi]
  216b55:	31 ed                	xor    ebp,ebp
  216b57:	e9 79 fc ff ff       	jmp    2167d5 <printLineFromFile+0x35>
                list.first = node.next;
  216b5c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216b60:	48 89 0d e9 a4 00 00 	mov    QWORD PTR [rip+0xa4e9],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  216b67:	48 85 c9             	test   rcx,rcx
  216b6a:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  216b6d:	48 8d 35 e4 a4 00 00 	lea    rsi,[rip+0xa4e4]        # 221058 <emfile_promise_queue+0x8>
  216b74:	48 0f 45 f1          	cmovne rsi,rcx
  216b78:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  216b7b:	48 83 05 dd a4 00 00 	add    QWORD PTR [rip+0xa4dd],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  216b82:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  216b83:	74 16                	je     216b9b <printLineFromFile+0x3fb>
  216b85:	48 83 3d c3 a4 00 00 	cmp    QWORD PTR [rip+0xa4c3],0x0        # 221050 <emfile_promise_queue>
  216b8c:	00 
  216b8d:	74 35                	je     216bc4 <printLineFromFile+0x424>
  216b8f:	48 8b 0d c2 a4 00 00 	mov    rcx,QWORD PTR [rip+0xa4c2]        # 221058 <emfile_promise_queue+0x8>
  216b96:	48 85 c9             	test   rcx,rcx
  216b99:	74 29                	je     216bc4 <printLineFromFile+0x424>
  216b9b:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  216b9f:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  216ba3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  216baa:	84 00 00 00 00 00 
  216bb0:	48 89 c1             	mov    rcx,rax
  216bb3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  216bb7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  216bbd:	75 f1                	jne    216bb0 <printLineFromFile+0x410>
  216bbf:	e9 1b ff ff ff       	jmp    216adf <printLineFromFile+0x33f>
            @panic("assertion failure");
  216bc4:	e8 e7 30 ff ff       	call   209cb0 <panic>
  216bc9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000216bd0 <Allocator_alignedRealloc.71>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  216bd0:	41 56                	push   r14
  216bd2:	53                   	push   rbx
  216bd3:	48 83 ec 78          	sub    rsp,0x78
  216bd7:	49 89 ce             	mov    r14,rcx
  216bda:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  216bdd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  216be1:	48 85 c0             	test   rax,rax
  216be4:	74 59                	je     216c3f <Allocator_alignedRealloc.71+0x6f>
        if (n == 0) {
  216be6:	4d 85 f6             	test   r14,r14
  216be9:	0f 84 92 00 00 00    	je     216c81 <Allocator_alignedRealloc.71+0xb1>
        const old_byte_slice = @sliceToBytes(old_mem);
  216bef:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  216bf2:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  216bf7:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  216bfc:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  216c01:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  216c06:	41 b8 01 00 00 00    	mov    r8d,0x1
  216c0c:	4c 89 f1             	mov    rcx,r14
  216c0f:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  216c12:	0f b7 44 24 48       	movzx  eax,WORD PTR [rsp+0x48]
  216c17:	66 85 c0             	test   ax,ax
  216c1a:	0f 84 9e 00 00 00    	je     216cbe <Allocator_alignedRealloc.71+0xee>
  216c20:	66 89 03             	mov    WORD PTR [rbx],ax
  216c23:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  216c28:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  216c2c:	c5 f8 10 44 24 62    	vmovups xmm0,XMMWORD PTR [rsp+0x62]
  216c32:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  216c37:	48 83 c4 78          	add    rsp,0x78
  216c3b:	5b                   	pop    rbx
  216c3c:	41 5e                	pop    r14
  216c3e:	c3                   	ret    
        if (n == 0) {
  216c3f:	4d 85 f6             	test   r14,r14
  216c42:	0f 84 a1 00 00 00    	je     216ce9 <Allocator_alignedRealloc.71+0x119>
  216c48:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  216c4d:	b9 01 00 00 00       	mov    ecx,0x1
  216c52:	4c 89 f2             	mov    rdx,r14
  216c55:	ff 16                	call   QWORD PTR [rsi]
  216c57:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  216c5c:	66 85 c9             	test   cx,cx
  216c5f:	0f 84 a6 00 00 00    	je     216d0b <Allocator_alignedRealloc.71+0x13b>
  216c65:	0f b7 44 24 1e       	movzx  eax,WORD PTR [rsp+0x1e]
  216c6a:	66 89 44 24 0c       	mov    WORD PTR [rsp+0xc],ax
  216c6f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  216c74:	8b 54 24 1a          	mov    edx,DWORD PTR [rsp+0x1a]
  216c78:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
  216c7c:	e9 af 00 00 00       	jmp    216d30 <Allocator_alignedRealloc.71+0x160>
        const bytes = @sliceToBytes(memory);
  216c81:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  216c84:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  216c88:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  216c8d:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  216c92:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  216c97:	48 89 f7             	mov    rdi,rsi
  216c9a:	48 89 c6             	mov    rsi,rax
  216c9d:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  216c9f:	48 8b 05 8a f8 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffef88a]        # 206530 <__unnamed_81+0x10>
  216ca6:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  216caa:	c5 f8 10 05 6e f8 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffef86e]        # 206520 <__unnamed_81>
  216cb1:	ff 
  216cb2:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  216cb6:	48 83 c4 78          	add    rsp,0x78
  216cba:	5b                   	pop    rbx
  216cbb:	41 5e                	pop    r14
  216cbd:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  216cbe:	4c 39 74 24 58       	cmp    QWORD PTR [rsp+0x58],r14
    if (!ok) {
  216cc3:	0f 85 87 00 00 00    	jne    216d50 <Allocator_alignedRealloc.71+0x180>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  216cc9:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  216cce:	0f b7 44 24 12       	movzx  eax,WORD PTR [rsp+0x12]
  216cd3:	66 89 43 06          	mov    WORD PTR [rbx+0x6],ax
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  216cd7:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  216cdc:	8b 4c 24 0e          	mov    ecx,DWORD PTR [rsp+0xe]
  216ce0:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  216ce3:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  216ce7:	eb 5b                	jmp    216d44 <Allocator_alignedRealloc.71+0x174>
  216ce9:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            return ([*]align(alignment) T)(undefined)[0..0];
  216cee:	0f b7 0d 31 f8 fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffef831]        # 206526 <__unnamed_81+0x6>
  216cf5:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  216cfa:	8b 0d 22 f8 fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffef822]        # 206522 <__unnamed_81+0x2>
  216d00:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  216d04:	31 c9                	xor    ecx,ecx
  216d06:	45 31 f6             	xor    r14d,r14d
  216d09:	eb 25                	jmp    216d30 <Allocator_alignedRealloc.71+0x160>
        assert(byte_slice.len == byte_count);
  216d0b:	4c 39 74 24 30       	cmp    QWORD PTR [rsp+0x30],r14
  216d10:	75 3e                	jne    216d50 <Allocator_alignedRealloc.71+0x180>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  216d12:	48 8b 54 24 28       	mov    rdx,QWORD PTR [rsp+0x28]
  216d17:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  216d1c:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  216d20:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  216d24:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  216d29:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  216d2e:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  216d30:	66 89 0b             	mov    WORD PTR [rbx],cx
  216d33:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  216d37:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  216d3b:	8b 00                	mov    eax,DWORD PTR [rax]
  216d3d:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  216d40:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  216d44:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  216d48:	48 83 c4 78          	add    rsp,0x78
  216d4c:	5b                   	pop    rbx
  216d4d:	41 5e                	pop    r14
  216d4f:	c3                   	ret    
            @panic("assertion failure");
  216d50:	e8 5b 2f ff ff       	call   209cb0 <panic>
  216d55:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  216d5c:	00 00 00 00 

0000000000216d60 <LineNumberProgram_checkLineMatch>:
    pub fn checkLineMatch(self: *LineNumberProgram) !?LineInfo {
  216d60:	55                   	push   rbp
  216d61:	41 57                	push   r15
  216d63:	41 56                	push   r14
  216d65:	41 55                	push   r13
  216d67:	41 54                	push   r12
  216d69:	53                   	push   rbx
  216d6a:	48 83 ec 78          	sub    rsp,0x78
  216d6e:	48 89 f3             	mov    rbx,rsi
  216d71:	49 89 fe             	mov    r14,rdi
  216d74:	48 8b 03             	mov    rax,QWORD PTR [rbx]
        if (self.target_address >= self.prev_address and self.target_address < self.address) {
  216d77:	48 8b 4b 28          	mov    rcx,QWORD PTR [rbx+0x28]
  216d7b:	48 3b 4b 48          	cmp    rcx,QWORD PTR [rbx+0x48]
  216d7f:	0f 82 aa 00 00 00    	jb     216e2f <LineNumberProgram_checkLineMatch+0xcf>
  216d85:	48 39 c1             	cmp    rcx,rax
  216d88:	0f 83 a1 00 00 00    	jae    216e2f <LineNumberProgram_checkLineMatch+0xcf>
            const file_entry = if (self.prev_file == 0) {
  216d8e:	48 8b 4b 50          	mov    rcx,QWORD PTR [rbx+0x50]
  216d92:	48 85 c9             	test   rcx,rcx
  216d95:	0f 84 ec 00 00 00    	je     216e87 <LineNumberProgram_checkLineMatch+0x127>
            } else if (self.prev_file - 1 >= self.file_entries.len) {
  216d9b:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  216d9f:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
  216da3:	48 3b 48 10          	cmp    rcx,QWORD PTR [rax+0x10]
  216da7:	0f 83 c2 00 00 00    	jae    216e6f <LineNumberProgram_checkLineMatch+0x10f>
                &self.file_entries.items[self.prev_file - 1];
  216dad:	4c 8b 08             	mov    r9,QWORD PTR [rax]
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  216db0:	4c 8d 14 89          	lea    r10,[rcx+rcx*4]
  216db4:	4b 8b 4c d1 10       	mov    rcx,QWORD PTR [r9+r10*8+0x10]
  216db9:	48 3b 4b 38          	cmp    rcx,QWORD PTR [rbx+0x38]
  216dbd:	0f 83 ac 00 00 00    	jae    216e6f <LineNumberProgram_checkLineMatch+0x10f>
                self.include_dirs[file_entry.dir_index];
  216dc3:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  216dc7:	48 c1 e1 04          	shl    rcx,0x4
  216dcb:	4c 8b 2c 0a          	mov    r13,QWORD PTR [rdx+rcx*1]
  216dcf:	4c 8b 64 0a 08       	mov    r12,QWORD PTR [rdx+rcx*1+0x8]
  216dd4:	4f 8b 7c d1 08       	mov    r15,QWORD PTR [r9+r10*8+0x8]
    var total_strings_len: usize = strings.len; // 1 sep per string
    {
        comptime var string_i = 0;
        inline while (string_i < strings.len) : (string_i += 1) {
            const arg = ([]const u8)(strings[string_i]);
            total_strings_len += arg.len;
  216dd9:	4d 01 e7             	add    r15,r12
        if (n == 0) {
  216ddc:	49 83 c7 02          	add    r15,0x2
  216de0:	0f 84 ce 00 00 00    	je     216eb4 <LineNumberProgram_checkLineMatch+0x154>
  216de6:	4c 89 54 24 18       	mov    QWORD PTR [rsp+0x18],r10
  216deb:	4c 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],r9
  216df0:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  216df4:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  216df9:	b9 01 00 00 00       	mov    ecx,0x1
  216dfe:	4c 89 fa             	mov    rdx,r15
  216e01:	ff 16                	call   QWORD PTR [rsi]
  216e03:	0f b7 44 24 28       	movzx  eax,WORD PTR [rsp+0x28]
  216e08:	66 85 c0             	test   ax,ax
  216e0b:	0f 84 b0 00 00 00    	je     216ec1 <LineNumberProgram_checkLineMatch+0x161>
            const file_name = try os.path.join(self.file_entries.allocator, dir_name, file_entry.file_name);
  216e11:	66 41 89 06          	mov    WORD PTR [r14],ax
  216e15:	c5 fc 10 44 24 42    	vmovups ymm0,YMMWORD PTR [rsp+0x42]
  216e1b:	c5 fc 10 4c 24 58    	vmovups ymm1,YMMWORD PTR [rsp+0x58]
  216e21:	c4 c1 7c 11 4e 18    	vmovups YMMWORD PTR [r14+0x18],ymm1
  216e27:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  216e2d:	eb 73                	jmp    216ea2 <LineNumberProgram_checkLineMatch+0x142>
        self.prev_address = self.address;
  216e2f:	48 89 43 48          	mov    QWORD PTR [rbx+0x48],rax
        self.prev_file = self.file;
  216e33:	c5 f8 10 43 08       	vmovups xmm0,XMMWORD PTR [rbx+0x8]
  216e38:	c5 f8 11 43 50       	vmovups XMMWORD PTR [rbx+0x50],xmm0
        self.prev_column = self.column;
  216e3d:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  216e41:	48 89 43 60          	mov    QWORD PTR [rbx+0x60],rax
        self.prev_is_stmt = self.is_stmt;
  216e45:	8a 43 20             	mov    al,BYTE PTR [rbx+0x20]
  216e48:	88 43 68             	mov    BYTE PTR [rbx+0x68],al
        self.prev_basic_block = self.basic_block;
  216e4b:	8a 43 21             	mov    al,BYTE PTR [rbx+0x21]
  216e4e:	88 43 69             	mov    BYTE PTR [rbx+0x69],al
        self.prev_end_sequence = self.end_sequence;
  216e51:	8a 43 22             	mov    al,BYTE PTR [rbx+0x22]
  216e54:	88 43 6a             	mov    BYTE PTR [rbx+0x6a],al
        return null;
  216e57:	c5 fc 10 05 21 f8 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef821]        # 206680 <__unnamed_82+0x18>
  216e5e:	ff 
  216e5f:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  216e65:	c5 fc 10 05 fb f7 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef7fb]        # 206668 <__unnamed_82>
  216e6c:	ff 
  216e6d:	eb 2e                	jmp    216e9d <LineNumberProgram_checkLineMatch+0x13d>
  216e6f:	c5 fc 10 05 d1 f7 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef7d1]        # 206648 <__unnamed_83+0x18>
  216e76:	ff 
  216e77:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  216e7d:	c5 fc 10 05 ab f7 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef7ab]        # 206630 <__unnamed_83>
  216e84:	ff 
  216e85:	eb 16                	jmp    216e9d <LineNumberProgram_checkLineMatch+0x13d>
                return error.MissingDebugInfo;
  216e87:	c5 fc 10 05 81 f7 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef781]        # 206610 <__unnamed_84+0x18>
  216e8e:	ff 
  216e8f:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  216e95:	c5 fc 10 05 5b f7 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef75b]        # 2065f8 <__unnamed_84>
  216e9c:	ff 
  216e9d:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  216ea2:	48 83 c4 78          	add    rsp,0x78
  216ea6:	5b                   	pop    rbx
  216ea7:	41 5c                	pop    r12
  216ea9:	41 5d                	pop    r13
  216eab:	41 5e                	pop    r14
  216ead:	41 5f                	pop    r15
  216eaf:	5d                   	pop    rbp
  216eb0:	c5 f8 77             	vzeroupper 
  216eb3:	c3                   	ret    
  216eb4:	45 31 ff             	xor    r15d,r15d
    assert(dest.len >= source.len);
  216eb7:	4d 39 e7             	cmp    r15,r12
    if (!ok) {
  216eba:	73 28                	jae    216ee4 <LineNumberProgram_checkLineMatch+0x184>
  216ebc:	e9 c6 05 00 00       	jmp    217487 <LineNumberProgram_checkLineMatch+0x727>
        assert(byte_slice.len == byte_count);
  216ec1:	4c 39 7c 24 38       	cmp    QWORD PTR [rsp+0x38],r15
  216ec6:	0f 85 bb 05 00 00    	jne    217487 <LineNumberProgram_checkLineMatch+0x727>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  216ecc:	48 8b 6c 24 30       	mov    rbp,QWORD PTR [rsp+0x30]
  216ed1:	4c 8b 4c 24 20       	mov    r9,QWORD PTR [rsp+0x20]
  216ed6:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
    assert(dest.len >= source.len);
  216edb:	4d 39 e7             	cmp    r15,r12
  216ede:	0f 82 a3 05 00 00    	jb     217487 <LineNumberProgram_checkLineMatch+0x727>
    for (source) |s, i|
  216ee4:	4d 85 e4             	test   r12,r12
  216ee7:	0f 84 77 02 00 00    	je     217164 <LineNumberProgram_checkLineMatch+0x404>
  216eed:	49 81 fc 80 00 00 00 	cmp    r12,0x80
  216ef4:	72 1a                	jb     216f10 <LineNumberProgram_checkLineMatch+0x1b0>
  216ef6:	4b 8d 0c 2c          	lea    rcx,[r12+r13*1]
  216efa:	48 39 cd             	cmp    rbp,rcx
  216efd:	0f 83 ab 00 00 00    	jae    216fae <LineNumberProgram_checkLineMatch+0x24e>
  216f03:	49 8d 0c 2c          	lea    rcx,[r12+rbp*1]
  216f07:	49 39 cd             	cmp    r13,rcx
  216f0a:	0f 83 9e 00 00 00    	jae    216fae <LineNumberProgram_checkLineMatch+0x24e>
  216f10:	31 c9                	xor    ecx,ecx
  216f12:	49 8d 7c 24 ff       	lea    rdi,[r12-0x1]
  216f17:	48 29 cf             	sub    rdi,rcx
  216f1a:	4c 89 e6             	mov    rsi,r12
  216f1d:	48 83 e6 07          	and    rsi,0x7
  216f21:	74 21                	je     216f44 <LineNumberProgram_checkLineMatch+0x1e4>
  216f23:	48 f7 de             	neg    rsi
  216f26:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  216f2d:	00 00 00 
  216f30:	41 0f b6 54 0d 00    	movzx  edx,BYTE PTR [r13+rcx*1+0x0]
        dest[i] = s;
  216f36:	88 54 0d 00          	mov    BYTE PTR [rbp+rcx*1+0x0],dl
    for (source) |s, i|
  216f3a:	48 83 c1 01          	add    rcx,0x1
  216f3e:	48 83 c6 01          	add    rsi,0x1
  216f42:	75 ec                	jne    216f30 <LineNumberProgram_checkLineMatch+0x1d0>
  216f44:	48 83 ff 07          	cmp    rdi,0x7
  216f48:	0f 82 16 02 00 00    	jb     217164 <LineNumberProgram_checkLineMatch+0x404>
  216f4e:	66 90                	xchg   ax,ax
  216f50:	41 0f b6 54 0d 00    	movzx  edx,BYTE PTR [r13+rcx*1+0x0]
        dest[i] = s;
  216f56:	88 54 0d 00          	mov    BYTE PTR [rbp+rcx*1+0x0],dl
    for (source) |s, i|
  216f5a:	41 0f b6 54 0d 01    	movzx  edx,BYTE PTR [r13+rcx*1+0x1]
        dest[i] = s;
  216f60:	88 54 0d 01          	mov    BYTE PTR [rbp+rcx*1+0x1],dl
    for (source) |s, i|
  216f64:	41 0f b6 54 0d 02    	movzx  edx,BYTE PTR [r13+rcx*1+0x2]
        dest[i] = s;
  216f6a:	88 54 0d 02          	mov    BYTE PTR [rbp+rcx*1+0x2],dl
    for (source) |s, i|
  216f6e:	41 0f b6 54 0d 03    	movzx  edx,BYTE PTR [r13+rcx*1+0x3]
        dest[i] = s;
  216f74:	88 54 0d 03          	mov    BYTE PTR [rbp+rcx*1+0x3],dl
    for (source) |s, i|
  216f78:	41 0f b6 54 0d 04    	movzx  edx,BYTE PTR [r13+rcx*1+0x4]
        dest[i] = s;
  216f7e:	88 54 0d 04          	mov    BYTE PTR [rbp+rcx*1+0x4],dl
    for (source) |s, i|
  216f82:	41 0f b6 54 0d 05    	movzx  edx,BYTE PTR [r13+rcx*1+0x5]
        dest[i] = s;
  216f88:	88 54 0d 05          	mov    BYTE PTR [rbp+rcx*1+0x5],dl
    for (source) |s, i|
  216f8c:	41 0f b6 54 0d 06    	movzx  edx,BYTE PTR [r13+rcx*1+0x6]
        dest[i] = s;
  216f92:	88 54 0d 06          	mov    BYTE PTR [rbp+rcx*1+0x6],dl
    for (source) |s, i|
  216f96:	41 0f b6 54 0d 07    	movzx  edx,BYTE PTR [r13+rcx*1+0x7]
        dest[i] = s;
  216f9c:	88 54 0d 07          	mov    BYTE PTR [rbp+rcx*1+0x7],dl
    for (source) |s, i|
  216fa0:	48 83 c1 08          	add    rcx,0x8
  216fa4:	49 39 cc             	cmp    r12,rcx
  216fa7:	75 a7                	jne    216f50 <LineNumberProgram_checkLineMatch+0x1f0>
  216fa9:	e9 b6 01 00 00       	jmp    217164 <LineNumberProgram_checkLineMatch+0x404>
  216fae:	4c 89 e1             	mov    rcx,r12
  216fb1:	48 83 e1 80          	and    rcx,0xffffffffffffff80
  216fb5:	48 8d 79 80          	lea    rdi,[rcx-0x80]
  216fb9:	48 89 fe             	mov    rsi,rdi
  216fbc:	48 c1 ee 07          	shr    rsi,0x7
  216fc0:	8d 56 01             	lea    edx,[rsi+0x1]
  216fc3:	83 e2 03             	and    edx,0x3
  216fc6:	48 81 ff 80 01 00 00 	cmp    rdi,0x180
  216fcd:	73 10                	jae    216fdf <LineNumberProgram_checkLineMatch+0x27f>
  216fcf:	31 f6                	xor    esi,esi
  216fd1:	48 85 d2             	test   rdx,rdx
  216fd4:	0f 85 3c 01 00 00    	jne    217116 <LineNumberProgram_checkLineMatch+0x3b6>
  216fda:	e9 7c 01 00 00       	jmp    21715b <LineNumberProgram_checkLineMatch+0x3fb>
  216fdf:	48 8d 7a ff          	lea    rdi,[rdx-0x1]
  216fe3:	48 29 f7             	sub    rdi,rsi
  216fe6:	31 f6                	xor    esi,esi
  216fe8:	c4 c1 7c 10 44 35 00 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x0]
  216fef:	c4 c1 7c 10 4c 35 20 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x20]
  216ff6:	c4 c1 7c 10 54 35 40 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0x40]
  216ffd:	c4 c1 7c 10 5c 35 60 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x60]
        dest[i] = s;
  217004:	c5 fc 11 44 35 00    	vmovups YMMWORD PTR [rbp+rsi*1+0x0],ymm0
  21700a:	c5 fc 11 4c 35 20    	vmovups YMMWORD PTR [rbp+rsi*1+0x20],ymm1
  217010:	c5 fc 11 54 35 40    	vmovups YMMWORD PTR [rbp+rsi*1+0x40],ymm2
  217016:	c5 fc 11 5c 35 60    	vmovups YMMWORD PTR [rbp+rsi*1+0x60],ymm3
    for (source) |s, i|
  21701c:	c4 c1 7c 10 84 35 80 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x80]
  217023:	00 00 00 
  217026:	c4 c1 7c 10 8c 35 a0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0xa0]
  21702d:	00 00 00 
  217030:	c4 c1 7c 10 94 35 c0 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0xc0]
  217037:	00 00 00 
  21703a:	c4 c1 7c 10 9c 35 e0 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0xe0]
  217041:	00 00 00 
        dest[i] = s;
  217044:	c5 fc 11 84 35 80 00 	vmovups YMMWORD PTR [rbp+rsi*1+0x80],ymm0
  21704b:	00 00 
  21704d:	c5 fc 11 8c 35 a0 00 	vmovups YMMWORD PTR [rbp+rsi*1+0xa0],ymm1
  217054:	00 00 
  217056:	c5 fc 11 94 35 c0 00 	vmovups YMMWORD PTR [rbp+rsi*1+0xc0],ymm2
  21705d:	00 00 
  21705f:	c5 fc 11 9c 35 e0 00 	vmovups YMMWORD PTR [rbp+rsi*1+0xe0],ymm3
  217066:	00 00 
    for (source) |s, i|
  217068:	c4 c1 7c 10 84 35 00 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x100]
  21706f:	01 00 00 
  217072:	c4 c1 7c 10 8c 35 20 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x120]
  217079:	01 00 00 
  21707c:	c4 c1 7c 10 94 35 40 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0x140]
  217083:	01 00 00 
  217086:	c4 c1 7c 10 9c 35 60 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x160]
  21708d:	01 00 00 
        dest[i] = s;
  217090:	c5 fc 11 84 35 00 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x100],ymm0
  217097:	00 00 
  217099:	c5 fc 11 8c 35 20 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x120],ymm1
  2170a0:	00 00 
  2170a2:	c5 fc 11 94 35 40 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x140],ymm2
  2170a9:	00 00 
  2170ab:	c5 fc 11 9c 35 60 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x160],ymm3
  2170b2:	00 00 
    for (source) |s, i|
  2170b4:	c4 c1 7c 10 84 35 80 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x180]
  2170bb:	01 00 00 
  2170be:	c4 c1 7c 10 8c 35 a0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x1a0]
  2170c5:	01 00 00 
  2170c8:	c4 c1 7c 10 94 35 c0 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0x1c0]
  2170cf:	01 00 00 
  2170d2:	c4 c1 7c 10 9c 35 e0 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x1e0]
  2170d9:	01 00 00 
        dest[i] = s;
  2170dc:	c5 fc 11 84 35 80 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x180],ymm0
  2170e3:	00 00 
  2170e5:	c5 fc 11 8c 35 a0 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x1a0],ymm1
  2170ec:	00 00 
  2170ee:	c5 fc 11 94 35 c0 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x1c0],ymm2
  2170f5:	00 00 
  2170f7:	c5 fc 11 9c 35 e0 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x1e0],ymm3
  2170fe:	00 00 
    for (source) |s, i|
  217100:	48 81 c6 00 02 00 00 	add    rsi,0x200
  217107:	48 83 c7 04          	add    rdi,0x4
  21710b:	0f 85 d7 fe ff ff    	jne    216fe8 <LineNumberProgram_checkLineMatch+0x288>
  217111:	48 85 d2             	test   rdx,rdx
  217114:	74 45                	je     21715b <LineNumberProgram_checkLineMatch+0x3fb>
  217116:	48 83 c6 60          	add    rsi,0x60
  21711a:	48 f7 da             	neg    rdx
  21711d:	c4 c1 7c 10 44 35 a0 	vmovups ymm0,YMMWORD PTR [r13+rsi*1-0x60]
  217124:	c4 c1 7c 10 4c 35 c0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1-0x40]
  21712b:	c4 c1 7c 10 54 35 e0 	vmovups ymm2,YMMWORD PTR [r13+rsi*1-0x20]
  217132:	c4 c1 7c 10 5c 35 00 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x0]
        dest[i] = s;
  217139:	c5 fc 11 44 35 a0    	vmovups YMMWORD PTR [rbp+rsi*1-0x60],ymm0
  21713f:	c5 fc 11 4c 35 c0    	vmovups YMMWORD PTR [rbp+rsi*1-0x40],ymm1
  217145:	c5 fc 11 54 35 e0    	vmovups YMMWORD PTR [rbp+rsi*1-0x20],ymm2
  21714b:	c5 fc 11 5c 35 00    	vmovups YMMWORD PTR [rbp+rsi*1+0x0],ymm3
    for (source) |s, i|
  217151:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  217155:	48 83 c2 01          	add    rdx,0x1
  217159:	75 c2                	jne    21711d <LineNumberProgram_checkLineMatch+0x3bd>
  21715b:	49 39 cc             	cmp    r12,rcx
  21715e:	0f 85 ae fd ff ff    	jne    216f12 <LineNumberProgram_checkLineMatch+0x1b2>
  217164:	4b 8d 0c d1          	lea    rcx,[r9+r10*8]
  217168:	48 83 c1 08          	add    rcx,0x8
        const arg = ([]const u8)(strings[string_i]);
        string_i += 1;
        copy(u8, buf[buf_index..], arg);
        buf_index += arg.len;
        if (string_i >= strings.len) break;
        if (buf[buf_index - 1] != sep) {
  21716c:	42 80 7c 25 ff 2f    	cmp    BYTE PTR [rbp+r12*1-0x1],0x2f
  217172:	74 0a                	je     21717e <LineNumberProgram_checkLineMatch+0x41e>
            buf[buf_index] = sep;
  217174:	42 c6 44 25 00 2f    	mov    BYTE PTR [rbp+r12*1+0x0],0x2f
            buf_index += 1;
  21717a:	49 83 c4 01          	add    r12,0x1
        const arg = ([]const u8)(strings[string_i]);
  21717e:	4c 8b 01             	mov    r8,QWORD PTR [rcx]
        copy(u8, buf[buf_index..], arg);
  217181:	4d 29 e7             	sub    r15,r12
    assert(dest.len >= source.len);
  217184:	4d 39 c7             	cmp    r15,r8
  217187:	0f 82 fa 02 00 00    	jb     217487 <LineNumberProgram_checkLineMatch+0x727>
    for (source) |s, i|
  21718d:	4d 85 c0             	test   r8,r8
  217190:	0f 84 7a 02 00 00    	je     217410 <LineNumberProgram_checkLineMatch+0x6b0>
  217196:	4b 8b 14 d1          	mov    rdx,QWORD PTR [r9+r10*8]
  21719a:	4d 8d 0c 2c          	lea    r9,[r12+rbp*1]
  21719e:	49 81 f8 80 00 00 00 	cmp    r8,0x80
  2171a5:	72 1d                	jb     2171c4 <LineNumberProgram_checkLineMatch+0x464>
  2171a7:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  2171ab:	49 39 c9             	cmp    r9,rcx
  2171ae:	0f 83 b0 00 00 00    	jae    217264 <LineNumberProgram_checkLineMatch+0x504>
  2171b4:	4b 8d 0c 04          	lea    rcx,[r12+r8*1]
  2171b8:	48 01 e9             	add    rcx,rbp
  2171bb:	48 39 ca             	cmp    rdx,rcx
  2171be:	0f 83 a0 00 00 00    	jae    217264 <LineNumberProgram_checkLineMatch+0x504>
  2171c4:	31 f6                	xor    esi,esi
  2171c6:	49 8d 40 ff          	lea    rax,[r8-0x1]
  2171ca:	48 29 f0             	sub    rax,rsi
  2171cd:	4c 89 c7             	mov    rdi,r8
  2171d0:	48 83 e7 07          	and    rdi,0x7
  2171d4:	74 1c                	je     2171f2 <LineNumberProgram_checkLineMatch+0x492>
  2171d6:	48 f7 df             	neg    rdi
  2171d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  2171e0:	0f b6 0c 32          	movzx  ecx,BYTE PTR [rdx+rsi*1]
        dest[i] = s;
  2171e4:	41 88 0c 31          	mov    BYTE PTR [r9+rsi*1],cl
    for (source) |s, i|
  2171e8:	48 83 c6 01          	add    rsi,0x1
  2171ec:	48 83 c7 01          	add    rdi,0x1
  2171f0:	75 ee                	jne    2171e0 <LineNumberProgram_checkLineMatch+0x480>
  2171f2:	48 83 f8 07          	cmp    rax,0x7
  2171f6:	0f 82 14 02 00 00    	jb     217410 <LineNumberProgram_checkLineMatch+0x6b0>
  2171fc:	49 8d 0c 2c          	lea    rcx,[r12+rbp*1]
  217200:	48 83 c1 07          	add    rcx,0x7
  217204:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21720b:	00 00 00 00 00 
  217210:	0f b6 04 32          	movzx  eax,BYTE PTR [rdx+rsi*1]
        dest[i] = s;
  217214:	88 44 31 f9          	mov    BYTE PTR [rcx+rsi*1-0x7],al
    for (source) |s, i|
  217218:	0f b6 44 32 01       	movzx  eax,BYTE PTR [rdx+rsi*1+0x1]
        dest[i] = s;
  21721d:	88 44 31 fa          	mov    BYTE PTR [rcx+rsi*1-0x6],al
    for (source) |s, i|
  217221:	0f b6 44 32 02       	movzx  eax,BYTE PTR [rdx+rsi*1+0x2]
        dest[i] = s;
  217226:	88 44 31 fb          	mov    BYTE PTR [rcx+rsi*1-0x5],al
    for (source) |s, i|
  21722a:	0f b6 44 32 03       	movzx  eax,BYTE PTR [rdx+rsi*1+0x3]
        dest[i] = s;
  21722f:	88 44 31 fc          	mov    BYTE PTR [rcx+rsi*1-0x4],al
    for (source) |s, i|
  217233:	0f b6 44 32 04       	movzx  eax,BYTE PTR [rdx+rsi*1+0x4]
        dest[i] = s;
  217238:	88 44 31 fd          	mov    BYTE PTR [rcx+rsi*1-0x3],al
    for (source) |s, i|
  21723c:	0f b6 44 32 05       	movzx  eax,BYTE PTR [rdx+rsi*1+0x5]
        dest[i] = s;
  217241:	88 44 31 fe          	mov    BYTE PTR [rcx+rsi*1-0x2],al
    for (source) |s, i|
  217245:	0f b6 44 32 06       	movzx  eax,BYTE PTR [rdx+rsi*1+0x6]
        dest[i] = s;
  21724a:	88 44 31 ff          	mov    BYTE PTR [rcx+rsi*1-0x1],al
    for (source) |s, i|
  21724e:	0f b6 44 32 07       	movzx  eax,BYTE PTR [rdx+rsi*1+0x7]
        dest[i] = s;
  217253:	88 04 31             	mov    BYTE PTR [rcx+rsi*1],al
    for (source) |s, i|
  217256:	48 83 c6 08          	add    rsi,0x8
  21725a:	49 39 f0             	cmp    r8,rsi
  21725d:	75 b1                	jne    217210 <LineNumberProgram_checkLineMatch+0x4b0>
  21725f:	e9 ac 01 00 00       	jmp    217410 <LineNumberProgram_checkLineMatch+0x6b0>
  217264:	4c 89 c6             	mov    rsi,r8
  217267:	48 83 e6 80          	and    rsi,0xffffffffffffff80
  21726b:	48 8d 7e 80          	lea    rdi,[rsi-0x80]
  21726f:	48 89 f9             	mov    rcx,rdi
  217272:	48 c1 e9 07          	shr    rcx,0x7
  217276:	44 8d 51 01          	lea    r10d,[rcx+0x1]
  21727a:	41 83 e2 03          	and    r10d,0x3
  21727e:	48 81 ff 80 01 00 00 	cmp    rdi,0x180
  217285:	73 10                	jae    217297 <LineNumberProgram_checkLineMatch+0x537>
  217287:	31 c9                	xor    ecx,ecx
  217289:	4d 85 d2             	test   r10,r10
  21728c:	0f 85 32 01 00 00    	jne    2173c4 <LineNumberProgram_checkLineMatch+0x664>
  217292:	e9 70 01 00 00       	jmp    217407 <LineNumberProgram_checkLineMatch+0x6a7>
  217297:	49 8d 3c 2c          	lea    rdi,[r12+rbp*1]
  21729b:	48 81 c7 e0 01 00 00 	add    rdi,0x1e0
  2172a2:	49 8d 42 ff          	lea    rax,[r10-0x1]
  2172a6:	48 29 c8             	sub    rax,rcx
  2172a9:	31 c9                	xor    ecx,ecx
  2172ab:	c5 fc 10 04 0a       	vmovups ymm0,YMMWORD PTR [rdx+rcx*1]
  2172b0:	c5 fc 10 4c 0a 20    	vmovups ymm1,YMMWORD PTR [rdx+rcx*1+0x20]
  2172b6:	c5 fc 10 54 0a 40    	vmovups ymm2,YMMWORD PTR [rdx+rcx*1+0x40]
  2172bc:	c5 fc 10 5c 0a 60    	vmovups ymm3,YMMWORD PTR [rdx+rcx*1+0x60]
        dest[i] = s;
  2172c2:	c5 fc 11 84 0f 20 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x1e0],ymm0
  2172c9:	ff ff 
  2172cb:	c5 fc 11 8c 0f 40 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x1c0],ymm1
  2172d2:	ff ff 
  2172d4:	c5 fc 11 94 0f 60 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x1a0],ymm2
  2172db:	ff ff 
  2172dd:	c5 fc 11 9c 0f 80 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x180],ymm3
  2172e4:	ff ff 
    for (source) |s, i|
  2172e6:	c5 fc 10 84 0a 80 00 	vmovups ymm0,YMMWORD PTR [rdx+rcx*1+0x80]
  2172ed:	00 00 
  2172ef:	c5 fc 10 8c 0a a0 00 	vmovups ymm1,YMMWORD PTR [rdx+rcx*1+0xa0]
  2172f6:	00 00 
  2172f8:	c5 fc 10 94 0a c0 00 	vmovups ymm2,YMMWORD PTR [rdx+rcx*1+0xc0]
  2172ff:	00 00 
  217301:	c5 fc 10 9c 0a e0 00 	vmovups ymm3,YMMWORD PTR [rdx+rcx*1+0xe0]
  217308:	00 00 
        dest[i] = s;
  21730a:	c5 fc 11 84 0f a0 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x160],ymm0
  217311:	ff ff 
  217313:	c5 fc 11 8c 0f c0 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x140],ymm1
  21731a:	ff ff 
  21731c:	c5 fc 11 94 0f e0 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x120],ymm2
  217323:	ff ff 
  217325:	c5 fc 11 9c 0f 00 ff 	vmovups YMMWORD PTR [rdi+rcx*1-0x100],ymm3
  21732c:	ff ff 
    for (source) |s, i|
  21732e:	c5 fc 10 84 0a 00 01 	vmovups ymm0,YMMWORD PTR [rdx+rcx*1+0x100]
  217335:	00 00 
  217337:	c5 fc 10 8c 0a 20 01 	vmovups ymm1,YMMWORD PTR [rdx+rcx*1+0x120]
  21733e:	00 00 
  217340:	c5 fc 10 94 0a 40 01 	vmovups ymm2,YMMWORD PTR [rdx+rcx*1+0x140]
  217347:	00 00 
  217349:	c5 fc 10 9c 0a 60 01 	vmovups ymm3,YMMWORD PTR [rdx+rcx*1+0x160]
  217350:	00 00 
        dest[i] = s;
  217352:	c5 fc 11 84 0f 20 ff 	vmovups YMMWORD PTR [rdi+rcx*1-0xe0],ymm0
  217359:	ff ff 
  21735b:	c5 fc 11 8c 0f 40 ff 	vmovups YMMWORD PTR [rdi+rcx*1-0xc0],ymm1
  217362:	ff ff 
  217364:	c5 fc 11 94 0f 60 ff 	vmovups YMMWORD PTR [rdi+rcx*1-0xa0],ymm2
  21736b:	ff ff 
  21736d:	c5 fc 11 5c 0f 80    	vmovups YMMWORD PTR [rdi+rcx*1-0x80],ymm3
    for (source) |s, i|
  217373:	c5 fc 10 84 0a 80 01 	vmovups ymm0,YMMWORD PTR [rdx+rcx*1+0x180]
  21737a:	00 00 
  21737c:	c5 fc 10 8c 0a a0 01 	vmovups ymm1,YMMWORD PTR [rdx+rcx*1+0x1a0]
  217383:	00 00 
  217385:	c5 fc 10 94 0a c0 01 	vmovups ymm2,YMMWORD PTR [rdx+rcx*1+0x1c0]
  21738c:	00 00 
  21738e:	c5 fc 10 9c 0a e0 01 	vmovups ymm3,YMMWORD PTR [rdx+rcx*1+0x1e0]
  217395:	00 00 
        dest[i] = s;
  217397:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  21739d:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  2173a3:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  2173a9:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
    for (source) |s, i|
  2173ae:	48 81 c1 00 02 00 00 	add    rcx,0x200
  2173b5:	48 83 c0 04          	add    rax,0x4
  2173b9:	0f 85 ec fe ff ff    	jne    2172ab <LineNumberProgram_checkLineMatch+0x54b>
  2173bf:	4d 85 d2             	test   r10,r10
  2173c2:	74 43                	je     217407 <LineNumberProgram_checkLineMatch+0x6a7>
  2173c4:	48 83 c1 60          	add    rcx,0x60
  2173c8:	49 f7 da             	neg    r10
  2173cb:	c5 fc 10 44 0a a0    	vmovups ymm0,YMMWORD PTR [rdx+rcx*1-0x60]
  2173d1:	c5 fc 10 4c 0a c0    	vmovups ymm1,YMMWORD PTR [rdx+rcx*1-0x40]
  2173d7:	c5 fc 10 54 0a e0    	vmovups ymm2,YMMWORD PTR [rdx+rcx*1-0x20]
  2173dd:	c5 fc 10 1c 0a       	vmovups ymm3,YMMWORD PTR [rdx+rcx*1]
        dest[i] = s;
  2173e2:	c4 c1 7c 11 44 09 a0 	vmovups YMMWORD PTR [r9+rcx*1-0x60],ymm0
  2173e9:	c4 c1 7c 11 4c 09 c0 	vmovups YMMWORD PTR [r9+rcx*1-0x40],ymm1
  2173f0:	c4 c1 7c 11 54 09 e0 	vmovups YMMWORD PTR [r9+rcx*1-0x20],ymm2
  2173f7:	c4 c1 7c 11 1c 09    	vmovups YMMWORD PTR [r9+rcx*1],ymm3
    for (source) |s, i|
  2173fd:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  217401:	49 83 c2 01          	add    r10,0x1
  217405:	75 c4                	jne    2173cb <LineNumberProgram_checkLineMatch+0x66b>
  217407:	49 39 f0             	cmp    r8,rsi
  21740a:	0f 85 b6 fd ff ff    	jne    2171c6 <LineNumberProgram_checkLineMatch+0x466>
        buf_index += arg.len;
  217410:	4d 01 e0             	add    r8,r12
                .allocator = self.file_entries.allocator,
  217413:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
                .line = if (self.prev_line >= 0) @intCast(usize, self.prev_line) else 0,
  217417:	48 8b 4b 58          	mov    rcx,QWORD PTR [rbx+0x58]
  21741b:	48 89 ca             	mov    rdx,rcx
  21741e:	48 c1 fa 3f          	sar    rdx,0x3f
  217422:	c4 e2 e8 f2 c9       	andn   rcx,rdx,rcx
                .column = self.prev_column,
  217427:	48 8b 53 60          	mov    rdx,QWORD PTR [rbx+0x60]
                .allocator = self.file_entries.allocator,
  21742b:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
            return LineInfo{
  21742f:	c6 44 24 0a 01       	mov    BYTE PTR [rsp+0xa],0x1
  217434:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  21743a:	0f b7 74 24 16       	movzx  esi,WORD PTR [rsp+0x16]
  21743f:	66 41 89 76 06       	mov    WORD PTR [r14+0x6],si
  217444:	8b 74 24 12          	mov    esi,DWORD PTR [rsp+0x12]
  217448:	41 89 76 02          	mov    DWORD PTR [r14+0x2],esi
  21744c:	49 89 4e 08          	mov    QWORD PTR [r14+0x8],rcx
  217450:	49 89 56 10          	mov    QWORD PTR [r14+0x10],rdx
  217454:	49 89 6e 18          	mov    QWORD PTR [r14+0x18],rbp
  217458:	4d 89 46 20          	mov    QWORD PTR [r14+0x20],r8
  21745c:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
  217460:	8a 44 24 0a          	mov    al,BYTE PTR [rsp+0xa]
  217464:	41 88 46 30          	mov    BYTE PTR [r14+0x30],al
  217468:	8a 44 24 11          	mov    al,BYTE PTR [rsp+0x11]
  21746c:	41 88 46 37          	mov    BYTE PTR [r14+0x37],al
  217470:	0f b7 44 24 0f       	movzx  eax,WORD PTR [rsp+0xf]
  217475:	66 41 89 46 35       	mov    WORD PTR [r14+0x35],ax
  21747a:	8b 44 24 0b          	mov    eax,DWORD PTR [rsp+0xb]
  21747e:	41 89 46 31          	mov    DWORD PTR [r14+0x31],eax
  217482:	e9 1b fa ff ff       	jmp    216ea2 <LineNumberProgram_checkLineMatch+0x142>
            @panic("assertion failure");
  217487:	c5 f8 77             	vzeroupper 
  21748a:	e8 21 28 ff ff       	call   209cb0 <panic>
  21748f:	90                   	nop

0000000000217490 <Allocator_alignedRealloc.76>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  217490:	41 56                	push   r14
  217492:	53                   	push   rbx
  217493:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21749a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21749d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  2174a1:	48 85 c0             	test   rax,rax
  2174a4:	74 5e                	je     217504 <Allocator_alignedRealloc.76+0x74>
        if (n == 0) {
  2174a6:	48 85 c9             	test   rcx,rcx
  2174a9:	0f 84 a6 00 00 00    	je     217555 <Allocator_alignedRealloc.76+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  2174af:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  2174b2:	48 c1 e0 04          	shl    rax,0x4
  2174b6:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  2174bb:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  2174c0:	ba 10 00 00 00       	mov    edx,0x10
  2174c5:	48 89 c8             	mov    rax,rcx
  2174c8:	48 f7 e2             	mul    rdx
  2174cb:	0f 81 ca 00 00 00    	jno    21759b <Allocator_alignedRealloc.76+0x10b>
  2174d1:	48 8d 0d f8 92 fe ff 	lea    rcx,[rip+0xfffffffffffe92f8]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2174d8:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2174dc:	0f 84 d4 00 00 00    	je     2175b6 <Allocator_alignedRealloc.76+0x126>
  2174e2:	48 8b 05 d7 f0 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffef0d7]        # 2065c0 <__unnamed_85+0x10>
  2174e9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2174ed:	c5 f8 10 05 bb f0 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffef0bb]        # 2065b0 <__unnamed_85>
  2174f4:	ff 
  2174f5:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2174f9:	48 81 c4 88 00 00 00 	add    rsp,0x88
  217500:	5b                   	pop    rbx
  217501:	41 5e                	pop    r14
  217503:	c3                   	ret    
        if (n == 0) {
  217504:	48 85 c9             	test   rcx,rcx
  217507:	0f 84 f6 00 00 00    	je     217603 <Allocator_alignedRealloc.76+0x173>
  21750d:	ba 10 00 00 00       	mov    edx,0x10
  217512:	48 89 c8             	mov    rax,rcx
  217515:	48 f7 e2             	mul    rdx
  217518:	0f 81 07 01 00 00    	jno    217625 <Allocator_alignedRealloc.76+0x195>
  21751e:	48 8d 0d ab 92 fe ff 	lea    rcx,[rip+0xfffffffffffe92ab]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  217525:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  217529:	0f 84 11 01 00 00    	je     217640 <Allocator_alignedRealloc.76+0x1b0>
  21752f:	0f b7 05 80 f0 fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffef080]        # 2065b6 <__unnamed_85+0x6>
  217536:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21753b:	8b 05 71 f0 fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffef071]        # 2065b2 <__unnamed_85+0x2>
  217541:	89 04 24             	mov    DWORD PTR [rsp],eax
  217544:	48 89 e0             	mov    rax,rsp
  217547:	66 b9 05 00          	mov    cx,0x5
  21754b:	31 d2                	xor    edx,edx
  21754d:	45 31 f6             	xor    r14d,r14d
  217550:	e9 6f 01 00 00       	jmp    2176c4 <Allocator_alignedRealloc.76+0x234>
        const bytes = @sliceToBytes(memory);
  217555:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  217559:	74 1e                	je     217579 <Allocator_alignedRealloc.76+0xe9>
        const bytes = @sliceToBytes(memory);
  21755b:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21755e:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  217562:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  217567:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21756c:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  217571:	48 89 f7             	mov    rdi,rsi
  217574:	48 89 c6             	mov    rsi,rax
  217577:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  217579:	48 8b 05 28 f0 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffef028]        # 2065a8 <__unnamed_86+0x10>
  217580:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  217584:	c5 f8 10 05 0c f0 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffef00c]        # 206598 <__unnamed_86>
  21758b:	ff 
  21758c:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  217590:	48 81 c4 88 00 00 00 	add    rsp,0x88
  217597:	5b                   	pop    rbx
  217598:	41 5e                	pop    r14
  21759a:	c3                   	ret    
  21759b:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  2175a0:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  2175a7:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2175ac:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2175b0:	0f 85 2c ff ff ff    	jne    2174e2 <Allocator_alignedRealloc.76+0x52>
  2175b6:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2175ba:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  2175bf:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2175c4:	41 b8 08 00 00 00    	mov    r8d,0x8
  2175ca:	4c 89 f1             	mov    rcx,r14
  2175cd:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  2175d0:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  2175d5:	66 85 c0             	test   ax,ax
  2175d8:	0f 84 95 00 00 00    	je     217673 <Allocator_alignedRealloc.76+0x1e3>
  2175de:	66 89 03             	mov    WORD PTR [rbx],ax
  2175e1:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2175e8:	00 
  2175e9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2175ed:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  2175f3:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  2175f8:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2175ff:	5b                   	pop    rbx
  217600:	41 5e                	pop    r14
  217602:	c3                   	ret    
  217603:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  217606:	0f b7 0d 91 ef fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffeef91]        # 20659e <__unnamed_86+0x6>
  21760d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  217612:	8b 0d 82 ef fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffeef82]        # 20659a <__unnamed_86+0x2>
  217618:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  21761b:	31 c9                	xor    ecx,ecx
  21761d:	45 31 f6             	xor    r14d,r14d
  217620:	e9 9f 00 00 00       	jmp    2176c4 <Allocator_alignedRealloc.76+0x234>
  217625:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  21762a:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  217631:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  217636:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21763a:	0f 85 ef fe ff ff    	jne    21752f <Allocator_alignedRealloc.76+0x9f>
  217640:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  217644:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  217649:	b9 08 00 00 00       	mov    ecx,0x8
  21764e:	4c 89 f2             	mov    rdx,r14
  217651:	ff 16                	call   QWORD PTR [rsi]
  217653:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  217658:	66 85 c9             	test   cx,cx
  21765b:	74 41                	je     21769e <Allocator_alignedRealloc.76+0x20e>
  21765d:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  217662:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  217667:	48 89 e0             	mov    rax,rsp
  21766a:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  21766e:	89 14 24             	mov    DWORD PTR [rsp],edx
  217671:	eb 51                	jmp    2176c4 <Allocator_alignedRealloc.76+0x234>
        assert(byte_slice.len == byte_count);
  217673:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  217678:	75 6d                	jne    2176e7 <Allocator_alignedRealloc.76+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21767a:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21767f:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  217684:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  217689:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21768d:	49 c1 ee 04          	shr    r14,0x4
  217691:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  217695:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  217698:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21769c:	eb 3a                	jmp    2176d8 <Allocator_alignedRealloc.76+0x248>
        assert(byte_slice.len == byte_count);
  21769e:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  2176a3:	75 42                	jne    2176e7 <Allocator_alignedRealloc.76+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2176a5:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2176aa:	49 c1 ee 04          	shr    r14,0x4
  2176ae:	48 89 e0             	mov    rax,rsp
  2176b1:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  2176b5:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2176b8:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  2176bd:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2176c2:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  2176c4:	66 89 0b             	mov    WORD PTR [rbx],cx
  2176c7:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  2176cb:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2176cf:	8b 00                	mov    eax,DWORD PTR [rax]
  2176d1:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  2176d4:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  2176d8:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  2176dc:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2176e3:	5b                   	pop    rbx
  2176e4:	41 5e                	pop    r14
  2176e6:	c3                   	ret    
            @panic("assertion failure");
  2176e7:	e8 c4 25 ff ff       	call   209cb0 <panic>
  2176ec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000002176f0 <Allocator_alignedRealloc.79>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  2176f0:	41 56                	push   r14
  2176f2:	53                   	push   rbx
  2176f3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  2176fa:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  2176fd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  217701:	48 85 c0             	test   rax,rax
  217704:	74 62                	je     217768 <Allocator_alignedRealloc.79+0x78>
        if (n == 0) {
  217706:	48 85 c9             	test   rcx,rcx
  217709:	0f 84 a9 00 00 00    	je     2177b8 <Allocator_alignedRealloc.79+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  21770f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  217712:	48 c1 e0 03          	shl    rax,0x3
  217716:	48 8d 04 80          	lea    rax,[rax+rax*4]
  21771a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21771f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  217724:	ba 28 00 00 00       	mov    edx,0x28
  217729:	48 89 c8             	mov    rax,rcx
  21772c:	48 f7 e2             	mul    rdx
  21772f:	0f 81 d0 00 00 00    	jno    217805 <Allocator_alignedRealloc.79+0x115>
  217735:	48 8d 0d 94 90 fe ff 	lea    rcx,[rip+0xfffffffffffe9094]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21773c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  217740:	0f 84 da 00 00 00    	je     217820 <Allocator_alignedRealloc.79+0x130>
  217746:	48 8b 05 a3 ee fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffeeea3]        # 2065f0 <__unnamed_87+0x10>
  21774d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  217751:	c5 f8 10 05 87 ee fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffeee87]        # 2065e0 <__unnamed_87>
  217758:	ff 
  217759:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21775d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  217764:	5b                   	pop    rbx
  217765:	41 5e                	pop    r14
  217767:	c3                   	ret    
        if (n == 0) {
  217768:	48 85 c9             	test   rcx,rcx
  21776b:	0f 84 fc 00 00 00    	je     21786d <Allocator_alignedRealloc.79+0x17d>
  217771:	ba 28 00 00 00       	mov    edx,0x28
  217776:	48 89 c8             	mov    rax,rcx
  217779:	48 f7 e2             	mul    rdx
  21777c:	0f 81 0c 01 00 00    	jno    21788e <Allocator_alignedRealloc.79+0x19e>
  217782:	48 8d 0d 47 90 fe ff 	lea    rcx,[rip+0xfffffffffffe9047]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  217789:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21778d:	0f 84 16 01 00 00    	je     2178a9 <Allocator_alignedRealloc.79+0x1b9>
  217793:	0f b7 05 4c ee fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffeee4c]        # 2065e6 <__unnamed_87+0x6>
  21779a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21779f:	8b 05 3d ee fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffeee3d]        # 2065e2 <__unnamed_87+0x2>
  2177a5:	89 04 24             	mov    DWORD PTR [rsp],eax
  2177a8:	48 89 e0             	mov    rax,rsp
  2177ab:	66 b9 05 00          	mov    cx,0x5
  2177af:	31 f6                	xor    esi,esi
  2177b1:	31 d2                	xor    edx,edx
  2177b3:	e9 9d 01 00 00       	jmp    217955 <Allocator_alignedRealloc.79+0x265>
        const bytes = @sliceToBytes(memory);
  2177b8:	48 c1 e0 03          	shl    rax,0x3
  2177bc:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  2177c0:	48 85 c0             	test   rax,rax
  2177c3:	74 1e                	je     2177e3 <Allocator_alignedRealloc.79+0xf3>
        const bytes = @sliceToBytes(memory);
  2177c5:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2177c8:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  2177cc:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2177d1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2177d6:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2177db:	48 89 f7             	mov    rdi,rsi
  2177de:	48 89 c6             	mov    rsi,rax
  2177e1:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  2177e3:	48 8b 05 ee ed fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffeedee]        # 2065d8 <__unnamed_88+0x10>
  2177ea:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2177ee:	c5 f8 10 05 d2 ed fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffeedd2]        # 2065c8 <__unnamed_88>
  2177f5:	ff 
  2177f6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2177fa:	48 81 c4 88 00 00 00 	add    rsp,0x88
  217801:	5b                   	pop    rbx
  217802:	41 5e                	pop    r14
  217804:	c3                   	ret    
  217805:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  21780a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  217811:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  217816:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21781a:	0f 85 26 ff ff ff    	jne    217746 <Allocator_alignedRealloc.79+0x56>
  217820:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  217824:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  217829:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21782e:	41 b8 08 00 00 00    	mov    r8d,0x8
  217834:	4c 89 f1             	mov    rcx,r14
  217837:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21783a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21783f:	66 85 c0             	test   ax,ax
  217842:	0f 84 94 00 00 00    	je     2178dc <Allocator_alignedRealloc.79+0x1ec>
  217848:	66 89 03             	mov    WORD PTR [rbx],ax
  21784b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  217852:	00 
  217853:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  217857:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  21785d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  217862:	48 81 c4 88 00 00 00 	add    rsp,0x88
  217869:	5b                   	pop    rbx
  21786a:	41 5e                	pop    r14
  21786c:	c3                   	ret    
  21786d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  217870:	0f b7 0d 57 ed fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffeed57]        # 2065ce <__unnamed_88+0x6>
  217877:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21787c:	8b 0d 48 ed fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffeed48]        # 2065ca <__unnamed_88+0x2>
  217882:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  217885:	31 c9                	xor    ecx,ecx
  217887:	31 d2                	xor    edx,edx
  217889:	e9 c7 00 00 00       	jmp    217955 <Allocator_alignedRealloc.79+0x265>
  21788e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  217893:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  21789a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21789f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2178a3:	0f 85 ea fe ff ff    	jne    217793 <Allocator_alignedRealloc.79+0xa3>
  2178a9:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2178ad:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2178b2:	b9 08 00 00 00       	mov    ecx,0x8
  2178b7:	4c 89 f2             	mov    rdx,r14
  2178ba:	ff 16                	call   QWORD PTR [rsi]
  2178bc:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  2178c1:	66 85 c9             	test   cx,cx
  2178c4:	74 57                	je     21791d <Allocator_alignedRealloc.79+0x22d>
  2178c6:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  2178cb:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2178d0:	48 89 e0             	mov    rax,rsp
  2178d3:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  2178d7:	89 14 24             	mov    DWORD PTR [rsp],edx
  2178da:	eb 79                	jmp    217955 <Allocator_alignedRealloc.79+0x265>
        assert(byte_slice.len == byte_count);
  2178dc:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  2178e1:	0f 85 91 00 00 00    	jne    217978 <Allocator_alignedRealloc.79+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2178e7:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2178ec:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  2178f3:	cc cc cc 
  2178f6:	4c 89 f2             	mov    rdx,r14
  2178f9:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  2178fe:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  217903:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  217908:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21790c:	48 c1 ea 05          	shr    rdx,0x5
  217910:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  217914:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  217917:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21791b:	eb 4c                	jmp    217969 <Allocator_alignedRealloc.79+0x279>
        assert(byte_slice.len == byte_count);
  21791d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  217922:	75 54                	jne    217978 <Allocator_alignedRealloc.79+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  217924:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  217929:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  217930:	cc cc cc 
  217933:	4c 89 f2             	mov    rdx,r14
  217936:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  21793b:	48 c1 ea 05          	shr    rdx,0x5
  21793f:	48 89 e0             	mov    rax,rsp
  217942:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  217946:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  217949:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21794e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  217953:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  217955:	66 89 0b             	mov    WORD PTR [rbx],cx
  217958:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21795c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  217960:	8b 00                	mov    eax,DWORD PTR [rax]
  217962:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  217965:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  217969:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  21796d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  217974:	5b                   	pop    rbx
  217975:	41 5e                	pop    r14
  217977:	c3                   	ret    
            @panic("assertion failure");
  217978:	e8 33 23 ff ff       	call   209cb0 <panic>
  21797d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000217980 <DirectAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  217980:	41 57                	push   r15
  217982:	41 56                	push   r14
  217984:	41 55                	push   r13
  217986:	41 54                	push   r12
  217988:	53                   	push   rbx
  217989:	48 83 ec 10          	sub    rsp,0x10
  21798d:	41 89 cc             	mov    r12d,ecx
  217990:	49 89 d6             	mov    r14,rdx
  217993:	49 89 ff             	mov    r15,rdi
  217996:	45 89 e5             	mov    r13d,r12d
  217999:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  2179a0:	31 c0                	xor    eax,eax
  2179a2:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  2179a9:	4c 89 eb             	mov    rbx,r13
  2179ac:	48 0f 42 d8          	cmovb  rbx,rax
  2179b0:	4a 8d 34 33          	lea    rsi,[rbx+r14*1]
    return asm volatile ("syscall"
  2179b4:	b8 09 00 00 00       	mov    eax,0x9
  2179b9:	bf 00 00 00 00       	mov    edi,0x0
  2179be:	ba 03 00 00 00       	mov    edx,0x3
  2179c3:	41 ba 22 00 00 00    	mov    r10d,0x22
  2179c9:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  2179d0:	45 31 c9             	xor    r9d,r9d
  2179d3:	0f 05                	syscall 
  2179d5:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  2179d8:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  2179dc:	74 55                	je     217a33 <DirectAllocator_alloc+0xb3>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  2179de:	48 85 db             	test   rbx,rbx
  2179e1:	74 6a                	je     217a4d <DirectAllocator_alloc+0xcd>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  2179e3:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  2179ea:	41 f7 d4             	not    r12d
  2179ed:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  2179f4:	49 21 cc             	and    r12,rcx
  2179f7:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  2179fa:	48 89 ce             	mov    rsi,rcx
  2179fd:	48 f7 d6             	not    rsi
  217a00:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  217a03:	b8 0b 00 00 00       	mov    eax,0xb
  217a08:	48 89 cf             	mov    rdi,rcx
  217a0b:	0f 05                	syscall 
  217a0d:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  217a13:	73 69                	jae    217a7e <DirectAllocator_alloc+0xfe>
                return @intToPtr([*]u8, aligned_addr)[0..n];
  217a15:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  217a1b:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  217a20:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  217a25:	8b 44 24 04          	mov    eax,DWORD PTR [rsp+0x4]
  217a29:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  217a2d:	4d 89 67 08          	mov    QWORD PTR [r15+0x8],r12
  217a31:	eb 36                	jmp    217a69 <DirectAllocator_alloc+0xe9>
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  217a33:	48 8b 05 0e fd fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffefd0e]        # 207748 <__unnamed_61+0x10>
  217a3a:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  217a3e:	c5 f8 10 05 f2 fc fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffefcf2]        # 207738 <__unnamed_61>
  217a45:	ff 
  217a46:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  217a4b:	eb 20                	jmp    217a6d <DirectAllocator_alloc+0xed>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  217a4d:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  217a53:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  217a58:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  217a5d:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  217a61:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  217a65:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  217a69:	4d 89 77 10          	mov    QWORD PTR [r15+0x10],r14
  217a6d:	4c 89 f8             	mov    rax,r15
  217a70:	48 83 c4 10          	add    rsp,0x10
  217a74:	5b                   	pop    rbx
  217a75:	41 5c                	pop    r12
  217a77:	41 5d                	pop    r13
  217a79:	41 5e                	pop    r14
  217a7b:	41 5f                	pop    r15
  217a7d:	c3                   	ret    
            @panic("assertion failure");
  217a7e:	e8 2d 22 ff ff       	call   209cb0 <panic>
  217a83:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  217a8a:	84 00 00 00 00 00 

0000000000217a90 <DirectAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  217a90:	55                   	push   rbp
  217a91:	41 57                	push   r15
  217a93:	41 56                	push   r14
  217a95:	41 55                	push   r13
  217a97:	41 54                	push   r12
  217a99:	53                   	push   rbx
  217a9a:	48 83 ec 28          	sub    rsp,0x28
  217a9e:	45 89 c4             	mov    r12d,r8d
  217aa1:	48 89 cb             	mov    rbx,rcx
  217aa4:	49 89 d6             	mov    r14,rdx
  217aa7:	49 89 ff             	mov    r15,rdi
                if (new_size <= old_mem.len) {
  217aaa:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  217aae:	48 39 de             	cmp    rsi,rbx
  217ab1:	0f 83 c7 00 00 00    	jae    217b7e <DirectAllocator_realloc+0xee>
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  217ab7:	45 89 e5             	mov    r13d,r12d
  217aba:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  217ac1:	31 c0                	xor    eax,eax
  217ac3:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  217aca:	4c 89 ed             	mov    rbp,r13
  217acd:	48 0f 42 e8          	cmovb  rbp,rax
  217ad1:	48 8d 74 1d 00       	lea    rsi,[rbp+rbx*1+0x0]
    return asm volatile ("syscall"
  217ad6:	b8 09 00 00 00       	mov    eax,0x9
  217adb:	bf 00 00 00 00       	mov    edi,0x0
  217ae0:	ba 03 00 00 00       	mov    edx,0x3
  217ae5:	41 ba 22 00 00 00    	mov    r10d,0x22
  217aeb:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  217af2:	45 31 c9             	xor    r9d,r9d
  217af5:	0f 05                	syscall 
  217af7:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  217afa:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  217afe:	0f 84 d2 00 00 00    	je     217bd6 <DirectAllocator_realloc+0x146>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  217b04:	48 85 ed             	test   rbp,rbp
  217b07:	74 39                	je     217b42 <DirectAllocator_realloc+0xb2>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  217b09:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  217b10:	41 f7 d4             	not    r12d
  217b13:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  217b1a:	49 21 cc             	and    r12,rcx
  217b1d:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  217b20:	48 89 ce             	mov    rsi,rcx
  217b23:	48 f7 d6             	not    rsi
  217b26:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  217b29:	b8 0b 00 00 00       	mov    eax,0xb
  217b2e:	48 89 cf             	mov    rdi,rcx
  217b31:	0f 05                	syscall 
  217b33:	4c 89 e1             	mov    rcx,r12
  217b36:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  217b3c:	0f 83 74 01 00 00    	jae    217cb6 <DirectAllocator_realloc+0x226>
    assert(dest.len >= source.len);
  217b42:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  217b46:	48 89 dd             	mov    rbp,rbx
  217b49:	48 39 de             	cmp    rsi,rbx
  217b4c:	0f 87 64 01 00 00    	ja     217cb6 <DirectAllocator_realloc+0x226>
    for (source) |s, i|
  217b52:	48 85 f6             	test   rsi,rsi
  217b55:	0f 84 29 01 00 00    	je     217c84 <DirectAllocator_realloc+0x1f4>
  217b5b:	48 8d 56 ff          	lea    rdx,[rsi-0x1]
  217b5f:	89 f0                	mov    eax,esi
  217b61:	83 e0 07             	and    eax,0x7
  217b64:	48 83 fa 07          	cmp    rdx,0x7
  217b68:	0f 83 88 00 00 00    	jae    217bf6 <DirectAllocator_realloc+0x166>
  217b6e:	31 d2                	xor    edx,edx
  217b70:	48 85 c0             	test   rax,rax
  217b73:	0f 85 f3 00 00 00    	jne    217c6c <DirectAllocator_realloc+0x1dc>
  217b79:	e9 06 01 00 00       	jmp    217c84 <DirectAllocator_realloc+0x1f4>
                    const base_addr = @ptrToInt(old_mem.ptr);
  217b7e:	49 8b 06             	mov    rax,QWORD PTR [r14]
                    const old_addr_end = base_addr + old_mem.len;
  217b81:	48 01 c6             	add    rsi,rax
                    const new_addr_end = base_addr + new_size;
  217b84:	48 8d 0c 18          	lea    rcx,[rax+rbx*1]
                    const rem = @rem(new_addr_end, os.page_size);
  217b88:	89 ca                	mov    edx,ecx
  217b8a:	81 e2 ff 0f 00 00    	and    edx,0xfff
                    const new_addr_end_rounded = new_addr_end + if (rem == 0) 0 else (os.page_size - rem);
  217b90:	bf 00 10 00 00       	mov    edi,0x1000
  217b95:	48 29 d7             	sub    rdi,rdx
  217b98:	48 85 d2             	test   rdx,rdx
  217b9b:	48 0f 44 fa          	cmove  rdi,rdx
  217b9f:	48 01 cf             	add    rdi,rcx
                    if (old_addr_end > new_addr_end_rounded) {
  217ba2:	48 29 fe             	sub    rsi,rdi
  217ba5:	76 0a                	jbe    217bb1 <DirectAllocator_realloc+0x121>
  217ba7:	b8 0b 00 00 00       	mov    eax,0xb
  217bac:	0f 05                	syscall 
                    return old_mem[0..new_size];
  217bae:	49 8b 06             	mov    rax,QWORD PTR [r14]
  217bb1:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  217bb7:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
  217bbc:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  217bc1:	8b 4c 24 0c          	mov    ecx,DWORD PTR [rsp+0xc]
  217bc5:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  217bc9:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  217bcd:	49 89 5f 10          	mov    QWORD PTR [r15+0x10],rbx
  217bd1:	e9 ce 00 00 00       	jmp    217ca4 <DirectAllocator_realloc+0x214>
                const result = try alloc(allocator, new_size, alignment);
  217bd6:	66 41 c7 07 05 00    	mov    WORD PTR [r15],0x5
  217bdc:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  217be1:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  217be5:	c5 f8 10 44 24 12    	vmovups xmm0,XMMWORD PTR [rsp+0x12]
  217beb:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  217bf1:	e9 ae 00 00 00       	jmp    217ca4 <DirectAllocator_realloc+0x214>
  217bf6:	48 29 c6             	sub    rsi,rax
  217bf9:	31 d2                	xor    edx,edx
  217bfb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  217c00:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217c03:	0f b6 1c 17          	movzx  ebx,BYTE PTR [rdi+rdx*1]
        dest[i] = s;
  217c07:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  217c0a:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217c0d:	0f b6 5c 17 01       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x1]
        dest[i] = s;
  217c12:	88 5c 11 01          	mov    BYTE PTR [rcx+rdx*1+0x1],bl
    for (source) |s, i|
  217c16:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217c19:	0f b6 5c 17 02       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x2]
        dest[i] = s;
  217c1e:	88 5c 11 02          	mov    BYTE PTR [rcx+rdx*1+0x2],bl
    for (source) |s, i|
  217c22:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217c25:	0f b6 5c 17 03       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x3]
        dest[i] = s;
  217c2a:	88 5c 11 03          	mov    BYTE PTR [rcx+rdx*1+0x3],bl
    for (source) |s, i|
  217c2e:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217c31:	0f b6 5c 17 04       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x4]
        dest[i] = s;
  217c36:	88 5c 11 04          	mov    BYTE PTR [rcx+rdx*1+0x4],bl
    for (source) |s, i|
  217c3a:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217c3d:	0f b6 5c 17 05       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x5]
        dest[i] = s;
  217c42:	88 5c 11 05          	mov    BYTE PTR [rcx+rdx*1+0x5],bl
    for (source) |s, i|
  217c46:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217c49:	0f b6 5c 17 06       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x6]
        dest[i] = s;
  217c4e:	88 5c 11 06          	mov    BYTE PTR [rcx+rdx*1+0x6],bl
    for (source) |s, i|
  217c52:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217c55:	0f b6 5c 17 07       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x7]
        dest[i] = s;
  217c5a:	88 5c 11 07          	mov    BYTE PTR [rcx+rdx*1+0x7],bl
    for (source) |s, i|
  217c5e:	48 83 c2 08          	add    rdx,0x8
  217c62:	48 39 d6             	cmp    rsi,rdx
  217c65:	75 99                	jne    217c00 <DirectAllocator_realloc+0x170>
  217c67:	48 85 c0             	test   rax,rax
  217c6a:	74 18                	je     217c84 <DirectAllocator_realloc+0x1f4>
  217c6c:	48 f7 d8             	neg    rax
  217c6f:	90                   	nop
  217c70:	49 8b 36             	mov    rsi,QWORD PTR [r14]
  217c73:	0f b6 1c 16          	movzx  ebx,BYTE PTR [rsi+rdx*1]
        dest[i] = s;
  217c77:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  217c7a:	48 83 c2 01          	add    rdx,0x1
  217c7e:	48 83 c0 01          	add    rax,0x1
  217c82:	75 ec                	jne    217c70 <DirectAllocator_realloc+0x1e0>
                return result;
  217c84:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  217c8a:	0f b7 44 24 0a       	movzx  eax,WORD PTR [rsp+0xa]
  217c8f:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  217c94:	8b 44 24 06          	mov    eax,DWORD PTR [rsp+0x6]
  217c98:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  217c9c:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  217ca0:	49 89 6f 10          	mov    QWORD PTR [r15+0x10],rbp
  217ca4:	4c 89 f8             	mov    rax,r15
  217ca7:	48 83 c4 28          	add    rsp,0x28
  217cab:	5b                   	pop    rbx
  217cac:	41 5c                	pop    r12
  217cae:	41 5d                	pop    r13
  217cb0:	41 5e                	pop    r14
  217cb2:	41 5f                	pop    r15
  217cb4:	5d                   	pop    rbp
  217cb5:	c3                   	ret    
            @panic("assertion failure");
  217cb6:	e8 f5 1f ff ff       	call   209cb0 <panic>
  217cbb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000217cc0 <DirectAllocator_free>:
                _ = os.posix.munmap(@ptrToInt(bytes.ptr), bytes.len);
  217cc0:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  217cc3:	48 8b 76 08          	mov    rsi,QWORD PTR [rsi+0x8]
  217cc7:	b8 0b 00 00 00       	mov    eax,0xb
  217ccc:	0f 05                	syscall 
    fn free(allocator: *Allocator, bytes: []u8) void {
  217cce:	c3                   	ret    
  217ccf:	90                   	nop

0000000000217cd0 <ArenaAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  217cd0:	55                   	push   rbp
  217cd1:	41 57                	push   r15
  217cd3:	41 56                	push   r14
  217cd5:	41 55                	push   r13
  217cd7:	41 54                	push   r12
  217cd9:	53                   	push   rbx
  217cda:	48 83 ec 58          	sub    rsp,0x58
  217cde:	89 cb                	mov    ebx,ecx
  217ce0:	49 89 d7             	mov    r15,rdx
  217ce3:	49 89 f4             	mov    r12,rsi
  217ce6:	49 89 fe             	mov    r14,rdi
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  217ce9:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  217cee:	81 e3 ff ff ff 1f    	and    ebx,0x1fffffff
  217cf4:	4e 8d 2c 3b          	lea    r13,[rbx+r15*1]
  217cf8:	48 85 c0             	test   rax,rax
  217cfb:	74 29                	je     217d26 <ArenaAllocator_alloc+0x56>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  217cfd:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  217d01:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  217d05:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  217d09:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  217d0e:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  217d12:	48 83 c0 20          	add    rax,0x20
  217d16:	48 89 c2             	mov    rdx,rax
  217d19:	48 c1 ea 20          	shr    rdx,0x20
  217d1d:	74 3f                	je     217d5e <ArenaAllocator_alloc+0x8e>
  217d1f:	31 d2                	xor    edx,edx
  217d21:	48 f7 f3             	div    rbx
  217d24:	eb 3c                	jmp    217d62 <ArenaAllocator_alloc+0x92>
  217d26:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  217d2b:	31 d2                	xor    edx,edx
  217d2d:	4c 89 e6             	mov    rsi,r12
  217d30:	4c 89 e9             	mov    rcx,r13
  217d33:	e8 68 03 00 00       	call   2180a0 <ArenaAllocator_createNode>
  217d38:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  217d3d:	66 85 c0             	test   ax,ax
  217d40:	0f 84 fe 00 00 00    	je     217e44 <ArenaAllocator_alloc+0x174>
  217d46:	66 41 89 06          	mov    WORD PTR [r14],ax
  217d4a:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  217d4f:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  217d53:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  217d59:	e9 ce 00 00 00       	jmp    217e2c <ArenaAllocator_alloc+0x15c>
  217d5e:	31 d2                	xor    edx,edx
  217d60:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  217d62:	48 89 d8             	mov    rax,rbx
  217d65:	48 29 d0             	sub    rax,rdx
  217d68:	48 85 d2             	test   rdx,rdx
  217d6b:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  217d6f:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  217d72:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  217d76:	48 39 ca             	cmp    rdx,rcx
  217d79:	76 72                	jbe    217ded <ArenaAllocator_alloc+0x11d>
  217d7b:	48 8d 6c 24 08       	lea    rbp,[rsp+0x8]
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  217d80:	48 89 ef             	mov    rdi,rbp
  217d83:	4c 89 e6             	mov    rsi,r12
  217d86:	48 89 ca             	mov    rdx,rcx
  217d89:	4c 89 e9             	mov    rcx,r13
  217d8c:	e8 0f 03 00 00       	call   2180a0 <ArenaAllocator_createNode>
  217d91:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  217d96:	66 85 c0             	test   ax,ax
  217d99:	75 7e                	jne    217e19 <ArenaAllocator_alloc+0x149>
  217d9b:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  217da0:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  217da4:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  217da8:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  217dac:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  217db1:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  217db5:	48 83 c0 20          	add    rax,0x20
  217db9:	48 89 c2             	mov    rdx,rax
  217dbc:	48 c1 ea 20          	shr    rdx,0x20
  217dc0:	74 0e                	je     217dd0 <ArenaAllocator_alloc+0x100>
  217dc2:	31 d2                	xor    edx,edx
  217dc4:	48 f7 f3             	div    rbx
  217dc7:	eb 0b                	jmp    217dd4 <ArenaAllocator_alloc+0x104>
  217dc9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  217dd0:	31 d2                	xor    edx,edx
  217dd2:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  217dd4:	48 89 d8             	mov    rax,rbx
  217dd7:	48 29 d0             	sub    rax,rdx
  217dda:	48 85 d2             	test   rdx,rdx
  217ddd:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  217de1:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  217de4:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  217de8:	48 39 ca             	cmp    rdx,rcx
  217deb:	77 93                	ja     217d80 <ArenaAllocator_alloc+0xb0>
            self.end_index = new_end_index;
  217ded:	49 89 54 24 38       	mov    QWORD PTR [r12+0x38],rdx
            return result;
  217df2:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  217df8:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  217dfd:	66 41 89 4e 06       	mov    WORD PTR [r14+0x6],cx
            const result = cur_buf[adjusted_index..new_end_index];
  217e02:	48 8d 44 06 20       	lea    rax,[rsi+rax*1+0x20]
            return result;
  217e07:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  217e0b:	41 89 4e 02          	mov    DWORD PTR [r14+0x2],ecx
  217e0f:	49 89 46 08          	mov    QWORD PTR [r14+0x8],rax
  217e13:	4d 89 7e 10          	mov    QWORD PTR [r14+0x10],r15
  217e17:	eb 19                	jmp    217e32 <ArenaAllocator_alloc+0x162>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  217e19:	66 41 89 06          	mov    WORD PTR [r14],ax
  217e1d:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  217e22:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  217e26:	c5 f8 10 44 24 2c    	vmovups xmm0,XMMWORD PTR [rsp+0x2c]
  217e2c:	c4 c1 78 11 46 02    	vmovups XMMWORD PTR [r14+0x2],xmm0
  217e32:	4c 89 f0             	mov    rax,r14
  217e35:	48 83 c4 58          	add    rsp,0x58
  217e39:	5b                   	pop    rbx
  217e3a:	41 5c                	pop    r12
  217e3c:	41 5d                	pop    r13
  217e3e:	41 5e                	pop    r14
  217e40:	41 5f                	pop    r15
  217e42:	5d                   	pop    rbp
  217e43:	c3                   	ret    
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  217e44:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  217e49:	e9 af fe ff ff       	jmp    217cfd <ArenaAllocator_alloc+0x2d>
  217e4e:	66 90                	xchg   ax,ax

0000000000217e50 <ArenaAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  217e50:	55                   	push   rbp
  217e51:	41 57                	push   r15
  217e53:	41 56                	push   r14
  217e55:	41 55                	push   r13
  217e57:	41 54                	push   r12
  217e59:	53                   	push   rbx
  217e5a:	48 83 ec 58          	sub    rsp,0x58
  217e5e:	45 89 c5             	mov    r13d,r8d
  217e61:	49 89 cf             	mov    r15,rcx
  217e64:	48 89 d3             	mov    rbx,rdx
  217e67:	49 89 f4             	mov    r12,rsi
  217e6a:	48 89 fd             	mov    rbp,rdi
        if (new_size <= old_mem.len) {
  217e6d:	4c 39 7b 08          	cmp    QWORD PTR [rbx+0x8],r15
  217e71:	73 43                	jae    217eb6 <ArenaAllocator_realloc+0x66>
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  217e73:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  217e78:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  217e7f:	4f 8d 34 2f          	lea    r14,[r15+r13*1]
  217e83:	48 85 c0             	test   rax,rax
  217e86:	74 54                	je     217edc <ArenaAllocator_realloc+0x8c>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  217e88:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  217e8c:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  217e90:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  217e94:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  217e99:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  217e9d:	48 83 c0 20          	add    rax,0x20
  217ea1:	48 89 c2             	mov    rdx,rax
  217ea4:	48 c1 ea 20          	shr    rdx,0x20
  217ea8:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  217ead:	75 77                	jne    217f26 <ArenaAllocator_realloc+0xd6>
  217eaf:	31 d2                	xor    edx,edx
  217eb1:	41 f7 f5             	div    r13d
  217eb4:	eb 75                	jmp    217f2b <ArenaAllocator_realloc+0xdb>
            return old_mem[0..new_size];
  217eb6:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  217eb9:	66 c7 45 00 00 00    	mov    WORD PTR [rbp+0x0],0x0
  217ebf:	0f b7 4c 24 1e       	movzx  ecx,WORD PTR [rsp+0x1e]
  217ec4:	66 89 4d 06          	mov    WORD PTR [rbp+0x6],cx
  217ec8:	8b 4c 24 1a          	mov    ecx,DWORD PTR [rsp+0x1a]
  217ecc:	89 4d 02             	mov    DWORD PTR [rbp+0x2],ecx
  217ecf:	48 89 45 08          	mov    QWORD PTR [rbp+0x8],rax
  217ed3:	4c 89 7d 10          	mov    QWORD PTR [rbp+0x10],r15
  217ed7:	e9 a2 00 00 00       	jmp    217f7e <ArenaAllocator_realloc+0x12e>
  217edc:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  217ee1:	31 d2                	xor    edx,edx
  217ee3:	4c 89 e6             	mov    rsi,r12
  217ee6:	4c 89 f1             	mov    rcx,r14
  217ee9:	e8 b2 01 00 00       	call   2180a0 <ArenaAllocator_createNode>
  217eee:	0f b7 44 24 30       	movzx  eax,WORD PTR [rsp+0x30]
  217ef3:	66 85 c0             	test   ax,ax
  217ef6:	75 6e                	jne    217f66 <ArenaAllocator_realloc+0x116>
  217ef8:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  217efd:	eb 89                	jmp    217e88 <ArenaAllocator_realloc+0x38>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  217eff:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  217f04:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  217f08:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  217f0c:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  217f10:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  217f15:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  217f19:	48 83 c0 20          	add    rax,0x20
  217f1d:	48 89 c2             	mov    rdx,rax
  217f20:	48 c1 ea 20          	shr    rdx,0x20
  217f24:	74 89                	je     217eaf <ArenaAllocator_realloc+0x5f>
  217f26:	31 d2                	xor    edx,edx
  217f28:	49 f7 f5             	div    r13
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  217f2b:	4c 89 ed             	mov    rbp,r13
  217f2e:	48 29 d5             	sub    rbp,rdx
  217f31:	48 85 d2             	test   rdx,rdx
  217f34:	48 0f 44 ea          	cmove  rbp,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  217f38:	48 01 fd             	add    rbp,rdi
            const new_end_index = adjusted_index + n;
  217f3b:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
            if (new_end_index > cur_buf.len) {
  217f3f:	48 39 c8             	cmp    rax,rcx
  217f42:	76 42                	jbe    217f86 <ArenaAllocator_realloc+0x136>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  217f44:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  217f49:	4c 89 e6             	mov    rsi,r12
  217f4c:	48 89 ca             	mov    rdx,rcx
  217f4f:	4c 89 f1             	mov    rcx,r14
  217f52:	e8 49 01 00 00       	call   2180a0 <ArenaAllocator_createNode>
  217f57:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  217f5c:	66 85 c0             	test   ax,ax
  217f5f:	74 9e                	je     217eff <ArenaAllocator_realloc+0xaf>
  217f61:	48 8b 6c 24 08       	mov    rbp,QWORD PTR [rsp+0x8]
            const result = try alloc(allocator, new_size, alignment);
  217f66:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  217f6a:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  217f6f:	48 89 45 10          	mov    QWORD PTR [rbp+0x10],rax
  217f73:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  217f79:	c5 f8 11 45 02       	vmovups XMMWORD PTR [rbp+0x2],xmm0
  217f7e:	48 89 e8             	mov    rax,rbp
  217f81:	e9 f1 00 00 00       	jmp    218077 <ArenaAllocator_realloc+0x227>
            self.end_index = new_end_index;
  217f86:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
    assert(dest.len >= source.len);
  217f8b:	48 8b 7b 08          	mov    rdi,QWORD PTR [rbx+0x8]
  217f8f:	4c 39 ff             	cmp    rdi,r15
    if (!ok) {
  217f92:	0f 87 ee 00 00 00    	ja     218086 <ArenaAllocator_realloc+0x236>
  217f98:	4c 8d 04 2e          	lea    r8,[rsi+rbp*1]
  217f9c:	49 83 c0 20          	add    r8,0x20
    for (source) |s, i|
  217fa0:	48 85 ff             	test   rdi,rdi
  217fa3:	0f 84 ac 00 00 00    	je     218055 <ArenaAllocator_realloc+0x205>
  217fa9:	48 8d 57 ff          	lea    rdx,[rdi-0x1]
  217fad:	89 f9                	mov    ecx,edi
  217faf:	83 e1 07             	and    ecx,0x7
  217fb2:	48 83 fa 07          	cmp    rdx,0x7
  217fb6:	73 0c                	jae    217fc4 <ArenaAllocator_realloc+0x174>
  217fb8:	31 d2                	xor    edx,edx
  217fba:	48 85 c9             	test   rcx,rcx
  217fbd:	75 7e                	jne    21803d <ArenaAllocator_realloc+0x1ed>
  217fbf:	e9 91 00 00 00       	jmp    218055 <ArenaAllocator_realloc+0x205>
  217fc4:	48 29 cf             	sub    rdi,rcx
  217fc7:	48 01 ee             	add    rsi,rbp
  217fca:	48 83 c6 27          	add    rsi,0x27
  217fce:	31 d2                	xor    edx,edx
  217fd0:	48 8b 2b             	mov    rbp,QWORD PTR [rbx]
  217fd3:	0f b6 44 15 00       	movzx  eax,BYTE PTR [rbp+rdx*1+0x0]
        dest[i] = s;
  217fd8:	88 44 16 f9          	mov    BYTE PTR [rsi+rdx*1-0x7],al
    for (source) |s, i|
  217fdc:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  217fdf:	0f b6 44 10 01       	movzx  eax,BYTE PTR [rax+rdx*1+0x1]
        dest[i] = s;
  217fe4:	88 44 16 fa          	mov    BYTE PTR [rsi+rdx*1-0x6],al
    for (source) |s, i|
  217fe8:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  217feb:	0f b6 44 10 02       	movzx  eax,BYTE PTR [rax+rdx*1+0x2]
        dest[i] = s;
  217ff0:	88 44 16 fb          	mov    BYTE PTR [rsi+rdx*1-0x5],al
    for (source) |s, i|
  217ff4:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  217ff7:	0f b6 44 10 03       	movzx  eax,BYTE PTR [rax+rdx*1+0x3]
        dest[i] = s;
  217ffc:	88 44 16 fc          	mov    BYTE PTR [rsi+rdx*1-0x4],al
    for (source) |s, i|
  218000:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  218003:	0f b6 44 10 04       	movzx  eax,BYTE PTR [rax+rdx*1+0x4]
        dest[i] = s;
  218008:	88 44 16 fd          	mov    BYTE PTR [rsi+rdx*1-0x3],al
    for (source) |s, i|
  21800c:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  21800f:	0f b6 44 10 05       	movzx  eax,BYTE PTR [rax+rdx*1+0x5]
        dest[i] = s;
  218014:	88 44 16 fe          	mov    BYTE PTR [rsi+rdx*1-0x2],al
    for (source) |s, i|
  218018:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  21801b:	0f b6 44 10 06       	movzx  eax,BYTE PTR [rax+rdx*1+0x6]
        dest[i] = s;
  218020:	88 44 16 ff          	mov    BYTE PTR [rsi+rdx*1-0x1],al
    for (source) |s, i|
  218024:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  218027:	0f b6 44 10 07       	movzx  eax,BYTE PTR [rax+rdx*1+0x7]
        dest[i] = s;
  21802c:	88 04 16             	mov    BYTE PTR [rsi+rdx*1],al
    for (source) |s, i|
  21802f:	48 83 c2 08          	add    rdx,0x8
  218033:	48 39 d7             	cmp    rdi,rdx
  218036:	75 98                	jne    217fd0 <ArenaAllocator_realloc+0x180>
  218038:	48 85 c9             	test   rcx,rcx
  21803b:	74 18                	je     218055 <ArenaAllocator_realloc+0x205>
  21803d:	48 f7 d9             	neg    rcx
  218040:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  218043:	0f b6 04 10          	movzx  eax,BYTE PTR [rax+rdx*1]
        dest[i] = s;
  218047:	41 88 04 10          	mov    BYTE PTR [r8+rdx*1],al
    for (source) |s, i|
  21804b:	48 83 c2 01          	add    rdx,0x1
  21804f:	48 83 c1 01          	add    rcx,0x1
  218053:	75 eb                	jne    218040 <ArenaAllocator_realloc+0x1f0>
  218055:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
            return result;
  21805a:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  21805f:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  218064:	66 89 48 06          	mov    WORD PTR [rax+0x6],cx
  218068:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  21806c:	89 48 02             	mov    DWORD PTR [rax+0x2],ecx
  21806f:	4c 89 40 08          	mov    QWORD PTR [rax+0x8],r8
  218073:	4c 89 78 10          	mov    QWORD PTR [rax+0x10],r15
  218077:	48 83 c4 58          	add    rsp,0x58
  21807b:	5b                   	pop    rbx
  21807c:	41 5c                	pop    r12
  21807e:	41 5d                	pop    r13
  218080:	41 5e                	pop    r14
  218082:	41 5f                	pop    r15
  218084:	5d                   	pop    rbp
  218085:	c3                   	ret    
            @panic("assertion failure");
  218086:	e8 25 1c ff ff       	call   209cb0 <panic>
  21808b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000218090 <ArenaAllocator_free>:
    fn free(allocator: *Allocator, bytes: []u8) void {}
  218090:	c3                   	ret    
  218091:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218098:	0f 1f 84 00 00 00 00 
  21809f:	00 

00000000002180a0 <ArenaAllocator_createNode>:
    fn createNode(self: *ArenaAllocator, prev_len: usize, minimum_size: usize) !*BufNode {
  2180a0:	41 57                	push   r15
  2180a2:	41 56                	push   r14
  2180a4:	53                   	push   rbx
  2180a5:	48 83 ec 30          	sub    rsp,0x30
  2180a9:	48 89 d3             	mov    rbx,rdx
  2180ac:	49 89 f6             	mov    r14,rsi
  2180af:	49 89 ff             	mov    r15,rdi
        const actual_min_size = minimum_size + @sizeOf(BufNode);
  2180b2:	48 83 c1 20          	add    rcx,0x20
  2180b6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2180bd:	00 00 00 
            len += len / 2;
  2180c0:	48 89 d8             	mov    rax,rbx
  2180c3:	48 d1 e8             	shr    rax,1
  2180c6:	48 01 d8             	add    rax,rbx
            len += os.page_size - @rem(len, os.page_size);
  2180c9:	89 c2                	mov    edx,eax
  2180cb:	81 e2 ff 0f 00 00    	and    edx,0xfff
  2180d1:	bb 00 10 00 00       	mov    ebx,0x1000
  2180d6:	48 29 d3             	sub    rbx,rdx
  2180d9:	48 01 c3             	add    rbx,rax
            if (len >= actual_min_size) break;
  2180dc:	48 39 cb             	cmp    rbx,rcx
  2180df:	72 df                	jb     2180c0 <ArenaAllocator_createNode+0x20>
        if (n == 0) {
  2180e1:	48 85 db             	test   rbx,rbx
  2180e4:	74 38                	je     21811e <ArenaAllocator_createNode+0x7e>
  2180e6:	49 8b 76 18          	mov    rsi,QWORD PTR [r14+0x18]
  2180ea:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2180ef:	b9 08 00 00 00       	mov    ecx,0x8
  2180f4:	48 89 da             	mov    rdx,rbx
  2180f7:	ff 16                	call   QWORD PTR [rsi]
  2180f9:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  2180fe:	66 85 c0             	test   ax,ax
  218101:	74 1f                	je     218122 <ArenaAllocator_createNode+0x82>
        const buf = try self.child_allocator.alignedAlloc(u8, @alignOf(BufNode), len);
  218103:	66 41 89 07          	mov    WORD PTR [r15],ax
  218107:	48 8b 44 24 22       	mov    rax,QWORD PTR [rsp+0x22]
  21810c:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  218111:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  218115:	49 89 47 02          	mov    QWORD PTR [r15+0x2],rax
  218119:	e9 c6 00 00 00       	jmp    2181e4 <ArenaAllocator_createNode+0x144>
  21811e:	31 db                	xor    ebx,ebx
  218120:	eb 10                	jmp    218132 <ArenaAllocator_createNode+0x92>
        assert(byte_slice.len == byte_count);
  218122:	48 39 5c 24 18       	cmp    QWORD PTR [rsp+0x18],rbx
    if (!ok) {
  218127:	0f 85 c1 00 00 00    	jne    2181ee <ArenaAllocator_createNode+0x14e>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21812d:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
        buf_node.* = BufNode{
  218132:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  218136:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  21813a:	48 89 40 10          	mov    QWORD PTR [rax+0x10],rax
  21813e:	48 89 58 18          	mov    QWORD PTR [rax+0x18],rbx
            if (list.last) |last| {
  218142:	49 8b 4e 28          	mov    rcx,QWORD PTR [r14+0x28]
  218146:	48 85 c9             	test   rcx,rcx
  218149:	74 12                	je     21815d <ArenaAllocator_createNode+0xbd>
            new_node.prev = node;
  21814b:	48 89 08             	mov    QWORD PTR [rax],rcx
            if (node.next) |next_node| {
  21814e:	48 8b 51 08          	mov    rdx,QWORD PTR [rcx+0x8]
  218152:	48 85 d2             	test   rdx,rdx
  218155:	74 24                	je     21817b <ArenaAllocator_createNode+0xdb>
                new_node.next = next_node;
  218157:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  21815b:	eb 2a                	jmp    218187 <ArenaAllocator_createNode+0xe7>
            if (list.first) |first| {
  21815d:	49 8b 4e 20          	mov    rcx,QWORD PTR [r14+0x20]
  218161:	48 85 c9             	test   rcx,rcx
  218164:	74 2a                	je     218190 <ArenaAllocator_createNode+0xf0>
            new_node.next = node;
  218166:	48 89 48 08          	mov    QWORD PTR [rax+0x8],rcx
            if (node.prev) |prev_node| {
  21816a:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  21816d:	48 85 d2             	test   rdx,rdx
  218170:	74 38                	je     2181aa <ArenaAllocator_createNode+0x10a>
                new_node.prev = prev_node;
  218172:	48 89 10             	mov    QWORD PTR [rax],rdx
                prev_node.next = new_node;
  218175:	48 83 c2 08          	add    rdx,0x8
  218179:	eb 3a                	jmp    2181b5 <ArenaAllocator_createNode+0x115>
  21817b:	49 8d 56 28          	lea    rdx,[r14+0x28]
                new_node.next = null;
  21817f:	48 c7 40 08 00 00 00 	mov    QWORD PTR [rax+0x8],0x0
  218186:	00 
  218187:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.next = new_node;
  21818a:	48 89 41 08          	mov    QWORD PTR [rcx+0x8],rax
  21818e:	eb 2b                	jmp    2181bb <ArenaAllocator_createNode+0x11b>
                list.first = new_node;
  218190:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
                list.last = new_node;
  218194:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
                new_node.next = null;
  218198:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21819c:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
                list.len = 1;
  2181a0:	49 c7 46 30 01 00 00 	mov    QWORD PTR [r14+0x30],0x1
  2181a7:	00 
  2181a8:	eb 16                	jmp    2181c0 <ArenaAllocator_createNode+0x120>
  2181aa:	49 8d 56 20          	lea    rdx,[r14+0x20]
                new_node.prev = null;
  2181ae:	48 c7 00 00 00 00 00 	mov    QWORD PTR [rax],0x0
  2181b5:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.prev = new_node;
  2181b8:	48 89 01             	mov    QWORD PTR [rcx],rax
  2181bb:	49 83 46 30 01       	add    QWORD PTR [r14+0x30],0x1
        self.end_index = 0;
  2181c0:	49 c7 46 38 00 00 00 	mov    QWORD PTR [r14+0x38],0x0
  2181c7:	00 
        return buf_node;
  2181c8:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  2181ce:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  2181d3:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  2181d8:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  2181dc:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  2181e0:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  2181e4:	48 83 c4 30          	add    rsp,0x30
  2181e8:	5b                   	pop    rbx
  2181e9:	41 5e                	pop    r14
  2181eb:	41 5f                	pop    r15
  2181ed:	c3                   	ret    
            @panic("assertion failure");
  2181ee:	e8 bd 1a ff ff       	call   209cb0 <panic>
  2181f3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2181fa:	84 00 00 00 00 00 

0000000000218200 <u64toa>:
    if (value < kTen8) {
  218200:	41 57                	push   r15
  218202:	41 56                	push   r14
  218204:	53                   	push   rbx
  218205:	48 81 ff ff e0 f5 05 	cmp    rdi,0x5f5e0ff
  21820c:	77 4b                	ja     218259 <u64toa+0x59>
            const b: u32 = v / 10000;
  21820e:	89 f8                	mov    eax,edi
        if (v < 10000) {
  218210:	81 ff 0f 27 00 00    	cmp    edi,0x270f
  218216:	0f 87 48 01 00 00    	ja     218364 <u64toa+0x164>
            const d1: u32 = (v / 100) << 1;
  21821c:	48 69 d0 1f 85 eb 51 	imul   rdx,rax,0x51eb851f
  218223:	48 c1 ea 25          	shr    rdx,0x25
            const d2: u32 = (v % 100) << 1;
  218227:	6b c2 64             	imul   eax,edx,0x64
            const d1: u32 = (v / 100) << 1;
  21822a:	48 01 d2             	add    rdx,rdx
            const d2: u32 = (v % 100) << 1;
  21822d:	89 f9                	mov    ecx,edi
  21822f:	29 c1                	sub    ecx,eax
  218231:	48 01 c9             	add    rcx,rcx
            if (v >= 1000) {
  218234:	81 ff e8 03 00 00    	cmp    edi,0x3e8
  21823a:	0f 82 bf 01 00 00    	jb     2183ff <u64toa+0x1ff>
                buffer[buf_index] = c_digits_lut[d1];
  218240:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  218243:	48 8d 3d 7e dd fe ff 	lea    rdi,[rip+0xfffffffffffedd7e]        # 205fc8 <c_digits_lut>
  21824a:	8a 1c 3a             	mov    bl,BYTE PTR [rdx+rdi*1]
  21824d:	88 18                	mov    BYTE PTR [rax],bl
  21824f:	b8 01 00 00 00       	mov    eax,0x1
  218254:	e9 b1 01 00 00       	jmp    21840a <u64toa+0x20a>
  218259:	48 b9 00 00 c1 6f f2 	movabs rcx,0x2386f26fc10000
  218260:	86 23 00 
    } else if (value < kTen16) {
  218263:	48 39 cf             	cmp    rdi,rcx
  218266:	0f 83 71 01 00 00    	jae    2183dd <u64toa+0x1dd>
        const v0: u32 = @intCast(u32, value / kTen8);
  21826c:	48 b8 fd ce 61 84 11 	movabs rax,0xabcc77118461cefd
  218273:	77 cc ab 
  218276:	48 89 fa             	mov    rdx,rdi
  218279:	c4 62 fb f6 f8       	mulx   r15,rax,rax
  21827e:	49 c1 ef 1a          	shr    r15,0x1a
        const v1: u32 = @intCast(u32, value % kTen8);
  218282:	49 69 cf 00 e1 f5 05 	imul   rcx,r15,0x5f5e100
  218289:	48 89 f8             	mov    rax,rdi
  21828c:	48 29 c8             	sub    rax,rcx
        const b0: u32 = v0 / 10000;
  21828f:	44 89 fb             	mov    ebx,r15d
  218292:	41 be 59 17 b7 d1    	mov    r14d,0xd1b71759
        const d1: u32 = (b0 / 100) << 1;
  218298:	48 69 cb 83 de 1b 43 	imul   rcx,rbx,0x431bde83
        const b0: u32 = v0 / 10000;
  21829f:	49 0f af de          	imul   rbx,r14
  2182a3:	48 c1 eb 2d          	shr    rbx,0x2d
        const c0: u32 = v0 % 10000;
  2182a7:	69 d3 10 27 00 00    	imul   edx,ebx,0x2710
  2182ad:	41 29 d7             	sub    r15d,edx
        const d1: u32 = (b0 / 100) << 1;
  2182b0:	48 c1 e9 31          	shr    rcx,0x31
  2182b4:	81 e1 fe 3f 00 00    	and    ecx,0x3ffe
        const d2: u32 = (b0 % 100) << 1;
  2182ba:	48 69 d3 1f 85 eb 51 	imul   rdx,rbx,0x51eb851f
  2182c1:	48 c1 ea 25          	shr    rdx,0x25
  2182c5:	6b d2 64             	imul   edx,edx,0x64
  2182c8:	29 d3                	sub    ebx,edx
  2182ca:	48 01 db             	add    rbx,rbx
        const d3: u32 = (c0 / 100) << 1;
  2182cd:	4d 69 df 1f 85 eb 51 	imul   r11,r15,0x51eb851f
  2182d4:	49 c1 eb 25          	shr    r11,0x25
        const d4: u32 = (c0 % 100) << 1;
  2182d8:	41 6b d3 64          	imul   edx,r11d,0x64
        const d3: u32 = (c0 / 100) << 1;
  2182dc:	4d 01 db             	add    r11,r11
        const d4: u32 = (c0 % 100) << 1;
  2182df:	41 29 d7             	sub    r15d,edx
  2182e2:	4d 01 ff             	add    r15,r15
        const b1: u32 = v1 / 10000;
  2182e5:	4c 0f af f0          	imul   r14,rax
  2182e9:	49 c1 ee 2d          	shr    r14,0x2d
        const c1: u32 = v1 % 10000;
  2182ed:	41 69 d6 10 27 00 00 	imul   edx,r14d,0x2710
        const d5: u32 = (b1 / 100) << 1;
  2182f4:	4c 69 c8 83 de 1b 43 	imul   r9,rax,0x431bde83
        const c1: u32 = v1 % 10000;
  2182fb:	41 89 c0             	mov    r8d,eax
  2182fe:	41 29 d0             	sub    r8d,edx
        const d5: u32 = (b1 / 100) << 1;
  218301:	49 c1 e9 31          	shr    r9,0x31
  218305:	41 81 e1 fe 01 00 00 	and    r9d,0x1fe
        const d6: u32 = (b1 % 100) << 1;
  21830c:	49 69 c6 1f 85 eb 51 	imul   rax,r14,0x51eb851f
  218313:	48 c1 e8 25          	shr    rax,0x25
  218317:	6b c0 64             	imul   eax,eax,0x64
  21831a:	41 29 c6             	sub    r14d,eax
  21831d:	4d 01 f6             	add    r14,r14
        const d7: u32 = (c1 / 100) << 1;
  218320:	4d 69 d0 1f 85 eb 51 	imul   r10,r8,0x51eb851f
  218327:	49 c1 ea 25          	shr    r10,0x25
        const d8: u32 = (c1 % 100) << 1;
  21832b:	41 6b c2 64          	imul   eax,r10d,0x64
        const d7: u32 = (c1 / 100) << 1;
  21832f:	4d 01 d2             	add    r10,r10
        const d8: u32 = (c1 % 100) << 1;
  218332:	41 29 c0             	sub    r8d,eax
  218335:	4d 01 c0             	add    r8,r8
        if (value >= kTen15) {
  218338:	48 b8 00 80 c6 a4 7e 	movabs rax,0x38d7ea4c68000
  21833f:	8d 03 00 
  218342:	48 39 c7             	cmp    rdi,rax
  218345:	0f 82 07 01 00 00    	jb     218452 <u64toa+0x252>
            buffer[buf_index] = c_digits_lut[d1];
  21834b:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  21834e:	48 8d 15 73 dc fe ff 	lea    rdx,[rip+0xfffffffffffedc73]        # 205fc8 <c_digits_lut>
  218355:	8a 14 11             	mov    dl,BYTE PTR [rcx+rdx*1]
  218358:	88 10                	mov    BYTE PTR [rax],dl
  21835a:	b8 01 00 00 00       	mov    eax,0x1
  21835f:	e9 03 01 00 00       	jmp    218467 <u64toa+0x267>
            const b: u32 = v / 10000;
  218364:	ba 59 17 b7 d1       	mov    edx,0xd1b71759
  218369:	48 0f af d0          	imul   rdx,rax
  21836d:	48 c1 ea 2d          	shr    rdx,0x2d
            const c: u32 = v % 10000;
  218371:	69 da 10 27 00 00    	imul   ebx,edx,0x2710
  218377:	89 f9                	mov    ecx,edi
  218379:	29 d9                	sub    ecx,ebx
            const d1: u32 = (b / 100) << 1;
  21837b:	48 69 d8 83 de 1b 43 	imul   rbx,rax,0x431bde83
  218382:	48 c1 eb 31          	shr    rbx,0x31
            const d2: u32 = (b % 100) << 1;
  218386:	48 69 c2 1f 85 eb 51 	imul   rax,rdx,0x51eb851f
  21838d:	48 c1 e8 25          	shr    rax,0x25
  218391:	6b c0 64             	imul   eax,eax,0x64
            const d1: u32 = (b / 100) << 1;
  218394:	81 e3 fe 3f 00 00    	and    ebx,0x3ffe
            const d2: u32 = (b % 100) << 1;
  21839a:	29 c2                	sub    edx,eax
  21839c:	48 01 d2             	add    rdx,rdx
            const d3: u32 = (c / 100) << 1;
  21839f:	4c 69 c1 1f 85 eb 51 	imul   r8,rcx,0x51eb851f
  2183a6:	49 c1 e8 25          	shr    r8,0x25
            const d4: u32 = (c % 100) << 1;
  2183aa:	41 6b c0 64          	imul   eax,r8d,0x64
            const d3: u32 = (c / 100) << 1;
  2183ae:	4d 01 c0             	add    r8,r8
            const d4: u32 = (c % 100) << 1;
  2183b1:	29 c1                	sub    ecx,eax
  2183b3:	48 01 c9             	add    rcx,rcx
            if (value >= 10000000) {
  2183b6:	48 81 ff 80 96 98 00 	cmp    rdi,0x989680
  2183bd:	0f 82 b0 01 00 00    	jb     218573 <u64toa+0x373>
                buffer[buf_index] = c_digits_lut[d1];
  2183c3:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  2183c6:	48 8d 3d fb db fe ff 	lea    rdi,[rip+0xfffffffffffedbfb]        # 205fc8 <c_digits_lut>
  2183cd:	8a 04 3b             	mov    al,BYTE PTR [rbx+rdi*1]
  2183d0:	41 88 01             	mov    BYTE PTR [r9],al
  2183d3:	b8 01 00 00 00       	mov    eax,0x1
  2183d8:	e9 a5 01 00 00       	jmp    218582 <u64toa+0x382>
        value %= kTen16;
  2183dd:	31 d2                	xor    edx,edx
  2183df:	48 89 f8             	mov    rax,rdi
  2183e2:	48 f7 f1             	div    rcx
        if (a < 10) {
  2183e5:	83 f8 09             	cmp    eax,0x9
  2183e8:	0f 87 0e 02 00 00    	ja     2185fc <u64toa+0x3fc>
            buffer[buf_index] = '0' + @intCast(u8, a);
  2183ee:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2183f1:	04 30                	add    al,0x30
  2183f3:	88 01                	mov    BYTE PTR [rcx],al
  2183f5:	b8 01 00 00 00       	mov    eax,0x1
  2183fa:	e9 06 03 00 00       	jmp    218705 <u64toa+0x505>
  2183ff:	31 c0                	xor    eax,eax
            if (v >= 100) {
  218401:	83 ff 64             	cmp    edi,0x64
  218404:	0f 82 21 02 00 00    	jb     21862b <u64toa+0x42b>
                buffer[buf_index] = c_digits_lut[d1 + 1];
  21840a:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  21840d:	83 ca 01             	or     edx,0x1
  218410:	48 8d 1d b1 db fe ff 	lea    rbx,[rip+0xfffffffffffedbb1]        # 205fc8 <c_digits_lut>
  218417:	8a 14 1a             	mov    dl,BYTE PTR [rdx+rbx*1]
  21841a:	88 14 07             	mov    BYTE PTR [rdi+rax*1],dl
                buf_index += 1;
  21841d:	48 83 c0 01          	add    rax,0x1
                buffer[buf_index] = c_digits_lut[d2];
  218421:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218424:	48 8d 3d 9d db fe ff 	lea    rdi,[rip+0xfffffffffffedb9d]        # 205fc8 <c_digits_lut>
  21842b:	8a 1c 39             	mov    bl,BYTE PTR [rcx+rdi*1]
  21842e:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
                buf_index += 1;
  218431:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  218435:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218438:	83 c9 01             	or     ecx,0x1
  21843b:	48 8d 35 86 db fe ff 	lea    rsi,[rip+0xfffffffffffedb86]        # 205fc8 <c_digits_lut>
  218442:	8a 0c 31             	mov    cl,BYTE PTR [rcx+rsi*1]
  218445:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            buf_index += 1;
  218448:	48 83 c0 01          	add    rax,0x1
    return buf_index;
  21844c:	5b                   	pop    rbx
  21844d:	41 5e                	pop    r14
  21844f:	41 5f                	pop    r15
  218451:	c3                   	ret    
        if (value >= kTen14) {
  218452:	48 b8 00 40 7a 10 f3 	movabs rax,0x5af3107a4000
  218459:	5a 00 00 
  21845c:	48 39 c7             	cmp    rdi,rax
  21845f:	0f 82 d4 01 00 00    	jb     218639 <u64toa+0x439>
  218465:	31 c0                	xor    eax,eax
            buffer[buf_index] = c_digits_lut[d1 + 1];
  218467:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  21846a:	83 c9 01             	or     ecx,0x1
  21846d:	48 8d 3d 54 db fe ff 	lea    rdi,[rip+0xfffffffffffedb54]        # 205fc8 <c_digits_lut>
  218474:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  218477:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            buf_index += 1;
  21847a:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2];
  21847e:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218481:	48 8d 15 40 db fe ff 	lea    rdx,[rip+0xfffffffffffedb40]        # 205fc8 <c_digits_lut>
  218488:	8a 14 13             	mov    dl,BYTE PTR [rbx+rdx*1]
  21848b:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  21848e:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  218492:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218495:	83 cb 01             	or     ebx,0x1
  218498:	48 8d 15 29 db fe ff 	lea    rdx,[rip+0xfffffffffffedb29]        # 205fc8 <c_digits_lut>
  21849f:	8a 14 13             	mov    dl,BYTE PTR [rbx+rdx*1]
  2184a2:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  2184a5:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d3];
  2184a9:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2184ac:	48 8d 15 15 db fe ff 	lea    rdx,[rip+0xfffffffffffedb15]        # 205fc8 <c_digits_lut>
  2184b3:	41 8a 14 13          	mov    dl,BYTE PTR [r11+rdx*1]
  2184b7:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  2184ba:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d3 + 1];
  2184be:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2184c1:	41 83 cb 01          	or     r11d,0x1
  2184c5:	48 8d 15 fc da fe ff 	lea    rdx,[rip+0xfffffffffffedafc]        # 205fc8 <c_digits_lut>
  2184cc:	41 8a 14 13          	mov    dl,BYTE PTR [r11+rdx*1]
  2184d0:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  2184d3:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d4];
  2184d7:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2184da:	48 8d 15 e7 da fe ff 	lea    rdx,[rip+0xfffffffffffedae7]        # 205fc8 <c_digits_lut>
  2184e1:	41 8a 14 17          	mov    dl,BYTE PTR [r15+rdx*1]
  2184e5:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  2184e8:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d4 + 1];
  2184ec:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2184ef:	41 83 cf 01          	or     r15d,0x1
  2184f3:	48 8d 0d ce da fe ff 	lea    rcx,[rip+0xfffffffffffedace]        # 205fc8 <c_digits_lut>
  2184fa:	41 8a 1c 0f          	mov    bl,BYTE PTR [r15+rcx*1]
  2184fe:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
        buffer[buf_index] = c_digits_lut[d5];
  218501:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218504:	41 8a 1c 09          	mov    bl,BYTE PTR [r9+rcx*1]
  218508:	88 5c 02 01          	mov    BYTE PTR [rdx+rax*1+0x1],bl
        buffer[buf_index] = c_digits_lut[d5 + 1];
  21850c:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  21850f:	41 83 c9 01          	or     r9d,0x1
  218513:	41 8a 1c 09          	mov    bl,BYTE PTR [r9+rcx*1]
  218517:	88 5c 02 02          	mov    BYTE PTR [rdx+rax*1+0x2],bl
        buffer[buf_index] = c_digits_lut[d6];
  21851b:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  21851e:	41 8a 1c 0e          	mov    bl,BYTE PTR [r14+rcx*1]
  218522:	88 5c 02 03          	mov    BYTE PTR [rdx+rax*1+0x3],bl
        buffer[buf_index] = c_digits_lut[d6 + 1];
  218526:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218529:	41 83 ce 01          	or     r14d,0x1
  21852d:	41 8a 1c 0e          	mov    bl,BYTE PTR [r14+rcx*1]
  218531:	88 5c 02 04          	mov    BYTE PTR [rdx+rax*1+0x4],bl
        buffer[buf_index] = c_digits_lut[d7];
  218535:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218538:	41 8a 1c 0a          	mov    bl,BYTE PTR [r10+rcx*1]
  21853c:	88 5c 02 05          	mov    BYTE PTR [rdx+rax*1+0x5],bl
        buffer[buf_index] = c_digits_lut[d7 + 1];
  218540:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218543:	41 83 ca 01          	or     r10d,0x1
  218547:	41 8a 1c 0a          	mov    bl,BYTE PTR [r10+rcx*1]
  21854b:	88 5c 02 06          	mov    BYTE PTR [rdx+rax*1+0x6],bl
        buffer[buf_index] = c_digits_lut[d8];
  21854f:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218552:	41 8a 1c 08          	mov    bl,BYTE PTR [r8+rcx*1]
  218556:	88 5c 02 07          	mov    BYTE PTR [rdx+rax*1+0x7],bl
        buffer[buf_index] = c_digits_lut[d8 + 1];
  21855a:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  21855d:	41 83 c8 01          	or     r8d,0x1
  218561:	41 8a 0c 08          	mov    cl,BYTE PTR [r8+rcx*1]
  218565:	88 4c 02 08          	mov    BYTE PTR [rdx+rax*1+0x8],cl
        buf_index += 1;
  218569:	48 83 c0 09          	add    rax,0x9
    return buf_index;
  21856d:	5b                   	pop    rbx
  21856e:	41 5e                	pop    r14
  218570:	41 5f                	pop    r15
  218572:	c3                   	ret    
  218573:	31 c0                	xor    eax,eax
            if (value >= 1000000) {
  218575:	48 81 ff 40 42 0f 00 	cmp    rdi,0xf4240
  21857c:	0f 82 cd 00 00 00    	jb     21864f <u64toa+0x44f>
                buffer[buf_index] = c_digits_lut[d1 + 1];
  218582:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  218585:	83 cb 01             	or     ebx,0x1
  218588:	48 8d 3d 39 da fe ff 	lea    rdi,[rip+0xfffffffffffeda39]        # 205fc8 <c_digits_lut>
  21858f:	8a 1c 3b             	mov    bl,BYTE PTR [rbx+rdi*1]
  218592:	41 88 1c 01          	mov    BYTE PTR [r9+rax*1],bl
                buf_index += 1;
  218596:	48 83 c0 01          	add    rax,0x1
                buffer[buf_index] = c_digits_lut[d2];
  21859a:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  21859d:	48 8d 1d 24 da fe ff 	lea    rbx,[rip+0xfffffffffffeda24]        # 205fc8 <c_digits_lut>
  2185a4:	8a 1c 1a             	mov    bl,BYTE PTR [rdx+rbx*1]
  2185a7:	88 1c 07             	mov    BYTE PTR [rdi+rax*1],bl
                buf_index += 1;
  2185aa:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  2185ae:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  2185b1:	83 ca 01             	or     edx,0x1
  2185b4:	48 8d 3d 0d da fe ff 	lea    rdi,[rip+0xfffffffffffeda0d]        # 205fc8 <c_digits_lut>
  2185bb:	8a 14 3a             	mov    dl,BYTE PTR [rdx+rdi*1]
  2185be:	88 14 03             	mov    BYTE PTR [rbx+rax*1],dl
            buffer[buf_index] = c_digits_lut[d3];
  2185c1:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2185c4:	41 8a 1c 38          	mov    bl,BYTE PTR [r8+rdi*1]
  2185c8:	88 5c 02 01          	mov    BYTE PTR [rdx+rax*1+0x1],bl
            buffer[buf_index] = c_digits_lut[d3 + 1];
  2185cc:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2185cf:	41 83 c8 01          	or     r8d,0x1
  2185d3:	41 8a 1c 38          	mov    bl,BYTE PTR [r8+rdi*1]
  2185d7:	88 5c 02 02          	mov    BYTE PTR [rdx+rax*1+0x2],bl
            buffer[buf_index] = c_digits_lut[d4];
  2185db:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2185de:	8a 1c 39             	mov    bl,BYTE PTR [rcx+rdi*1]
  2185e1:	88 5c 02 03          	mov    BYTE PTR [rdx+rax*1+0x3],bl
            buffer[buf_index] = c_digits_lut[d4 + 1];
  2185e5:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2185e8:	83 c9 01             	or     ecx,0x1
  2185eb:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  2185ee:	88 4c 02 04          	mov    BYTE PTR [rdx+rax*1+0x4],cl
            buf_index += 1;
  2185f2:	48 83 c0 05          	add    rax,0x5
    return buf_index;
  2185f6:	5b                   	pop    rbx
  2185f7:	41 5e                	pop    r14
  2185f9:	41 5f                	pop    r15
  2185fb:	c3                   	ret    
        } else if (a < 100) {
  2185fc:	83 f8 63             	cmp    eax,0x63
  2185ff:	77 60                	ja     218661 <u64toa+0x461>
            buffer[buf_index] = c_digits_lut[i];
  218601:	89 c0                	mov    eax,eax
  218603:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218606:	48 8d 3d bb d9 fe ff 	lea    rdi,[rip+0xfffffffffffed9bb]        # 205fc8 <c_digits_lut>
  21860d:	8a 1c 47             	mov    bl,BYTE PTR [rdi+rax*2]
            const i: u32 = a << 1;
  218610:	48 01 c0             	add    rax,rax
            buffer[buf_index] = c_digits_lut[i];
  218613:	88 19                	mov    BYTE PTR [rcx],bl
            buffer[buf_index] = c_digits_lut[i + 1];
  218615:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218618:	83 c8 01             	or     eax,0x1
  21861b:	8a 04 38             	mov    al,BYTE PTR [rax+rdi*1]
  21861e:	88 41 01             	mov    BYTE PTR [rcx+0x1],al
  218621:	b8 02 00 00 00       	mov    eax,0x2
  218626:	e9 da 00 00 00       	jmp    218705 <u64toa+0x505>
            if (v >= 10) {
  21862b:	83 ff 0a             	cmp    edi,0xa
  21862e:	0f 83 ed fd ff ff    	jae    218421 <u64toa+0x221>
  218634:	e9 fc fd ff ff       	jmp    218435 <u64toa+0x235>
        if (value >= kTen13) {
  218639:	48 89 f8             	mov    rax,rdi
  21863c:	48 c1 e8 0d          	shr    rax,0xd
  218640:	48 3d 95 73 c2 48    	cmp    rax,0x48c27395
  218646:	72 60                	jb     2186a8 <u64toa+0x4a8>
  218648:	31 c0                	xor    eax,eax
  21864a:	e9 2f fe ff ff       	jmp    21847e <u64toa+0x27e>
            if (value >= 100000) {
  21864f:	48 81 ff a0 86 01 00 	cmp    rdi,0x186a0
  218656:	0f 83 3e ff ff ff    	jae    21859a <u64toa+0x39a>
  21865c:	e9 4d ff ff ff       	jmp    2185ae <u64toa+0x3ae>
            const i: u32 = (a / 100) << 1;
  218661:	89 c1                	mov    ecx,eax
  218663:	48 69 c9 1f 85 eb 51 	imul   rcx,rcx,0x51eb851f
  21866a:	48 c1 e9 25          	shr    rcx,0x25
            const j: u32 = (a % 100) << 1;
  21866e:	6b f9 64             	imul   edi,ecx,0x64
        } else if (a < 1000) {
  218671:	3d e7 03 00 00       	cmp    eax,0x3e7
  218676:	77 4a                	ja     2186c2 <u64toa+0x4c2>
            buffer[buf_index] = '0' + @intCast(u8, a / 100);
  218678:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  21867b:	80 c1 30             	add    cl,0x30
  21867e:	88 0b                	mov    BYTE PTR [rbx],cl
            const i: u32 = (a % 100) << 1;
  218680:	29 f8                	sub    eax,edi
            buffer[buf_index] = c_digits_lut[i];
  218682:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218685:	48 8d 3d 3c d9 fe ff 	lea    rdi,[rip+0xfffffffffffed93c]        # 205fc8 <c_digits_lut>
  21868c:	8a 1c 47             	mov    bl,BYTE PTR [rdi+rax*2]
            const i: u32 = (a % 100) << 1;
  21868f:	48 01 c0             	add    rax,rax
            buffer[buf_index] = c_digits_lut[i];
  218692:	88 59 01             	mov    BYTE PTR [rcx+0x1],bl
            buffer[buf_index] = c_digits_lut[i + 1];
  218695:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218698:	83 c8 01             	or     eax,0x1
  21869b:	8a 04 38             	mov    al,BYTE PTR [rax+rdi*1]
  21869e:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
  2186a1:	b8 03 00 00 00       	mov    eax,0x3
  2186a6:	eb 5d                	jmp    218705 <u64toa+0x505>
        if (value >= kTen12) {
  2186a8:	48 89 f8             	mov    rax,rdi
  2186ab:	48 c1 e8 0c          	shr    rax,0xc
  2186af:	48 3d 51 4a 8d 0e    	cmp    rax,0xe8d4a51
  2186b5:	0f 82 e9 01 00 00    	jb     2188a4 <u64toa+0x6a4>
  2186bb:	31 c0                	xor    eax,eax
  2186bd:	e9 d0 fd ff ff       	jmp    218492 <u64toa+0x292>
            const j: u32 = (a % 100) << 1;
  2186c2:	29 f8                	sub    eax,edi
  2186c4:	48 8d 3c 00          	lea    rdi,[rax+rax*1]
            buffer[buf_index] = c_digits_lut[i];
  2186c8:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  2186cb:	4c 8d 05 f6 d8 fe ff 	lea    r8,[rip+0xfffffffffffed8f6]        # 205fc8 <c_digits_lut>
  2186d2:	41 8a 1c 48          	mov    bl,BYTE PTR [r8+rcx*2]
  2186d6:	41 88 19             	mov    BYTE PTR [r9],bl
            const i: u32 = (a / 100) << 1;
  2186d9:	48 01 c9             	add    rcx,rcx
            buffer[buf_index] = c_digits_lut[i + 1];
  2186dc:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  2186df:	83 c9 01             	or     ecx,0x1
  2186e2:	42 8a 0c 01          	mov    cl,BYTE PTR [rcx+r8*1]
  2186e6:	88 4b 01             	mov    BYTE PTR [rbx+0x1],cl
            buffer[buf_index] = c_digits_lut[j];
  2186e9:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2186ec:	41 8a 04 40          	mov    al,BYTE PTR [r8+rax*2]
  2186f0:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
            buffer[buf_index] = c_digits_lut[j + 1];
  2186f3:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  2186f6:	83 cf 01             	or     edi,0x1
  2186f9:	42 8a 0c 07          	mov    cl,BYTE PTR [rdi+r8*1]
  2186fd:	88 48 03             	mov    BYTE PTR [rax+0x3],cl
  218700:	b8 04 00 00 00       	mov    eax,0x4
        const v0 = @intCast(u32, value / kTen8);
  218705:	48 b9 fd ce 61 84 11 	movabs rcx,0xabcc77118461cefd
  21870c:	77 cc ab 
  21870f:	c4 62 f3 f6 f1       	mulx   r14,rcx,rcx
  218714:	49 c1 ee 1a          	shr    r14,0x1a
        const v1 = @intCast(u32, value % kTen8);
  218718:	4d 69 c6 00 e1 f5 05 	imul   r8,r14,0x5f5e100
        const b0: u32 = v0 / 10000;
  21871f:	44 89 f3             	mov    ebx,r14d
  218722:	41 ba 59 17 b7 d1    	mov    r10d,0xd1b71759
        const d1: u32 = (b0 / 100) << 1;
  218728:	4c 69 cb 83 de 1b 43 	imul   r9,rbx,0x431bde83
        const b0: u32 = v0 / 10000;
  21872f:	49 0f af da          	imul   rbx,r10
  218733:	48 c1 eb 2d          	shr    rbx,0x2d
        const d1: u32 = (b0 / 100) << 1;
  218737:	49 c1 e9 32          	shr    r9,0x32
        buffer[buf_index] = c_digits_lut[d1];
  21873b:	4c 8b 1e             	mov    r11,QWORD PTR [rsi]
  21873e:	48 8d 3d 83 d8 fe ff 	lea    rdi,[rip+0xfffffffffffed883]        # 205fc8 <c_digits_lut>
  218745:	42 8a 0c 4f          	mov    cl,BYTE PTR [rdi+r9*2]
  218749:	41 88 0c 03          	mov    BYTE PTR [r11+rax*1],cl
        const c0: u32 = v0 % 10000;
  21874d:	44 69 db 10 27 00 00 	imul   r11d,ebx,0x2710
        const d2: u32 = (b0 % 100) << 1;
  218754:	48 69 cb 1f 85 eb 51 	imul   rcx,rbx,0x51eb851f
  21875b:	48 c1 e9 25          	shr    rcx,0x25
  21875f:	6b c9 64             	imul   ecx,ecx,0x64
        const c0: u32 = v0 % 10000;
  218762:	45 29 de             	sub    r14d,r11d
        const d2: u32 = (b0 % 100) << 1;
  218765:	29 cb                	sub    ebx,ecx
        const d1: u32 = (b0 / 100) << 1;
  218767:	4b 8d 0c 09          	lea    rcx,[r9+r9*1]
        buffer[buf_index] = c_digits_lut[d1 + 1];
  21876b:	83 c9 01             	or     ecx,0x1
  21876e:	44 8a 0c 39          	mov    r9b,BYTE PTR [rcx+rdi*1]
  218772:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218775:	44 88 4c 01 01       	mov    BYTE PTR [rcx+rax*1+0x1],r9b
        buffer[buf_index] = c_digits_lut[d2];
  21877a:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  21877d:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  218780:	41 88 4c 01 02       	mov    BYTE PTR [r9+rax*1+0x2],cl
        const d2: u32 = (b0 % 100) << 1;
  218785:	48 8d 0c 1b          	lea    rcx,[rbx+rbx*1]
        const d3: u32 = (c0 / 100) << 1;
  218789:	49 69 de 1f 85 eb 51 	imul   rbx,r14,0x51eb851f
  218790:	48 c1 eb 25          	shr    rbx,0x25
        buffer[buf_index] = c_digits_lut[d2 + 1];
  218794:	83 c9 01             	or     ecx,0x1
  218797:	44 8a 0c 39          	mov    r9b,BYTE PTR [rcx+rdi*1]
  21879b:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  21879e:	44 88 4c 01 03       	mov    BYTE PTR [rcx+rax*1+0x3],r9b
        buffer[buf_index] = c_digits_lut[d3];
  2187a3:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  2187a6:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  2187a9:	41 88 4c 01 04       	mov    BYTE PTR [r9+rax*1+0x4],cl
        const d4: u32 = (c0 % 100) << 1;
  2187ae:	6b cb 64             	imul   ecx,ebx,0x64
        const v1 = @intCast(u32, value % kTen8);
  2187b1:	4c 29 c2             	sub    rdx,r8
        const d3: u32 = (c0 / 100) << 1;
  2187b4:	48 8d 1c 1b          	lea    rbx,[rbx+rbx*1]
        const d4: u32 = (c0 % 100) << 1;
  2187b8:	41 29 ce             	sub    r14d,ecx
        buffer[buf_index] = c_digits_lut[d3 + 1];
  2187bb:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2187be:	83 cb 01             	or     ebx,0x1
  2187c1:	8a 1c 3b             	mov    bl,BYTE PTR [rbx+rdi*1]
  2187c4:	88 5c 01 05          	mov    BYTE PTR [rcx+rax*1+0x5],bl
        const d4: u32 = (c0 % 100) << 1;
  2187c8:	4b 8d 0c 36          	lea    rcx,[r14+r14*1]
        const b1: u32 = v1 / 10000;
  2187cc:	4c 0f af d2          	imul   r10,rdx
  2187d0:	49 c1 ea 2d          	shr    r10,0x2d
        buffer[buf_index] = c_digits_lut[d4];
  2187d4:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  2187d7:	42 8a 1c 77          	mov    bl,BYTE PTR [rdi+r14*2]
  2187db:	41 88 5c 00 06       	mov    BYTE PTR [r8+rax*1+0x6],bl
        const d5: u32 = (b1 / 100) << 1;
  2187e0:	48 69 da 83 de 1b 43 	imul   rbx,rdx,0x431bde83
  2187e7:	48 c1 eb 31          	shr    rbx,0x31
  2187eb:	81 e3 fe 01 00 00    	and    ebx,0x1fe
        buffer[buf_index] = c_digits_lut[d4 + 1];
  2187f1:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  2187f4:	83 c9 01             	or     ecx,0x1
  2187f7:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  2187fa:	41 88 4c 00 07       	mov    BYTE PTR [r8+rax*1+0x7],cl
        buf_index += 1;
  2187ff:	48 83 c8 08          	or     rax,0x8
        buffer[buf_index] = c_digits_lut[d5];
  218803:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  218806:	8a 0c 3b             	mov    cl,BYTE PTR [rbx+rdi*1]
  218809:	41 88 0c 00          	mov    BYTE PTR [r8+rax*1],cl
        const c1: u32 = v1 % 10000;
  21880d:	45 69 c2 10 27 00 00 	imul   r8d,r10d,0x2710
        const d6: u32 = (b1 % 100) << 1;
  218814:	49 69 ca 1f 85 eb 51 	imul   rcx,r10,0x51eb851f
  21881b:	48 c1 e9 25          	shr    rcx,0x25
  21881f:	6b c9 64             	imul   ecx,ecx,0x64
        const c1: u32 = v1 % 10000;
  218822:	44 29 c2             	sub    edx,r8d
        const d6: u32 = (b1 % 100) << 1;
  218825:	41 29 ca             	sub    r10d,ecx
        buffer[buf_index] = c_digits_lut[d5 + 1];
  218828:	8d 4b 01             	lea    ecx,[rbx+0x1]
  21882b:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  21882e:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  218831:	88 4c 03 01          	mov    BYTE PTR [rbx+rax*1+0x1],cl
        buffer[buf_index] = c_digits_lut[d6];
  218835:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218838:	42 8a 1c 57          	mov    bl,BYTE PTR [rdi+r10*2]
  21883c:	88 5c 01 02          	mov    BYTE PTR [rcx+rax*1+0x2],bl
        const d6: u32 = (b1 % 100) << 1;
  218840:	4b 8d 0c 12          	lea    rcx,[r10+r10*1]
        const d7: u32 = (c1 / 100) << 1;
  218844:	48 69 da 1f 85 eb 51 	imul   rbx,rdx,0x51eb851f
  21884b:	48 c1 eb 25          	shr    rbx,0x25
        buffer[buf_index] = c_digits_lut[d6 + 1];
  21884f:	83 c9 01             	or     ecx,0x1
  218852:	44 8a 04 39          	mov    r8b,BYTE PTR [rcx+rdi*1]
  218856:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218859:	44 88 44 01 03       	mov    BYTE PTR [rcx+rax*1+0x3],r8b
        buffer[buf_index] = c_digits_lut[d7];
  21885e:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  218861:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  218864:	41 88 4c 00 04       	mov    BYTE PTR [r8+rax*1+0x4],cl
        const d8: u32 = (c1 % 100) << 1;
  218869:	6b cb 64             	imul   ecx,ebx,0x64
  21886c:	29 ca                	sub    edx,ecx
        const d7: u32 = (c1 / 100) << 1;
  21886e:	48 8d 0c 1b          	lea    rcx,[rbx+rbx*1]
        buffer[buf_index] = c_digits_lut[d7 + 1];
  218872:	83 c9 01             	or     ecx,0x1
  218875:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  218878:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  21887b:	88 4c 03 05          	mov    BYTE PTR [rbx+rax*1+0x5],cl
        buffer[buf_index] = c_digits_lut[d8];
  21887f:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218882:	8a 1c 57             	mov    bl,BYTE PTR [rdi+rdx*2]
  218885:	88 5c 01 06          	mov    BYTE PTR [rcx+rax*1+0x6],bl
        const d8: u32 = (c1 % 100) << 1;
  218889:	48 8d 0c 12          	lea    rcx,[rdx+rdx*1]
        buffer[buf_index] = c_digits_lut[d8 + 1];
  21888d:	83 c9 01             	or     ecx,0x1
  218890:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  218893:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218896:	88 4c 02 07          	mov    BYTE PTR [rdx+rax*1+0x7],cl
        buf_index += 1;
  21889a:	48 83 c0 08          	add    rax,0x8
    return buf_index;
  21889e:	5b                   	pop    rbx
  21889f:	41 5e                	pop    r14
  2188a1:	41 5f                	pop    r15
  2188a3:	c3                   	ret    
        if (value >= kTen11) {
  2188a4:	48 89 f8             	mov    rax,rdi
  2188a7:	48 c1 e8 0b          	shr    rax,0xb
  2188ab:	48 3d dd 0e e9 02    	cmp    rax,0x2e90edd
  2188b1:	72 07                	jb     2188ba <u64toa+0x6ba>
  2188b3:	31 c0                	xor    eax,eax
  2188b5:	e9 ef fb ff ff       	jmp    2184a9 <u64toa+0x2a9>
        if (value >= kTen10) {
  2188ba:	48 89 f8             	mov    rax,rdi
  2188bd:	48 c1 e8 0a          	shr    rax,0xa
  2188c1:	48 3d f9 02 95 00    	cmp    rax,0x9502f9
  2188c7:	72 07                	jb     2188d0 <u64toa+0x6d0>
  2188c9:	31 c0                	xor    eax,eax
  2188cb:	e9 ee fb ff ff       	jmp    2184be <u64toa+0x2be>
  2188d0:	31 c0                	xor    eax,eax
        if (value >= kTen9) {
  2188d2:	48 81 ff 00 ca 9a 3b 	cmp    rdi,0x3b9aca00
  2188d9:	0f 83 f8 fb ff ff    	jae    2184d7 <u64toa+0x2d7>
  2188df:	e9 08 fc ff ff       	jmp    2184ec <u64toa+0x2ec>
  2188e4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2188eb:	00 00 00 00 00 

00000000002188f0 <frexp64>:
    y |= 0x3F000000;
    result.significand = @bitCast(f32, y);
    return result;
}

fn frexp64(x: f64) frexp64_result {
  2188f0:	53                   	push   rbx
  2188f1:	48 83 ec 10          	sub    rsp,0x10
  2188f5:	48 89 fb             	mov    rbx,rdi
    var result: frexp64_result = undefined;

    var y = @bitCast(u64, x);
  2188f8:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    const e = @intCast(i32, y >> 52) & 0x7FF;
  2188fd:	48 89 c8             	mov    rax,rcx
  218900:	48 c1 e8 34          	shr    rax,0x34

    if (e == 0) {
  218904:	89 c2                	mov    edx,eax
  218906:	81 e2 ff 07 00 00    	and    edx,0x7ff
  21890c:	81 fa ff 07 00 00    	cmp    edx,0x7ff
  218912:	74 31                	je     218945 <frexp64+0x55>
  218914:	66 85 d2             	test   dx,dx
  218917:	75 3d                	jne    218956 <frexp64+0x66>
        if (x != 0) {
  218919:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  21891d:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  218921:	74 63                	je     218986 <frexp64+0x96>
            // subnormal
            result = frexp64(x * 0x1.0p64);
  218923:	c5 fb 59 05 3d 83 fe 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffe833d]        # 200c68 <app_mask+0x30>
  21892a:	ff 
  21892b:	48 89 e7             	mov    rdi,rsp
  21892e:	e8 bd ff ff ff       	call   2188f0 <frexp64>
  218933:	c5 fb 10 04 24       	vmovsd xmm0,QWORD PTR [rsp]
  218938:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
  21893c:	8b 4c 24 0c          	mov    ecx,DWORD PTR [rsp+0xc]
            result.exponent -= 64;
  218940:	83 c0 c0             	add    eax,0xffffffc0
  218943:	eb 43                	jmp    218988 <frexp64+0x98>
        // frexp(+-inf) = (+-inf, 0)
        if (math.isInf(x)) {
            result.exponent = 0;
        }

        return result;
  218945:	c5 fb 11 03          	vmovsd QWORD PTR [rbx],xmm0
  218949:	c7 43 08 00 00 00 00 	mov    DWORD PTR [rbx+0x8],0x0
  218950:	48 83 c4 10          	add    rsp,0x10
  218954:	5b                   	pop    rbx
  218955:	c3                   	ret    
    const e = @intCast(i32, y >> 52) & 0x7FF;
  218956:	25 ff 07 00 00       	and    eax,0x7ff
    }

    result.exponent = e - 0x3FE;
  21895b:	05 02 fc ff ff       	add    eax,0xfffffc02
    y &= 0x800FFFFFFFFFFFFF;
  218960:	48 ba ff ff ff ff ff 	movabs rdx,0x800fffffffffffff
  218967:	ff 0f 80 
  21896a:	48 21 d1             	and    rcx,rdx
    y |= 0x3FE0000000000000;
  21896d:	48 ba 00 00 00 00 00 	movabs rdx,0x3fe0000000000000
  218974:	00 e0 3f 
  218977:	48 09 ca             	or     rdx,rcx
    result.significand = @bitCast(f64, y);
    return result;
  21897a:	48 89 13             	mov    QWORD PTR [rbx],rdx
  21897d:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  218980:	48 83 c4 10          	add    rsp,0x10
  218984:	5b                   	pop    rbx
  218985:	c3                   	ret    
  218986:	31 c0                	xor    eax,eax
        return result;
  218988:	c5 fb 11 03          	vmovsd QWORD PTR [rbx],xmm0
  21898c:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  21898f:	89 4b 0c             	mov    DWORD PTR [rbx+0xc],ecx
  218992:	48 83 c4 10          	add    rsp,0x10
  218996:	5b                   	pop    rbx
  218997:	c3                   	ret    
  218998:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21899f:	00 

00000000002189a0 <_start>:
}

nakedcc fn _start() noreturn {
    switch (builtin.arch) {
        builtin.Arch.x86_64 => {
            argc_ptr = asm ("lea (%%rsp), %[argc]"
  2189a0:	48 8d 04 24          	lea    rax,[rsp]
  2189a4:	48 89 05 05 47 00 00 	mov    QWORD PTR [rip+0x4705],rax        # 21d0b0 <argc_ptr>
        },
        else => @compileError("unsupported arch"),
    }
    // If LLVM inlines stack variables into _start, they will overwrite
    // the command line argument data.
    @noInlineCall(posixCallMainAndExit);
  2189ab:	e8 00 00 00 00       	call   2189b0 <posixCallMainAndExit>

00000000002189b0 <posixCallMainAndExit>:
    std.os.windows.ExitProcess(callMain());
}

// TODO https://github.com/ziglang/zig/issues/265
fn posixCallMainAndExit() noreturn {
    const argc = argc_ptr[0];
  2189b0:	41 56                	push   r14
  2189b2:	53                   	push   rbx
  2189b3:	48 83 ec 18          	sub    rsp,0x18
  2189b7:	48 8b 15 f2 46 00 00 	mov    rdx,QWORD PTR [rip+0x46f2]        # 21d0b0 <argc_ptr>
  2189be:	48 8b 1a             	mov    rbx,QWORD PTR [rdx]
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);

    const envp_optional = @ptrCast([*]?[*]u8, argv + argc + 1);
  2189c1:	48 8d 0c da          	lea    rcx,[rdx+rbx*8]
  2189c5:	48 83 c1 10          	add    rcx,0x10
    var envp_count: usize = 0;
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  2189c9:	48 8d 04 da          	lea    rax,[rdx+rbx*8]
  2189cd:	48 83 c0 20          	add    rax,0x20
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);
  2189d1:	4c 8d 72 08          	lea    r14,[rdx+0x8]
  2189d5:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  2189dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  2189e0:	48 83 c2 01          	add    rdx,0x1
  2189e4:	48 83 78 f0 00       	cmp    QWORD PTR [rax-0x10],0x0
  2189e9:	48 8d 40 08          	lea    rax,[rax+0x8]
  2189ed:	75 f1                	jne    2189e0 <posixCallMainAndExit+0x30>
    const envp = @ptrCast([*][*]u8, envp_optional)[0..envp_count];
  2189ef:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2189f4:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
    if (builtin.os == builtin.Os.linux) {
        const auxv = @ptrCast([*]usize, envp.ptr + envp_count + 1);
        var i: usize = 0;
        while (auxv[i] != 0) : (i += 2) {
  2189f9:	48 8b 48 f0          	mov    rcx,QWORD PTR [rax-0x10]
  2189fd:	48 85 c9             	test   rcx,rcx
  218a00:	74 28                	je     218a2a <posixCallMainAndExit+0x7a>
  218a02:	48 8d 15 5f 86 00 00 	lea    rdx,[rip+0x865f]        # 221068 <linux_aux_raw>
  218a09:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
            if (auxv[i] < std.os.linux_aux_raw.len) std.os.linux_aux_raw[auxv[i]] = auxv[i + 1];
  218a10:	48 83 f9 25          	cmp    rcx,0x25
  218a14:	77 08                	ja     218a1e <posixCallMainAndExit+0x6e>
  218a16:	48 8b 70 f8          	mov    rsi,QWORD PTR [rax-0x8]
  218a1a:	48 89 34 ca          	mov    QWORD PTR [rdx+rcx*8],rsi
        while (auxv[i] != 0) : (i += 2) {
  218a1e:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  218a21:	48 83 c0 10          	add    rax,0x10
  218a25:	48 85 c9             	test   rcx,rcx
  218a28:	75 e6                	jne    218a10 <posixCallMainAndExit+0x60>
        }
        std.debug.assert(std.os.linux_aux_raw[std.elf.AT_PAGESZ] == std.os.page_size);
  218a2a:	31 ff                	xor    edi,edi
  218a2c:	48 81 3d 61 86 00 00 	cmp    QWORD PTR [rip+0x8661],0x1000        # 221098 <linux_aux_raw+0x30>
  218a33:	00 10 00 00 
  218a37:	40 0f 94 c7          	sete   dil
  218a3b:	e8 c0 f5 fe ff       	call   208000 <assert>
  218a40:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
    }

    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
  218a45:	48 89 df             	mov    rdi,rbx
  218a48:	4c 89 f6             	mov    rsi,r14
  218a4b:	e8 10 00 00 00       	call   218a60 <callMainWithArgs>
    _ = syscall1(SYS_exit, @bitCast(usize, isize(status)));
  218a50:	0f b6 f8             	movzx  edi,al
    return asm volatile ("syscall"
  218a53:	b8 3c 00 00 00       	mov    eax,0x3c
  218a58:	0f 05                	syscall 
  218a5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000218a60 <callMainWithArgs>:
}

fn callMainWithArgs(argc: usize, argv: [*][*]u8, envp: [][*]u8) u8 {
    std.os.ArgIteratorPosix.raw = argv[0..argc];
  218a60:	55                   	push   rbp
  218a61:	41 57                	push   r15
  218a63:	41 56                	push   r14
  218a65:	53                   	push   rbx
  218a66:	48 83 ec 58          	sub    rsp,0x58
  218a6a:	48 89 35 47 46 00 00 	mov    QWORD PTR [rip+0x4647],rsi        # 21d0b8 <raw>
  218a71:	48 89 3d 48 46 00 00 	mov    QWORD PTR [rip+0x4648],rdi        # 21d0c0 <raw+0x8>
    std.os.posix_environ_raw = envp;
  218a78:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  218a7c:	c5 f8 11 05 1c 46 00 	vmovups XMMWORD PTR [rip+0x461c],xmm0        # 21d0a0 <posix_environ_raw>
  218a83:	00 
    if (stderr_stream) |st| {
  218a84:	48 8b 1d a5 85 00 00 	mov    rbx,QWORD PTR [rip+0x85a5]        # 221030 <stderr_stream>
  218a8b:	48 85 db             	test   rbx,rbx
  218a8e:	74 09                	je     218a99 <callMainWithArgs+0x39>
            return std.fmt.format(self, Error, self.writeFn, format, args);
  218a90:	48 8b 2d 99 45 00 00 	mov    rbp,QWORD PTR [rip+0x4599]        # 21d030 <stderr_file_out_stream+0x8>
  218a97:	eb 34                	jmp    218acd <callMainWithArgs+0x6d>
        stderr_file = try io.getStdErr();
  218a99:	48 8d 05 80 45 00 00 	lea    rax,[rip+0x4580]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218aa0:	48 89 05 81 45 00 00 	mov    QWORD PTR [rip+0x4581],rax        # 21d028 <stderr_file_out_stream>
  218aa7:	48 8d 2d 92 2e ff ff 	lea    rbp,[rip+0xffffffffffff2e92]        # 20b940 <FileOutStream_writeFn>
  218aae:	48 89 2d 7b 45 00 00 	mov    QWORD PTR [rip+0x457b],rbp        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  218ab5:	c7 05 61 45 00 00 02 	mov    DWORD PTR [rip+0x4561],0x2        # 21d020 <stderr_file>
  218abc:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218abf:	48 8d 1d 6a 45 00 00 	lea    rbx,[rip+0x456a]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  218ac6:	48 89 1d 63 85 00 00 	mov    QWORD PTR [rip+0x8563],rbx        # 221030 <stderr_stream>
  218acd:	4c 8d 74 24 4f       	lea    r14,[rsp+0x4f]
                        try output(context, fmt[start_index..i]);
  218ad2:	48 8d 35 5f 83 00 00 	lea    rsi,[rip+0x835f]        # 220e38 <__unnamed_89>
  218ad9:	48 89 df             	mov    rdi,rbx
  218adc:	ff d5                	call   rbp
  218ade:	66 85 c0             	test   ax,ax
  218ae1:	0f 85 cb 00 00 00    	jne    218bb2 <callMainWithArgs+0x152>
    var buf: [max_int_digits - 1]u8 = undefined;
  218ae7:	c5 fc 10 05 89 ec fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffeec89]        # 207778 <__unnamed_14+0x1f>
  218aee:	ff 
  218aef:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  218af5:	c5 fc 10 05 5c ec fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffeec5c]        # 207759 <__unnamed_14>
  218afc:	ff 
  218afd:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  218b03:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  218b08:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  218b0c:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  218b13:	00 00 
  218b15:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  218b18:	48 89 df             	mov    rdi,rbx
  218b1b:	c5 f8 77             	vzeroupper 
  218b1e:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218b20:	66 85 c0             	test   ax,ax
  218b23:	0f 85 89 00 00 00    	jne    218bb2 <callMainWithArgs+0x152>
                        try output(context, fmt[start_index..i]);
  218b29:	48 8d 35 18 83 00 00 	lea    rsi,[rip+0x8318]        # 220e48 <__unnamed_90>
  218b30:	48 89 df             	mov    rdi,rbx
  218b33:	ff d5                	call   rbp
  218b35:	66 85 c0             	test   ax,ax
  218b38:	75 78                	jne    218bb2 <callMainWithArgs+0x152>
    var buf: [max_int_digits - 1]u8 = undefined;
  218b3a:	c5 fc 10 05 36 ec fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffeec36]        # 207778 <__unnamed_14+0x1f>
  218b41:	ff 
  218b42:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  218b48:	c5 fc 10 05 09 ec fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffeec09]        # 207759 <__unnamed_14>
  218b4f:	ff 
  218b50:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  218b56:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  218b5b:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  218b5f:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  218b66:	00 00 
  218b68:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  218b6b:	48 89 df             	mov    rdi,rbx
  218b6e:	c5 f8 77             	vzeroupper 
  218b71:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218b73:	66 85 c0             	test   ax,ax
  218b76:	75 3a                	jne    218bb2 <callMainWithArgs+0x152>
                        try output(context, fmt[start_index..i]);
  218b78:	48 8d 35 d9 82 00 00 	lea    rsi,[rip+0x82d9]        # 220e58 <__unnamed_91>
  218b7f:	48 89 df             	mov    rdi,rbx
  218b82:	ff d5                	call   rbp
  218b84:	66 85 c0             	test   ax,ax
  218b87:	75 29                	jne    218bb2 <callMainWithArgs+0x152>
                const casted_value = ([]const u8)(value);
  218b89:	c5 f8 10 05 8f 7f 00 	vmovups xmm0,XMMWORD PTR [rip+0x7f8f]        # 220b20 <__unnamed_92>
  218b90:	00 
  218b91:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  218b97:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  218b9c:	48 89 df             	mov    rdi,rbx
  218b9f:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218ba1:	66 85 c0             	test   ax,ax
  218ba4:	75 0c                	jne    218bb2 <callMainWithArgs+0x152>
        try output(context, fmt[start_index..]);
  218ba6:	48 8d 35 bb 82 00 00 	lea    rsi,[rip+0x82bb]        # 220e68 <__unnamed_93>
  218bad:	48 89 df             	mov    rdi,rbx
  218bb0:	ff d5                	call   rbp
    var ok_count: usize = 0;
    var skip_count: usize = 0;
    for (test_fn_list) |test_fn, i| {
        warn("Test {}/{} {}...", i + 1, test_fn_list.len, test_fn.name);

        if (test_fn.func()) |_| {
  218bb2:	e8 19 fa fe ff       	call   2085d0 <Futex>
  218bb7:	89 c5                	mov    ebp,eax
  218bb9:	0f b7 c5             	movzx  eax,bp
  218bbc:	83 f8 29             	cmp    eax,0x29
  218bbf:	74 1a                	je     218bdb <callMainWithArgs+0x17b>
  218bc1:	66 85 ed             	test   bp,bp
  218bc4:	75 31                	jne    218bf7 <callMainWithArgs+0x197>
    if (stderr_stream) |st| {
  218bc6:	48 8b 3d 63 84 00 00 	mov    rdi,QWORD PTR [rip+0x8463]        # 221030 <stderr_stream>
  218bcd:	48 85 ff             	test   rdi,rdi
  218bd0:	74 41                	je     218c13 <callMainWithArgs+0x1b3>
  218bd2:	48 8b 0d 57 44 00 00 	mov    rcx,QWORD PTR [rip+0x4457]        # 21d030 <stderr_file_out_stream+0x8>
  218bd9:	eb 6c                	jmp    218c47 <callMainWithArgs+0x1e7>
  218bdb:	48 8b 3d 4e 84 00 00 	mov    rdi,QWORD PTR [rip+0x844e]        # 221030 <stderr_stream>
  218be2:	48 85 ff             	test   rdi,rdi
  218be5:	0f 84 81 00 00 00    	je     218c6c <callMainWithArgs+0x20c>
  218beb:	48 8b 05 3e 44 00 00 	mov    rax,QWORD PTR [rip+0x443e]        # 21d030 <stderr_file_out_stream+0x8>
  218bf2:	e9 a9 00 00 00       	jmp    218ca0 <callMainWithArgs+0x240>
  218bf7:	4c 8b 35 32 84 00 00 	mov    r14,QWORD PTR [rip+0x8432]        # 221030 <stderr_stream>
  218bfe:	4d 85 f6             	test   r14,r14
  218c01:	0f 84 be 00 00 00    	je     218cc5 <callMainWithArgs+0x265>
  218c07:	4c 8b 3d 22 44 00 00 	mov    r15,QWORD PTR [rip+0x4422]        # 21d030 <stderr_file_out_stream+0x8>
  218c0e:	e9 e6 00 00 00       	jmp    218cf9 <callMainWithArgs+0x299>
        stderr_file = try io.getStdErr();
  218c13:	48 8d 05 06 44 00 00 	lea    rax,[rip+0x4406]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218c1a:	48 89 05 07 44 00 00 	mov    QWORD PTR [rip+0x4407],rax        # 21d028 <stderr_file_out_stream>
  218c21:	48 8d 0d 18 2d ff ff 	lea    rcx,[rip+0xffffffffffff2d18]        # 20b940 <FileOutStream_writeFn>
  218c28:	48 89 0d 01 44 00 00 	mov    QWORD PTR [rip+0x4401],rcx        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  218c2f:	c7 05 e7 43 00 00 02 	mov    DWORD PTR [rip+0x43e7],0x2        # 21d020 <stderr_file>
  218c36:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218c39:	48 8d 3d f0 43 00 00 	lea    rdi,[rip+0x43f0]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  218c40:	48 89 3d e9 83 00 00 	mov    QWORD PTR [rip+0x83e9],rdi        # 221030 <stderr_stream>
  218c47:	48 8d 35 2a 82 00 00 	lea    rsi,[rip+0x822a]        # 220e78 <__unnamed_94>
  218c4e:	ff d1                	call   rcx
    if (stderr_stream) |st| {
  218c50:	48 8b 3d d9 83 00 00 	mov    rdi,QWORD PTR [rip+0x83d9]        # 221030 <stderr_stream>
  218c57:	48 85 ff             	test   rdi,rdi
  218c5a:	0f 84 f3 00 00 00    	je     218d53 <callMainWithArgs+0x2f3>
  218c60:	48 8b 0d c9 43 00 00 	mov    rcx,QWORD PTR [rip+0x43c9]        # 21d030 <stderr_file_out_stream+0x8>
  218c67:	e9 1b 01 00 00       	jmp    218d87 <callMainWithArgs+0x327>
        stderr_file = try io.getStdErr();
  218c6c:	48 8d 05 ad 43 00 00 	lea    rax,[rip+0x43ad]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218c73:	48 89 05 ae 43 00 00 	mov    QWORD PTR [rip+0x43ae],rax        # 21d028 <stderr_file_out_stream>
  218c7a:	48 8d 05 bf 2c ff ff 	lea    rax,[rip+0xffffffffffff2cbf]        # 20b940 <FileOutStream_writeFn>
  218c81:	48 89 05 a8 43 00 00 	mov    QWORD PTR [rip+0x43a8],rax        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  218c88:	c7 05 8e 43 00 00 02 	mov    DWORD PTR [rip+0x438e],0x2        # 21d020 <stderr_file>
  218c8f:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218c92:	48 8d 3d 97 43 00 00 	lea    rdi,[rip+0x4397]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  218c99:	48 89 3d 90 83 00 00 	mov    QWORD PTR [rip+0x8390],rdi        # 221030 <stderr_stream>
  218ca0:	48 8d 35 e1 81 00 00 	lea    rsi,[rip+0x81e1]        # 220e88 <__unnamed_95>
  218ca7:	ff d0                	call   rax
    if (stderr_stream) |st| {
  218ca9:	48 8b 1d 80 83 00 00 	mov    rbx,QWORD PTR [rip+0x8380]        # 221030 <stderr_stream>
  218cb0:	48 85 db             	test   rbx,rbx
  218cb3:	0f 84 dc 00 00 00    	je     218d95 <callMainWithArgs+0x335>
  218cb9:	48 8b 2d 70 43 00 00 	mov    rbp,QWORD PTR [rip+0x4370]        # 21d030 <stderr_file_out_stream+0x8>
  218cc0:	e9 04 01 00 00       	jmp    218dc9 <callMainWithArgs+0x369>
        stderr_file = try io.getStdErr();
  218cc5:	48 8d 05 54 43 00 00 	lea    rax,[rip+0x4354]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218ccc:	48 89 05 55 43 00 00 	mov    QWORD PTR [rip+0x4355],rax        # 21d028 <stderr_file_out_stream>
  218cd3:	4c 8d 3d 66 2c ff ff 	lea    r15,[rip+0xffffffffffff2c66]        # 20b940 <FileOutStream_writeFn>
  218cda:	4c 89 3d 4f 43 00 00 	mov    QWORD PTR [rip+0x434f],r15        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  218ce1:	c7 05 35 43 00 00 02 	mov    DWORD PTR [rip+0x4335],0x2        # 21d020 <stderr_file>
  218ce8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218ceb:	4c 8d 35 3e 43 00 00 	lea    r14,[rip+0x433e]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  218cf2:	4c 89 35 37 83 00 00 	mov    QWORD PTR [rip+0x8337],r14        # 221030 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  218cf9:	48 8d 35 c8 81 00 00 	lea    rsi,[rip+0x81c8]        # 220ec8 <__unnamed_96>
  218d00:	4c 89 f7             	mov    rdi,r14
  218d03:	41 ff d7             	call   r15
  218d06:	b3 01                	mov    bl,0x1
  218d08:	66 85 c0             	test   ax,ax
  218d0b:	0f 85 53 01 00 00    	jne    218e64 <callMainWithArgs+0x404>
  218d11:	48 0f bf c5          	movsx  rax,bp
  218d15:	48 c1 e0 04          	shl    rax,0x4
  218d19:	48 8d 0d e0 52 00 00 	lea    rcx,[rip+0x52e0]        # 21e000 <raw+0xf48>
  218d20:	48 01 c1             	add    rcx,rax
                const casted_value = ([]const u8)(value);
  218d23:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  218d27:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  218d2d:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  218d32:	4c 89 f7             	mov    rdi,r14
  218d35:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218d38:	66 85 c0             	test   ax,ax
  218d3b:	0f 85 23 01 00 00    	jne    218e64 <callMainWithArgs+0x404>
        try output(context, fmt[start_index..]);
  218d41:	48 8d 35 90 81 00 00 	lea    rsi,[rip+0x8190]        # 220ed8 <__unnamed_97>
  218d48:	4c 89 f7             	mov    rdi,r14
  218d4b:	41 ff d7             	call   r15
  218d4e:	e9 11 01 00 00       	jmp    218e64 <callMainWithArgs+0x404>
        stderr_file = try io.getStdErr();
  218d53:	48 8d 05 c6 42 00 00 	lea    rax,[rip+0x42c6]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218d5a:	48 89 05 c7 42 00 00 	mov    QWORD PTR [rip+0x42c7],rax        # 21d028 <stderr_file_out_stream>
  218d61:	48 8d 0d d8 2b ff ff 	lea    rcx,[rip+0xffffffffffff2bd8]        # 20b940 <FileOutStream_writeFn>
  218d68:	48 89 0d c1 42 00 00 	mov    QWORD PTR [rip+0x42c1],rcx        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  218d6f:	c7 05 a7 42 00 00 02 	mov    DWORD PTR [rip+0x42a7],0x2        # 21d020 <stderr_file>
  218d76:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218d79:	48 8d 3d b0 42 00 00 	lea    rdi,[rip+0x42b0]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  218d80:	48 89 3d a9 82 00 00 	mov    QWORD PTR [rip+0x82a9],rdi        # 221030 <stderr_stream>
  218d87:	48 8d 35 0a 81 00 00 	lea    rsi,[rip+0x810a]        # 220e98 <__unnamed_98>
  218d8e:	ff d1                	call   rcx
  218d90:	e9 cd 00 00 00       	jmp    218e62 <callMainWithArgs+0x402>
        stderr_file = try io.getStdErr();
  218d95:	48 8d 05 84 42 00 00 	lea    rax,[rip+0x4284]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218d9c:	48 89 05 85 42 00 00 	mov    QWORD PTR [rip+0x4285],rax        # 21d028 <stderr_file_out_stream>
  218da3:	48 8d 2d 96 2b ff ff 	lea    rbp,[rip+0xffffffffffff2b96]        # 20b940 <FileOutStream_writeFn>
  218daa:	48 89 2d 7f 42 00 00 	mov    QWORD PTR [rip+0x427f],rbp        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  218db1:	c7 05 65 42 00 00 02 	mov    DWORD PTR [rip+0x4265],0x2        # 21d020 <stderr_file>
  218db8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218dbb:	48 8d 1d 6e 42 00 00 	lea    rbx,[rip+0x426e]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  218dc2:	48 89 1d 67 82 00 00 	mov    QWORD PTR [rip+0x8267],rbx        # 221030 <stderr_stream>
    var buf: [max_int_digits - 1]u8 = undefined;
  218dc9:	c5 fc 10 05 a7 e9 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffee9a7]        # 207778 <__unnamed_14+0x1f>
  218dd0:	ff 
  218dd1:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  218dd7:	c5 fc 10 05 7a e9 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffee97a]        # 207759 <__unnamed_14>
  218dde:	ff 
  218ddf:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  218de5:	c6 44 24 4f 30       	mov    BYTE PTR [rsp+0x4f],0x30
        const padded_buf = buf[index - padding ..];
  218dea:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  218dee:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  218df5:	00 00 
  218df7:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  218dfa:	48 89 df             	mov    rdi,rbx
  218dfd:	c5 f8 77             	vzeroupper 
  218e00:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218e02:	66 85 c0             	test   ax,ax
  218e05:	75 5b                	jne    218e62 <callMainWithArgs+0x402>
                        try output(context, fmt[start_index..i]);
  218e07:	48 8d 35 9a 80 00 00 	lea    rsi,[rip+0x809a]        # 220ea8 <__unnamed_99>
  218e0e:	48 89 df             	mov    rdi,rbx
  218e11:	ff d5                	call   rbp
  218e13:	66 85 c0             	test   ax,ax
  218e16:	75 4a                	jne    218e62 <callMainWithArgs+0x402>
    var buf: [max_int_digits - 1]u8 = undefined;
  218e18:	c5 fc 10 05 58 e9 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffee958]        # 207778 <__unnamed_14+0x1f>
  218e1f:	ff 
  218e20:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  218e26:	c5 fc 10 05 2b e9 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffee92b]        # 207759 <__unnamed_14>
  218e2d:	ff 
  218e2e:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  218e34:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  218e39:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  218e3d:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  218e44:	00 00 
  218e46:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  218e49:	48 89 df             	mov    rdi,rbx
  218e4c:	c5 f8 77             	vzeroupper 
  218e4f:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218e51:	66 85 c0             	test   ax,ax
  218e54:	75 0c                	jne    218e62 <callMainWithArgs+0x402>
        try output(context, fmt[start_index..]);
  218e56:	48 8d 35 5b 80 00 00 	lea    rsi,[rip+0x805b]        # 220eb8 <__unnamed_100>
  218e5d:	48 89 df             	mov    rdi,rbx
  218e60:	ff d5                	call   rbp
  218e62:	31 db                	xor    ebx,ebx
    return callMain();
  218e64:	89 d8                	mov    eax,ebx
  218e66:	48 83 c4 58          	add    rsp,0x58
  218e6a:	5b                   	pop    rbx
  218e6b:	41 5e                	pop    r14
  218e6d:	41 5f                	pop    r15
  218e6f:	5d                   	pop    rbp
  218e70:	c3                   	ret    
  218e71:	cc                   	int3   
  218e72:	cc                   	int3   
  218e73:	cc                   	int3   
  218e74:	cc                   	int3   
  218e75:	cc                   	int3   
  218e76:	cc                   	int3   
  218e77:	cc                   	int3   
  218e78:	cc                   	int3   
  218e79:	cc                   	int3   
  218e7a:	cc                   	int3   
  218e7b:	cc                   	int3   
  218e7c:	cc                   	int3   
  218e7d:	cc                   	int3   
  218e7e:	cc                   	int3   
  218e7f:	cc                   	int3   

0000000000218e80 <memset>:

export fn memset(dest: ?[*]u8, c: u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  218e80:	48 85 d2             	test   rdx,rdx
  218e83:	0f 84 d4 01 00 00    	je     21905d <memset+0x1dd>
  218e89:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  218e90:	73 08                	jae    218e9a <memset+0x1a>
  218e92:	45 31 c0             	xor    r8d,r8d
  218e95:	e9 a8 01 00 00       	jmp    219042 <memset+0x1c2>
  218e9a:	49 89 d0             	mov    r8,rdx
  218e9d:	49 83 e0 80          	and    r8,0xffffffffffffff80
  218ea1:	c5 f9 6e c6          	vmovd  xmm0,esi
  218ea5:	c4 e2 7d 78 c0       	vpbroadcastb ymm0,xmm0
  218eaa:	49 8d 48 80          	lea    rcx,[r8-0x80]
  218eae:	48 89 c8             	mov    rax,rcx
  218eb1:	48 c1 e8 07          	shr    rax,0x7
  218eb5:	44 8d 48 01          	lea    r9d,[rax+0x1]
  218eb9:	41 83 e1 07          	and    r9d,0x7
  218ebd:	48 81 f9 80 03 00 00 	cmp    rcx,0x380
  218ec4:	73 10                	jae    218ed6 <memset+0x56>
  218ec6:	31 c0                	xor    eax,eax
  218ec8:	4d 85 c9             	test   r9,r9
  218ecb:	0f 85 44 01 00 00    	jne    219015 <memset+0x195>
  218ed1:	e9 67 01 00 00       	jmp    21903d <memset+0x1bd>
  218ed6:	48 8d 8f e0 03 00 00 	lea    rcx,[rdi+0x3e0]
  218edd:	4d 8d 51 ff          	lea    r10,[r9-0x1]
  218ee1:	49 29 c2             	sub    r10,rax
  218ee4:	31 c0                	xor    eax,eax
  218ee6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  218eed:	00 00 00 
        dest.?[index] = c;
  218ef0:	c5 fe 7f 84 01 20 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3e0],ymm0
  218ef7:	ff ff 
  218ef9:	c5 fe 7f 84 01 40 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3c0],ymm0
  218f00:	ff ff 
  218f02:	c5 fe 7f 84 01 60 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3a0],ymm0
  218f09:	ff ff 
  218f0b:	c5 fe 7f 84 01 80 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x380],ymm0
  218f12:	ff ff 
  218f14:	c5 fe 7f 84 01 a0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x360],ymm0
  218f1b:	ff ff 
  218f1d:	c5 fe 7f 84 01 c0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x340],ymm0
  218f24:	ff ff 
  218f26:	c5 fe 7f 84 01 e0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x320],ymm0
  218f2d:	ff ff 
  218f2f:	c5 fe 7f 84 01 00 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x300],ymm0
  218f36:	ff ff 
  218f38:	c5 fe 7f 84 01 20 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2e0],ymm0
  218f3f:	ff ff 
  218f41:	c5 fe 7f 84 01 40 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2c0],ymm0
  218f48:	ff ff 
  218f4a:	c5 fe 7f 84 01 60 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2a0],ymm0
  218f51:	ff ff 
  218f53:	c5 fe 7f 84 01 80 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x280],ymm0
  218f5a:	ff ff 
  218f5c:	c5 fe 7f 84 01 a0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x260],ymm0
  218f63:	ff ff 
  218f65:	c5 fe 7f 84 01 c0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x240],ymm0
  218f6c:	ff ff 
  218f6e:	c5 fe 7f 84 01 e0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x220],ymm0
  218f75:	ff ff 
  218f77:	c5 fe 7f 84 01 00 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x200],ymm0
  218f7e:	ff ff 
  218f80:	c5 fe 7f 84 01 20 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  218f87:	ff ff 
  218f89:	c5 fe 7f 84 01 40 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1c0],ymm0
  218f90:	ff ff 
  218f92:	c5 fe 7f 84 01 60 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1a0],ymm0
  218f99:	ff ff 
  218f9b:	c5 fe 7f 84 01 80 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x180],ymm0
  218fa2:	ff ff 
  218fa4:	c5 fe 7f 84 01 a0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x160],ymm0
  218fab:	ff ff 
  218fad:	c5 fe 7f 84 01 c0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x140],ymm0
  218fb4:	ff ff 
  218fb6:	c5 fe 7f 84 01 e0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x120],ymm0
  218fbd:	ff ff 
  218fbf:	c5 fe 7f 84 01 00 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0x100],ymm0
  218fc6:	ff ff 
  218fc8:	c5 fe 7f 84 01 20 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  218fcf:	ff ff 
  218fd1:	c5 fe 7f 84 01 40 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xc0],ymm0
  218fd8:	ff ff 
  218fda:	c5 fe 7f 84 01 60 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xa0],ymm0
  218fe1:	ff ff 
  218fe3:	c5 fe 7f 44 01 80    	vmovdqu YMMWORD PTR [rcx+rax*1-0x80],ymm0
  218fe9:	c5 fe 7f 44 01 a0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x60],ymm0
  218fef:	c5 fe 7f 44 01 c0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x40],ymm0
  218ff5:	c5 fe 7f 44 01 e0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x20],ymm0
  218ffb:	c5 fe 7f 04 01       	vmovdqu YMMWORD PTR [rcx+rax*1],ymm0
    while (index != n) : (index += 1)
  219000:	48 05 00 04 00 00    	add    rax,0x400
  219006:	49 83 c2 08          	add    r10,0x8
  21900a:	0f 85 e0 fe ff ff    	jne    218ef0 <memset+0x70>
  219010:	4d 85 c9             	test   r9,r9
  219013:	74 28                	je     21903d <memset+0x1bd>
  219015:	48 01 f8             	add    rax,rdi
  219018:	48 83 c0 60          	add    rax,0x60
  21901c:	49 f7 d9             	neg    r9
  21901f:	90                   	nop
        dest.?[index] = c;
  219020:	c5 fe 7f 40 a0       	vmovdqu YMMWORD PTR [rax-0x60],ymm0
  219025:	c5 fe 7f 40 c0       	vmovdqu YMMWORD PTR [rax-0x40],ymm0
  21902a:	c5 fe 7f 40 e0       	vmovdqu YMMWORD PTR [rax-0x20],ymm0
  21902f:	c5 fe 7f 00          	vmovdqu YMMWORD PTR [rax],ymm0
    while (index != n) : (index += 1)
  219033:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  219037:	49 83 c1 01          	add    r9,0x1
  21903b:	75 e3                	jne    219020 <memset+0x1a0>
  21903d:	49 39 d0             	cmp    r8,rdx
  219040:	74 1b                	je     21905d <memset+0x1dd>
        dest.?[index] = c;
  219042:	4a 8d 04 07          	lea    rax,[rdi+r8*1]
  219046:	4c 29 c2             	sub    rdx,r8
  219049:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  219050:	40 88 30             	mov    BYTE PTR [rax],sil
    while (index != n) : (index += 1)
  219053:	48 83 c0 01          	add    rax,0x1
  219057:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  21905b:	75 f3                	jne    219050 <memset+0x1d0>

    return dest;
  21905d:	48 89 f8             	mov    rax,rdi
  219060:	c5 f8 77             	vzeroupper 
  219063:	c3                   	ret    
  219064:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21906b:	00 00 00 00 00 

0000000000219070 <memcpy>:

export fn memcpy(noalias dest: ?[*]u8, noalias src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  219070:	48 85 d2             	test   rdx,rdx
  219073:	0f 84 d7 01 00 00    	je     219250 <memcpy+0x1e0>
  219079:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  219080:	73 07                	jae    219089 <memcpy+0x19>
  219082:	31 c0                	xor    eax,eax
  219084:	e9 b7 01 00 00       	jmp    219240 <memcpy+0x1d0>
  219089:	48 89 d0             	mov    rax,rdx
  21908c:	48 83 e0 80          	and    rax,0xffffffffffffff80
  219090:	4c 8d 48 80          	lea    r9,[rax-0x80]
  219094:	4c 89 c9             	mov    rcx,r9
  219097:	48 c1 e9 07          	shr    rcx,0x7
  21909b:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  21909f:	41 83 e0 03          	and    r8d,0x3
  2190a3:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  2190aa:	73 10                	jae    2190bc <memcpy+0x4c>
  2190ac:	31 c9                	xor    ecx,ecx
  2190ae:	4d 85 c0             	test   r8,r8
  2190b1:	0f 85 35 01 00 00    	jne    2191ec <memcpy+0x17c>
  2190b7:	e9 7c 01 00 00       	jmp    219238 <memcpy+0x1c8>
  2190bc:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  2190c0:	49 29 c9             	sub    r9,rcx
  2190c3:	31 c9                	xor    ecx,ecx
  2190c5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2190cc:	00 00 00 00 
        dest.?[index] = src.?[index];
  2190d0:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  2190d5:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  2190db:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  2190e1:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  2190e7:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  2190ec:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  2190f2:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  2190f8:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  2190fe:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  219105:	00 00 
  219107:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  21910e:	00 00 
  219110:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  219117:	00 00 
  219119:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  219120:	00 00 
  219122:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  219129:	00 00 
  21912b:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  219132:	00 00 
  219134:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  21913b:	00 00 
  21913d:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  219144:	00 00 
  219146:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  21914d:	00 00 
  21914f:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  219156:	00 00 
  219158:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  21915f:	00 00 
  219161:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  219168:	00 00 
  21916a:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  219171:	00 00 
  219173:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  21917a:	00 00 
  21917c:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  219183:	00 00 
  219185:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  21918c:	00 00 
  21918e:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  219195:	00 00 
  219197:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  21919e:	00 00 
  2191a0:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  2191a7:	00 00 
  2191a9:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  2191b0:	00 00 
  2191b2:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  2191b9:	00 00 
  2191bb:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  2191c2:	00 00 
  2191c4:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  2191cb:	00 00 
  2191cd:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  2191d4:	00 00 
    while (index != n) : (index += 1)
  2191d6:	48 81 c1 00 02 00 00 	add    rcx,0x200
  2191dd:	49 83 c1 04          	add    r9,0x4
  2191e1:	0f 85 e9 fe ff ff    	jne    2190d0 <memcpy+0x60>
  2191e7:	4d 85 c0             	test   r8,r8
  2191ea:	74 4c                	je     219238 <memcpy+0x1c8>
  2191ec:	48 83 c1 60          	add    rcx,0x60
  2191f0:	49 f7 d8             	neg    r8
  2191f3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2191fa:	84 00 00 00 00 00 
        dest.?[index] = src.?[index];
  219200:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  219206:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  21920c:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  219212:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  219217:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  21921d:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  219223:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  219229:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
    while (index != n) : (index += 1)
  21922e:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  219232:	49 83 c0 01          	add    r8,0x1
  219236:	75 c8                	jne    219200 <memcpy+0x190>
  219238:	48 39 d0             	cmp    rax,rdx
  21923b:	74 13                	je     219250 <memcpy+0x1e0>
  21923d:	0f 1f 00             	nop    DWORD PTR [rax]
        dest.?[index] = src.?[index];
  219240:	0f b6 0c 06          	movzx  ecx,BYTE PTR [rsi+rax*1]
  219244:	88 0c 07             	mov    BYTE PTR [rdi+rax*1],cl
    while (index != n) : (index += 1)
  219247:	48 83 c0 01          	add    rax,0x1
  21924b:	48 39 c2             	cmp    rdx,rax
  21924e:	75 f0                	jne    219240 <memcpy+0x1d0>

    return dest;
  219250:	48 89 f8             	mov    rax,rdi
  219253:	c5 f8 77             	vzeroupper 
  219256:	c3                   	ret    
  219257:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21925e:	00 00 

0000000000219260 <memmove>:
}

export fn memmove(dest: ?[*]u8, src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    if (@ptrToInt(dest) < @ptrToInt(src)) {
  219260:	48 39 f7             	cmp    rdi,rsi
  219263:	0f 83 cb 00 00 00    	jae    219334 <memmove+0xd4>
  219269:	48 85 d2             	test   rdx,rdx
        var index: usize = 0;
        while (index != n) : (index += 1) {
  21926c:	0f 84 0f 05 00 00    	je     219781 <memmove+0x521>
  219272:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  219279:	72 1a                	jb     219295 <memmove+0x35>
  21927b:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  21927f:	48 39 f8             	cmp    rax,rdi
  219282:	0f 86 0b 01 00 00    	jbe    219393 <memmove+0x133>
  219288:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  21928c:	48 39 f0             	cmp    rax,rsi
  21928f:	0f 86 fe 00 00 00    	jbe    219393 <memmove+0x133>
  219295:	45 31 d2             	xor    r10d,r10d
            dest.?[index] = src.?[index];
  219298:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  21929c:	4d 29 d0             	sub    r8,r10
  21929f:	48 89 d1             	mov    rcx,rdx
  2192a2:	48 83 e1 07          	and    rcx,0x7
  2192a6:	74 1b                	je     2192c3 <memmove+0x63>
  2192a8:	48 f7 d9             	neg    rcx
  2192ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  2192b0:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  2192b5:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
        while (index != n) : (index += 1) {
  2192b9:	49 83 c2 01          	add    r10,0x1
  2192bd:	48 83 c1 01          	add    rcx,0x1
  2192c1:	75 ed                	jne    2192b0 <memmove+0x50>
            dest.?[index] = src.?[index];
  2192c3:	49 83 f8 07          	cmp    r8,0x7
  2192c7:	0f 82 b4 04 00 00    	jb     219781 <memmove+0x521>
  2192cd:	0f 1f 00             	nop    DWORD PTR [rax]
  2192d0:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  2192d5:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
  2192d9:	42 0f b6 44 16 01    	movzx  eax,BYTE PTR [rsi+r10*1+0x1]
  2192df:	42 88 44 17 01       	mov    BYTE PTR [rdi+r10*1+0x1],al
  2192e4:	42 0f b6 44 16 02    	movzx  eax,BYTE PTR [rsi+r10*1+0x2]
  2192ea:	42 88 44 17 02       	mov    BYTE PTR [rdi+r10*1+0x2],al
  2192ef:	42 0f b6 44 16 03    	movzx  eax,BYTE PTR [rsi+r10*1+0x3]
  2192f5:	42 88 44 17 03       	mov    BYTE PTR [rdi+r10*1+0x3],al
  2192fa:	42 0f b6 44 16 04    	movzx  eax,BYTE PTR [rsi+r10*1+0x4]
  219300:	42 88 44 17 04       	mov    BYTE PTR [rdi+r10*1+0x4],al
  219305:	42 0f b6 44 16 05    	movzx  eax,BYTE PTR [rsi+r10*1+0x5]
  21930b:	42 88 44 17 05       	mov    BYTE PTR [rdi+r10*1+0x5],al
  219310:	42 0f b6 44 16 06    	movzx  eax,BYTE PTR [rsi+r10*1+0x6]
  219316:	42 88 44 17 06       	mov    BYTE PTR [rdi+r10*1+0x6],al
  21931b:	42 0f b6 44 16 07    	movzx  eax,BYTE PTR [rsi+r10*1+0x7]
  219321:	42 88 44 17 07       	mov    BYTE PTR [rdi+r10*1+0x7],al
        while (index != n) : (index += 1) {
  219326:	49 83 c2 08          	add    r10,0x8
  21932a:	4c 39 d2             	cmp    rdx,r10
  21932d:	75 a1                	jne    2192d0 <memmove+0x70>
  21932f:	e9 4d 04 00 00       	jmp    219781 <memmove+0x521>
  219334:	48 85 d2             	test   rdx,rdx
        }
    } else {
        var index = n;
        while (index != 0) {
  219337:	0f 84 44 04 00 00    	je     219781 <memmove+0x521>
  21933d:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  219344:	0f 82 2a 02 00 00    	jb     219574 <memmove+0x314>
  21934a:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  21934e:	48 39 f8             	cmp    rax,rdi
  219351:	76 0d                	jbe    219360 <memmove+0x100>
  219353:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  219357:	48 39 f0             	cmp    rax,rsi
  21935a:	0f 87 14 02 00 00    	ja     219574 <memmove+0x314>
  219360:	49 89 d0             	mov    r8,rdx
  219363:	49 83 e0 80          	and    r8,0xffffffffffffff80
  219367:	49 8d 48 80          	lea    rcx,[r8-0x80]
  21936b:	48 89 c8             	mov    rax,rcx
  21936e:	48 c1 e8 07          	shr    rax,0x7
  219372:	44 8d 48 01          	lea    r9d,[rax+0x1]
  219376:	41 83 e1 03          	and    r9d,0x3
  21937a:	48 81 f9 80 01 00 00 	cmp    rcx,0x180
  219381:	73 47                	jae    2193ca <memmove+0x16a>
  219383:	31 c0                	xor    eax,eax
  219385:	4d 85 c9             	test   r9,r9
  219388:	0f 85 8a 01 00 00    	jne    219518 <memmove+0x2b8>
  21938e:	e9 d5 01 00 00       	jmp    219568 <memmove+0x308>
        while (index != n) : (index += 1) {
  219393:	49 89 d2             	mov    r10,rdx
  219396:	49 83 e2 80          	and    r10,0xffffffffffffff80
  21939a:	4d 8d 4a 80          	lea    r9,[r10-0x80]
  21939e:	4c 89 c9             	mov    rcx,r9
  2193a1:	48 c1 e9 07          	shr    rcx,0x7
  2193a5:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  2193a9:	41 83 e0 03          	and    r8d,0x3
  2193ad:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  2193b4:	0f 83 4c 02 00 00    	jae    219606 <memmove+0x3a6>
  2193ba:	31 c9                	xor    ecx,ecx
  2193bc:	4d 85 c0             	test   r8,r8
  2193bf:	0f 85 67 03 00 00    	jne    21972c <memmove+0x4cc>
  2193c5:	e9 ae 03 00 00       	jmp    219778 <memmove+0x518>
        while (index != 0) {
  2193ca:	4c 8d 14 16          	lea    r10,[rsi+rdx*1]
  2193ce:	49 83 c2 e0          	add    r10,0xffffffffffffffe0
  2193d2:	48 8d 0c 17          	lea    rcx,[rdi+rdx*1]
  2193d6:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  2193da:	4d 8d 59 ff          	lea    r11,[r9-0x1]
  2193de:	49 29 c3             	sub    r11,rax
  2193e1:	31 c0                	xor    eax,eax
  2193e3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2193ea:	84 00 00 00 00 00 
            index -= 1;
            dest.?[index] = src.?[index];
  2193f0:	c4 c1 7c 10 44 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x60]
  2193f7:	c4 c1 7c 10 4c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x40]
  2193fe:	c4 c1 7c 10 54 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x20]
  219405:	c4 c1 7c 10 1c 02    	vmovups ymm3,YMMWORD PTR [r10+rax*1]
  21940b:	c5 fc 11 1c 01       	vmovups YMMWORD PTR [rcx+rax*1],ymm3
  219410:	c5 fc 11 54 01 e0    	vmovups YMMWORD PTR [rcx+rax*1-0x20],ymm2
  219416:	c5 fc 11 4c 01 c0    	vmovups YMMWORD PTR [rcx+rax*1-0x40],ymm1
  21941c:	c5 fc 11 44 01 a0    	vmovups YMMWORD PTR [rcx+rax*1-0x60],ymm0
  219422:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0xe0]
  219429:	ff ff ff 
  21942c:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0xc0]
  219433:	ff ff ff 
  219436:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0xa0]
  21943d:	ff ff ff 
  219440:	c4 c1 7c 10 5c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x80]
  219447:	c5 fc 11 5c 01 80    	vmovups YMMWORD PTR [rcx+rax*1-0x80],ymm3
  21944d:	c5 fc 11 94 01 60 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xa0],ymm2
  219454:	ff ff 
  219456:	c5 fc 11 8c 01 40 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xc0],ymm1
  21945d:	ff ff 
  21945f:	c5 fc 11 84 01 20 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  219466:	ff ff 
  219468:	c4 c1 7c 10 84 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x160]
  21946f:	fe ff ff 
  219472:	c4 c1 7c 10 8c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x140]
  219479:	fe ff ff 
  21947c:	c4 c1 7c 10 94 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x120]
  219483:	fe ff ff 
  219486:	c4 c1 7c 10 9c 02 00 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x100]
  21948d:	ff ff ff 
  219490:	c5 fc 11 9c 01 00 ff 	vmovups YMMWORD PTR [rcx+rax*1-0x100],ymm3
  219497:	ff ff 
  219499:	c5 fc 11 94 01 e0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x120],ymm2
  2194a0:	ff ff 
  2194a2:	c5 fc 11 8c 01 c0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x140],ymm1
  2194a9:	ff ff 
  2194ab:	c5 fc 11 84 01 a0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x160],ymm0
  2194b2:	ff ff 
  2194b4:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x1e0]
  2194bb:	fe ff ff 
  2194be:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x1c0]
  2194c5:	fe ff ff 
  2194c8:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x1a0]
  2194cf:	fe ff ff 
  2194d2:	c4 c1 7c 10 9c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x180]
  2194d9:	fe ff ff 
  2194dc:	c5 fc 11 9c 01 80 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x180],ymm3
  2194e3:	ff ff 
  2194e5:	c5 fc 11 94 01 60 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1a0],ymm2
  2194ec:	ff ff 
  2194ee:	c5 fc 11 8c 01 40 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1c0],ymm1
  2194f5:	ff ff 
  2194f7:	c5 fc 11 84 01 20 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  2194fe:	ff ff 
  219500:	48 05 00 fe ff ff    	add    rax,0xfffffffffffffe00
  219506:	49 83 c3 04          	add    r11,0x4
  21950a:	0f 85 e0 fe ff ff    	jne    2193f0 <memmove+0x190>
  219510:	48 f7 d8             	neg    rax
  219513:	4d 85 c9             	test   r9,r9
  219516:	74 50                	je     219568 <memmove+0x308>
  219518:	48 8d 4a e0          	lea    rcx,[rdx-0x20]
  21951c:	48 29 c1             	sub    rcx,rax
  21951f:	49 f7 d9             	neg    r9
  219522:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219529:	1f 84 00 00 00 00 00 
  219530:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  219536:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  21953c:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  219542:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  219547:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
  21954c:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  219552:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  219558:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  21955e:	48 83 c1 80          	add    rcx,0xffffffffffffff80
  219562:	49 83 c1 01          	add    r9,0x1
  219566:	75 c8                	jne    219530 <memmove+0x2d0>
  219568:	49 39 d0             	cmp    r8,rdx
        while (index != 0) {
  21956b:	0f 84 10 02 00 00    	je     219781 <memmove+0x521>
  219571:	4c 29 c2             	sub    rdx,r8
            index -= 1;
  219574:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  219578:	48 89 d1             	mov    rcx,rdx
  21957b:	48 83 e1 07          	and    rcx,0x7
  21957f:	74 22                	je     2195a3 <memmove+0x343>
  219581:	48 f7 d9             	neg    rcx
  219584:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21958b:	00 00 00 00 00 
            dest.?[index] = src.?[index];
  219590:	0f b6 44 16 ff       	movzx  eax,BYTE PTR [rsi+rdx*1-0x1]
  219595:	88 44 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],al
            index -= 1;
  219599:	48 8d 52 ff          	lea    rdx,[rdx-0x1]
        while (index != 0) {
  21959d:	48 83 c1 01          	add    rcx,0x1
  2195a1:	75 ed                	jne    219590 <memmove+0x330>
            index -= 1;
  2195a3:	49 83 f8 07          	cmp    r8,0x7
  2195a7:	0f 82 d4 01 00 00    	jb     219781 <memmove+0x521>
        while (index != 0) {
  2195ad:	48 89 d0             	mov    rax,rdx
            dest.?[index] = src.?[index];
  2195b0:	0f b6 4c 16 ff       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x1]
  2195b5:	88 4c 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],cl
  2195b9:	0f b6 4c 16 fe       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x2]
  2195be:	88 4c 17 fe          	mov    BYTE PTR [rdi+rdx*1-0x2],cl
  2195c2:	0f b6 4c 16 fd       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x3]
  2195c7:	88 4c 17 fd          	mov    BYTE PTR [rdi+rdx*1-0x3],cl
  2195cb:	0f b6 4c 16 fc       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x4]
  2195d0:	88 4c 17 fc          	mov    BYTE PTR [rdi+rdx*1-0x4],cl
  2195d4:	0f b6 4c 16 fb       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x5]
  2195d9:	88 4c 17 fb          	mov    BYTE PTR [rdi+rdx*1-0x5],cl
  2195dd:	0f b6 4c 16 fa       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x6]
  2195e2:	88 4c 17 fa          	mov    BYTE PTR [rdi+rdx*1-0x6],cl
  2195e6:	0f b6 4c 16 f9       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x7]
  2195eb:	88 4c 17 f9          	mov    BYTE PTR [rdi+rdx*1-0x7],cl
  2195ef:	0f b6 4c 16 f8       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x8]
  2195f4:	88 4c 17 f8          	mov    BYTE PTR [rdi+rdx*1-0x8],cl
        while (index != 0) {
  2195f8:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
  2195fc:	48 89 c2             	mov    rdx,rax
  2195ff:	75 af                	jne    2195b0 <memmove+0x350>
  219601:	e9 7b 01 00 00       	jmp    219781 <memmove+0x521>
        while (index != n) : (index += 1) {
  219606:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  21960a:	49 29 c9             	sub    r9,rcx
  21960d:	31 c9                	xor    ecx,ecx
  21960f:	90                   	nop
            dest.?[index] = src.?[index];
  219610:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  219615:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  21961b:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  219621:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  219627:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  21962c:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  219632:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  219638:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  21963e:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  219645:	00 00 
  219647:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  21964e:	00 00 
  219650:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  219657:	00 00 
  219659:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  219660:	00 00 
  219662:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  219669:	00 00 
  21966b:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  219672:	00 00 
  219674:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  21967b:	00 00 
  21967d:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  219684:	00 00 
  219686:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  21968d:	00 00 
  21968f:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  219696:	00 00 
  219698:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  21969f:	00 00 
  2196a1:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  2196a8:	00 00 
  2196aa:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  2196b1:	00 00 
  2196b3:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  2196ba:	00 00 
  2196bc:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  2196c3:	00 00 
  2196c5:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  2196cc:	00 00 
  2196ce:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  2196d5:	00 00 
  2196d7:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  2196de:	00 00 
  2196e0:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  2196e7:	00 00 
  2196e9:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  2196f0:	00 00 
  2196f2:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  2196f9:	00 00 
  2196fb:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  219702:	00 00 
  219704:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  21970b:	00 00 
  21970d:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  219714:	00 00 
        while (index != n) : (index += 1) {
  219716:	48 81 c1 00 02 00 00 	add    rcx,0x200
  21971d:	49 83 c1 04          	add    r9,0x4
  219721:	0f 85 e9 fe ff ff    	jne    219610 <memmove+0x3b0>
  219727:	4d 85 c0             	test   r8,r8
  21972a:	74 4c                	je     219778 <memmove+0x518>
  21972c:	48 83 c1 60          	add    rcx,0x60
  219730:	49 f7 d8             	neg    r8
  219733:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21973a:	84 00 00 00 00 00 
            dest.?[index] = src.?[index];
  219740:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  219746:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  21974c:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  219752:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  219757:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  21975d:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  219763:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  219769:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
        while (index != n) : (index += 1) {
  21976e:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  219772:	49 83 c0 01          	add    r8,0x1
  219776:	75 c8                	jne    219740 <memmove+0x4e0>
  219778:	49 39 d2             	cmp    r10,rdx
  21977b:	0f 85 17 fb ff ff    	jne    219298 <memmove+0x38>
        }
    }

    return dest;
  219781:	48 89 f8             	mov    rax,rdi
  219784:	c5 f8 77             	vzeroupper 
  219787:	c3                   	ret    
  219788:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21978f:	00 

0000000000219790 <clone>:

// TODO we should be able to put this directly in std/linux/x86_64.zig but
// it causes a segfault in release mode. this is a workaround of calling it
// across .o file boundaries. fix comptime @ptrCast of nakedcc functions.
nakedcc fn clone() void {
    asm volatile (
  219790:	31 c0                	xor    eax,eax
  219792:	b0 38                	mov    al,0x38
  219794:	49 89 fb             	mov    r11,rdi
  219797:	48 89 d7             	mov    rdi,rdx
  21979a:	4c 89 c2             	mov    rdx,r8
  21979d:	4d 89 c8             	mov    r8,r9
  2197a0:	4c 8b 54 24 08       	mov    r10,QWORD PTR [rsp+0x8]
  2197a5:	4d 89 d9             	mov    r9,r11
  2197a8:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  2197ac:	48 83 ee 08          	sub    rsi,0x8
  2197b0:	48 89 0e             	mov    QWORD PTR [rsi],rcx
  2197b3:	0f 05                	syscall 
  2197b5:	85 c0                	test   eax,eax
  2197b7:	75 0f                	jne    2197c8 <clone+0x38>
  2197b9:	31 ed                	xor    ebp,ebp
  2197bb:	5f                   	pop    rdi
  2197bc:	41 ff d1             	call   r9
  2197bf:	89 c7                	mov    edi,eax
  2197c1:	31 c0                	xor    eax,eax
  2197c3:	b0 3c                	mov    al,0x3c
  2197c5:	0f 05                	syscall 
  2197c7:	f4                   	hlt    
  2197c8:	c3                   	ret    
nakedcc fn clone() void {
  2197c9:	c3                   	ret    
  2197ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000002197d0 <fmodf>:
    );
}

const math = @import("../math/index.zig");

export fn fmodf(x: f32, y: f32) f32 {
  2197d0:	c5 f9 6f d0          	vmovdqa xmm2,xmm0
    const digits = if (T == f32) 23 else 52;
    const exp_bits = if (T == f32) 9 else 12;
    const bits_minus_1 = T.bit_count - 1;
    const mask = if (T == f32) 0xff else 0x7ff;
    var ux = @bitCast(uint, x);
    var uy = @bitCast(uint, y);
  2197d4:	c4 c1 79 7e c9       	vmovd  r9d,xmm1
    var ex = @intCast(i32, (ux >> digits) & mask);
    var ey = @intCast(i32, (uy >> digits) & mask);
    const sx = if (T == f32) @intCast(u32, ux & 0x80000000) else @intCast(i32, ux >> bits_minus_1);
    var i: uint = undefined;

    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  2197d9:	44 89 c8             	mov    eax,r9d
  2197dc:	c5 fa 10 05 f0 df fe 	vmovss xmm0,DWORD PTR [rip+0xfffffffffffedff0]        # 2077d4 <__unnamed_605+0xa>
  2197e3:	ff 
  2197e4:	01 c0                	add    eax,eax
  2197e6:	0f 84 4a 01 00 00    	je     219936 <fmodf+0x166>

fn isNan(comptime T: type, bits: T) bool {
    if (T == u16) {
        return (bits & 0x7fff) > 0x7c00;
    } else if (T == u32) {
        return (bits & 0x7fffffff) > 0x7f800000;
  2197ec:	44 89 c9             	mov    ecx,r9d
  2197ef:	81 e1 ff ff ff 7f    	and    ecx,0x7fffffff
  2197f5:	81 f9 00 00 80 7f    	cmp    ecx,0x7f800000
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  2197fb:	0f 87 35 01 00 00    	ja     219936 <fmodf+0x166>
  219801:	c4 c1 79 7e d0       	vmovd  r8d,xmm2
  219806:	ba 17 08 00 00       	mov    edx,0x817
  21980b:	c4 c2 68 f7 c8       	bextr  ecx,r8d,edx
  219810:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  219816:	0f 84 1a 01 00 00    	je     219936 <fmodf+0x166>
    if (ux << 1 <= uy << 1) {
  21981c:	43 8d 34 00          	lea    esi,[r8+r8*1]
  219820:	39 c6                	cmp    esi,eax
  219822:	76 2a                	jbe    21984e <fmodf+0x7e>
  219824:	c4 c2 68 f7 f9       	bextr  edi,r9d,edx
        ux &= @maxValue(uint) >> exp_bits;
  219829:	44 89 c0             	mov    eax,r8d
    if (ex == 0) {
  21982c:	85 c9                	test   ecx,ecx
  21982e:	74 2d                	je     21985d <fmodf+0x8d>
        ux &= @maxValue(uint) >> exp_bits;
  219830:	25 ff ff 7f 00       	and    eax,0x7fffff
        ux |= 1 << digits;
  219835:	0d 00 00 80 00       	or     eax,0x800000
    if (ey == 0) {
  21983a:	85 ff                	test   edi,edi
  21983c:	74 49                	je     219887 <fmodf+0xb7>
        uy &= @maxValue(uint) >> exp_bits;
  21983e:	41 81 e1 ff ff 7f 00 	and    r9d,0x7fffff
        uy |= 1 << digits;
  219845:	41 81 c9 00 00 80 00 	or     r9d,0x800000
  21984c:	eb 77                	jmp    2198c5 <fmodf+0xf5>
  21984e:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  219852:	0f 84 de 00 00 00    	je     219936 <fmodf+0x166>
  219858:	c5 f9 6f c2          	vmovdqa xmm0,xmm2
    return generic_fmod(f32, x, y);
  21985c:	c3                   	ret    
  21985d:	31 c9                	xor    ecx,ecx
        i = ux << exp_bits;
  21985f:	c1 e0 09             	shl    eax,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  219862:	78 13                	js     219877 <fmodf+0xa7>
  219864:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21986b:	00 00 00 00 00 
            ex -= 1;
  219870:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  219873:	01 c0                	add    eax,eax
        while (i >> bits_minus_1 == 0) : (b: {
  219875:	79 f9                	jns    219870 <fmodf+0xa0>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  219877:	b8 01 00 00 00       	mov    eax,0x1
  21987c:	29 c8                	sub    eax,ecx
  21987e:	c4 c2 79 f7 c0       	shlx   eax,r8d,eax
    if (ey == 0) {
  219883:	85 ff                	test   edi,edi
  219885:	75 b7                	jne    21983e <fmodf+0x6e>
        i = uy << exp_bits;
  219887:	44 89 ca             	mov    edx,r9d
  21988a:	31 ff                	xor    edi,edi
  21988c:	c1 e2 09             	shl    edx,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  21988f:	78 16                	js     2198a7 <fmodf+0xd7>
  219891:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219898:	0f 1f 84 00 00 00 00 
  21989f:	00 
            ey -= 1;
  2198a0:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  2198a3:	01 d2                	add    edx,edx
        while (i >> bits_minus_1 == 0) : (b: {
  2198a5:	79 f9                	jns    2198a0 <fmodf+0xd0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  2198a7:	ba 01 00 00 00       	mov    edx,0x1
  2198ac:	29 fa                	sub    edx,edi
  2198ae:	c4 42 69 f7 c9       	shlx   r9d,r9d,edx
  2198b3:	eb 10                	jmp    2198c5 <fmodf+0xf5>
  2198b5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2198bc:	00 00 00 00 
        ux <<= 1;
  2198c0:	01 c0                	add    eax,eax
    while (ex > ey) : (ex -= 1) {
  2198c2:	83 c1 ff             	add    ecx,0xffffffff
  2198c5:	89 c6                	mov    esi,eax
  2198c7:	44 29 ce             	sub    esi,r9d
  2198ca:	0f 99 c2             	setns  dl
  2198cd:	39 f9                	cmp    ecx,edi
  2198cf:	7e 10                	jle    2198e1 <fmodf+0x111>
        if (i >> bits_minus_1 == 0) {
  2198d1:	f6 c2 01             	test   dl,0x1
  2198d4:	74 ea                	je     2198c0 <fmodf+0xf0>
  2198d6:	89 f0                	mov    eax,esi
            if (i == 0)
  2198d8:	85 f6                	test   esi,esi
  2198da:	75 e4                	jne    2198c0 <fmodf+0xf0>
  2198dc:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
    return generic_fmod(f32, x, y);
  2198e0:	c3                   	ret    
    if (i >> bits_minus_1 == 0) {
  2198e1:	84 d2                	test   dl,dl
  2198e3:	74 06                	je     2198eb <fmodf+0x11b>
  2198e5:	89 f0                	mov    eax,esi
        if (i == 0)
  2198e7:	85 f6                	test   esi,esi
  2198e9:	74 4c                	je     219937 <fmodf+0x167>
    while (ux >> digits == 0) : (b: {
  2198eb:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  2198f0:	77 1a                	ja     21990c <fmodf+0x13c>
  2198f2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2198f9:	1f 84 00 00 00 00 00 
        ux <<= 1;
  219900:	01 c0                	add    eax,eax
        ex -= 1;
  219902:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  219905:	3d 00 00 80 00       	cmp    eax,0x800000
  21990a:	72 f4                	jb     219900 <fmodf+0x130>
  21990c:	41 81 e0 00 00 00 80 	and    r8d,0x80000000
    if (ex > 0) {
  219913:	85 c9                	test   ecx,ecx
  219915:	7e 0c                	jle    219923 <fmodf+0x153>
        ux -%= 1 << digits;
  219917:	05 00 00 80 ff       	add    eax,0xff800000
        ux |= uint(@bitCast(u32, ex)) << digits;
  21991c:	c1 e1 17             	shl    ecx,0x17
  21991f:	09 c1                	or     ecx,eax
  219921:	eb 0c                	jmp    21992f <fmodf+0x15f>
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  219923:	ba 01 00 00 00       	mov    edx,0x1
  219928:	29 ca                	sub    edx,ecx
  21992a:	c4 e2 6b f7 c8       	shrx   ecx,eax,edx
        ux |= sx;
  21992f:	44 09 c1             	or     ecx,r8d
    return @bitCast(T, ux);
  219932:	c5 f9 6e c1          	vmovd  xmm0,ecx
    return generic_fmod(f32, x, y);
  219936:	c3                   	ret    
  219937:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21993b:	c3                   	ret    
  21993c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000219940 <fmod>:
export fn fmod(x: f64, y: f64) f64 {
  219940:	c5 f9 6f d0          	vmovdqa xmm2,xmm0
    var uy = @bitCast(uint, y);
  219944:	c4 c1 f9 7e cb       	vmovq  r11,xmm1
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  219949:	4c 89 d8             	mov    rax,r11
  21994c:	c5 fb 10 05 84 72 fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffe7284]        # 200bd8 <__unnamed_441+0x38>
  219953:	ff 
  219954:	48 01 c0             	add    rax,rax
  219957:	0f 84 6f 01 00 00    	je     219acc <fmod+0x18c>
  21995d:	49 b9 ff ff ff ff ff 	movabs r9,0x7fffffffffffffff
  219964:	ff ff 7f 
    } else if (T == u64) {
        return (bits & (@maxValue(u64) >> 1)) > (u64(0x7ff) << 52);
  219967:	4c 89 d9             	mov    rcx,r11
  21996a:	4c 21 c9             	and    rcx,r9
  21996d:	48 ba 00 00 00 00 00 	movabs rdx,0x7ff0000000000000
  219974:	00 f0 7f 
  219977:	48 39 d1             	cmp    rcx,rdx
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  21997a:	0f 87 4c 01 00 00    	ja     219acc <fmod+0x18c>
  219980:	c4 c1 f9 7e d2       	vmovq  r10,xmm2
  219985:	4c 89 d1             	mov    rcx,r10
  219988:	48 c1 e9 34          	shr    rcx,0x34
  21998c:	81 e1 ff 07 00 00    	and    ecx,0x7ff
  219992:	81 f9 ff 07 00 00    	cmp    ecx,0x7ff
  219998:	0f 84 2e 01 00 00    	je     219acc <fmod+0x18c>
    if (ux << 1 <= uy << 1) {
  21999e:	4b 8d 14 12          	lea    rdx,[r10+r10*1]
  2199a2:	48 39 c2             	cmp    rdx,rax
  2199a5:	76 35                	jbe    2199dc <fmod+0x9c>
  2199a7:	4c 89 df             	mov    rdi,r11
  2199aa:	48 c1 ef 34          	shr    rdi,0x34
  2199ae:	81 e7 ff 07 00 00    	and    edi,0x7ff
  2199b4:	49 b8 00 00 00 00 00 	movabs r8,0x10000000000000
  2199bb:	00 10 00 
    if (ex == 0) {
  2199be:	85 c9                	test   ecx,ecx
  2199c0:	74 29                	je     2199eb <fmod+0xab>
        ux &= @maxValue(uint) >> exp_bits;
  2199c2:	49 8d 40 ff          	lea    rax,[r8-0x1]
  2199c6:	4c 21 d0             	and    rax,r10
        ux |= 1 << digits;
  2199c9:	4c 09 c0             	or     rax,r8
    if (ey == 0) {
  2199cc:	85 ff                	test   edi,edi
  2199ce:	74 48                	je     219a18 <fmod+0xd8>
        uy &= @maxValue(uint) >> exp_bits;
  2199d0:	49 8d 50 ff          	lea    rdx,[r8-0x1]
  2199d4:	49 21 d3             	and    r11,rdx
        uy |= 1 << digits;
  2199d7:	4d 09 c3             	or     r11,r8
  2199da:	eb 7a                	jmp    219a56 <fmod+0x116>
  2199dc:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2199e0:	0f 84 e6 00 00 00    	je     219acc <fmod+0x18c>
  2199e6:	c5 f9 6f c2          	vmovdqa xmm0,xmm2
    return generic_fmod(f64, x, y);
  2199ea:	c3                   	ret    
        i = ux << exp_bits;
  2199eb:	4c 89 d0             	mov    rax,r10
  2199ee:	31 c9                	xor    ecx,ecx
  2199f0:	48 c1 e0 0c          	shl    rax,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  2199f4:	78 12                	js     219a08 <fmod+0xc8>
  2199f6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2199fd:	00 00 00 
            ex -= 1;
  219a00:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  219a03:	48 01 c0             	add    rax,rax
        while (i >> bits_minus_1 == 0) : (b: {
  219a06:	79 f8                	jns    219a00 <fmod+0xc0>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  219a08:	b8 01 00 00 00       	mov    eax,0x1
  219a0d:	29 c8                	sub    eax,ecx
  219a0f:	c4 c2 f9 f7 c2       	shlx   rax,r10,rax
    if (ey == 0) {
  219a14:	85 ff                	test   edi,edi
  219a16:	75 b8                	jne    2199d0 <fmod+0x90>
        i = uy << exp_bits;
  219a18:	4c 89 da             	mov    rdx,r11
  219a1b:	31 ff                	xor    edi,edi
  219a1d:	48 c1 e2 0c          	shl    rdx,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  219a21:	78 15                	js     219a38 <fmod+0xf8>
  219a23:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219a2a:	84 00 00 00 00 00 
            ey -= 1;
  219a30:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  219a33:	48 01 d2             	add    rdx,rdx
        while (i >> bits_minus_1 == 0) : (b: {
  219a36:	79 f8                	jns    219a30 <fmod+0xf0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  219a38:	ba 01 00 00 00       	mov    edx,0x1
  219a3d:	29 fa                	sub    edx,edi
  219a3f:	c4 42 e9 f7 db       	shlx   r11,r11,rdx
  219a44:	eb 10                	jmp    219a56 <fmod+0x116>
  219a46:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  219a4d:	00 00 00 
        ux <<= 1;
  219a50:	48 01 c0             	add    rax,rax
    while (ex > ey) : (ex -= 1) {
  219a53:	83 c1 ff             	add    ecx,0xffffffff
  219a56:	48 89 c6             	mov    rsi,rax
  219a59:	4c 29 de             	sub    rsi,r11
  219a5c:	0f 99 c2             	setns  dl
  219a5f:	39 f9                	cmp    ecx,edi
  219a61:	7e 12                	jle    219a75 <fmod+0x135>
        if (i >> bits_minus_1 == 0) {
  219a63:	f6 c2 01             	test   dl,0x1
  219a66:	74 e8                	je     219a50 <fmod+0x110>
  219a68:	48 89 f0             	mov    rax,rsi
            if (i == 0)
  219a6b:	48 85 f6             	test   rsi,rsi
  219a6e:	75 e0                	jne    219a50 <fmod+0x110>
  219a70:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
    return generic_fmod(f64, x, y);
  219a74:	c3                   	ret    
    if (i >> bits_minus_1 == 0) {
  219a75:	84 d2                	test   dl,dl
  219a77:	74 08                	je     219a81 <fmod+0x141>
  219a79:	48 89 f0             	mov    rax,rsi
        if (i == 0)
  219a7c:	48 85 f6             	test   rsi,rsi
  219a7f:	74 4c                	je     219acd <fmod+0x18d>
  219a81:	49 83 c1 01          	add    r9,0x1
    while (ux >> digits == 0) : (b: {
  219a85:	4c 39 c0             	cmp    rax,r8
  219a88:	73 11                	jae    219a9b <fmod+0x15b>
  219a8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        ux <<= 1;
  219a90:	48 01 c0             	add    rax,rax
        ex -= 1;
  219a93:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  219a96:	4c 39 c0             	cmp    rax,r8
  219a99:	72 f5                	jb     219a90 <fmod+0x150>
  219a9b:	4d 21 ca             	and    r10,r9
    if (ex > 0) {
  219a9e:	85 c9                	test   ecx,ecx
  219aa0:	7e 16                	jle    219ab8 <fmod+0x178>
        ux -%= 1 << digits;
  219aa2:	48 ba 00 00 00 00 00 	movabs rdx,0xfff0000000000000
  219aa9:	00 f0 ff 
  219aac:	48 01 d0             	add    rax,rdx
        ux |= uint(@bitCast(u32, ex)) << digits;
  219aaf:	48 c1 e1 34          	shl    rcx,0x34
  219ab3:	48 09 c1             	or     rcx,rax
  219ab6:	eb 0c                	jmp    219ac4 <fmod+0x184>
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  219ab8:	ba 01 00 00 00       	mov    edx,0x1
  219abd:	29 ca                	sub    edx,ecx
  219abf:	c4 e2 eb f7 c8       	shrx   rcx,rax,rdx
        ux |= @intCast(uint, sx) << bits_minus_1;
  219ac4:	4c 09 d1             	or     rcx,r10
    return @bitCast(T, ux);
  219ac7:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    return generic_fmod(f64, x, y);
  219acc:	c3                   	ret    
  219acd:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  219ad1:	c3                   	ret    
  219ad2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219ad9:	1f 84 00 00 00 00 00 

0000000000219ae0 <floorf>:
    if (x == 0.0) {
  219ae0:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  219ae4:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  219ae8:	75 02                	jne    219aec <floorf+0xc>
  219aea:	7b 57                	jnp    219b43 <floorf+0x63>
  219aec:	c5 f9 7e c1          	vmovd  ecx,xmm0
  219af0:	89 c8                	mov    eax,ecx
  219af2:	c1 e8 17             	shr    eax,0x17
  219af5:	0f b6 d0             	movzx  edx,al
  219af8:	81 fa 95 00 00 00    	cmp    edx,0x95
  219afe:	77 43                	ja     219b43 <floorf+0x63>
    if (e >= 0) {
  219b00:	83 fa 7f             	cmp    edx,0x7f
  219b03:	72 2e                	jb     219b33 <floorf+0x53>
  219b05:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  219b08:	83 e0 1f             	and    eax,0x1f
  219b0b:	ba ff ff 7f 00       	mov    edx,0x7fffff
  219b10:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  219b15:	85 ca                	test   edx,ecx
  219b17:	74 2a                	je     219b43 <floorf+0x63>
        if (u >> 31 != 0) {
  219b19:	89 ce                	mov    esi,ecx
  219b1b:	c1 fe 1f             	sar    esi,0x1f
  219b1e:	21 d6                	and    esi,edx
  219b20:	01 ce                	add    esi,ecx
        return @bitCast(f32, u & ~m);
  219b22:	b9 00 00 80 ff       	mov    ecx,0xff800000
  219b27:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  219b2c:	21 f0                	and    eax,esi
  219b2e:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.floor(x);
  219b32:	c3                   	ret    
        if (u >> 31 == 0) {
  219b33:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  219b37:	85 c9                	test   ecx,ecx
  219b39:	79 08                	jns    219b43 <floorf+0x63>
  219b3b:	c5 f9 6e 05 95 dc fe 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffedc95]        # 2077d8 <__unnamed_605+0xe>
  219b42:	ff 
  219b43:	c3                   	ret    
  219b44:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219b4b:	00 00 00 00 00 

0000000000219b50 <ceilf>:
    var u = @bitCast(u32, x);
    var e = @intCast(i32, (u >> 23) & 0xFF) - 0x7F;
    var m: u32 = undefined;

    // TODO: Shouldn't need this explicit check.
    if (x == 0.0) {
  219b50:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  219b54:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  219b58:	75 02                	jne    219b5c <ceilf+0xc>
  219b5a:	7b 5a                	jnp    219bb6 <ceilf+0x66>
  219b5c:	c5 f9 7e c1          	vmovd  ecx,xmm0
  219b60:	89 c8                	mov    eax,ecx
  219b62:	c1 e8 17             	shr    eax,0x17
  219b65:	0f b6 d0             	movzx  edx,al
  219b68:	81 fa 95 00 00 00    	cmp    edx,0x95
  219b6e:	77 46                	ja     219bb6 <ceilf+0x66>
        return x;
    }

    if (e >= 23) {
        return x;
    } else if (e >= 0) {
  219b70:	83 fa 7f             	cmp    edx,0x7f
  219b73:	72 31                	jb     219ba6 <ceilf+0x56>
  219b75:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  219b78:	83 e0 1f             	and    eax,0x1f
  219b7b:	ba ff ff 7f 00       	mov    edx,0x7fffff
  219b80:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  219b85:	85 ca                	test   edx,ecx
  219b87:	74 2d                	je     219bb6 <ceilf+0x66>
            return x;
        }
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 == 0) {
  219b89:	89 ce                	mov    esi,ecx
  219b8b:	c1 fe 1f             	sar    esi,0x1f
  219b8e:	c4 e2 48 f2 d2       	andn   edx,esi,edx
  219b93:	01 ca                	add    edx,ecx
            u += m;
        }
        u &= ~m;
  219b95:	b9 00 00 80 ff       	mov    ecx,0xff800000
  219b9a:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  219b9f:	21 d0                	and    eax,edx
        return @bitCast(f32, u);
  219ba1:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.ceil(x);
  219ba5:	c3                   	ret    
    } else {
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 != 0) {
  219ba6:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  219baa:	85 c9                	test   ecx,ecx
  219bac:	78 08                	js     219bb6 <ceilf+0x66>
  219bae:	c5 f9 6e 05 1e dc fe 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffedc1e]        # 2077d4 <__unnamed_605+0xa>
  219bb5:	ff 
  219bb6:	c3                   	ret    
  219bb7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  219bbe:	00 00 

0000000000219bc0 <floor>:
    if (e >= 0x3FF + 52 or x == 0) {
  219bc0:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  219bc4:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  219bc8:	75 02                	jne    219bcc <floor+0xc>
  219bca:	7b 54                	jnp    219c20 <floor+0x60>
  219bcc:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  219bd1:	b9 34 0b 00 00       	mov    ecx,0xb34
  219bd6:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  219bdb:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  219be2:	77 3c                	ja     219c20 <floor+0x60>
        y = x - math.f64_toint + math.f64_toint - x;
  219be4:	c5 fb 10 0d fc 6f fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe6ffc]        # 200be8 <__unnamed_441+0x48>
  219beb:	ff 
  219bec:	c5 fb 10 15 2c 70 fe 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffe702c]        # 200c20 <__unnamed_441+0x80>
  219bf3:	ff 
    if (u >> 63 != 0) {
  219bf4:	48 85 c0             	test   rax,rax
  219bf7:	78 28                	js     219c21 <floor+0x61>
  219bf9:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  219bfd:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    if (e <= 0x3FF - 1) {
  219c01:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  219c08:	76 28                	jbe    219c32 <floor+0x72>
  219c0a:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
    } else if (y > 0) {
  219c0e:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  219c12:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  219c16:	76 24                	jbe    219c3c <floor+0x7c>
        return x + y - 1;
  219c18:	c5 f3 58 05 e0 6f fe 	vaddsd xmm0,xmm1,QWORD PTR [rip+0xfffffffffffe6fe0]        # 200c00 <__unnamed_441+0x60>
  219c1f:	ff 
    return math.floor(x);
  219c20:	c3                   	ret    
  219c21:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  219c25:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  219c29:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  219c30:	77 d8                	ja     219c0a <floor+0x4a>
    if (u >> 63 != 0) {
  219c32:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  219c35:	78 0a                	js     219c41 <floor+0x81>
  219c37:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  219c3b:	c3                   	ret    
  219c3c:	c5 f9 28 c1          	vmovapd xmm0,xmm1
  219c40:	c3                   	ret    
  219c41:	c5 fb 10 05 b7 6f fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffe6fb7]        # 200c00 <__unnamed_441+0x60>
  219c48:	ff 
  219c49:	c3                   	ret    
  219c4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000219c50 <ceil>:
fn ceil64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  219c50:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  219c54:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  219c58:	75 02                	jne    219c5c <ceil+0xc>
  219c5a:	7b 79                	jnp    219cd5 <ceil+0x85>
  219c5c:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  219c61:	b9 34 0b 00 00       	mov    ecx,0xb34
  219c66:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  219c6b:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  219c72:	77 61                	ja     219cd5 <ceil+0x85>
        return x;
    }

    if (u >> 63 != 0) {
        @setFloatMode(this, builtin.FloatMode.Strict);
        y = x - math.f64_toint + math.f64_toint - x;
  219c74:	c5 fb 10 0d 6c 6f fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe6f6c]        # 200be8 <__unnamed_441+0x48>
  219c7b:	ff 
  219c7c:	c5 fb 10 15 9c 6f fe 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffe6f9c]        # 200c20 <__unnamed_441+0x80>
  219c83:	ff 
    if (u >> 63 != 0) {
  219c84:	48 85 c0             	test   rax,rax
  219c87:	78 29                	js     219cb2 <ceil+0x62>
  219c89:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  219c8d:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    } else {
        @setFloatMode(this, builtin.FloatMode.Strict);
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  219c91:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  219c98:	76 29                	jbe    219cc3 <ceil+0x73>
  219c9a:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
        if (u >> 63 != 0) {
            return -0.0;
        } else {
            return 1.0;
        }
    } else if (y < 0) {
  219c9e:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  219ca2:	c5 f9 2e d0          	vucomisd xmm2,xmm0
  219ca6:	76 2e                	jbe    219cd6 <ceil+0x86>
        return x + y + 1;
  219ca8:	c5 f3 58 05 28 6f fe 	vaddsd xmm0,xmm1,QWORD PTR [rip+0xfffffffffffe6f28]        # 200bd8 <__unnamed_441+0x38>
  219caf:	ff 
  219cb0:	eb 23                	jmp    219cd5 <ceil+0x85>
  219cb2:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  219cb6:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  219cba:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  219cc1:	77 d7                	ja     219c9a <ceil+0x4a>
        if (u >> 63 != 0) {
  219cc3:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
    if (u >> 63 != 0) {
  219cc7:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  219cca:	78 09                	js     219cd5 <ceil+0x85>
  219ccc:	c5 fb 10 05 04 6f fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffe6f04]        # 200bd8 <__unnamed_441+0x38>
  219cd3:	ff 
    return math.ceil(x);
  219cd4:	c3                   	ret    
  219cd5:	c3                   	ret    
  219cd6:	c5 f9 28 c1          	vmovapd xmm0,xmm1
  219cda:	c3                   	ret    
  219cdb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000219ce0 <sqrt>:
// behaviour. Most intermediate i32 values are changed to u32 where appropriate but there are
// potentially some edge cases remaining that are not handled in the same way.
export fn sqrt(x: f64) f64 {
    const tiny: f64 = 1.0e-300;
    const sign: u32 = 0x80000000;
    const u = @bitCast(u64, x);
  219ce0:	c4 e1 f9 7e c0       	vmovq  rax,xmm0

    var ix0 = @intCast(u32, u >> 32);
  219ce5:	48 89 c7             	mov    rdi,rax
  219ce8:	48 c1 ef 20          	shr    rdi,0x20
    var ix1 = @intCast(u32, u & 0xFFFFFFFF);

    // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = nan
    if (ix0 & 0x7FF00000 == 0x7FF00000) {
  219cec:	b9 00 00 f0 7f       	mov    ecx,0x7ff00000
  219cf1:	c4 e2 40 f2 c9       	andn   ecx,edi,ecx
  219cf6:	75 06                	jne    219cfe <sqrt+0x1e>
        return x * x + x;
  219cf8:	c4 e2 f9 a9 c0       	vfmadd213sd xmm0,xmm0,xmm0
  219cfd:	c3                   	ret    
    }

    // sqrt(+-0) = +-0
    if (x == 0.0) {
  219cfe:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  219d02:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  219d06:	75 03                	jne    219d0b <sqrt+0x2b>
  219d08:	7a 01                	jp     219d0b <sqrt+0x2b>
        return x;
  219d0a:	c3                   	ret    
    }
    // sqrt(-ve) = snan
    if (ix0 & sign != 0) {
  219d0b:	85 ff                	test   edi,edi
  219d0d:	0f 88 d2 00 00 00    	js     219de5 <sqrt+0x105>
        return math.snan(f64);
    }

    // normalize x
    var m = @intCast(i32, ix0 >> 20);
  219d13:	49 89 c0             	mov    r8,rax
  219d16:	49 c1 e8 34          	shr    r8,0x34
    if (m == 0) {
  219d1a:	45 85 c0             	test   r8d,r8d
  219d1d:	75 5e                	jne    219d7d <sqrt+0x9d>
  219d1f:	31 d2                	xor    edx,edx
  219d21:	31 c9                	xor    ecx,ecx
        // subnormal
        while (ix0 == 0) {
  219d23:	85 ff                	test   edi,edi
  219d25:	75 18                	jne    219d3f <sqrt+0x5f>
  219d27:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  219d2e:	00 00 
            m -= 21;
  219d30:	83 c1 eb             	add    ecx,0xffffffeb
            ix0 |= ix1 >> 11;
  219d33:	89 c7                	mov    edi,eax
  219d35:	c1 ef 0b             	shr    edi,0xb
            ix1 <<= 21;
  219d38:	c1 e0 15             	shl    eax,0x15
        while (ix0 == 0) {
  219d3b:	85 ff                	test   edi,edi
  219d3d:	74 f1                	je     219d30 <sqrt+0x50>
  219d3f:	31 f6                	xor    esi,esi
        }

        // subnormal
        var i: u32 = 0;
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  219d41:	0f ba e7 14          	bt     edi,0x14
  219d45:	72 20                	jb     219d67 <sqrt+0x87>
  219d47:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  219d4e:	00 00 
  219d50:	89 fa                	mov    edx,edi
            ix0 <<= 1;
  219d52:	8d 3c 12             	lea    edi,[rdx+rdx*1]
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  219d55:	83 c6 ff             	add    esi,0xffffffff
  219d58:	f7 c2 00 00 08 00    	test   edx,0x80000
  219d5e:	74 f0                	je     219d50 <sqrt+0x70>
  219d60:	89 f2                	mov    edx,esi
  219d62:	f7 da                	neg    edx
  219d64:	83 e2 1f             	and    edx,0x1f
        }
        m -= @intCast(i32, i) - 1;
  219d67:	44 8d 04 31          	lea    r8d,[rcx+rsi*1]
  219d6b:	41 83 c0 01          	add    r8d,0x1
        ix0 |= ix1 >> @intCast(u5, 32 - i);
  219d6f:	c4 e2 4b f7 c8       	shrx   ecx,eax,esi
  219d74:	09 f9                	or     ecx,edi
        ix1 <<= @intCast(u5, i);
  219d76:	c4 e2 69 f7 c0       	shlx   eax,eax,edx
  219d7b:	89 cf                	mov    edi,ecx
    }

    // unbias exponent
    m -= 1023;
  219d7d:	41 81 c0 01 fc ff ff 	add    r8d,0xfffffc01
    ix0 = (ix0 & 0x000FFFFF) | 0x00100000;
  219d84:	81 e7 ff ff 0f 00    	and    edi,0xfffff
  219d8a:	81 cf 00 00 10 00    	or     edi,0x100000
    if (m & 1 != 0) {
  219d90:	41 f6 c0 01          	test   r8b,0x1
  219d94:	74 06                	je     219d9c <sqrt+0xbc>
        ix0 += ix0 + (ix1 >> 31);
  219d96:	0f a4 c7 01          	shld   edi,eax,0x1
        ix1 = ix1 +% ix1;
  219d9a:	01 c0                	add    eax,eax
    }
    m >>= 1;

    // sqrt(x) bit by bit
    ix0 += ix0 + (ix1 >> 31);
  219d9c:	0f a4 c7 01          	shld   edi,eax,0x1
    var t: u32 = undefined;
    var t1: u32 = undefined;

    while (r != 0) {
        t = s0 +% r;
        if (t <= ix0) {
  219da0:	31 f6                	xor    esi,esi
  219da2:	81 ff ff ff 1f 00    	cmp    edi,0x1fffff
  219da8:	40 0f 97 c6          	seta   sil
  219dac:	41 89 f1             	mov    r9d,esi
  219daf:	41 c1 e1 15          	shl    r9d,0x15
  219db3:	c1 e6 16             	shl    esi,0x16
            s0 = t + r;
            ix0 -= t;
            q += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219db6:	8d 0c 3f             	lea    ecx,[rdi+rdi*1]
        if (t <= ix0) {
  219db9:	81 ff 00 00 20 00    	cmp    edi,0x200000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219dbf:	8d bc 3f 00 00 c0 ff 	lea    edi,[rdi+rdi*1-0x400000]
  219dc6:	0f 42 f9             	cmovb  edi,ecx
  219dc9:	b9 1e 01 00 00       	mov    ecx,0x11e
  219dce:	c4 e2 70 f7 d0       	bextr  edx,eax,ecx
  219dd3:	09 fa                	or     edx,edi
        t = s0 +% r;
  219dd5:	8d be 00 00 10 00    	lea    edi,[rsi+0x100000]
        if (t <= ix0) {
  219ddb:	89 d1                	mov    ecx,edx
  219ddd:	29 f9                	sub    ecx,edi
  219ddf:	73 0d                	jae    219dee <sqrt+0x10e>
  219de1:	89 d1                	mov    ecx,edx
  219de3:	eb 18                	jmp    219dfd <sqrt+0x11d>
  219de5:	c5 fb 10 05 83 6e fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffe6e83]        # 200c70 <app_mask+0x38>
  219dec:	ff 
        return x;
  219ded:	c3                   	ret    
            s0 = t + r;
  219dee:	81 c7 00 00 10 00    	add    edi,0x100000
            q += r;
  219df4:	41 81 c9 00 00 10 00 	or     r9d,0x100000
  219dfb:	89 fe                	mov    esi,edi
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219dfd:	ba 1d 01 00 00       	mov    edx,0x11d
  219e02:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219e07:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219e0a:	8d be 00 00 08 00    	lea    edi,[rsi+0x80000]
        if (t <= ix0) {
  219e10:	89 d1                	mov    ecx,edx
  219e12:	29 f9                	sub    ecx,edi
  219e14:	73 04                	jae    219e1a <sqrt+0x13a>
  219e16:	89 d1                	mov    ecx,edx
  219e18:	eb 0d                	jmp    219e27 <sqrt+0x147>
            s0 = t + r;
  219e1a:	81 c6 00 00 10 00    	add    esi,0x100000
            q += r;
  219e20:	41 81 c1 00 00 08 00 	add    r9d,0x80000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219e27:	ba 1c 01 00 00       	mov    edx,0x11c
  219e2c:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219e31:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219e34:	8d be 00 00 04 00    	lea    edi,[rsi+0x40000]
        if (t <= ix0) {
  219e3a:	89 d1                	mov    ecx,edx
  219e3c:	29 f9                	sub    ecx,edi
  219e3e:	73 04                	jae    219e44 <sqrt+0x164>
  219e40:	89 d1                	mov    ecx,edx
  219e42:	eb 0d                	jmp    219e51 <sqrt+0x171>
            s0 = t + r;
  219e44:	81 c6 00 00 08 00    	add    esi,0x80000
            q += r;
  219e4a:	41 81 c1 00 00 04 00 	add    r9d,0x40000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219e51:	ba 1b 01 00 00       	mov    edx,0x11b
  219e56:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219e5b:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219e5e:	8d be 00 00 02 00    	lea    edi,[rsi+0x20000]
        if (t <= ix0) {
  219e64:	89 d1                	mov    ecx,edx
  219e66:	29 f9                	sub    ecx,edi
  219e68:	73 04                	jae    219e6e <sqrt+0x18e>
  219e6a:	89 d1                	mov    ecx,edx
  219e6c:	eb 0d                	jmp    219e7b <sqrt+0x19b>
            s0 = t + r;
  219e6e:	81 c6 00 00 04 00    	add    esi,0x40000
            q += r;
  219e74:	41 81 c1 00 00 02 00 	add    r9d,0x20000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219e7b:	ba 1a 01 00 00       	mov    edx,0x11a
  219e80:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219e85:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219e88:	8d be 00 00 01 00    	lea    edi,[rsi+0x10000]
        if (t <= ix0) {
  219e8e:	89 d1                	mov    ecx,edx
  219e90:	29 f9                	sub    ecx,edi
  219e92:	73 04                	jae    219e98 <sqrt+0x1b8>
  219e94:	89 d1                	mov    ecx,edx
  219e96:	eb 0d                	jmp    219ea5 <sqrt+0x1c5>
            s0 = t + r;
  219e98:	81 c6 00 00 02 00    	add    esi,0x20000
            q += r;
  219e9e:	41 81 c1 00 00 01 00 	add    r9d,0x10000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219ea5:	ba 19 01 00 00       	mov    edx,0x119
  219eaa:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219eaf:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219eb2:	8d be 00 80 00 00    	lea    edi,[rsi+0x8000]
        if (t <= ix0) {
  219eb8:	89 d1                	mov    ecx,edx
  219eba:	29 f9                	sub    ecx,edi
  219ebc:	73 04                	jae    219ec2 <sqrt+0x1e2>
  219ebe:	89 d1                	mov    ecx,edx
  219ec0:	eb 0d                	jmp    219ecf <sqrt+0x1ef>
            s0 = t + r;
  219ec2:	81 c6 00 00 01 00    	add    esi,0x10000
            q += r;
  219ec8:	41 81 c1 00 80 00 00 	add    r9d,0x8000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219ecf:	ba 18 01 00 00       	mov    edx,0x118
  219ed4:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219ed9:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219edc:	8d be 00 40 00 00    	lea    edi,[rsi+0x4000]
        if (t <= ix0) {
  219ee2:	89 d1                	mov    ecx,edx
  219ee4:	29 f9                	sub    ecx,edi
  219ee6:	73 04                	jae    219eec <sqrt+0x20c>
  219ee8:	89 d1                	mov    ecx,edx
  219eea:	eb 0d                	jmp    219ef9 <sqrt+0x219>
            s0 = t + r;
  219eec:	81 c6 00 80 00 00    	add    esi,0x8000
            q += r;
  219ef2:	41 81 c1 00 40 00 00 	add    r9d,0x4000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219ef9:	ba 17 01 00 00       	mov    edx,0x117
  219efe:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219f03:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219f06:	8d be 00 20 00 00    	lea    edi,[rsi+0x2000]
        if (t <= ix0) {
  219f0c:	89 d1                	mov    ecx,edx
  219f0e:	29 f9                	sub    ecx,edi
  219f10:	73 04                	jae    219f16 <sqrt+0x236>
  219f12:	89 d1                	mov    ecx,edx
  219f14:	eb 0d                	jmp    219f23 <sqrt+0x243>
            s0 = t + r;
  219f16:	81 c6 00 40 00 00    	add    esi,0x4000
            q += r;
  219f1c:	41 81 c1 00 20 00 00 	add    r9d,0x2000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219f23:	ba 16 01 00 00       	mov    edx,0x116
  219f28:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219f2d:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219f30:	8d be 00 10 00 00    	lea    edi,[rsi+0x1000]
        if (t <= ix0) {
  219f36:	89 d1                	mov    ecx,edx
  219f38:	29 f9                	sub    ecx,edi
  219f3a:	73 04                	jae    219f40 <sqrt+0x260>
  219f3c:	89 d1                	mov    ecx,edx
  219f3e:	eb 0d                	jmp    219f4d <sqrt+0x26d>
            s0 = t + r;
  219f40:	81 c6 00 20 00 00    	add    esi,0x2000
            q += r;
  219f46:	41 81 c1 00 10 00 00 	add    r9d,0x1000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219f4d:	ba 15 01 00 00       	mov    edx,0x115
  219f52:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219f57:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219f5a:	8d be 00 08 00 00    	lea    edi,[rsi+0x800]
        if (t <= ix0) {
  219f60:	89 d1                	mov    ecx,edx
  219f62:	29 f9                	sub    ecx,edi
  219f64:	73 04                	jae    219f6a <sqrt+0x28a>
  219f66:	89 d1                	mov    ecx,edx
  219f68:	eb 0d                	jmp    219f77 <sqrt+0x297>
            s0 = t + r;
  219f6a:	81 c6 00 10 00 00    	add    esi,0x1000
            q += r;
  219f70:	41 81 c1 00 08 00 00 	add    r9d,0x800
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219f77:	ba 14 01 00 00       	mov    edx,0x114
  219f7c:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219f81:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219f84:	8d be 00 04 00 00    	lea    edi,[rsi+0x400]
        if (t <= ix0) {
  219f8a:	89 d1                	mov    ecx,edx
  219f8c:	29 f9                	sub    ecx,edi
  219f8e:	73 04                	jae    219f94 <sqrt+0x2b4>
  219f90:	89 d1                	mov    ecx,edx
  219f92:	eb 0d                	jmp    219fa1 <sqrt+0x2c1>
            s0 = t + r;
  219f94:	81 c6 00 08 00 00    	add    esi,0x800
            q += r;
  219f9a:	41 81 c1 00 04 00 00 	add    r9d,0x400
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219fa1:	ba 13 01 00 00       	mov    edx,0x113
  219fa6:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219fab:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219fae:	8d be 00 02 00 00    	lea    edi,[rsi+0x200]
        if (t <= ix0) {
  219fb4:	89 d1                	mov    ecx,edx
  219fb6:	29 f9                	sub    ecx,edi
  219fb8:	73 04                	jae    219fbe <sqrt+0x2de>
  219fba:	89 d1                	mov    ecx,edx
  219fbc:	eb 0d                	jmp    219fcb <sqrt+0x2eb>
            s0 = t + r;
  219fbe:	81 c6 00 04 00 00    	add    esi,0x400
            q += r;
  219fc4:	41 81 c1 00 02 00 00 	add    r9d,0x200
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219fcb:	ba 12 01 00 00       	mov    edx,0x112
  219fd0:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219fd5:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219fd8:	8d be 00 01 00 00    	lea    edi,[rsi+0x100]
        if (t <= ix0) {
  219fde:	89 d1                	mov    ecx,edx
  219fe0:	29 f9                	sub    ecx,edi
  219fe2:	73 04                	jae    219fe8 <sqrt+0x308>
  219fe4:	89 d1                	mov    ecx,edx
  219fe6:	eb 0d                	jmp    219ff5 <sqrt+0x315>
            s0 = t + r;
  219fe8:	81 c6 00 02 00 00    	add    esi,0x200
            q += r;
  219fee:	41 81 c1 00 01 00 00 	add    r9d,0x100
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219ff5:	ba 11 01 00 00       	mov    edx,0x111
  219ffa:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219fff:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a002:	89 f7                	mov    edi,esi
  21a004:	83 ef 80             	sub    edi,0xffffff80
        if (t <= ix0) {
  21a007:	89 d1                	mov    ecx,edx
  21a009:	29 f9                	sub    ecx,edi
  21a00b:	73 04                	jae    21a011 <sqrt+0x331>
  21a00d:	89 d1                	mov    ecx,edx
  21a00f:	eb 0a                	jmp    21a01b <sqrt+0x33b>
            s0 = t + r;
  21a011:	81 c6 00 01 00 00    	add    esi,0x100
            q += r;
  21a017:	41 83 e9 80          	sub    r9d,0xffffff80
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a01b:	ba 10 01 00 00       	mov    edx,0x110
  21a020:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a025:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a028:	8d 7e 40             	lea    edi,[rsi+0x40]
        if (t <= ix0) {
  21a02b:	89 d1                	mov    ecx,edx
  21a02d:	29 f9                	sub    ecx,edi
  21a02f:	73 04                	jae    21a035 <sqrt+0x355>
  21a031:	89 d1                	mov    ecx,edx
  21a033:	eb 07                	jmp    21a03c <sqrt+0x35c>
            s0 = t + r;
  21a035:	83 ee 80             	sub    esi,0xffffff80
            q += r;
  21a038:	41 83 c1 40          	add    r9d,0x40
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a03c:	ba 0f 01 00 00       	mov    edx,0x10f
  21a041:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a046:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a049:	8d 7e 20             	lea    edi,[rsi+0x20]
        if (t <= ix0) {
  21a04c:	89 d1                	mov    ecx,edx
  21a04e:	29 f9                	sub    ecx,edi
  21a050:	73 04                	jae    21a056 <sqrt+0x376>
  21a052:	89 d1                	mov    ecx,edx
  21a054:	eb 07                	jmp    21a05d <sqrt+0x37d>
            s0 = t + r;
  21a056:	83 c6 40             	add    esi,0x40
            q += r;
  21a059:	41 83 c1 20          	add    r9d,0x20
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a05d:	ba 0e 01 00 00       	mov    edx,0x10e
  21a062:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a067:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a06a:	8d 7e 10             	lea    edi,[rsi+0x10]
        if (t <= ix0) {
  21a06d:	89 d1                	mov    ecx,edx
  21a06f:	29 f9                	sub    ecx,edi
  21a071:	73 04                	jae    21a077 <sqrt+0x397>
  21a073:	89 d1                	mov    ecx,edx
  21a075:	eb 07                	jmp    21a07e <sqrt+0x39e>
            s0 = t + r;
  21a077:	83 c6 20             	add    esi,0x20
            q += r;
  21a07a:	41 83 c1 10          	add    r9d,0x10
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a07e:	ba 0d 01 00 00       	mov    edx,0x10d
  21a083:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a088:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a08b:	8d 7e 08             	lea    edi,[rsi+0x8]
        if (t <= ix0) {
  21a08e:	89 d1                	mov    ecx,edx
  21a090:	29 f9                	sub    ecx,edi
  21a092:	73 04                	jae    21a098 <sqrt+0x3b8>
  21a094:	89 d1                	mov    ecx,edx
  21a096:	eb 07                	jmp    21a09f <sqrt+0x3bf>
            s0 = t + r;
  21a098:	83 c6 10             	add    esi,0x10
            q += r;
  21a09b:	41 83 c1 08          	add    r9d,0x8
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a09f:	ba 0c 01 00 00       	mov    edx,0x10c
  21a0a4:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a0a9:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a0ac:	8d 7e 04             	lea    edi,[rsi+0x4]
        if (t <= ix0) {
  21a0af:	89 d1                	mov    ecx,edx
  21a0b1:	29 f9                	sub    ecx,edi
  21a0b3:	73 04                	jae    21a0b9 <sqrt+0x3d9>
  21a0b5:	89 d1                	mov    ecx,edx
  21a0b7:	eb 07                	jmp    21a0c0 <sqrt+0x3e0>
            s0 = t + r;
  21a0b9:	83 c6 08             	add    esi,0x8
            q += r;
  21a0bc:	41 83 c1 04          	add    r9d,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a0c0:	ba 0b 01 00 00       	mov    edx,0x10b
  21a0c5:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a0ca:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a0cd:	8d 7e 02             	lea    edi,[rsi+0x2]
        if (t <= ix0) {
  21a0d0:	89 d1                	mov    ecx,edx
  21a0d2:	29 f9                	sub    ecx,edi
  21a0d4:	73 04                	jae    21a0da <sqrt+0x3fa>
  21a0d6:	89 d1                	mov    ecx,edx
  21a0d8:	eb 07                	jmp    21a0e1 <sqrt+0x401>
            s0 = t + r;
  21a0da:	83 c6 04             	add    esi,0x4
            q += r;
  21a0dd:	41 83 c1 02          	add    r9d,0x2
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a0e1:	ba 0a 01 00 00       	mov    edx,0x10a
  21a0e6:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a0eb:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a0ee:	8d 7e 01             	lea    edi,[rsi+0x1]
        if (t <= ix0) {
  21a0f1:	89 d1                	mov    ecx,edx
  21a0f3:	29 f9                	sub    ecx,edi
  21a0f5:	73 04                	jae    21a0fb <sqrt+0x41b>
  21a0f7:	89 d1                	mov    ecx,edx
  21a0f9:	eb 07                	jmp    21a102 <sqrt+0x422>
            s0 = t + r;
  21a0fb:	83 c6 02             	add    esi,0x2
            q += r;
  21a0fe:	41 83 c1 01          	add    r9d,0x1
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a102:	55                   	push   rbp
  21a103:	41 56                	push   r14
  21a105:	53                   	push   rbx
  21a106:	ba 09 01 00 00       	mov    edx,0x109
  21a10b:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a110:	c1 e0 17             	shl    eax,0x17
  21a113:	8d 1c 4a             	lea    ebx,[rdx+rcx*2]
    m >>= 1;
  21a116:	41 d1 e8             	shr    r8d,1
  21a119:	31 d2                	xor    edx,edx
  21a11b:	bf 00 00 00 80       	mov    edi,0x80000000
  21a120:	41 ba 1e 01 00 00    	mov    r10d,0x11e
  21a126:	41 bb 1d 01 00 00    	mov    r11d,0x11d
  21a12c:	41 be 1c 01 00 00    	mov    r14d,0x11c
  21a132:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a139:	1f 84 00 00 00 00 00 

    r = sign;
    while (r != 0) {
        t = s1 +% r;
        t = s0;
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a140:	89 fd                	mov    ebp,edi
  21a142:	89 f1                	mov    ecx,esi
  21a144:	39 f3                	cmp    ebx,esi
  21a146:	73 04                	jae    21a14c <sqrt+0x46c>
  21a148:	31 ed                	xor    ebp,ebp
  21a14a:	31 c9                	xor    ecx,ecx
  21a14c:	01 d5                	add    ebp,edx
  21a14e:	29 cb                	sub    ebx,ecx
                ix0 -= 1;
            }
            ix1 = ix1 -% t1;
            q1 += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a150:	0f a4 c3 01          	shld   ebx,eax,0x1
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a154:	39 f3                	cmp    ebx,esi
  21a156:	73 08                	jae    21a160 <sqrt+0x480>
  21a158:	31 d2                	xor    edx,edx
  21a15a:	31 c9                	xor    ecx,ecx
  21a15c:	eb 08                	jmp    21a166 <sqrt+0x486>
  21a15e:	66 90                	xchg   ax,ax
  21a160:	89 fa                	mov    edx,edi
  21a162:	d1 ea                	shr    edx,1
  21a164:	89 f1                	mov    ecx,esi
  21a166:	01 ea                	add    edx,ebp
  21a168:	29 cb                	sub    ebx,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a16a:	c4 e2 28 f7 c8       	bextr  ecx,eax,r10d
  21a16f:	8d 2c 59             	lea    ebp,[rcx+rbx*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a172:	39 f5                	cmp    ebp,esi
  21a174:	73 0a                	jae    21a180 <sqrt+0x4a0>
  21a176:	31 db                	xor    ebx,ebx
  21a178:	31 c9                	xor    ecx,ecx
  21a17a:	eb 0b                	jmp    21a187 <sqrt+0x4a7>
  21a17c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  21a180:	89 fb                	mov    ebx,edi
  21a182:	c1 eb 02             	shr    ebx,0x2
  21a185:	89 f1                	mov    ecx,esi
  21a187:	01 d3                	add    ebx,edx
  21a189:	29 cd                	sub    ebp,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a18b:	c4 e2 20 f7 c8       	bextr  ecx,eax,r11d
  21a190:	8d 2c 69             	lea    ebp,[rcx+rbp*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a193:	39 f5                	cmp    ebp,esi
  21a195:	73 09                	jae    21a1a0 <sqrt+0x4c0>
  21a197:	31 d2                	xor    edx,edx
  21a199:	31 c9                	xor    ecx,ecx
  21a19b:	eb 0a                	jmp    21a1a7 <sqrt+0x4c7>
  21a19d:	0f 1f 00             	nop    DWORD PTR [rax]
  21a1a0:	89 fa                	mov    edx,edi
  21a1a2:	c1 ea 03             	shr    edx,0x3
  21a1a5:	89 f1                	mov    ecx,esi
  21a1a7:	01 da                	add    edx,ebx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a1a9:	c4 e2 08 f7 d8       	bextr  ebx,eax,r14d
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a1ae:	29 cd                	sub    ebp,ecx
  21a1b0:	c1 e0 04             	shl    eax,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a1b3:	8d 1c 6b             	lea    ebx,[rbx+rbp*2]
        ix1 = ix1 +% ix1;
        r >>= 1;
  21a1b6:	c1 ef 04             	shr    edi,0x4
    while (r != 0) {
  21a1b9:	75 85                	jne    21a140 <sqrt+0x460>
    }

    // rounding direction
    if (ix0 | ix1 != 0) {
  21a1bb:	09 c3                	or     ebx,eax
  21a1bd:	5b                   	pop    rbx
  21a1be:	41 5e                	pop    r14
  21a1c0:	5d                   	pop    rbp
  21a1c1:	74 16                	je     21a1d9 <sqrt+0x4f9>
        var z = 1.0 - tiny; // raise inexact
        if (z >= 1.0) {
            z = 1.0 + tiny;
            if (q1 == 0xFFFFFFFF) {
  21a1c3:	83 fa ff             	cmp    edx,0xffffffff
  21a1c6:	74 0b                	je     21a1d3 <sqrt+0x4f3>
                if (q1 == 0xFFFFFFFE) {
                    q += 1;
                }
                q1 += 2;
            } else {
                q1 += q1 & 1;
  21a1c8:	89 d0                	mov    eax,edx
  21a1ca:	83 e0 01             	and    eax,0x1
  21a1cd:	01 d0                	add    eax,edx
  21a1cf:	89 c2                	mov    edx,eax
  21a1d1:	eb 06                	jmp    21a1d9 <sqrt+0x4f9>
                q += 1;
  21a1d3:	41 83 c1 01          	add    r9d,0x1
  21a1d7:	31 d2                	xor    edx,edx
            }
        }
    }

    ix0 = (q >> 1) + 0x3FE00000;
  21a1d9:	44 89 c8             	mov    eax,r9d
  21a1dc:	d1 e8                	shr    eax,1
    ix1 = q1 >> 1;
    if (q & 1 != 0) {
  21a1de:	44 0f ac ca 01       	shrd   edx,r9d,0x1
    }

    // NOTE: musl here appears to rely on signed twos-complement wraparound. +% has the same
    // behaviour at least.
    var iix0 = @intCast(i32, ix0);
    iix0 = iix0 +% (m << 20);
  21a1e3:	41 c1 e0 14          	shl    r8d,0x14
  21a1e7:	41 8d 04 00          	lea    eax,[r8+rax*1]
  21a1eb:	05 00 00 e0 3f       	add    eax,0x3fe00000

    const uz = (@intCast(u64, iix0) << 32) | ix1;
  21a1f0:	48 c1 e0 20          	shl    rax,0x20
  21a1f4:	48 09 c2             	or     rdx,rax
    return @bitCast(f64, uz);
  21a1f7:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  21a1fc:	c3                   	ret    
  21a1fd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000021a200 <sqrtf>:
}

export fn sqrtf(x: f32) f32 {
    const tiny: f32 = 1.0e-30;
    const sign: i32 = @bitCast(i32, u32(0x80000000));
    var ix: i32 = @bitCast(i32, x);
  21a200:	c5 f9 7e c1          	vmovd  ecx,xmm0

    if ((ix & 0x7F800000) == 0x7F800000) {
  21a204:	b8 00 00 80 7f       	mov    eax,0x7f800000
  21a209:	c4 e2 70 f2 c0       	andn   eax,ecx,eax
  21a20e:	75 06                	jne    21a216 <sqrtf+0x16>
        return x * x + x; // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = snan
  21a210:	c4 e2 79 a9 c0       	vfmadd213ss xmm0,xmm0,xmm0
  21a215:	c3                   	ret    
    }

    // zero
    if (ix <= 0) {
  21a216:	85 c9                	test   ecx,ecx
  21a218:	7e 15                	jle    21a22f <sqrtf+0x2f>
  21a21a:	41 89 c8             	mov    r8d,ecx
  21a21d:	41 c1 e8 17          	shr    r8d,0x17
        }
    }

    // normalize
    var m = ix >> 23;
    if (m == 0) {
  21a221:	75 48                	jne    21a26b <sqrtf+0x6b>
  21a223:	31 d2                	xor    edx,edx
        // subnormal
        var i: i32 = 0;
        while (ix & 0x00800000 == 0) : (i += 1) {
  21a225:	0f ba e1 17          	bt     ecx,0x17
  21a229:	73 18                	jae    21a243 <sqrtf+0x43>
  21a22b:	89 ce                	mov    esi,ecx
  21a22d:	eb 31                	jmp    21a260 <sqrtf+0x60>
        if (ix & ~sign == 0) {
  21a22f:	f7 c1 ff ff ff 7f    	test   ecx,0x7fffffff
  21a235:	0f 84 29 03 00 00    	je     21a564 <sqrtf+0x364>
        if (ix < 0) {
  21a23b:	85 c9                	test   ecx,ecx
  21a23d:	0f 88 19 03 00 00    	js     21a55c <sqrtf+0x35c>
  21a243:	31 d2                	xor    edx,edx
  21a245:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a24c:	00 00 00 00 
            ix <<= 1;
  21a250:	8d 34 09             	lea    esi,[rcx+rcx*1]
        while (ix & 0x00800000 == 0) : (i += 1) {
  21a253:	83 c2 01             	add    edx,0x1
  21a256:	f7 c1 00 00 40 00    	test   ecx,0x400000
  21a25c:	89 f1                	mov    ecx,esi
  21a25e:	74 f0                	je     21a250 <sqrtf+0x50>
        }
        m -= i - 1;
  21a260:	41 b8 01 00 00 00    	mov    r8d,0x1
  21a266:	41 29 d0             	sub    r8d,edx
  21a269:	89 f1                	mov    ecx,esi
    }

    m -= 127; // unbias exponent
  21a26b:	41 83 c0 81          	add    r8d,0xffffff81
    ix = (ix & 0x007FFFFF) | 0x00800000;
  21a26f:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  21a275:	81 c9 00 00 80 00    	or     ecx,0x800000

    if (m & 1 != 0) { // odd m, double x to even
  21a27b:	44 89 c0             	mov    eax,r8d
  21a27e:	24 01                	and    al,0x1
  21a280:	c4 e2 79 f7 c1       	shlx   eax,ecx,eax
  21a285:	8d 34 85 00 00 00 00 	lea    esi,[rax*4+0x0]
    var s: i32 = 0;
    var r: i32 = 0x01000000; // r = moving bit right -> left

    while (r != 0) {
        const t = s + r;
        if (t <= ix) {
  21a28c:	31 d2                	xor    edx,edx
  21a28e:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  21a293:	0f 9f c2             	setg   dl
  21a296:	89 d1                	mov    ecx,edx
  21a298:	c1 e1 18             	shl    ecx,0x18
  21a29b:	c1 e2 19             	shl    edx,0x19
  21a29e:	3d 00 00 80 00       	cmp    eax,0x800000
  21a2a3:	8d 3c 85 00 00 00 fe 	lea    edi,[rax*4-0x2000000]
  21a2aa:	0f 4c fe             	cmovl  edi,esi
        const t = s + r;
  21a2ad:	8d 82 00 00 80 00    	lea    eax,[rdx+0x800000]
        if (t <= ix) {
  21a2b3:	89 fe                	mov    esi,edi
  21a2b5:	29 c6                	sub    esi,eax
  21a2b7:	7d 04                	jge    21a2bd <sqrtf+0xbd>
  21a2b9:	89 fe                	mov    esi,edi
  21a2bb:	eb 0d                	jmp    21a2ca <sqrtf+0xca>
            s = t + r;
  21a2bd:	05 00 00 80 00       	add    eax,0x800000
            ix -= t;
            q += r;
  21a2c2:	81 c9 00 00 80 00    	or     ecx,0x800000
  21a2c8:	89 c2                	mov    edx,eax
  21a2ca:	01 f6                	add    esi,esi
        const t = s + r;
  21a2cc:	8d 82 00 00 40 00    	lea    eax,[rdx+0x400000]
        if (t <= ix) {
  21a2d2:	89 f7                	mov    edi,esi
  21a2d4:	29 c7                	sub    edi,eax
  21a2d6:	7d 04                	jge    21a2dc <sqrtf+0xdc>
  21a2d8:	89 f7                	mov    edi,esi
  21a2da:	eb 0c                	jmp    21a2e8 <sqrtf+0xe8>
            s = t + r;
  21a2dc:	81 c2 00 00 80 00    	add    edx,0x800000
            q += r;
  21a2e2:	81 c1 00 00 40 00    	add    ecx,0x400000
  21a2e8:	01 ff                	add    edi,edi
        const t = s + r;
  21a2ea:	8d 82 00 00 20 00    	lea    eax,[rdx+0x200000]
        if (t <= ix) {
  21a2f0:	89 fe                	mov    esi,edi
  21a2f2:	29 c6                	sub    esi,eax
  21a2f4:	7d 04                	jge    21a2fa <sqrtf+0xfa>
  21a2f6:	89 fe                	mov    esi,edi
  21a2f8:	eb 0c                	jmp    21a306 <sqrtf+0x106>
            s = t + r;
  21a2fa:	81 c2 00 00 40 00    	add    edx,0x400000
            q += r;
  21a300:	81 c1 00 00 20 00    	add    ecx,0x200000
  21a306:	01 f6                	add    esi,esi
        const t = s + r;
  21a308:	8d 82 00 00 10 00    	lea    eax,[rdx+0x100000]
        if (t <= ix) {
  21a30e:	89 f7                	mov    edi,esi
  21a310:	29 c7                	sub    edi,eax
  21a312:	7d 04                	jge    21a318 <sqrtf+0x118>
  21a314:	89 f7                	mov    edi,esi
  21a316:	eb 0c                	jmp    21a324 <sqrtf+0x124>
            s = t + r;
  21a318:	81 c2 00 00 20 00    	add    edx,0x200000
            q += r;
  21a31e:	81 c1 00 00 10 00    	add    ecx,0x100000
  21a324:	01 ff                	add    edi,edi
        const t = s + r;
  21a326:	8d 82 00 00 08 00    	lea    eax,[rdx+0x80000]
        if (t <= ix) {
  21a32c:	89 fe                	mov    esi,edi
  21a32e:	29 c6                	sub    esi,eax
  21a330:	7d 04                	jge    21a336 <sqrtf+0x136>
  21a332:	89 fe                	mov    esi,edi
  21a334:	eb 0c                	jmp    21a342 <sqrtf+0x142>
            s = t + r;
  21a336:	81 c2 00 00 10 00    	add    edx,0x100000
            q += r;
  21a33c:	81 c1 00 00 08 00    	add    ecx,0x80000
  21a342:	01 f6                	add    esi,esi
        const t = s + r;
  21a344:	8d 82 00 00 04 00    	lea    eax,[rdx+0x40000]
        if (t <= ix) {
  21a34a:	89 f7                	mov    edi,esi
  21a34c:	29 c7                	sub    edi,eax
  21a34e:	7d 04                	jge    21a354 <sqrtf+0x154>
  21a350:	89 f7                	mov    edi,esi
  21a352:	eb 0c                	jmp    21a360 <sqrtf+0x160>
            s = t + r;
  21a354:	81 c2 00 00 08 00    	add    edx,0x80000
            q += r;
  21a35a:	81 c1 00 00 04 00    	add    ecx,0x40000
  21a360:	01 ff                	add    edi,edi
        const t = s + r;
  21a362:	8d 82 00 00 02 00    	lea    eax,[rdx+0x20000]
        if (t <= ix) {
  21a368:	89 fe                	mov    esi,edi
  21a36a:	29 c6                	sub    esi,eax
  21a36c:	7d 04                	jge    21a372 <sqrtf+0x172>
  21a36e:	89 fe                	mov    esi,edi
  21a370:	eb 0c                	jmp    21a37e <sqrtf+0x17e>
            s = t + r;
  21a372:	81 c2 00 00 04 00    	add    edx,0x40000
            q += r;
  21a378:	81 c1 00 00 02 00    	add    ecx,0x20000
  21a37e:	01 f6                	add    esi,esi
        const t = s + r;
  21a380:	8d 82 00 00 01 00    	lea    eax,[rdx+0x10000]
        if (t <= ix) {
  21a386:	89 f7                	mov    edi,esi
  21a388:	29 c7                	sub    edi,eax
  21a38a:	7d 04                	jge    21a390 <sqrtf+0x190>
  21a38c:	89 f7                	mov    edi,esi
  21a38e:	eb 0c                	jmp    21a39c <sqrtf+0x19c>
            s = t + r;
  21a390:	81 c2 00 00 02 00    	add    edx,0x20000
            q += r;
  21a396:	81 c1 00 00 01 00    	add    ecx,0x10000
  21a39c:	01 ff                	add    edi,edi
        const t = s + r;
  21a39e:	8d 82 00 80 00 00    	lea    eax,[rdx+0x8000]
        if (t <= ix) {
  21a3a4:	89 fe                	mov    esi,edi
  21a3a6:	29 c6                	sub    esi,eax
  21a3a8:	7d 04                	jge    21a3ae <sqrtf+0x1ae>
  21a3aa:	89 fe                	mov    esi,edi
  21a3ac:	eb 0c                	jmp    21a3ba <sqrtf+0x1ba>
            s = t + r;
  21a3ae:	81 c2 00 00 01 00    	add    edx,0x10000
            q += r;
  21a3b4:	81 c1 00 80 00 00    	add    ecx,0x8000
  21a3ba:	01 f6                	add    esi,esi
        const t = s + r;
  21a3bc:	8d 82 00 40 00 00    	lea    eax,[rdx+0x4000]
        if (t <= ix) {
  21a3c2:	89 f7                	mov    edi,esi
  21a3c4:	29 c7                	sub    edi,eax
  21a3c6:	7d 04                	jge    21a3cc <sqrtf+0x1cc>
  21a3c8:	89 f7                	mov    edi,esi
  21a3ca:	eb 0c                	jmp    21a3d8 <sqrtf+0x1d8>
            s = t + r;
  21a3cc:	81 c2 00 80 00 00    	add    edx,0x8000
            q += r;
  21a3d2:	81 c1 00 40 00 00    	add    ecx,0x4000
  21a3d8:	01 ff                	add    edi,edi
        const t = s + r;
  21a3da:	8d 82 00 20 00 00    	lea    eax,[rdx+0x2000]
        if (t <= ix) {
  21a3e0:	89 fe                	mov    esi,edi
  21a3e2:	29 c6                	sub    esi,eax
  21a3e4:	7d 04                	jge    21a3ea <sqrtf+0x1ea>
  21a3e6:	89 fe                	mov    esi,edi
  21a3e8:	eb 0c                	jmp    21a3f6 <sqrtf+0x1f6>
            s = t + r;
  21a3ea:	81 c2 00 40 00 00    	add    edx,0x4000
            q += r;
  21a3f0:	81 c1 00 20 00 00    	add    ecx,0x2000
  21a3f6:	01 f6                	add    esi,esi
        const t = s + r;
  21a3f8:	8d 82 00 10 00 00    	lea    eax,[rdx+0x1000]
        if (t <= ix) {
  21a3fe:	89 f7                	mov    edi,esi
  21a400:	29 c7                	sub    edi,eax
  21a402:	7d 04                	jge    21a408 <sqrtf+0x208>
  21a404:	89 f7                	mov    edi,esi
  21a406:	eb 0c                	jmp    21a414 <sqrtf+0x214>
            s = t + r;
  21a408:	81 c2 00 20 00 00    	add    edx,0x2000
            q += r;
  21a40e:	81 c1 00 10 00 00    	add    ecx,0x1000
  21a414:	01 ff                	add    edi,edi
        const t = s + r;
  21a416:	8d 82 00 08 00 00    	lea    eax,[rdx+0x800]
        if (t <= ix) {
  21a41c:	89 fe                	mov    esi,edi
  21a41e:	29 c6                	sub    esi,eax
  21a420:	7d 04                	jge    21a426 <sqrtf+0x226>
  21a422:	89 fe                	mov    esi,edi
  21a424:	eb 0c                	jmp    21a432 <sqrtf+0x232>
            s = t + r;
  21a426:	81 c2 00 10 00 00    	add    edx,0x1000
            q += r;
  21a42c:	81 c1 00 08 00 00    	add    ecx,0x800
  21a432:	01 f6                	add    esi,esi
        const t = s + r;
  21a434:	8d 82 00 04 00 00    	lea    eax,[rdx+0x400]
        if (t <= ix) {
  21a43a:	89 f7                	mov    edi,esi
  21a43c:	29 c7                	sub    edi,eax
  21a43e:	7d 04                	jge    21a444 <sqrtf+0x244>
  21a440:	89 f7                	mov    edi,esi
  21a442:	eb 0c                	jmp    21a450 <sqrtf+0x250>
            s = t + r;
  21a444:	81 c2 00 08 00 00    	add    edx,0x800
            q += r;
  21a44a:	81 c1 00 04 00 00    	add    ecx,0x400
  21a450:	01 ff                	add    edi,edi
        const t = s + r;
  21a452:	8d 82 00 02 00 00    	lea    eax,[rdx+0x200]
        if (t <= ix) {
  21a458:	89 fe                	mov    esi,edi
  21a45a:	29 c6                	sub    esi,eax
  21a45c:	7d 04                	jge    21a462 <sqrtf+0x262>
  21a45e:	89 fe                	mov    esi,edi
  21a460:	eb 0c                	jmp    21a46e <sqrtf+0x26e>
            s = t + r;
  21a462:	81 c2 00 04 00 00    	add    edx,0x400
            q += r;
  21a468:	81 c1 00 02 00 00    	add    ecx,0x200
  21a46e:	01 f6                	add    esi,esi
        const t = s + r;
  21a470:	8d 82 00 01 00 00    	lea    eax,[rdx+0x100]
        if (t <= ix) {
  21a476:	89 f7                	mov    edi,esi
  21a478:	29 c7                	sub    edi,eax
  21a47a:	7d 04                	jge    21a480 <sqrtf+0x280>
  21a47c:	89 f7                	mov    edi,esi
  21a47e:	eb 0c                	jmp    21a48c <sqrtf+0x28c>
            s = t + r;
  21a480:	81 c2 00 02 00 00    	add    edx,0x200
            q += r;
  21a486:	81 c1 00 01 00 00    	add    ecx,0x100
  21a48c:	01 ff                	add    edi,edi
        const t = s + r;
  21a48e:	89 d0                	mov    eax,edx
  21a490:	83 e8 80             	sub    eax,0xffffff80
        if (t <= ix) {
  21a493:	89 fe                	mov    esi,edi
  21a495:	29 c6                	sub    esi,eax
  21a497:	7d 04                	jge    21a49d <sqrtf+0x29d>
  21a499:	89 fe                	mov    esi,edi
  21a49b:	eb 09                	jmp    21a4a6 <sqrtf+0x2a6>
            s = t + r;
  21a49d:	81 c2 00 01 00 00    	add    edx,0x100
            q += r;
  21a4a3:	83 e9 80             	sub    ecx,0xffffff80
  21a4a6:	01 f6                	add    esi,esi
        const t = s + r;
  21a4a8:	8d 42 40             	lea    eax,[rdx+0x40]
        if (t <= ix) {
  21a4ab:	89 f7                	mov    edi,esi
  21a4ad:	29 c7                	sub    edi,eax
  21a4af:	7d 04                	jge    21a4b5 <sqrtf+0x2b5>
  21a4b1:	89 f7                	mov    edi,esi
  21a4b3:	eb 06                	jmp    21a4bb <sqrtf+0x2bb>
            s = t + r;
  21a4b5:	83 ea 80             	sub    edx,0xffffff80
            q += r;
  21a4b8:	83 c1 40             	add    ecx,0x40
  21a4bb:	01 ff                	add    edi,edi
        const t = s + r;
  21a4bd:	8d 42 20             	lea    eax,[rdx+0x20]
        if (t <= ix) {
  21a4c0:	89 fe                	mov    esi,edi
  21a4c2:	29 c6                	sub    esi,eax
  21a4c4:	7d 04                	jge    21a4ca <sqrtf+0x2ca>
  21a4c6:	89 fe                	mov    esi,edi
  21a4c8:	eb 06                	jmp    21a4d0 <sqrtf+0x2d0>
            s = t + r;
  21a4ca:	83 c2 40             	add    edx,0x40
            q += r;
  21a4cd:	83 c1 20             	add    ecx,0x20
  21a4d0:	01 f6                	add    esi,esi
        const t = s + r;
  21a4d2:	8d 42 10             	lea    eax,[rdx+0x10]
        if (t <= ix) {
  21a4d5:	89 f7                	mov    edi,esi
  21a4d7:	29 c7                	sub    edi,eax
  21a4d9:	7d 04                	jge    21a4df <sqrtf+0x2df>
  21a4db:	89 f7                	mov    edi,esi
  21a4dd:	eb 06                	jmp    21a4e5 <sqrtf+0x2e5>
            s = t + r;
  21a4df:	83 c2 20             	add    edx,0x20
            q += r;
  21a4e2:	83 c1 10             	add    ecx,0x10
  21a4e5:	01 ff                	add    edi,edi
        const t = s + r;
  21a4e7:	8d 42 08             	lea    eax,[rdx+0x8]
        if (t <= ix) {
  21a4ea:	89 fe                	mov    esi,edi
  21a4ec:	29 c6                	sub    esi,eax
  21a4ee:	7d 04                	jge    21a4f4 <sqrtf+0x2f4>
  21a4f0:	89 fe                	mov    esi,edi
  21a4f2:	eb 06                	jmp    21a4fa <sqrtf+0x2fa>
            s = t + r;
  21a4f4:	83 c2 10             	add    edx,0x10
            q += r;
  21a4f7:	83 c1 08             	add    ecx,0x8
  21a4fa:	01 f6                	add    esi,esi
        const t = s + r;
  21a4fc:	8d 42 04             	lea    eax,[rdx+0x4]
        if (t <= ix) {
  21a4ff:	89 f7                	mov    edi,esi
  21a501:	29 c7                	sub    edi,eax
  21a503:	7d 04                	jge    21a509 <sqrtf+0x309>
  21a505:	89 f7                	mov    edi,esi
  21a507:	eb 06                	jmp    21a50f <sqrtf+0x30f>
            s = t + r;
  21a509:	83 c2 08             	add    edx,0x8
            q += r;
  21a50c:	83 c1 04             	add    ecx,0x4
  21a50f:	01 ff                	add    edi,edi
        const t = s + r;
  21a511:	8d 42 02             	lea    eax,[rdx+0x2]
        if (t <= ix) {
  21a514:	89 fe                	mov    esi,edi
  21a516:	29 c6                	sub    esi,eax
  21a518:	7d 0a                	jge    21a524 <sqrtf+0x324>
  21a51a:	89 fe                	mov    esi,edi
  21a51c:	01 f6                	add    esi,esi
  21a51e:	39 d6                	cmp    esi,edx
  21a520:	7f 0e                	jg     21a530 <sqrtf+0x330>
  21a522:	eb 14                	jmp    21a538 <sqrtf+0x338>
            s = t + r;
  21a524:	83 c2 04             	add    edx,0x4
            q += r;
  21a527:	83 c1 02             	add    ecx,0x2
  21a52a:	01 f6                	add    esi,esi
        if (t <= ix) {
  21a52c:	39 d6                	cmp    esi,edx
  21a52e:	7e 08                	jle    21a538 <sqrtf+0x338>
        const t = s + r;
  21a530:	83 c2 01             	add    edx,0x1
            ix -= t;
  21a533:	29 d6                	sub    esi,edx
            q += r;
  21a535:	83 c1 01             	add    ecx,0x1
    m >>= 1; // m = [m / 2]
  21a538:	41 83 e0 fe          	and    r8d,0xfffffffe
  21a53c:	41 c1 e0 16          	shl    r8d,0x16
        ix += ix;
        r >>= 1;
    }

    // floating add to find rounding direction
    if (ix != 0) {
  21a540:	85 f6                	test   esi,esi
  21a542:	0f 95 c0             	setne  al
  21a545:	20 c8                	and    al,cl
  21a547:	0f b6 c0             	movzx  eax,al
  21a54a:	01 c8                	add    eax,ecx
                }
            }
        }
    }

    ix = (q >> 1) + 0x3f000000;
  21a54c:	d1 f8                	sar    eax,1
    ix += m << 23;
  21a54e:	41 8d 04 00          	lea    eax,[r8+rax*1]
  21a552:	05 00 00 00 3f       	add    eax,0x3f000000
    return @bitCast(f32, ix);
  21a557:	c5 f9 6e c0          	vmovd  xmm0,eax
  21a55b:	c3                   	ret    
  21a55c:	c5 f9 6e 05 78 d2 fe 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffed278]        # 2077dc <__unnamed_605+0x12>
  21a563:	ff 
            return x; // sqrt (+-0) = +-0
  21a564:	c3                   	ret    
  21a565:	cc                   	int3   
  21a566:	cc                   	int3   
  21a567:	cc                   	int3   
  21a568:	cc                   	int3   
  21a569:	cc                   	int3   
  21a56a:	cc                   	int3   
  21a56b:	cc                   	int3   
  21a56c:	cc                   	int3   
  21a56d:	cc                   	int3   
  21a56e:	cc                   	int3   
  21a56f:	cc                   	int3   

000000000021a570 <__udivmoddi4>:
const udivmod = @import("udivmod.zig").udivmod;
const builtin = @import("builtin");

pub extern fn __udivmoddi4(a: u64, b: u64, maybe_rem: ?*u64) u64 {
  21a570:	55                   	push   rbp
  21a571:	41 57                	push   r15
  21a573:	41 56                	push   r14
  21a575:	41 54                	push   r12
  21a577:	53                   	push   rbx
  21a578:	49 89 d0             	mov    r8,rdx
  21a57b:	49 89 fa             	mov    r10,rdi
  21a57e:	4c 89 d3             	mov    rbx,r10
  21a581:	48 c1 eb 20          	shr    rbx,0x20
  21a585:	48 89 f1             	mov    rcx,rsi
  21a588:	48 c1 e9 20          	shr    rcx,0x20
    const d = @ptrCast(*const [2]SingleInt, &b).*; // TODO issue #421
    var q: [2]SingleInt = undefined;
    var r: [2]SingleInt = undefined;
    var sr: c_uint = undefined;
    // special cases, X is unknown, K != 0
    if (n[high] == 0) {
  21a58c:	85 db                	test   ebx,ebx
  21a58e:	74 2f                	je     21a5bf <__udivmoddi4+0x4f>
            rem.* = n[low];
        }
        return 0;
    }
    // n[high] != 0
    if (d[low] == 0) {
  21a590:	85 f6                	test   esi,esi
  21a592:	74 46                	je     21a5da <__udivmoddi4+0x6a>
  21a594:	85 c9                	test   ecx,ecx
        // r.all = a >> sr;
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
    } else {
        // d[low] != 0
        if (d[high] == 0) {
  21a596:	74 78                	je     21a610 <__udivmoddi4+0xa0>
            }
        } else {
            // K X
            // ---
            // K K
            sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  21a598:	f3 0f bd e9          	lzcnt  ebp,ecx
  21a59c:	f3 0f bd c3          	lzcnt  eax,ebx
  21a5a0:	29 c5                	sub    ebp,eax
            // 0 <= sr <= SingleInt.bit_count - 1 or sr large
            if (sr > SingleInt.bit_count - 1) {
  21a5a2:	83 fd 20             	cmp    ebp,0x20
  21a5a5:	0f 82 b3 00 00 00    	jb     21a65e <__udivmoddi4+0xee>
                if (maybe_rem) |rem| {
  21a5ab:	4d 85 c0             	test   r8,r8
  21a5ae:	0f 84 d5 00 00 00    	je     21a689 <__udivmoddi4+0x119>
  21a5b4:	4d 89 10             	mov    QWORD PTR [r8],r10
  21a5b7:	45 31 d2             	xor    r10d,r10d
  21a5ba:	e9 06 03 00 00       	jmp    21a8c5 <__udivmoddi4+0x355>
        if (d[high] == 0) {
  21a5bf:	85 c9                	test   ecx,ecx
  21a5c1:	74 7d                	je     21a640 <__udivmoddi4+0xd0>
  21a5c3:	4d 85 c0             	test   r8,r8
        if (maybe_rem) |rem| {
  21a5c6:	0f 84 bd 00 00 00    	je     21a689 <__udivmoddi4+0x119>
            rem.* = n[low];
  21a5cc:	44 89 d0             	mov    eax,r10d
  21a5cf:	49 89 00             	mov    QWORD PTR [r8],rax
  21a5d2:	45 31 d2             	xor    r10d,r10d
  21a5d5:	e9 eb 02 00 00       	jmp    21a8c5 <__udivmoddi4+0x355>
  21a5da:	85 c9                	test   ecx,ecx
        if (d[high] == 0) {
  21a5dc:	0f 84 93 00 00 00    	je     21a675 <__udivmoddi4+0x105>
        if (n[low] == 0) {
  21a5e2:	45 85 d2             	test   r10d,r10d
  21a5e5:	0f 84 d2 00 00 00    	je     21a6bd <__udivmoddi4+0x14d>
        if ((d[high] & (d[high] - 1)) == 0) {
  21a5eb:	8d 41 ff             	lea    eax,[rcx-0x1]
  21a5ee:	85 c8                	test   eax,ecx
  21a5f0:	0f 84 5d 01 00 00    	je     21a753 <__udivmoddi4+0x1e3>
        sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  21a5f6:	f3 0f bd c9          	lzcnt  ecx,ecx
  21a5fa:	f3 0f bd c3          	lzcnt  eax,ebx
  21a5fe:	29 c1                	sub    ecx,eax
        if (sr > SingleInt.bit_count - 2) {
  21a600:	83 f9 1f             	cmp    ecx,0x1f
  21a603:	0f 82 6c 01 00 00    	jb     21a775 <__udivmoddi4+0x205>
            if (maybe_rem) |rem| {
  21a609:	4d 85 c0             	test   r8,r8
  21a60c:	75 a6                	jne    21a5b4 <__udivmoddi4+0x44>
  21a60e:	eb 79                	jmp    21a689 <__udivmoddi4+0x119>
            if ((d[low] & (d[low] - 1)) == 0) {
  21a610:	8d 46 ff             	lea    eax,[rsi-0x1]
  21a613:	85 f0                	test   eax,esi
  21a615:	0f 84 c2 00 00 00    	je     21a6dd <__udivmoddi4+0x16d>
            sr = 1 + SingleInt.bit_count + c_uint(@clz(d[low])) - c_uint(@clz(n[high]));
  21a61b:	f3 0f bd ce          	lzcnt  ecx,esi
  21a61f:	83 c1 21             	add    ecx,0x21
  21a622:	f3 0f bd c3          	lzcnt  eax,ebx
  21a626:	29 c1                	sub    ecx,eax
  21a628:	31 d2                	xor    edx,edx
            if (sr == SingleInt.bit_count) {
  21a62a:	83 f9 20             	cmp    ecx,0x20
  21a62d:	0f 85 e7 00 00 00    	jne    21a71a <__udivmoddi4+0x1aa>
  21a633:	45 31 ff             	xor    r15d,r15d
  21a636:	b9 20 00 00 00       	mov    ecx,0x20
  21a63b:	e9 7c 01 00 00       	jmp    21a7bc <__udivmoddi4+0x24c>
  21a640:	4d 85 c0             	test   r8,r8
            if (maybe_rem) |rem| {
  21a643:	74 0a                	je     21a64f <__udivmoddi4+0xdf>
                rem.* = n[low] % d[low];
  21a645:	31 d2                	xor    edx,edx
  21a647:	44 89 d0             	mov    eax,r10d
  21a64a:	f7 f6                	div    esi
  21a64c:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[low] / d[low];
  21a64f:	31 d2                	xor    edx,edx
  21a651:	44 89 d0             	mov    eax,r10d
  21a654:	f7 f6                	div    esi
  21a656:	41 89 c2             	mov    r10d,eax
  21a659:	e9 67 02 00 00       	jmp    21a8c5 <__udivmoddi4+0x355>
                    rem.* = a;
                }
                return 0;
            }
            sr += 1;
  21a65e:	8d 4d 01             	lea    ecx,[rbp+0x1]
  21a661:	45 31 ff             	xor    r15d,r15d
            // 1 <= sr <= SingleInt.bit_count
            // q.all = a << (DoubleInt.bit_count - sr);
            // r.all = a >> sr;
            q[low] = 0;
            if (sr == SingleInt.bit_count) {
  21a664:	83 f9 20             	cmp    ecx,0x20
  21a667:	75 28                	jne    21a691 <__udivmoddi4+0x121>
  21a669:	31 d2                	xor    edx,edx
  21a66b:	b9 20 00 00 00       	mov    ecx,0x20
  21a670:	e9 47 01 00 00       	jmp    21a7bc <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  21a675:	4d 85 c0             	test   r8,r8
  21a678:	74 0f                	je     21a689 <__udivmoddi4+0x119>
                rem.* = n[high] % d[low];
  21a67a:	49 c7 00 00 00 00 00 	mov    QWORD PTR [r8],0x0
  21a681:	45 31 d2             	xor    r10d,r10d
  21a684:	e9 3c 02 00 00       	jmp    21a8c5 <__udivmoddi4+0x355>
  21a689:	45 31 d2             	xor    r10d,r10d
  21a68c:	e9 34 02 00 00       	jmp    21a8c5 <__udivmoddi4+0x355>
                q[high] = n[low];
                r[high] = 0;
                r[low] = n[high];
            } else {
                r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21a691:	41 89 c9             	mov    r9d,ecx
  21a694:	41 83 e1 1f          	and    r9d,0x1f
  21a698:	c4 e2 33 f7 d3       	shrx   edx,ebx,r9d
  21a69d:	b8 1f 00 00 00       	mov    eax,0x1f
                r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21a6a2:	29 e8                	sub    eax,ebp
  21a6a4:	83 e0 1f             	and    eax,0x1f
  21a6a7:	c4 e2 79 f7 eb       	shlx   ebp,ebx,eax
  21a6ac:	c4 c2 33 f7 da       	shrx   ebx,r10d,r9d
  21a6b1:	09 eb                	or     ebx,ebp
                q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21a6b3:	c4 42 79 f7 d2       	shlx   r10d,r10d,eax
  21a6b8:	e9 ff 00 00 00       	jmp    21a7bc <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  21a6bd:	4d 85 c0             	test   r8,r8
  21a6c0:	74 0d                	je     21a6cf <__udivmoddi4+0x15f>
                r[high] = n[high] % d[high];
  21a6c2:	31 d2                	xor    edx,edx
  21a6c4:	89 d8                	mov    eax,ebx
  21a6c6:	f7 f1                	div    ecx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21a6c8:	48 c1 e2 20          	shl    rdx,0x20
  21a6cc:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[high] / d[high];
  21a6cf:	31 d2                	xor    edx,edx
  21a6d1:	89 d8                	mov    eax,ebx
  21a6d3:	f7 f1                	div    ecx
  21a6d5:	41 89 c2             	mov    r10d,eax
  21a6d8:	e9 e8 01 00 00       	jmp    21a8c5 <__udivmoddi4+0x355>
                if (maybe_rem) |rem| {
  21a6dd:	4d 85 c0             	test   r8,r8
  21a6e0:	74 06                	je     21a6e8 <__udivmoddi4+0x178>
                    rem.* = n[low] & (d[low] - 1);
  21a6e2:	44 21 d0             	and    eax,r10d
  21a6e5:	49 89 00             	mov    QWORD PTR [r8],rax
                if (d[low] == 1) {
  21a6e8:	83 fe 01             	cmp    esi,0x1
  21a6eb:	0f 84 d4 01 00 00    	je     21a8c5 <__udivmoddi4+0x355>
                sr = @ctz(d[low]);
  21a6f1:	f3 0f bc c6          	tzcnt  eax,esi
                q[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21a6f5:	89 c1                	mov    ecx,eax
  21a6f7:	83 e1 1f             	and    ecx,0x1f
  21a6fa:	c4 e2 73 f7 d3       	shrx   edx,ebx,ecx
                q[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21a6ff:	f7 d8                	neg    eax
  21a701:	c4 e2 79 f7 c3       	shlx   eax,ebx,eax
  21a706:	c4 42 73 f7 d2       	shrx   r10d,r10d,ecx
  21a70b:	41 09 c2             	or     r10d,eax
                return @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*; // TODO issue #421
  21a70e:	48 c1 e2 20          	shl    rdx,0x20
  21a712:	49 09 d2             	or     r10,rdx
  21a715:	e9 ab 01 00 00       	jmp    21a8c5 <__udivmoddi4+0x355>
  21a71a:	89 cd                	mov    ebp,ecx
  21a71c:	f7 dd                	neg    ebp
  21a71e:	83 e5 1f             	and    ebp,0x1f
  21a721:	c4 42 51 f7 fa       	shlx   r15d,r10d,ebp
            } else if (sr < SingleInt.bit_count) {
  21a726:	83 f9 20             	cmp    ecx,0x20
  21a729:	73 7a                	jae    21a7a5 <__udivmoddi4+0x235>
  21a72b:	31 d2                	xor    edx,edx
    // q.all = a << (DoubleInt.bit_count - sr);
    // r.all = a >> sr;
    // 1 <= sr <= DoubleInt.bit_count - 1
    var carry: u32 = 0;
    var r_all: DoubleInt = undefined;
    while (sr > 0) : (sr -= 1) {
  21a72d:	85 c9                	test   ecx,ecx
  21a72f:	0f 84 9c 01 00 00    	je     21a8d1 <__udivmoddi4+0x361>
  21a735:	89 c8                	mov    eax,ecx
  21a737:	83 e0 1f             	and    eax,0x1f
  21a73a:	c4 e2 7b f7 d3       	shrx   edx,ebx,eax
  21a73f:	c4 e2 51 f7 eb       	shlx   ebp,ebx,ebp
  21a744:	c4 c2 7b f7 da       	shrx   ebx,r10d,eax
  21a749:	09 eb                	or     ebx,ebp
  21a74b:	45 89 fa             	mov    r10d,r15d
  21a74e:	45 31 ff             	xor    r15d,r15d
  21a751:	eb 69                	jmp    21a7bc <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  21a753:	4d 85 c0             	test   r8,r8
  21a756:	74 0f                	je     21a767 <__udivmoddi4+0x1f7>
                r[high] = n[high] & (d[high] - 1);
  21a758:	21 d8                	and    eax,ebx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21a75a:	48 c1 e0 20          	shl    rax,0x20
  21a75e:	44 89 d2             	mov    edx,r10d
  21a761:	48 09 c2             	or     rdx,rax
  21a764:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[high] >> @intCast(Log2SingleInt, @ctz(d[high]));
  21a767:	f3 0f bc c1          	tzcnt  eax,ecx
  21a76b:	c4 62 7b f7 d3       	shrx   r10d,ebx,eax
  21a770:	e9 50 01 00 00       	jmp    21a8c5 <__udivmoddi4+0x355>
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21a775:	b8 1f 00 00 00       	mov    eax,0x1f
  21a77a:	29 c8                	sub    eax,ecx
        sr += 1;
  21a77c:	83 c1 01             	add    ecx,0x1
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21a77f:	83 e0 1f             	and    eax,0x1f
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21a782:	89 cd                	mov    ebp,ecx
  21a784:	83 e5 1f             	and    ebp,0x1f
  21a787:	c4 e2 53 f7 d3       	shrx   edx,ebx,ebp
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21a78c:	c4 e2 79 f7 fb       	shlx   edi,ebx,eax
  21a791:	c4 c2 53 f7 da       	shrx   ebx,r10d,ebp
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21a796:	c4 c2 79 f7 ea       	shlx   ebp,r10d,eax
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21a79b:	09 fb                	or     ebx,edi
  21a79d:	45 31 ff             	xor    r15d,r15d
  21a7a0:	41 89 ea             	mov    r10d,ebp
  21a7a3:	eb 17                	jmp    21a7bc <__udivmoddi4+0x24c>
                q[high] = (n[high] << @intCast(Log2SingleInt, DoubleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count));
  21a7a5:	c4 e2 51 f7 eb       	shlx   ebp,ebx,ebp
  21a7aa:	89 c8                	mov    eax,ecx
  21a7ac:	83 e0 1f             	and    eax,0x1f
  21a7af:	c4 42 7b f7 d2       	shrx   r10d,r10d,eax
  21a7b4:	41 09 ea             	or     r10d,ebp
                r[low] = n[high] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count);
  21a7b7:	c4 e2 7b f7 db       	shrx   ebx,ebx,eax
  21a7bc:	4c 8d 4e ff          	lea    r9,[rsi-0x1]
    while (sr > 0) : (sr -= 1) {
  21a7c0:	41 89 cb             	mov    r11d,ecx
  21a7c3:	41 83 e3 01          	and    r11d,0x1
  21a7c7:	83 f9 01             	cmp    ecx,0x1
  21a7ca:	75 10                	jne    21a7dc <__udivmoddi4+0x26c>
  21a7cc:	31 c9                	xor    ecx,ecx
  21a7ce:	45 85 db             	test   r11d,r11d
  21a7d1:	0f 85 9e 00 00 00    	jne    21a875 <__udivmoddi4+0x305>
  21a7d7:	e9 c9 00 00 00       	jmp    21a8a5 <__udivmoddi4+0x335>
  21a7dc:	45 89 dc             	mov    r12d,r11d
  21a7df:	41 29 cc             	sub    r12d,ecx
  21a7e2:	31 c9                	xor    ecx,ecx
  21a7e4:	41 be 1e 01 00 00    	mov    r14d,0x11e
  21a7ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        // r:q = ((r:q)  << 1) | carry
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21a7f0:	0f a4 da 01          	shld   edx,ebx,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21a7f4:	44 0f a4 d3 01       	shld   ebx,r10d,0x1
  21a7f9:	c4 c2 08 f7 ea       	bextr  ebp,r10d,r14d
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21a7fe:	45 0f a4 fa 01       	shld   r10d,r15d,0x1
        q[low] = (q[low] << 1) | carry;
  21a803:	43 8d 04 3f          	lea    eax,[r15+r15*1]
  21a807:	09 c8                	or     eax,ecx
        // if (r.all >= b)
        // {
        //     r.all -= b;
        //      carry = 1;
        // }
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21a809:	48 c1 e2 20          	shl    rdx,0x20
  21a80d:	48 09 d3             	or     rbx,rdx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21a810:	4c 89 c9             	mov    rcx,r9
  21a813:	48 29 d9             	sub    rcx,rbx
  21a816:	48 c1 f9 3f          	sar    rcx,0x3f
        carry = @intCast(u32, s & 1);
  21a81a:	89 ca                	mov    edx,ecx
  21a81c:	83 e2 01             	and    edx,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  21a81f:	48 21 f1             	and    rcx,rsi
  21a822:	48 29 cb             	sub    rbx,rcx
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21a825:	48 89 d9             	mov    rcx,rbx
  21a828:	48 c1 e9 1f          	shr    rcx,0x1f
  21a82c:	83 e1 fe             	and    ecx,0xfffffffe
  21a82f:	89 df                	mov    edi,ebx
  21a831:	c1 ef 1f             	shr    edi,0x1f
  21a834:	09 cf                	or     edi,ecx
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21a836:	c4 c2 08 f7 cf       	bextr  ecx,r15d,r14d
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21a83b:	8d 5c 5d 00          	lea    ebx,[rbp+rbx*2+0x0]
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21a83f:	46 8d 14 51          	lea    r10d,[rcx+r10*2]
        q[low] = (q[low] << 1) | carry;
  21a843:	44 8d 3c 42          	lea    r15d,[rdx+rax*2]
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21a847:	48 c1 e7 20          	shl    rdi,0x20
  21a84b:	48 09 fb             	or     rbx,rdi
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21a84e:	4c 89 c8             	mov    rax,r9
  21a851:	48 29 d8             	sub    rax,rbx
  21a854:	48 c1 f8 3f          	sar    rax,0x3f
        carry = @intCast(u32, s & 1);
  21a858:	89 c1                	mov    ecx,eax
  21a85a:	83 e1 01             	and    ecx,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  21a85d:	48 21 f0             	and    rax,rsi
  21a860:	48 29 c3             	sub    rbx,rax
        r = @ptrCast(*[2]SingleInt, &r_all).*; // TODO issue #421
  21a863:	48 89 da             	mov    rdx,rbx
  21a866:	48 c1 ea 20          	shr    rdx,0x20
    while (sr > 0) : (sr -= 1) {
  21a86a:	41 83 c4 02          	add    r12d,0x2
  21a86e:	75 80                	jne    21a7f0 <__udivmoddi4+0x280>
  21a870:	45 85 db             	test   r11d,r11d
  21a873:	74 30                	je     21a8a5 <__udivmoddi4+0x335>
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21a875:	0f a4 da 01          	shld   edx,ebx,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21a879:	44 0f a4 d3 01       	shld   ebx,r10d,0x1
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21a87e:	48 c1 e2 20          	shl    rdx,0x20
  21a882:	48 09 d3             	or     rbx,rdx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21a885:	49 29 d9             	sub    r9,rbx
  21a888:	49 c1 f9 3f          	sar    r9,0x3f
        r_all -= b & @bitCast(DoubleInt, s);
  21a88c:	4c 21 ce             	and    rsi,r9
  21a88f:	48 29 f3             	sub    rbx,rsi
        carry = @intCast(u32, s & 1);
  21a892:	41 83 e1 01          	and    r9d,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21a896:	45 0f a4 fa 01       	shld   r10d,r15d,0x1
        q[low] = (q[low] << 1) | carry;
  21a89b:	42 8d 04 79          	lea    eax,[rcx+r15*2]
  21a89f:	41 89 c7             	mov    r15d,eax
  21a8a2:	44 89 c9             	mov    ecx,r9d
    }
    const q_all = ((@ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*) << 1) | carry; // TODO issue #421
  21a8a5:	89 ca                	mov    edx,ecx
  21a8a7:	44 89 f9             	mov    ecx,r15d
  21a8aa:	45 89 d7             	mov    r15d,r10d
  21a8ad:	49 c1 e7 20          	shl    r15,0x20
  21a8b1:	49 09 cf             	or     r15,rcx
  21a8b4:	4d 01 ff             	add    r15,r15
  21a8b7:	4d 89 fa             	mov    r10,r15
  21a8ba:	49 09 d2             	or     r10,rdx
    if (maybe_rem) |rem| {
  21a8bd:	4d 85 c0             	test   r8,r8
  21a8c0:	74 03                	je     21a8c5 <__udivmoddi4+0x355>
        rem.* = r_all;
  21a8c2:	49 89 18             	mov    QWORD PTR [r8],rbx
    @setRuntimeSafety(builtin.is_test);
    return udivmod(u64, a, b, maybe_rem);
  21a8c5:	4c 89 d0             	mov    rax,r10
  21a8c8:	5b                   	pop    rbx
  21a8c9:	41 5c                	pop    r12
  21a8cb:	41 5e                	pop    r14
  21a8cd:	41 5f                	pop    r15
  21a8cf:	5d                   	pop    rbp
  21a8d0:	c3                   	ret    
  21a8d1:	31 c9                	xor    ecx,ecx
  21a8d3:	eb d8                	jmp    21a8ad <__udivmoddi4+0x33d>
  21a8d5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a8dc:	00 00 00 00 

000000000021a8e0 <__cmptf2>:
const is_test = builtin.is_test;

pub extern fn __letf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aInt = @bitCast(rep_t, a);
  21a8e0:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  21a8e6:	4c 8b 5c 24 e8       	mov    r11,QWORD PTR [rsp-0x18]
  21a8eb:	4c 8b 44 24 f0       	mov    r8,QWORD PTR [rsp-0x10]
    const bInt = @bitCast(rep_t, b);
  21a8f0:	66 0f 7f 4c 24 d8    	movdqa XMMWORD PTR [rsp-0x28],xmm1

    const aAbs: rep_t = aInt & absMask;
  21a8f6:	40 b6 3f             	mov    sil,0x3f
  21a8f9:	c4 c2 c8 f5 c8       	bzhi   rcx,r8,rsi
    const bAbs: rep_t = bInt & absMask;

    // If either a or b is NaN, they are unordered.
    if (aAbs > infRep or bAbs > infRep) return LE_UNORDERED;
  21a8fe:	4c 89 d8             	mov    rax,r11
  21a901:	48 f7 d8             	neg    rax
  21a904:	49 ba 00 00 00 00 00 	movabs r10,0x7fff000000000000
  21a90b:	00 ff 7f 
  21a90e:	4c 89 d0             	mov    rax,r10
  21a911:	48 19 c8             	sbb    rax,rcx
  21a914:	b8 01 00 00 00       	mov    eax,0x1
  21a919:	72 68                	jb     21a983 <__cmptf2+0xa3>
  21a91b:	48 8b 7c 24 d8       	mov    rdi,QWORD PTR [rsp-0x28]
  21a920:	4c 8b 4c 24 e0       	mov    r9,QWORD PTR [rsp-0x20]
  21a925:	c4 c2 c8 f5 d1       	bzhi   rdx,r9,rsi
  21a92a:	48 83 ff 01          	cmp    rdi,0x1
  21a92e:	48 89 d6             	mov    rsi,rdx
  21a931:	4c 19 d6             	sbb    rsi,r10
  21a934:	73 4d                	jae    21a983 <__cmptf2+0xa3>

    // If a and b are both zeros, they are equal.
    if ((aAbs | bAbs) == 0) return LE_EQUAL;
  21a936:	48 89 f8             	mov    rax,rdi
  21a939:	4c 09 d8             	or     rax,r11
  21a93c:	48 09 ca             	or     rdx,rcx
  21a93f:	48 09 c2             	or     rdx,rax
  21a942:	74 40                	je     21a984 <__cmptf2+0xa4>
  21a944:	b8 ff ff ff ff       	mov    eax,0xffffffff

    // If at least one of a and b is positive, we get the same result comparing
    // a and b as signed integers as we would with a floating-point compare.
    return if ((aInt & bInt) >= 0) if (aInt < bInt)
  21a949:	49 39 fb             	cmp    r11,rdi
  21a94c:	4c 89 c1             	mov    rcx,r8
  21a94f:	4c 19 c9             	sbb    rcx,r9
  21a952:	72 2f                	jb     21a983 <__cmptf2+0xa3>
        LE_LESS
    else if (aInt == bInt)
  21a954:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  21a959:	c4 c1 f9 6e c9       	vmovq  xmm1,r9
  21a95e:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  21a962:	c4 c1 f9 6e cb       	vmovq  xmm1,r11
  21a967:	c4 c1 f9 6e d0       	vmovq  xmm2,r8
  21a96c:	c5 f1 6c ca          	vpunpcklqdq xmm1,xmm1,xmm2
  21a970:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  21a974:	c5 f9 d7 c8          	vpmovmskb ecx,xmm0
  21a978:	31 c0                	xor    eax,eax
  21a97a:	81 f9 ff ff 00 00    	cmp    ecx,0xffff
  21a980:	0f 95 c0             	setne  al
    if (aAbs > infRep or bAbs > infRep) return LE_UNORDERED;
  21a983:	c3                   	ret    
  21a984:	31 c0                	xor    eax,eax
  21a986:	c3                   	ret    
  21a987:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21a98e:	00 00 

000000000021a990 <__gttf2>:
const GE_UNORDERED = c_int(-1); // Note: different from LE_UNORDERED

pub extern fn __getf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aInt = @bitCast(srep_t, a);
  21a990:	53                   	push   rbx
  21a991:	0f 29 44 24 f0       	movaps XMMWORD PTR [rsp-0x10],xmm0
  21a996:	4c 8b 54 24 f0       	mov    r10,QWORD PTR [rsp-0x10]
  21a99b:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
    const bInt = @bitCast(srep_t, b);
  21a9a0:	0f 29 4c 24 e0       	movaps XMMWORD PTR [rsp-0x20],xmm1
    const aAbs = @bitCast(rep_t, aInt) & absMask;
  21a9a5:	41 b1 3f             	mov    r9b,0x3f
  21a9a8:	c4 c2 b0 f5 c8       	bzhi   rcx,r8,r9
    const bAbs = @bitCast(rep_t, bInt) & absMask;

    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  21a9ad:	4c 89 d0             	mov    rax,r10
  21a9b0:	48 f7 d8             	neg    rax
  21a9b3:	48 bb 00 00 00 00 00 	movabs rbx,0x7fff000000000000
  21a9ba:	00 ff 7f 
  21a9bd:	48 89 d8             	mov    rax,rbx
  21a9c0:	48 19 c8             	sbb    rax,rcx
  21a9c3:	b8 ff ff ff ff       	mov    eax,0xffffffff
  21a9c8:	72 39                	jb     21aa03 <__gttf2+0x73>
  21a9ca:	48 8b 7c 24 e0       	mov    rdi,QWORD PTR [rsp-0x20]
  21a9cf:	4c 8b 5c 24 e8       	mov    r11,QWORD PTR [rsp-0x18]
  21a9d4:	c4 c2 b0 f5 f3       	bzhi   rsi,r11,r9
  21a9d9:	48 83 ff 01          	cmp    rdi,0x1
  21a9dd:	48 89 f2             	mov    rdx,rsi
  21a9e0:	48 19 da             	sbb    rdx,rbx
  21a9e3:	73 1e                	jae    21aa03 <__gttf2+0x73>
    if ((aAbs | bAbs) == 0) return GE_EQUAL;
  21a9e5:	48 89 fa             	mov    rdx,rdi
  21a9e8:	4c 09 d2             	or     rdx,r10
  21a9eb:	48 09 ce             	or     rsi,rcx
  21a9ee:	48 09 d6             	or     rsi,rdx
  21a9f1:	74 12                	je     21aa05 <__gttf2+0x75>
    return if ((aInt & bInt) >= 0) if (aInt < bInt)
  21a9f3:	4d 85 c3             	test   r11,r8
  21a9f6:	78 11                	js     21aa09 <__gttf2+0x79>
  21a9f8:	49 39 fa             	cmp    r10,rdi
  21a9fb:	4c 89 c1             	mov    rcx,r8
  21a9fe:	4c 19 d9             	sbb    rcx,r11
  21aa01:	7d 11                	jge    21aa14 <__gttf2+0x84>
    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  21aa03:	5b                   	pop    rbx
  21aa04:	c3                   	ret    
  21aa05:	31 c0                	xor    eax,eax
  21aa07:	5b                   	pop    rbx
  21aa08:	c3                   	ret    
        GE_LESS
    else if (aInt == bInt)
        GE_EQUAL
    else
        GE_GREATER else if (aInt > bInt)
  21aa09:	4c 39 d7             	cmp    rdi,r10
  21aa0c:	4c 89 d9             	mov    rcx,r11
  21aa0f:	4c 19 c1             	sbb    rcx,r8
  21aa12:	7c ef                	jl     21aa03 <__gttf2+0x73>
  21aa14:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  21aa19:	c4 c1 f9 6e cb       	vmovq  xmm1,r11
  21aa1e:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  21aa22:	c4 c1 f9 6e ca       	vmovq  xmm1,r10
  21aa27:	c4 c1 f9 6e d0       	vmovq  xmm2,r8
  21aa2c:	c5 f1 6c ca          	vpunpcklqdq xmm1,xmm1,xmm2
  21aa30:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  21aa34:	c5 f9 d7 c8          	vpmovmskb ecx,xmm0
  21aa38:	31 c0                	xor    eax,eax
  21aa3a:	81 f9 ff ff 00 00    	cmp    ecx,0xffff
  21aa40:	0f 95 c0             	setne  al
    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  21aa43:	5b                   	pop    rbx
  21aa44:	c3                   	ret    
  21aa45:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21aa4c:	00 00 00 00 

000000000021aa50 <__extendhfsf2>:

    const dstMinNormal: dst_rep_t = dst_rep_t(1) << dstSigBits;

    // Break a into a sign and representation of the absolute value
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21aa50:	89 f9                	mov    ecx,edi
  21aa52:	81 e1 ff 7f 00 00    	and    ecx,0x7fff
    const sign: src_rep_t = aRep & srcSignMask;
  21aa58:	89 f8                	mov    eax,edi
  21aa5a:	25 00 80 00 00       	and    eax,0x8000
    var absResult: dst_rep_t = undefined;

    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  21aa5f:	89 ca                	mov    edx,ecx
  21aa61:	81 c2 00 fc ff ff    	add    edx,0xfffffc00
  21aa67:	0f b7 d2             	movzx  edx,dx
  21aa6a:	81 fa ff 77 00 00    	cmp    edx,0x77ff
  21aa70:	77 16                	ja     21aa88 <__extendhfsf2+0x38>
        // a is a normal number.
        // Extend to the destination type by shifting the significand and
        // exponent into the proper position and rebiasing the exponent.
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  21aa72:	0f b7 c9             	movzx  ecx,cx
  21aa75:	c1 e1 0d             	shl    ecx,0xd
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  21aa78:	81 c1 00 00 00 38    	add    ecx,0x38000000
        // a is zero.
        absResult = 0;
    }

    // Apply the signbit to (dst_t)abs(a).
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21aa7e:	c1 e0 10             	shl    eax,0x10
  21aa81:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  21aa83:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  21aa87:	c3                   	ret    
    } else if (aAbs >= srcInfinity) {
  21aa88:	0f b7 d1             	movzx  edx,cx
  21aa8b:	81 fa 00 7c 00 00    	cmp    edx,0x7c00
  21aa91:	72 16                	jb     21aaa9 <__extendhfsf2+0x59>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  21aa93:	0f b7 cf             	movzx  ecx,di
  21aa96:	c1 e1 0d             	shl    ecx,0xd
  21aa99:	81 c9 00 00 80 7f    	or     ecx,0x7f800000
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21aa9f:	c1 e0 10             	shl    eax,0x10
  21aaa2:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  21aaa4:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  21aaa8:	c3                   	ret    
    } else if (aAbs != 0) {
  21aaa9:	66 85 c9             	test   cx,cx
  21aaac:	74 2f                	je     21aadd <__extendhfsf2+0x8d>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  21aaae:	66 f3 0f bd c9       	lzcnt  cx,cx
  21aab3:	8d 71 1b             	lea    esi,[rcx+0x1b]
  21aab6:	83 e6 1f             	and    esi,0x1f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  21aab9:	83 c1 08             	add    ecx,0x8
  21aabc:	c4 e2 71 f7 d2       	shlx   edx,edx,ecx
        absResult ^= dstMinNormal;
  21aac1:	81 f2 00 00 80 00    	xor    edx,0x800000
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  21aac7:	c1 e6 17             	shl    esi,0x17
  21aaca:	b9 00 00 80 38       	mov    ecx,0x38800000
  21aacf:	29 f1                	sub    ecx,esi
  21aad1:	09 d1                	or     ecx,edx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21aad3:	c1 e0 10             	shl    eax,0x10
  21aad6:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  21aad8:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  21aadc:	c3                   	ret    
  21aadd:	31 c9                	xor    ecx,ecx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21aadf:	c1 e0 10             	shl    eax,0x10
  21aae2:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  21aae4:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  21aae8:	c3                   	ret    
  21aae9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021aaf0 <__truncsfhf2>:

    const dstQNaN = 1 << (dstSigBits - 1);
    const dstNaNCode = dstQNaN - 1;

    // Break a into a sign and representation of the absolute value
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21aaf0:	c5 f9 7e c2          	vmovd  edx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21aaf4:	89 d6                	mov    esi,edx
  21aaf6:	81 e6 ff ff ff 7f    	and    esi,0x7fffffff
    const sign: src_rep_t = aRep & srcSignMask;
    var absResult: dst_rep_t = undefined;

    if (aAbs -% underflow < aAbs -% overflow) {
  21aafc:	8d 86 00 00 80 c7    	lea    eax,[rsi-0x38800000]
  21ab02:	8d 8e 00 00 80 b8    	lea    ecx,[rsi-0x47800000]
  21ab08:	39 c8                	cmp    eax,ecx
  21ab0a:	73 1f                	jae    21ab2b <__truncsfhf2+0x3b>
        // The exponent of a is within the range of normal numbers in the
        // destination format.  We can convert by simply right-shifting with
        // rounding and adjusting the exponent.
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  21ab0c:	89 d0                	mov    eax,edx
  21ab0e:	c1 e8 0d             	shr    eax,0xd
        absResult -%= dst_rep_t(srcExpBias - dstExpBias) << dstSigBits;

        const roundBits: src_rep_t = aAbs & roundMask;
  21ab11:	89 d1                	mov    ecx,edx
  21ab13:	81 e1 ff 1f 00 00    	and    ecx,0x1fff
        if (roundBits > halfway) {
  21ab19:	81 f9 01 10 00 00    	cmp    ecx,0x1001
  21ab1f:	72 23                	jb     21ab44 <__truncsfhf2+0x54>
            // Round to nearest
            absResult += 1;
  21ab21:	05 01 40 00 00       	add    eax,0x4001
  21ab26:	e9 83 00 00 00       	jmp    21abae <__truncsfhf2+0xbe>
        } else if (roundBits == halfway) {
            // Ties to even
            absResult += absResult & 1;
        }
    } else if (aAbs > srcInfinity) {
  21ab2b:	81 fe 01 00 80 7f    	cmp    esi,0x7f800001
  21ab31:	72 29                	jb     21ab5c <__truncsfhf2+0x6c>
        // a is NaN.
        // Conjure the result by beginning with infinity, setting the qNaN
        // bit and inserting the (truncated) trailing NaN field.
        absResult = @intCast(dst_rep_t, dstInfExp) << dstSigBits;
        absResult |= dstQNaN;
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  21ab33:	b8 0d 09 00 00       	mov    eax,0x90d
  21ab38:	c4 e2 78 f7 c2       	bextr  eax,edx,eax
  21ab3d:	0d 00 7e 00 00       	or     eax,0x7e00
  21ab42:	eb 6a                	jmp    21abae <__truncsfhf2+0xbe>
  21ab44:	05 00 40 00 00       	add    eax,0x4000
        } else if (roundBits == halfway) {
  21ab49:	81 f9 00 10 00 00    	cmp    ecx,0x1000
  21ab4f:	75 5d                	jne    21abae <__truncsfhf2+0xbe>
  21ab51:	89 c1                	mov    ecx,eax
  21ab53:	83 e1 01             	and    ecx,0x1
  21ab56:	01 c1                	add    ecx,eax
  21ab58:	89 c8                	mov    eax,ecx
  21ab5a:	eb 52                	jmp    21abae <__truncsfhf2+0xbe>
  21ab5c:	66 b8 00 7c          	mov    ax,0x7c00
    } else if (aAbs >= overflow) {
  21ab60:	81 fe ff ff 7f 47    	cmp    esi,0x477fffff
  21ab66:	77 46                	ja     21abae <__truncsfhf2+0xbe>
        absResult = @intCast(dst_rep_t, dstInfExp) << dstSigBits;
    } else {
        // a underflows on conversion to the destination type or is an exact
        // zero.  The result may be a denormal or zero.  Extract the exponent
        // to get the shift amount for the denormalization.
        const aExp = @intCast(u32, aAbs >> srcSigBits);
  21ab68:	c1 ee 17             	shr    esi,0x17
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21ab6b:	b9 70 00 00 00       	mov    ecx,0x70
  21ab70:	29 f1                	sub    ecx,esi

        const significand: src_rep_t = (aRep & srcSignificandMask) | srcMinNormal;

        // Right shift by the denormalization amount with sticky.
        if (shift > srcSigBits) {
  21ab72:	83 f9 16             	cmp    ecx,0x16
  21ab75:	76 04                	jbe    21ab7b <__truncsfhf2+0x8b>
  21ab77:	31 c0                	xor    eax,eax
  21ab79:	eb 33                	jmp    21abae <__truncsfhf2+0xbe>
  21ab7b:	89 d6                	mov    esi,edx
  21ab7d:	81 e6 ff ff 7f 00    	and    esi,0x7fffff
  21ab83:	81 ce 00 00 80 00    	or     esi,0x800000
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21ab89:	83 c1 01             	add    ecx,0x1
            absResult = 0;
        } else {
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  21ab8c:	d3 ce                	ror    esi,cl
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  21ab8e:	89 f0                	mov    eax,esi
  21ab90:	c1 e8 0d             	shr    eax,0xd
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  21ab93:	81 e6 ff 1f 00 00    	and    esi,0x1fff
            if (roundBits > halfway) {
  21ab99:	81 fe 01 10 00 00    	cmp    esi,0x1001
  21ab9f:	72 05                	jb     21aba6 <__truncsfhf2+0xb6>
                // Round to nearest
                absResult += 1;
  21aba1:	83 c0 01             	add    eax,0x1
  21aba4:	eb 08                	jmp    21abae <__truncsfhf2+0xbe>
            } else if (roundBits == halfway) {
  21aba6:	81 fe 00 10 00 00    	cmp    esi,0x1000
  21abac:	74 a3                	je     21ab51 <__truncsfhf2+0x61>
                absResult += absResult & 1;
            }
        }
    }

    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  21abae:	c1 ea 10             	shr    edx,0x10
  21abb1:	81 e2 00 80 00 00    	and    edx,0x8000
  21abb7:	09 d0                	or     eax,edx
    return @bitCast(u16, truncXfYf2(f16, f32, a));
  21abb9:	c3                   	ret    
  21abba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000021abc0 <__unordtf2>:
}

pub extern fn __unordtf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aAbs = @bitCast(rep_t, a) & absMask;
  21abc0:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  21abc5:	b0 3f                	mov    al,0x3f
  21abc7:	c4 e2 f8 f5 4c 24 f0 	bzhi   rcx,QWORD PTR [rsp-0x10],rax
    const bAbs = @bitCast(rep_t, b) & absMask;
  21abce:	0f 29 4c 24 d8       	movaps XMMWORD PTR [rsp-0x28],xmm1
  21abd3:	c4 e2 f8 f5 44 24 e0 	bzhi   rax,QWORD PTR [rsp-0x20],rax
    return @boolToInt(aAbs > infRep or bAbs > infRep);
  21abda:	31 d2                	xor    edx,edx
  21abdc:	48 3b 54 24 e8       	cmp    rdx,QWORD PTR [rsp-0x18]
  21abe1:	48 be 00 00 00 00 00 	movabs rsi,0x7fff000000000000
  21abe8:	00 ff 7f 
  21abeb:	48 89 f7             	mov    rdi,rsi
  21abee:	48 19 cf             	sbb    rdi,rcx
  21abf1:	0f 92 c1             	setb   cl
  21abf4:	48 3b 54 24 d8       	cmp    rdx,QWORD PTR [rsp-0x28]
  21abf9:	48 19 c6             	sbb    rsi,rax
  21abfc:	0f 92 c0             	setb   al
  21abff:	08 c8                	or     al,cl
  21ac01:	0f b6 c0             	movzx  eax,al
  21ac04:	c3                   	ret    
  21ac05:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ac0c:	00 00 00 00 

000000000021ac10 <__floattitf>:
const LDBL_MANT_DIG = 113;

pub extern fn __floattitf(arg: i128) f128 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21ac10:	48 89 f8             	mov    rax,rdi
  21ac13:	48 09 f0             	or     rax,rsi
  21ac16:	0f 84 ba 00 00 00    	je     21acd6 <__floattitf+0xc6>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  21ac1c:	41 57                	push   r15
  21ac1e:	41 56                	push   r14
  21ac20:	53                   	push   rbx
  21ac21:	48 89 f0             	mov    rax,rsi
  21ac24:	48 c1 f8 3f          	sar    rax,0x3f
    ai = ((ai ^ si) -% si);
  21ac28:	48 89 c2             	mov    rdx,rax
  21ac2b:	48 31 f2             	xor    rdx,rsi
  21ac2e:	48 31 c7             	xor    rdi,rax
  21ac31:	48 29 c7             	sub    rdi,rax
  21ac34:	48 19 c2             	sbb    rdx,rax
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21ac37:	f3 48 0f bd c2       	lzcnt  rax,rdx
  21ac3c:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21ac41:	83 c1 40             	add    ecx,0x40
  21ac44:	48 85 d2             	test   rdx,rdx
  21ac47:	0f 45 c8             	cmovne ecx,eax
  21ac4a:	41 b9 80 00 00 00    	mov    r9d,0x80
  21ac50:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  21ac53:	41 ba 7f 00 00 00    	mov    r10d,0x7f
  21ac59:	41 29 ca             	sub    r10d,ecx
    if (sd > LDBL_MANT_DIG) {
  21ac5c:	41 83 f9 72          	cmp    r9d,0x72
  21ac60:	7c 7c                	jl     21acde <__floattitf+0xce>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit LDBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit LDBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21ac62:	0f 84 99 00 00 00    	je     21ad01 <__floattitf+0xf1>
  21ac68:	41 83 f9 73          	cmp    r9d,0x73
  21ac6c:	0f 84 97 00 00 00    	je     21ad09 <__floattitf+0xf9>
            LDBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            LDBL_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (LDBL_MANT_DIG + 2));
  21ac72:	41 8d 49 0d          	lea    ecx,[r9+0xd]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  21ac76:	41 b8 73 00 00 00    	mov    r8d,0x73
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21ac7c:	83 e1 7f             	and    ecx,0x7f
  21ac7f:	49 89 ff             	mov    r15,rdi
  21ac82:	49 0f ad d7          	shrd   r15,rdx,cl
                const shift2_amt = @intCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  21ac86:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21ac89:	c4 62 f3 f7 da       	shrx   r11,rdx,rcx
  21ac8e:	45 31 f6             	xor    r14d,r14d
  21ac91:	f6 c1 40             	test   cl,0x40
  21ac94:	4d 0f 45 fb          	cmovne r15,r11
  21ac98:	4d 0f 45 de          	cmovne r11,r14
  21ac9c:	41 83 e0 7f          	and    r8d,0x7f
  21aca0:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21aca7:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  21acac:	44 89 c1             	mov    ecx,r8d
  21acaf:	48 0f ad db          	shrd   rbx,rbx,cl
  21acb3:	41 f6 c0 40          	test   r8b,0x40
  21acb7:	48 0f 45 d8          	cmovne rbx,rax
  21acbb:	49 0f 45 c6          	cmovne rax,r14
  21acbf:	48 21 fb             	and    rbx,rdi
  21acc2:	48 21 d0             	and    rax,rdx
  21acc5:	31 ff                	xor    edi,edi
  21acc7:	48 09 d8             	or     rax,rbx
  21acca:	40 0f 95 c7          	setne  dil
  21acce:	4c 09 ff             	or     rdi,r15
  21acd1:	4c 89 da             	mov    rdx,r11
  21acd4:	eb 33                	jmp    21ad09 <__floattitf+0xf9>
        return 0.0;
  21acd6:	0f 28 05 c3 55 fe ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffe55c3]        # 2002a0 <__unnamed_2>
  21acdd:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to LDBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, LDBL_MANT_DIG - sd);
  21acde:	b9 71 00 00 00       	mov    ecx,0x71
  21ace3:	44 29 c9             	sub    ecx,r9d
  21ace6:	83 e1 7f             	and    ecx,0x7f
  21ace9:	48 0f a5 fa          	shld   rdx,rdi,cl
  21aced:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  21acf2:	31 c0                	xor    eax,eax
  21acf4:	f6 c1 40             	test   cl,0x40
  21acf7:	48 0f 45 d7          	cmovne rdx,rdi
  21acfb:	48 0f 44 c7          	cmove  rax,rdi
  21acff:	eb 3b                	jmp    21ad3c <__floattitf+0x12c>
                a <<= 1;
  21ad01:	48 0f a4 fa 01       	shld   rdx,rdi,0x1
  21ad06:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21ad09:	b8 02 01 00 00       	mov    eax,0x102
  21ad0e:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  21ad13:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  21ad16:	48 83 c0 01          	add    rax,0x1
  21ad1a:	48 83 d2 00          	adc    rdx,0x0
        if ((a & (u128(1) << LDBL_MANT_DIG)) != 0) {
  21ad1e:	48 0f ba e2 33       	bt     rdx,0x33
  21ad23:	72 0b                	jb     21ad30 <__floattitf+0x120>
  21ad25:	48 0f ac d0 02       	shrd   rax,rdx,0x2
  21ad2a:	48 c1 ea 02          	shr    rdx,0x2
  21ad2e:	eb 0c                	jmp    21ad3c <__floattitf+0x12c>
            a >>= 1;
  21ad30:	48 0f ac d0 03       	shrd   rax,rdx,0x3
  21ad35:	48 c1 ea 03          	shr    rdx,0x3
  21ad39:	45 89 ca             	mov    r10d,r9d
        // a is now rounded to LDBL_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 64);
    const high: u128 = (@intCast(u64, s) & 0x8000000000000000) | // sign
  21ad3c:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  21ad43:	00 00 80 
  21ad46:	48 21 ce             	and    rsi,rcx
        (@intCast(u64, (e + 16383)) << 48) | // exponent
  21ad49:	41 81 c2 ff 3f 00 00 	add    r10d,0x3fff
  21ad50:	49 c1 e2 30          	shl    r10,0x30
    const high: u128 = (@intCast(u64, s) & 0x8000000000000000) | // sign
  21ad54:	49 09 f2             	or     r10,rsi
        (@truncate(u64, a >> 64) & 0x0000ffffffffffff); // mantissa-high
  21ad57:	b1 30                	mov    cl,0x30
  21ad59:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
    const low = @truncate(u64, a); // mantissa-low

    return @bitCast(f128, low | (high << 64));
  21ad5e:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
        (@intCast(u64, (e + 16383)) << 48) | // exponent
  21ad63:	4c 09 d1             	or     rcx,r10
    return @bitCast(f128, low | (high << 64));
  21ad66:	48 89 4c 24 f8       	mov    QWORD PTR [rsp-0x8],rcx
  21ad6b:	0f 28 44 24 f0       	movaps xmm0,XMMWORD PTR [rsp-0x10]
  21ad70:	5b                   	pop    rbx
  21ad71:	41 5e                	pop    r14
  21ad73:	41 5f                	pop    r15
  21ad75:	c3                   	ret    
  21ad76:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21ad7d:	00 00 00 

000000000021ad80 <__floattidf>:
const DBL_MANT_DIG = 53;

pub extern fn __floattidf(arg: i128) f64 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21ad80:	48 89 f8             	mov    rax,rdi
  21ad83:	48 09 f0             	or     rax,rsi
  21ad86:	0f 84 b8 00 00 00    	je     21ae44 <__floattidf+0xc4>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  21ad8c:	41 57                	push   r15
  21ad8e:	41 56                	push   r14
  21ad90:	53                   	push   rbx
  21ad91:	48 89 f0             	mov    rax,rsi
  21ad94:	48 c1 f8 3f          	sar    rax,0x3f
    ai = ((ai ^ si) -% si);
  21ad98:	48 89 c2             	mov    rdx,rax
  21ad9b:	48 31 f2             	xor    rdx,rsi
  21ad9e:	48 31 c7             	xor    rdi,rax
  21ada1:	48 29 c7             	sub    rdi,rax
  21ada4:	48 19 c2             	sbb    rdx,rax
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21ada7:	f3 48 0f bd c2       	lzcnt  rax,rdx
  21adac:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21adb1:	83 c1 40             	add    ecx,0x40
  21adb4:	48 85 d2             	test   rdx,rdx
  21adb7:	0f 45 c8             	cmovne ecx,eax
  21adba:	41 b9 80 00 00 00    	mov    r9d,0x80
  21adc0:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  21adc3:	b8 7f 00 00 00       	mov    eax,0x7f
  21adc8:	29 c8                	sub    eax,ecx
    if (sd > DBL_MANT_DIG) {
  21adca:	41 83 f9 36          	cmp    r9d,0x36
  21adce:	7c 79                	jl     21ae49 <__floattidf+0xc9>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit DBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit DBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21add0:	0f 84 9b 00 00 00    	je     21ae71 <__floattidf+0xf1>
  21add6:	41 83 f9 37          	cmp    r9d,0x37
  21adda:	0f 84 99 00 00 00    	je     21ae79 <__floattidf+0xf9>
            DBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            DBL_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (DBL_MANT_DIG + 2));
  21ade0:	41 8d 49 49          	lea    ecx,[r9+0x49]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  21ade4:	41 b8 37 00 00 00    	mov    r8d,0x37
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21adea:	83 e1 7f             	and    ecx,0x7f
  21aded:	49 89 fa             	mov    r10,rdi
  21adf0:	49 0f ad d2          	shrd   r10,rdx,cl
                const shift2_amt = @intCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  21adf4:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21adf7:	c4 62 f3 f7 da       	shrx   r11,rdx,rcx
  21adfc:	45 31 f6             	xor    r14d,r14d
  21adff:	f6 c1 40             	test   cl,0x40
  21ae02:	4d 0f 45 d3          	cmovne r10,r11
  21ae06:	4d 0f 45 de          	cmovne r11,r14
  21ae0a:	41 83 e0 7f          	and    r8d,0x7f
  21ae0e:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21ae15:	c4 62 bb f7 fb       	shrx   r15,rbx,r8
  21ae1a:	44 89 c1             	mov    ecx,r8d
  21ae1d:	48 0f ad db          	shrd   rbx,rbx,cl
  21ae21:	41 f6 c0 40          	test   r8b,0x40
  21ae25:	49 0f 45 df          	cmovne rbx,r15
  21ae29:	4d 0f 45 fe          	cmovne r15,r14
  21ae2d:	48 21 fb             	and    rbx,rdi
  21ae30:	49 21 d7             	and    r15,rdx
  21ae33:	31 ff                	xor    edi,edi
  21ae35:	49 09 df             	or     r15,rbx
  21ae38:	40 0f 95 c7          	setne  dil
  21ae3c:	4c 09 d7             	or     rdi,r10
  21ae3f:	4c 89 da             	mov    rdx,r11
  21ae42:	eb 35                	jmp    21ae79 <__floattidf+0xf9>
        return 0.0;
  21ae44:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21ae48:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to DBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, DBL_MANT_DIG - sd);
  21ae49:	b9 35 00 00 00       	mov    ecx,0x35
  21ae4e:	44 29 c9             	sub    ecx,r9d
  21ae51:	83 e1 7f             	and    ecx,0x7f
  21ae54:	48 0f a5 fa          	shld   rdx,rdi,cl
  21ae58:	c4 e2 f1 f7 df       	shlx   rbx,rdi,rcx
  21ae5d:	31 ff                	xor    edi,edi
  21ae5f:	f6 c1 40             	test   cl,0x40
  21ae62:	48 0f 45 d3          	cmovne rdx,rbx
  21ae66:	48 0f 44 fb          	cmove  rdi,rbx
    if (sd > DBL_MANT_DIG) {
  21ae6a:	48 0f a4 fa 20       	shld   rdx,rdi,0x20
  21ae6f:	eb 40                	jmp    21aeb1 <__floattidf+0x131>
                a <<= 1;
  21ae71:	48 0f a4 fa 01       	shld   rdx,rdi,0x1
  21ae76:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21ae79:	b9 02 01 00 00       	mov    ecx,0x102
  21ae7e:	c4 e2 70 f7 cf       	bextr  ecx,edi,ecx
  21ae83:	48 09 f9             	or     rcx,rdi
        a += 1; // round - this step may add a significant bit
  21ae86:	48 83 c1 01          	add    rcx,0x1
  21ae8a:	48 83 d2 00          	adc    rdx,0x0
            a >>= 1;
  21ae8e:	48 89 d7             	mov    rdi,rdx
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  21ae91:	48 0f ba e1 37       	bt     rcx,0x37
  21ae96:	72 0c                	jb     21aea4 <__floattidf+0x124>
  21ae98:	48 0f a4 cf 3e       	shld   rdi,rcx,0x3e
  21ae9d:	48 0f a4 ca 1e       	shld   rdx,rcx,0x1e
  21aea2:	eb 0d                	jmp    21aeb1 <__floattidf+0x131>
            a >>= 1;
  21aea4:	48 0f a4 cf 3d       	shld   rdi,rcx,0x3d
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  21aea9:	48 0f a4 ca 1d       	shld   rdx,rcx,0x1d
  21aeae:	44 89 c8             	mov    eax,r9d
        // a is now rounded to DBL_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 32);
  21aeb1:	48 c1 ee 20          	shr    rsi,0x20
    const high: u64 = (@intCast(u64, s) & 0x80000000) | // sign
  21aeb5:	81 e6 00 00 00 80    	and    esi,0x80000000
        (@intCast(u32, (e + 1023)) << 20) | // exponent
  21aebb:	c1 e0 14             	shl    eax,0x14
  21aebe:	05 00 00 f0 3f       	add    eax,0x3ff00000
    const high: u64 = (@intCast(u64, s) & 0x80000000) | // sign
  21aec3:	09 f0                	or     eax,esi
        (@truncate(u32, a >> 32) & 0x000fffff); // mantissa-high
  21aec5:	81 e2 ff ff 0f 00    	and    edx,0xfffff
        (@intCast(u32, (e + 1023)) << 20) | // exponent
  21aecb:	09 c2                	or     edx,eax
    const low: u64 = @truncate(u32, a); // mantissa-low
  21aecd:	89 f8                	mov    eax,edi

    return @bitCast(f64, low | (high << 32));
  21aecf:	48 c1 e2 20          	shl    rdx,0x20
  21aed3:	48 09 c2             	or     rdx,rax
  21aed6:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  21aedb:	5b                   	pop    rbx
  21aedc:	41 5e                	pop    r14
  21aede:	41 5f                	pop    r15
  21aee0:	c3                   	ret    
  21aee1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21aee8:	0f 1f 84 00 00 00 00 
  21aeef:	00 

000000000021aef0 <__floattisf>:
const FLT_MANT_DIG = 24;

pub extern fn __floattisf(arg: i128) f32 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21aef0:	48 89 f8             	mov    rax,rdi
  21aef3:	48 09 f0             	or     rax,rsi
  21aef6:	0f 84 b2 00 00 00    	je     21afae <__floattisf+0xbe>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  21aefc:	48 89 f1             	mov    rcx,rsi
  21aeff:	48 c1 f9 3f          	sar    rcx,0x3f
    ai = ((ai ^ si) -% si);
  21af03:	48 89 c8             	mov    rax,rcx
  21af06:	48 31 f0             	xor    rax,rsi
  21af09:	48 31 cf             	xor    rdi,rcx
  21af0c:	48 29 cf             	sub    rdi,rcx
  21af0f:	48 19 c8             	sbb    rax,rcx
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21af12:	f3 48 0f bd d0       	lzcnt  rdx,rax
  21af17:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21af1c:	83 c1 40             	add    ecx,0x40
  21af1f:	48 85 c0             	test   rax,rax
  21af22:	0f 45 ca             	cmovne ecx,edx
  21af25:	41 b9 80 00 00 00    	mov    r9d,0x80
  21af2b:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  21af2e:	ba 7f 00 00 00       	mov    edx,0x7f
  21af33:	29 ca                	sub    edx,ecx

    if (sd > FLT_MANT_DIG) {
  21af35:	41 83 f9 19          	cmp    r9d,0x19
  21af39:	7c 78                	jl     21afb3 <__floattisf+0xc3>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit FLT_MANT_DIG-1 bits to the right of 1
        //  Q = bit FLT_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21af3b:	0f 84 8d 00 00 00    	je     21afce <__floattisf+0xde>
  21af41:	41 83 f9 1a          	cmp    r9d,0x1a
  21af45:	0f 84 86 00 00 00    	je     21afd1 <__floattisf+0xe1>
            FLT_MANT_DIG + 1 => {
                a <<= 1;
            },
            FLT_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (FLT_MANT_DIG + 2));
  21af4b:	41 56                	push   r14
  21af4d:	53                   	push   rbx
  21af4e:	41 8d 49 66          	lea    ecx,[r9+0x66]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21af52:	83 e1 7f             	and    ecx,0x7f
  21af55:	49 89 fa             	mov    r10,rdi
  21af58:	49 0f ad c2          	shrd   r10,rax,cl
                const shift2_amt = @intCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
  21af5c:	41 b8 1a 00 00 00    	mov    r8d,0x1a
  21af62:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21af65:	c4 62 f3 f7 d8       	shrx   r11,rax,rcx
  21af6a:	45 31 f6             	xor    r14d,r14d
  21af6d:	f6 c1 40             	test   cl,0x40
  21af70:	4d 0f 44 da          	cmove  r11,r10
  21af74:	41 83 e0 7f          	and    r8d,0x7f
  21af78:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21af7f:	c4 62 bb f7 d3       	shrx   r10,rbx,r8
  21af84:	44 89 c1             	mov    ecx,r8d
  21af87:	48 0f ad db          	shrd   rbx,rbx,cl
  21af8b:	41 f6 c0 40          	test   r8b,0x40
  21af8f:	49 0f 45 da          	cmovne rbx,r10
  21af93:	4d 0f 44 f2          	cmove  r14,r10
  21af97:	48 21 fb             	and    rbx,rdi
  21af9a:	49 21 c6             	and    r14,rax
  21af9d:	31 ff                	xor    edi,edi
  21af9f:	49 09 de             	or     r14,rbx
  21afa2:	40 0f 95 c7          	setne  dil
  21afa6:	4c 09 df             	or     rdi,r11
        switch (sd) {
  21afa9:	5b                   	pop    rbx
  21afaa:	41 5e                	pop    r14
  21afac:	eb 23                	jmp    21afd1 <__floattisf+0xe1>
        return 0.0;
  21afae:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21afb2:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to FLT_MANT_DIG bits
    } else {
        a <<= @intCast(u7, FLT_MANT_DIG - sd);
  21afb3:	b9 18 00 00 00       	mov    ecx,0x18
  21afb8:	44 29 c9             	sub    ecx,r9d
  21afbb:	83 e1 7f             	and    ecx,0x7f
  21afbe:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  21afc3:	31 c0                	xor    eax,eax
  21afc5:	f6 c1 40             	test   cl,0x40
  21afc8:	48 0f 44 c7          	cmove  rax,rdi
  21afcc:	eb 28                	jmp    21aff6 <__floattisf+0x106>
                a <<= 1;
  21afce:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21afd1:	b8 02 01 00 00       	mov    eax,0x102
  21afd6:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  21afdb:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  21afde:	48 83 c0 01          	add    rax,0x1
        if ((a & (u128(1) << FLT_MANT_DIG)) != 0) {
  21afe2:	a9 00 00 00 04       	test   eax,0x4000000
  21afe7:	75 06                	jne    21afef <__floattisf+0xff>
  21afe9:	48 c1 e8 02          	shr    rax,0x2
  21afed:	eb 07                	jmp    21aff6 <__floattisf+0x106>
            a >>= 1;
  21afef:	48 c1 e8 03          	shr    rax,0x3
  21aff3:	44 89 ca             	mov    edx,r9d
        // a is now rounded to FLT_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 32);
  21aff6:	48 c1 ee 20          	shr    rsi,0x20
    const r = (@intCast(u32, s) & 0x80000000) | // sign
  21affa:	81 e6 00 00 00 80    	and    esi,0x80000000
        (@intCast(u32, (e + 127)) << 23) | // exponent
  21b000:	c1 e2 17             	shl    edx,0x17
  21b003:	81 c2 00 00 80 3f    	add    edx,0x3f800000
    const r = (@intCast(u32, s) & 0x80000000) | // sign
  21b009:	09 f2                	or     edx,esi
        (@truncate(u32, a) & 0x007fffff); // mantissa-high
  21b00b:	25 ff ff 7f 00       	and    eax,0x7fffff
        (@intCast(u32, (e + 127)) << 23) | // exponent
  21b010:	09 d0                	or     eax,edx

    return @bitCast(f32, r);
  21b012:	c5 f9 6e c0          	vmovd  xmm0,eax
  21b016:	c3                   	ret    
  21b017:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21b01e:	00 00 

000000000021b020 <__floatunditf>:
const std = @import("std");

pub extern fn __floatunditf(a: u128) f128 {
    @setRuntimeSafety(is_test);

    if (a == 0) {
  21b020:	48 89 f8             	mov    rax,rdi
  21b023:	48 09 f0             	or     rax,rsi
  21b026:	74 0f                	je     21b037 <__floatunditf+0x17>
    const mantissa_bits = std.math.floatMantissaBits(f128);
    const exponent_bits = std.math.floatExponentBits(f128);
    const exponent_bias = (1 << (exponent_bits - 1)) - 1;
    const implicit_bit = 1 << mantissa_bits;

    const exp = (u128.bit_count - 1) - @clz(a);
  21b028:	48 85 f6             	test   rsi,rsi
  21b02b:	75 12                	jne    21b03f <__floatunditf+0x1f>
  21b02d:	f3 48 0f bd c7       	lzcnt  rax,rdi
  21b032:	83 c0 40             	add    eax,0x40
  21b035:	eb 0d                	jmp    21b044 <__floatunditf+0x24>
        return 0;
  21b037:	0f 28 05 62 52 fe ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffe5262]        # 2002a0 <__unnamed_2>
  21b03e:	c3                   	ret    
  21b03f:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21b044:	b2 7f                	mov    dl,0x7f
    const exp = (u128.bit_count - 1) - @clz(a);
  21b046:	28 c2                	sub    dl,al
  21b048:	b1 70                	mov    cl,0x70
    const shift = mantissa_bits - @intCast(u7, exp);
  21b04a:	28 d1                	sub    cl,dl

    var result: u128 align(16) = (a << shift) ^ implicit_bit;
  21b04c:	48 0f a5 fe          	shld   rsi,rdi,cl
  21b050:	c4 e2 f1 f7 c7       	shlx   rax,rdi,rcx
  21b055:	31 ff                	xor    edi,edi
  21b057:	f6 c1 40             	test   cl,0x40
  21b05a:	48 0f 45 f0          	cmovne rsi,rax
  21b05e:	48 0f 44 f8          	cmove  rdi,rax
  21b062:	48 b8 00 00 00 00 00 	movabs rax,0x1000000000000
  21b069:	00 01 00 
  21b06c:	48 31 f0             	xor    rax,rsi
    result += (@intCast(u128, exp) + exponent_bias) << mantissa_bits;
  21b06f:	0f b6 ca             	movzx  ecx,dl
  21b072:	48 c1 e1 30          	shl    rcx,0x30
  21b076:	48 01 c1             	add    rcx,rax
  21b079:	48 89 7c 24 e8       	mov    QWORD PTR [rsp-0x18],rdi
  21b07e:	48 b8 00 00 00 00 00 	movabs rax,0x3fff000000000000
  21b085:	00 ff 3f 
  21b088:	48 01 c8             	add    rax,rcx
  21b08b:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  21b090:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]

    return @bitCast(f128, result);
  21b095:	c3                   	ret    
  21b096:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21b09d:	00 00 00 

000000000021b0a0 <__floatunsitf>:
const std = @import("std");

pub extern fn __floatunsitf(a: u64) f128 {
    @setRuntimeSafety(is_test);

    if (a == 0) {
  21b0a0:	48 85 ff             	test   rdi,rdi
  21b0a3:	74 5c                	je     21b101 <__floatunsitf+0x61>
    const mantissa_bits = std.math.floatMantissaBits(f128);
    const exponent_bits = std.math.floatExponentBits(f128);
    const exponent_bias = (1 << (exponent_bits - 1)) - 1;
    const implicit_bit = 1 << mantissa_bits;

    const exp = (u64.bit_count - 1) - @clz(a);
  21b0a5:	f3 48 0f bd c7       	lzcnt  rax,rdi
  21b0aa:	b2 3f                	mov    dl,0x3f
  21b0ac:	28 c2                	sub    dl,al
  21b0ae:	b1 70                	mov    cl,0x70
    const shift = mantissa_bits - @intCast(u7, exp);
  21b0b0:	28 d1                	sub    cl,dl
  21b0b2:	31 c0                	xor    eax,eax

    // TODO(#1148): @bitCast alignment error
    var result align(16) = (@intCast(u128, a) << shift) ^ implicit_bit;
  21b0b4:	31 f6                	xor    esi,esi
  21b0b6:	48 0f a5 fe          	shld   rsi,rdi,cl
  21b0ba:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  21b0bf:	f6 c1 40             	test   cl,0x40
  21b0c2:	48 0f 45 f7          	cmovne rsi,rdi
  21b0c6:	48 0f 45 f8          	cmovne rdi,rax
  21b0ca:	48 b8 00 00 00 00 00 	movabs rax,0x1000000000000
  21b0d1:	00 01 00 
  21b0d4:	48 31 f0             	xor    rax,rsi
    result += (@intCast(u128, exp) + exponent_bias) << mantissa_bits;
  21b0d7:	0f b6 ca             	movzx  ecx,dl
  21b0da:	83 e1 7f             	and    ecx,0x7f
  21b0dd:	48 c1 e1 30          	shl    rcx,0x30
  21b0e1:	48 01 c1             	add    rcx,rax
  21b0e4:	48 89 7c 24 e8       	mov    QWORD PTR [rsp-0x18],rdi
  21b0e9:	48 b8 00 00 00 00 00 	movabs rax,0x3fff000000000000
  21b0f0:	00 ff 3f 
  21b0f3:	48 01 c8             	add    rax,rcx
  21b0f6:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  21b0fb:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]

    return @bitCast(f128, result);
  21b100:	c3                   	ret    
        return 0;
  21b101:	0f 28 05 98 51 fe ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffe5198]        # 2002a0 <__unnamed_2>
  21b108:	c3                   	ret    
  21b109:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021b110 <__floatuntitf>:
const LDBL_MANT_DIG = 113;

pub extern fn __floatuntitf(arg: u128) f128 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21b110:	48 89 f8             	mov    rax,rdi
  21b113:	48 09 f0             	or     rax,rsi
  21b116:	0f 84 a0 00 00 00    	je     21b1bc <__floatuntitf+0xac>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21b11c:	41 56                	push   r14
  21b11e:	53                   	push   rbx
  21b11f:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21b124:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21b129:	83 c1 40             	add    ecx,0x40
  21b12c:	48 85 f6             	test   rsi,rsi
  21b12f:	0f 45 c8             	cmovne ecx,eax
  21b132:	41 b9 80 00 00 00    	mov    r9d,0x80
  21b138:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  21b13b:	ba 7f 00 00 00       	mov    edx,0x7f
  21b140:	29 ca                	sub    edx,ecx
    if (sd > LDBL_MANT_DIG) {
  21b142:	41 83 f9 72          	cmp    r9d,0x72
  21b146:	7c 7c                	jl     21b1c4 <__floatuntitf+0xb4>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit LDBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit LDBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21b148:	0f 84 99 00 00 00    	je     21b1e7 <__floatuntitf+0xd7>
  21b14e:	41 83 f9 73          	cmp    r9d,0x73
  21b152:	0f 84 97 00 00 00    	je     21b1ef <__floatuntitf+0xdf>
            LDBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            LDBL_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  21b158:	41 b8 73 00 00 00    	mov    r8d,0x73
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  21b15e:	41 8d 49 0d          	lea    ecx,[r9+0xd]
  21b162:	83 e1 7f             	and    ecx,0x7f
  21b165:	49 89 fe             	mov    r14,rdi
  21b168:	49 0f ad f6          	shrd   r14,rsi,cl
                const shift_amt = @bitCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  21b16c:	45 29 c8             	sub    r8d,r9d
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  21b16f:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  21b174:	45 31 db             	xor    r11d,r11d
  21b177:	f6 c1 40             	test   cl,0x40
  21b17a:	4d 0f 45 f2          	cmovne r14,r10
  21b17e:	4d 0f 45 d3          	cmovne r10,r11
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  21b182:	41 83 e0 7f          	and    r8d,0x7f
  21b186:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21b18d:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  21b192:	44 89 c1             	mov    ecx,r8d
  21b195:	48 0f ad db          	shrd   rbx,rbx,cl
  21b199:	41 f6 c0 40          	test   r8b,0x40
  21b19d:	48 0f 45 d8          	cmovne rbx,rax
  21b1a1:	49 0f 45 c3          	cmovne rax,r11
  21b1a5:	48 21 fb             	and    rbx,rdi
  21b1a8:	48 21 f0             	and    rax,rsi
  21b1ab:	31 ff                	xor    edi,edi
  21b1ad:	48 09 d8             	or     rax,rbx
  21b1b0:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  21b1b4:	4c 09 f7             	or     rdi,r14
  21b1b7:	4c 89 d6             	mov    rsi,r10
  21b1ba:	eb 33                	jmp    21b1ef <__floatuntitf+0xdf>
        return 0.0;
  21b1bc:	0f 28 05 dd 50 fe ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffe50dd]        # 2002a0 <__unnamed_2>
  21b1c3:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to LDBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, LDBL_MANT_DIG - sd);
  21b1c4:	b9 71 00 00 00       	mov    ecx,0x71
  21b1c9:	44 29 c9             	sub    ecx,r9d
  21b1cc:	83 e1 7f             	and    ecx,0x7f
  21b1cf:	48 0f a5 fe          	shld   rsi,rdi,cl
  21b1d3:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  21b1d8:	31 c0                	xor    eax,eax
  21b1da:	f6 c1 40             	test   cl,0x40
  21b1dd:	48 0f 45 f7          	cmovne rsi,rdi
  21b1e1:	48 0f 44 c7          	cmove  rax,rdi
  21b1e5:	eb 3b                	jmp    21b222 <__floatuntitf+0x112>
                a <<= 1;
  21b1e7:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  21b1ec:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21b1ef:	b8 02 01 00 00       	mov    eax,0x102
  21b1f4:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  21b1f9:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  21b1fc:	48 83 c0 01          	add    rax,0x1
  21b200:	48 83 d6 00          	adc    rsi,0x0
        if ((a & (u128(1) << LDBL_MANT_DIG)) != 0) {
  21b204:	48 0f ba e6 33       	bt     rsi,0x33
  21b209:	72 0b                	jb     21b216 <__floatuntitf+0x106>
  21b20b:	48 0f ac f0 02       	shrd   rax,rsi,0x2
  21b210:	48 c1 ee 02          	shr    rsi,0x2
  21b214:	eb 0c                	jmp    21b222 <__floatuntitf+0x112>
            a >>= 1;
  21b216:	48 0f ac f0 03       	shrd   rax,rsi,0x3
  21b21b:	48 c1 ee 03          	shr    rsi,0x3
  21b21f:	44 89 ca             	mov    edx,r9d
        // a is now rounded to LDBL_MANT_DIG bits
    }

    const high: u128 = (@intCast(u64, (e + 16383)) << 48) | // exponent
  21b222:	81 c2 ff 3f 00 00    	add    edx,0x3fff
  21b228:	48 c1 e2 30          	shl    rdx,0x30
        (@truncate(u64, a >> 64) & 0x0000ffffffffffff); // mantissa-high
  21b22c:	b1 30                	mov    cl,0x30
  21b22e:	c4 e2 f0 f5 ce       	bzhi   rcx,rsi,rcx
    const low = @truncate(u64, a); // mantissa-low

    return @bitCast(f128, low | (high << 64));
  21b233:	48 89 44 24 e8       	mov    QWORD PTR [rsp-0x18],rax
    const high: u128 = (@intCast(u64, (e + 16383)) << 48) | // exponent
  21b238:	48 09 d1             	or     rcx,rdx
    return @bitCast(f128, low | (high << 64));
  21b23b:	48 89 4c 24 f0       	mov    QWORD PTR [rsp-0x10],rcx
  21b240:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
  21b245:	5b                   	pop    rbx
  21b246:	41 5e                	pop    r14
  21b248:	c3                   	ret    
  21b249:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021b250 <__floatuntidf>:
const DBL_MANT_DIG = 53;

pub extern fn __floatuntidf(arg: u128) f64 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21b250:	48 89 f8             	mov    rax,rdi
  21b253:	48 09 f0             	or     rax,rsi
  21b256:	0f 84 a0 00 00 00    	je     21b2fc <__floatuntidf+0xac>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21b25c:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21b261:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21b266:	83 c1 40             	add    ecx,0x40
  21b269:	48 85 f6             	test   rsi,rsi
  21b26c:	0f 45 c8             	cmovne ecx,eax
  21b26f:	ba 80 00 00 00       	mov    edx,0x80
  21b274:	29 ca                	sub    edx,ecx
    var e: i32 = sd - 1; // exponent
  21b276:	41 bb 7f 00 00 00    	mov    r11d,0x7f
  21b27c:	41 29 cb             	sub    r11d,ecx
    if (sd > DBL_MANT_DIG) {
  21b27f:	83 fa 36             	cmp    edx,0x36
  21b282:	7c 7d                	jl     21b301 <__floatuntidf+0xb1>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit DBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit DBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21b284:	0f 84 97 00 00 00    	je     21b321 <__floatuntidf+0xd1>
  21b28a:	83 fa 37             	cmp    edx,0x37
  21b28d:	0f 84 96 00 00 00    	je     21b329 <__floatuntidf+0xd9>
            DBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            DBL_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  21b293:	41 56                	push   r14
  21b295:	53                   	push   rbx
  21b296:	41 b8 37 00 00 00    	mov    r8d,0x37
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  21b29c:	8d 4a 49             	lea    ecx,[rdx+0x49]
  21b29f:	83 e1 7f             	and    ecx,0x7f
  21b2a2:	49 89 f9             	mov    r9,rdi
  21b2a5:	49 0f ad f1          	shrd   r9,rsi,cl
                const shift_amt = @bitCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  21b2a9:	41 29 d0             	sub    r8d,edx
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  21b2ac:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  21b2b1:	45 31 f6             	xor    r14d,r14d
  21b2b4:	f6 c1 40             	test   cl,0x40
  21b2b7:	4d 0f 45 ca          	cmovne r9,r10
  21b2bb:	4d 0f 45 d6          	cmovne r10,r14
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  21b2bf:	41 83 e0 7f          	and    r8d,0x7f
  21b2c3:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21b2ca:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  21b2cf:	44 89 c1             	mov    ecx,r8d
  21b2d2:	48 0f ad db          	shrd   rbx,rbx,cl
  21b2d6:	41 f6 c0 40          	test   r8b,0x40
  21b2da:	48 0f 45 d8          	cmovne rbx,rax
  21b2de:	49 0f 45 c6          	cmovne rax,r14
  21b2e2:	48 21 fb             	and    rbx,rdi
  21b2e5:	48 21 f0             	and    rax,rsi
  21b2e8:	31 ff                	xor    edi,edi
  21b2ea:	48 09 d8             	or     rax,rbx
  21b2ed:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  21b2f1:	4c 09 cf             	or     rdi,r9
  21b2f4:	4c 89 d6             	mov    rsi,r10
        switch (sd) {
  21b2f7:	5b                   	pop    rbx
  21b2f8:	41 5e                	pop    r14
  21b2fa:	eb 2d                	jmp    21b329 <__floatuntidf+0xd9>
        return 0.0;
  21b2fc:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21b300:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to DBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, DBL_MANT_DIG - sd);
  21b301:	b8 35 00 00 00       	mov    eax,0x35
  21b306:	29 d0                	sub    eax,edx
  21b308:	83 e0 7f             	and    eax,0x7f
  21b30b:	c4 e2 f9 f7 d7       	shlx   rdx,rdi,rax
  21b310:	31 c9                	xor    ecx,ecx
  21b312:	a8 40                	test   al,0x40
  21b314:	48 0f 44 ca          	cmove  rcx,rdx
    if (sd > DBL_MANT_DIG) {
  21b318:	48 89 ce             	mov    rsi,rcx
  21b31b:	48 c1 ee 20          	shr    rsi,0x20
  21b31f:	eb 48                	jmp    21b369 <__floatuntidf+0x119>
                a <<= 1;
  21b321:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  21b326:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21b329:	b8 02 01 00 00       	mov    eax,0x102
  21b32e:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  21b333:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  21b336:	48 83 c0 01          	add    rax,0x1
  21b33a:	48 83 d6 00          	adc    rsi,0x0
            a >>= 1;
  21b33e:	48 89 f1             	mov    rcx,rsi
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  21b341:	48 0f ba e0 37       	bt     rax,0x37
  21b346:	72 10                	jb     21b358 <__floatuntidf+0x108>
  21b348:	48 0f a4 c1 3e       	shld   rcx,rax,0x3e
  21b34d:	48 c1 e8 22          	shr    rax,0x22
  21b351:	c1 e6 1e             	shl    esi,0x1e
  21b354:	09 c6                	or     esi,eax
  21b356:	eb 11                	jmp    21b369 <__floatuntidf+0x119>
            a >>= 1;
  21b358:	48 0f a4 c1 3d       	shld   rcx,rax,0x3d
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  21b35d:	48 c1 e8 23          	shr    rax,0x23
  21b361:	c1 e6 1d             	shl    esi,0x1d
  21b364:	09 c6                	or     esi,eax
  21b366:	41 89 d3             	mov    r11d,edx
        // a is now rounded to DBL_MANT_DIG bits
    }

    const high: u64 = @bitCast(u32, (e + 1023) << 20) | // exponent
  21b369:	41 c1 e3 14          	shl    r11d,0x14
        (@truncate(u32, a >> 32) & 0x000FFFFF); // mantissa-high
  21b36d:	81 e6 ff ff 0f 00    	and    esi,0xfffff
    const high: u64 = @bitCast(u32, (e + 1023) << 20) | // exponent
  21b373:	42 8d 04 1e          	lea    eax,[rsi+r11*1]
  21b377:	05 00 00 f0 3f       	add    eax,0x3ff00000
    const low = @truncate(u32, a); // mantissa-low

    return @bitCast(f64, low | (high << 32));
  21b37c:	48 c1 e0 20          	shl    rax,0x20
  21b380:	89 c9                	mov    ecx,ecx
  21b382:	48 09 c1             	or     rcx,rax
  21b385:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
  21b38a:	c3                   	ret    
  21b38b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000021b390 <__floatuntisf>:
const FLT_MANT_DIG = 24;

pub extern fn __floatuntisf(arg: u128) f32 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21b390:	48 89 f8             	mov    rax,rdi
  21b393:	48 09 f0             	or     rax,rsi
  21b396:	0f 84 93 00 00 00    	je     21b42f <__floatuntisf+0x9f>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21b39c:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21b3a1:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21b3a6:	83 c1 40             	add    ecx,0x40
  21b3a9:	48 85 f6             	test   rsi,rsi
  21b3ac:	0f 45 c8             	cmovne ecx,eax
  21b3af:	ba 80 00 00 00       	mov    edx,0x80
  21b3b4:	29 ca                	sub    edx,ecx
    var e: i32 = sd - 1; // exponent
  21b3b6:	b8 7f 00 00 00       	mov    eax,0x7f
  21b3bb:	29 c8                	sub    eax,ecx
    if (sd > FLT_MANT_DIG) {
  21b3bd:	83 fa 19             	cmp    edx,0x19
  21b3c0:	7c 72                	jl     21b434 <__floatuntisf+0xa4>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit FLT_MANT_DIG-1 bits to the right of 1
        //  Q = bit FLT_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21b3c2:	0f 84 87 00 00 00    	je     21b44f <__floatuntisf+0xbf>
  21b3c8:	83 fa 1a             	cmp    edx,0x1a
  21b3cb:	0f 84 81 00 00 00    	je     21b452 <__floatuntisf+0xc2>
            },
            FLT_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  21b3d1:	53                   	push   rbx
  21b3d2:	8d 4a 66             	lea    ecx,[rdx+0x66]
  21b3d5:	83 e1 7f             	and    ecx,0x7f
  21b3d8:	49 89 f9             	mov    r9,rdi
  21b3db:	49 0f ad f1          	shrd   r9,rsi,cl
                const shift_amt = @bitCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
  21b3df:	41 b8 1a 00 00 00    	mov    r8d,0x1a
  21b3e5:	41 29 d0             	sub    r8d,edx
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  21b3e8:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  21b3ed:	45 31 db             	xor    r11d,r11d
  21b3f0:	f6 c1 40             	test   cl,0x40
  21b3f3:	4d 0f 44 d1          	cmove  r10,r9
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  21b3f7:	41 83 e0 7f          	and    r8d,0x7f
  21b3fb:	49 c7 c1 ff ff ff ff 	mov    r9,0xffffffffffffffff
  21b402:	c4 c2 bb f7 d9       	shrx   rbx,r9,r8
  21b407:	44 89 c1             	mov    ecx,r8d
  21b40a:	4d 0f ad c9          	shrd   r9,r9,cl
  21b40e:	41 f6 c0 40          	test   r8b,0x40
  21b412:	4c 0f 45 cb          	cmovne r9,rbx
  21b416:	4c 0f 44 db          	cmove  r11,rbx
  21b41a:	49 21 f9             	and    r9,rdi
  21b41d:	49 21 f3             	and    r11,rsi
  21b420:	31 ff                	xor    edi,edi
  21b422:	4d 09 cb             	or     r11,r9
  21b425:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  21b429:	4c 09 d7             	or     rdi,r10
        switch (sd) {
  21b42c:	5b                   	pop    rbx
  21b42d:	eb 23                	jmp    21b452 <__floatuntisf+0xc2>
        return 0.0;
  21b42f:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21b433:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to FLT_MANT_DIG bits
    } else {
        a <<= @intCast(u7, FLT_MANT_DIG - sd);
  21b434:	be 18 00 00 00       	mov    esi,0x18
  21b439:	29 d6                	sub    esi,edx
  21b43b:	83 e6 7f             	and    esi,0x7f
  21b43e:	c4 e2 c9 f7 d7       	shlx   rdx,rdi,rsi
  21b443:	31 c9                	xor    ecx,ecx
  21b445:	40 f6 c6 40          	test   sil,0x40
  21b449:	48 0f 44 ca          	cmove  rcx,rdx
  21b44d:	eb 28                	jmp    21b477 <__floatuntisf+0xe7>
                a <<= 1;
  21b44f:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21b452:	b9 02 01 00 00       	mov    ecx,0x102
  21b457:	c4 e2 70 f7 cf       	bextr  ecx,edi,ecx
  21b45c:	48 09 f9             	or     rcx,rdi
        a += 1; // round - this step may add a significant bit
  21b45f:	48 83 c1 01          	add    rcx,0x1
        if ((a & (u128(1) << FLT_MANT_DIG)) != 0) {
  21b463:	f7 c1 00 00 00 04    	test   ecx,0x4000000
  21b469:	75 06                	jne    21b471 <__floatuntisf+0xe1>
  21b46b:	48 c1 e9 02          	shr    rcx,0x2
  21b46f:	eb 06                	jmp    21b477 <__floatuntisf+0xe7>
            a >>= 1;
  21b471:	48 c1 e9 03          	shr    rcx,0x3
  21b475:	89 d0                	mov    eax,edx
        // a is now rounded to FLT_MANT_DIG bits
    }

    const high = @bitCast(u32, (e + 127) << 23); // exponent
  21b477:	c1 e0 17             	shl    eax,0x17
    const low = @truncate(u32, a) & 0x007fffff; // mantissa
  21b47a:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff

    return @bitCast(f32, high | low);
  21b480:	8d 04 08             	lea    eax,[rax+rcx*1]
  21b483:	05 00 00 80 3f       	add    eax,0x3f800000
  21b488:	c5 f9 6e c0          	vmovd  xmm0,eax
  21b48c:	c3                   	ret    
  21b48d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000021b490 <__extenddftf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21b490:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21b495:	b0 3f                	mov    al,0x3f
  21b497:	c4 e2 f8 f5 f1       	bzhi   rsi,rcx,rax
  21b49c:	48 b8 ff ff ff ff ff 	movabs rax,0x7fffffffffffffff
  21b4a3:	ff ff 7f 
    const sign: src_rep_t = aRep & srcSignMask;
  21b4a6:	48 83 c0 01          	add    rax,0x1
  21b4aa:	48 21 c8             	and    rax,rcx
    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  21b4ad:	48 ba 00 00 00 00 00 	movabs rdx,0xfff0000000000000
  21b4b4:	00 f0 ff 
  21b4b7:	48 01 f2             	add    rdx,rsi
  21b4ba:	48 c1 ea 35          	shr    rdx,0x35
  21b4be:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  21b4c5:	77 1a                	ja     21b4e1 <__extenddftf2+0x51>
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  21b4c7:	48 89 f2             	mov    rdx,rsi
  21b4ca:	48 c1 e2 3c          	shl    rdx,0x3c
  21b4ce:	48 c1 ee 04          	shr    rsi,0x4
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  21b4d2:	48 bf 00 00 00 00 00 	movabs rdi,0x3c00000000000000
  21b4d9:	00 00 3c 
  21b4dc:	48 01 f7             	add    rdi,rsi
  21b4df:	eb 7a                	jmp    21b55b <__extenddftf2+0xcb>
    } else if (aAbs >= srcInfinity) {
  21b4e1:	48 89 f2             	mov    rdx,rsi
  21b4e4:	48 c1 ea 34          	shr    rdx,0x34
  21b4e8:	48 81 fa ff 07 00 00 	cmp    rdx,0x7ff
  21b4ef:	72 17                	jb     21b508 <__extenddftf2+0x78>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  21b4f1:	48 89 ca             	mov    rdx,rcx
  21b4f4:	48 c1 e2 3c          	shl    rdx,0x3c
  21b4f8:	48 c1 e9 04          	shr    rcx,0x4
  21b4fc:	48 bf 00 00 00 00 00 	movabs rdi,0x7fff000000000000
  21b503:	00 ff 7f 
  21b506:	eb 4a                	jmp    21b552 <__extenddftf2+0xc2>
    } else if (aAbs != 0) {
  21b508:	48 85 f6             	test   rsi,rsi
  21b50b:	74 4a                	je     21b557 <__extenddftf2+0xc7>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  21b50d:	f3 48 0f bd ce       	lzcnt  rcx,rsi
  21b512:	44 8d 41 75          	lea    r8d,[rcx+0x75]
  21b516:	41 83 e0 7f          	and    r8d,0x7f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  21b51a:	83 c1 31             	add    ecx,0x31
  21b51d:	83 e1 7f             	and    ecx,0x7f
  21b520:	45 31 c9             	xor    r9d,r9d
  21b523:	31 ff                	xor    edi,edi
  21b525:	48 0f a5 f7          	shld   rdi,rsi,cl
  21b529:	c4 e2 f1 f7 d6       	shlx   rdx,rsi,rcx
  21b52e:	f6 c1 40             	test   cl,0x40
  21b531:	48 0f 45 fa          	cmovne rdi,rdx
  21b535:	49 0f 45 d1          	cmovne rdx,r9
        absResult ^= dstMinNormal;
  21b539:	48 b9 00 00 00 00 00 	movabs rcx,0x1000000000000
  21b540:	00 01 00 
  21b543:	48 31 f9             	xor    rcx,rdi
        const resultExponent: u32 = dstExpBias - srcExpBias - scale + 1;
  21b546:	bf 01 3c 00 00       	mov    edi,0x3c01
  21b54b:	44 29 c7             	sub    edi,r8d
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  21b54e:	48 c1 e7 30          	shl    rdi,0x30
  21b552:	48 09 cf             	or     rdi,rcx
  21b555:	eb 04                	jmp    21b55b <__extenddftf2+0xcb>
  21b557:	31 d2                	xor    edx,edx
  21b559:	31 ff                	xor    edi,edi
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21b55b:	48 89 54 24 e8       	mov    QWORD PTR [rsp-0x18],rdx
  21b560:	48 09 c7             	or     rdi,rax
  21b563:	48 89 7c 24 f0       	mov    QWORD PTR [rsp-0x10],rdi
  21b568:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
    return extendXfYf2(f128, f64, a);
  21b56d:	c3                   	ret    
  21b56e:	66 90                	xchg   ax,ax

000000000021b570 <__extendsftf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21b570:	c5 f9 7e c2          	vmovd  edx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21b574:	89 d1                	mov    ecx,edx
  21b576:	81 e1 ff ff ff 7f    	and    ecx,0x7fffffff
    const sign: src_rep_t = aRep & srcSignMask;
  21b57c:	89 d0                	mov    eax,edx
  21b57e:	25 00 00 00 80       	and    eax,0x80000000
    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  21b583:	8d b1 00 00 80 ff    	lea    esi,[rcx-0x800000]
  21b589:	81 fe ff ff ff 7e    	cmp    esi,0x7effffff
  21b58f:	77 17                	ja     21b5a8 <__extendsftf2+0x38>
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  21b591:	89 ca                	mov    edx,ecx
  21b593:	48 c1 e2 19          	shl    rdx,0x19
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  21b597:	48 b9 00 00 00 00 00 	movabs rcx,0x3f80000000000000
  21b59e:	00 80 3f 
  21b5a1:	48 01 d1             	add    rcx,rdx
  21b5a4:	31 d2                	xor    edx,edx
  21b5a6:	eb 6f                	jmp    21b617 <__extendsftf2+0xa7>
    } else if (aAbs >= srcInfinity) {
  21b5a8:	81 f9 00 00 80 7f    	cmp    ecx,0x7f800000
  21b5ae:	72 17                	jb     21b5c7 <__extendsftf2+0x57>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  21b5b0:	89 d2                	mov    edx,edx
  21b5b2:	48 c1 e2 19          	shl    rdx,0x19
  21b5b6:	48 b9 00 00 00 00 00 	movabs rcx,0x7fff000000000000
  21b5bd:	00 ff 7f 
  21b5c0:	48 09 d1             	or     rcx,rdx
  21b5c3:	31 d2                	xor    edx,edx
  21b5c5:	eb 50                	jmp    21b617 <__extendsftf2+0xa7>
    } else if (aAbs != 0) {
  21b5c7:	85 c9                	test   ecx,ecx
  21b5c9:	74 48                	je     21b613 <__extendsftf2+0xa3>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  21b5cb:	f3 0f bd f1          	lzcnt  esi,ecx
  21b5cf:	83 c6 38             	add    esi,0x38
  21b5d2:	83 e6 3f             	and    esi,0x3f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  21b5d5:	89 ca                	mov    edx,ecx
  21b5d7:	8d 4e 59             	lea    ecx,[rsi+0x59]
  21b5da:	83 e1 7f             	and    ecx,0x7f
  21b5dd:	45 31 c0             	xor    r8d,r8d
  21b5e0:	31 ff                	xor    edi,edi
  21b5e2:	48 0f a5 d7          	shld   rdi,rdx,cl
  21b5e6:	c4 e2 f1 f7 d2       	shlx   rdx,rdx,rcx
  21b5eb:	f6 c1 40             	test   cl,0x40
  21b5ee:	48 0f 45 fa          	cmovne rdi,rdx
  21b5f2:	49 0f 45 d0          	cmovne rdx,r8
        absResult ^= dstMinNormal;
  21b5f6:	49 b8 00 00 00 00 00 	movabs r8,0x1000000000000
  21b5fd:	00 01 00 
  21b600:	49 31 f8             	xor    r8,rdi
        const resultExponent: u32 = dstExpBias - srcExpBias - scale + 1;
  21b603:	b9 81 3f 00 00       	mov    ecx,0x3f81
  21b608:	29 f1                	sub    ecx,esi
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  21b60a:	48 c1 e1 30          	shl    rcx,0x30
  21b60e:	4c 09 c1             	or     rcx,r8
  21b611:	eb 04                	jmp    21b617 <__extendsftf2+0xa7>
  21b613:	31 d2                	xor    edx,edx
  21b615:	31 c9                	xor    ecx,ecx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21b617:	48 c1 e0 20          	shl    rax,0x20
  21b61b:	48 89 54 24 e8       	mov    QWORD PTR [rsp-0x18],rdx
  21b620:	48 09 c8             	or     rax,rcx
  21b623:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  21b628:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
    return extendXfYf2(f128, f32, a);
  21b62d:	c3                   	ret    
  21b62e:	66 90                	xchg   ax,ax

000000000021b630 <__trunctfdf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21b630:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  21b636:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  21b63b:	48 8b 54 24 f0       	mov    rdx,QWORD PTR [rsp-0x10]
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21b640:	b0 3f                	mov    al,0x3f
  21b642:	c4 e2 f8 f5 ca       	bzhi   rcx,rdx,rax
    if (aAbs -% underflow < aAbs -% overflow) {
  21b647:	48 b8 00 00 00 00 00 	movabs rax,0xc3ff000000000000
  21b64e:	00 ff c3 
  21b651:	48 01 c8             	add    rax,rcx
  21b654:	48 bf 00 00 00 00 00 	movabs rdi,0xbc01000000000000
  21b65b:	00 01 bc 
  21b65e:	48 01 cf             	add    rdi,rcx
  21b661:	48 39 f8             	cmp    rax,rdi
  21b664:	73 35                	jae    21b69b <__trunctfdf2+0x6b>
  21b666:	48 b8 00 00 00 00 00 	movabs rax,0x4000000000000000
  21b66d:	00 00 40 
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  21b670:	48 89 d1             	mov    rcx,rdx
  21b673:	48 0f a4 f1 04       	shld   rcx,rsi,0x4
        const roundBits: src_rep_t = aAbs & roundMask;
  21b678:	40 b7 3c             	mov    dil,0x3c
  21b67b:	c4 e2 c0 f5 f6       	bzhi   rsi,rsi,rdi
        if (roundBits > halfway) {
  21b680:	48 bf 01 00 00 00 00 	movabs rdi,0x800000000000001
  21b687:	00 00 08 
  21b68a:	48 39 fe             	cmp    rsi,rdi
  21b68d:	72 40                	jb     21b6cf <__trunctfdf2+0x9f>
            absResult += 1;
  21b68f:	48 01 c1             	add    rcx,rax
  21b692:	48 83 c1 01          	add    rcx,0x1
  21b696:	e9 0f 01 00 00       	jmp    21b7aa <__trunctfdf2+0x17a>
    } else if (aAbs > srcInfinity) {
  21b69b:	48 83 fe 01          	cmp    rsi,0x1
  21b69f:	48 b8 00 00 00 00 00 	movabs rax,0x7fff000000000000
  21b6a6:	00 ff 7f 
  21b6a9:	48 89 cf             	mov    rdi,rcx
  21b6ac:	48 19 c7             	sbb    rdi,rax
  21b6af:	72 55                	jb     21b706 <__trunctfdf2+0xd6>
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  21b6b1:	48 0f ac d6 3c       	shrd   rsi,rdx,0x3c
  21b6b6:	b0 33                	mov    al,0x33
  21b6b8:	c4 e2 f8 f5 c6       	bzhi   rax,rsi,rax
  21b6bd:	48 b9 00 00 00 00 00 	movabs rcx,0x7ff8000000000000
  21b6c4:	00 f8 7f 
  21b6c7:	48 09 c1             	or     rcx,rax
  21b6ca:	e9 db 00 00 00       	jmp    21b7aa <__trunctfdf2+0x17a>
  21b6cf:	48 01 c1             	add    rcx,rax
        } else if (roundBits == halfway) {
  21b6d2:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  21b6d7:	48 b8 00 00 00 00 00 	movabs rax,0x800000000000000
  21b6de:	00 00 08 
  21b6e1:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  21b6e6:	c5 f9 74 c1          	vpcmpeqb xmm0,xmm0,xmm1
  21b6ea:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21b6ee:	3d ff ff 00 00       	cmp    eax,0xffff
  21b6f3:	0f 85 b1 00 00 00    	jne    21b7aa <__trunctfdf2+0x17a>
  21b6f9:	89 c8                	mov    eax,ecx
  21b6fb:	83 e0 01             	and    eax,0x1
  21b6fe:	48 01 c1             	add    rcx,rax
  21b701:	e9 a4 00 00 00       	jmp    21b7aa <__trunctfdf2+0x17a>
    } else if (aAbs >= overflow) {
  21b706:	48 c1 e9 30          	shr    rcx,0x30
  21b70a:	48 81 f9 fe 43 00 00 	cmp    rcx,0x43fe
  21b711:	76 0f                	jbe    21b722 <__trunctfdf2+0xf2>
  21b713:	48 b9 00 00 00 00 00 	movabs rcx,0x7ff0000000000000
  21b71a:	00 f0 7f 
  21b71d:	e9 88 00 00 00       	jmp    21b7aa <__trunctfdf2+0x17a>
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21b722:	b8 00 3c 00 00       	mov    eax,0x3c00
  21b727:	29 c8                	sub    eax,ecx
        if (shift > srcSigBits) {
  21b729:	83 f8 6f             	cmp    eax,0x6f
  21b72c:	76 04                	jbe    21b732 <__trunctfdf2+0x102>
  21b72e:	31 c9                	xor    ecx,ecx
  21b730:	eb 78                	jmp    21b7aa <__trunctfdf2+0x17a>
  21b732:	b1 30                	mov    cl,0x30
  21b734:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
  21b739:	49 b8 00 00 00 00 00 	movabs r8,0x1000000000000
  21b740:	00 01 00 
  21b743:	49 09 c8             	or     r8,rcx
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  21b746:	b9 7f 00 00 00       	mov    ecx,0x7f
  21b74b:	29 c1                	sub    ecx,eax
  21b74d:	83 e1 7f             	and    ecx,0x7f
  21b750:	4c 89 c7             	mov    rdi,r8
  21b753:	48 0f a5 f7          	shld   rdi,rsi,cl
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21b757:	83 c0 01             	add    eax,0x1
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  21b75a:	c4 62 f1 f7 ce       	shlx   r9,rsi,rcx
  21b75f:	45 31 d2             	xor    r10d,r10d
  21b762:	f6 c1 40             	test   cl,0x40
  21b765:	49 0f 45 f9          	cmovne rdi,r9
  21b769:	4d 0f 45 ca          	cmovne r9,r10
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  21b76d:	83 e0 7f             	and    eax,0x7f
  21b770:	89 c1                	mov    ecx,eax
  21b772:	4c 0f ad c6          	shrd   rsi,r8,cl
  21b776:	c4 c2 fb f7 c8       	shrx   rcx,r8,rax
  21b77b:	a8 40                	test   al,0x40
  21b77d:	48 0f 45 f1          	cmovne rsi,rcx
  21b781:	49 0f 45 ca          	cmovne rcx,r10
  21b785:	4c 09 ce             	or     rsi,r9
  21b788:	48 09 f9             	or     rcx,rdi
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  21b78b:	48 0f a4 f1 04       	shld   rcx,rsi,0x4
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  21b790:	b0 3c                	mov    al,0x3c
  21b792:	c4 e2 f8 f5 c6       	bzhi   rax,rsi,rax
            if (roundBits > halfway) {
  21b797:	48 be 01 00 00 00 00 	movabs rsi,0x800000000000001
  21b79e:	00 00 08 
  21b7a1:	48 39 f0             	cmp    rax,rsi
  21b7a4:	72 1a                	jb     21b7c0 <__trunctfdf2+0x190>
                absResult += 1;
  21b7a6:	48 83 c1 01          	add    rcx,0x1
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  21b7aa:	48 b8 00 00 00 00 00 	movabs rax,0x8000000000000000
  21b7b1:	00 00 80 
  21b7b4:	48 21 c2             	and    rdx,rax
  21b7b7:	48 09 ca             	or     rdx,rcx
    return @bitCast(dst_t, result);
  21b7ba:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
    return truncXfYf2(f64, f128, a);
  21b7bf:	c3                   	ret    
            } else if (roundBits == halfway) {
  21b7c0:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  21b7c5:	e9 0d ff ff ff       	jmp    21b6d7 <__trunctfdf2+0xa7>
  21b7ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000021b7d0 <__trunctfsf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21b7d0:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  21b7d6:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  21b7db:	48 8b 54 24 f0       	mov    rdx,QWORD PTR [rsp-0x10]
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21b7e0:	b0 3f                	mov    al,0x3f
  21b7e2:	c4 e2 f8 f5 fa       	bzhi   rdi,rdx,rax
    if (aAbs -% underflow < aAbs -% overflow) {
  21b7e7:	48 b8 00 00 00 00 00 	movabs rax,0xc07f000000000000
  21b7ee:	00 7f c0 
  21b7f1:	48 01 f8             	add    rax,rdi
  21b7f4:	48 b9 00 00 00 00 00 	movabs rcx,0xbf81000000000000
  21b7fb:	00 81 bf 
  21b7fe:	48 01 f9             	add    rcx,rdi
  21b801:	48 39 c8             	cmp    rax,rcx
  21b804:	73 29                	jae    21b82f <__trunctfsf2+0x5f>
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  21b806:	48 89 d1             	mov    rcx,rdx
  21b809:	48 c1 e9 19          	shr    rcx,0x19
        const roundBits: src_rep_t = aAbs & roundMask;
  21b80d:	89 d0                	mov    eax,edx
  21b80f:	25 ff ff ff 01       	and    eax,0x1ffffff
        if (roundBits > halfway) {
  21b814:	48 83 fe 01          	cmp    rsi,0x1
  21b818:	48 89 c7             	mov    rdi,rax
  21b81b:	48 81 df 00 00 00 01 	sbb    rdi,0x1000000
  21b822:	72 39                	jb     21b85d <__trunctfsf2+0x8d>
            absResult += 1;
  21b824:	81 c1 01 00 00 40    	add    ecx,0x40000001
  21b82a:	e9 0e 01 00 00       	jmp    21b93d <__trunctfsf2+0x16d>
    } else if (aAbs > srcInfinity) {
  21b82f:	48 83 fe 01          	cmp    rsi,0x1
  21b833:	48 b8 00 00 00 00 00 	movabs rax,0x7fff000000000000
  21b83a:	00 ff 7f 
  21b83d:	48 89 f9             	mov    rcx,rdi
  21b840:	48 19 c1             	sbb    rcx,rax
  21b843:	72 5c                	jb     21b8a1 <__trunctfsf2+0xd1>
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  21b845:	48 89 d1             	mov    rcx,rdx
  21b848:	48 c1 e9 19          	shr    rcx,0x19
  21b84c:	81 e1 ff ff 3f 00    	and    ecx,0x3fffff
  21b852:	81 c9 00 00 c0 7f    	or     ecx,0x7fc00000
  21b858:	e9 e0 00 00 00       	jmp    21b93d <__trunctfsf2+0x16d>
  21b85d:	81 c1 00 00 00 40    	add    ecx,0x40000000
        } else if (roundBits == halfway) {
  21b863:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  21b868:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  21b86d:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  21b871:	b8 00 00 00 01       	mov    eax,0x1000000
  21b876:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  21b87b:	c5 f1 73 f9 08       	vpslldq xmm1,xmm1,0x8
  21b880:	c5 f9 74 c1          	vpcmpeqb xmm0,xmm0,xmm1
  21b884:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21b888:	3d ff ff 00 00       	cmp    eax,0xffff
  21b88d:	0f 85 aa 00 00 00    	jne    21b93d <__trunctfsf2+0x16d>
  21b893:	89 c8                	mov    eax,ecx
  21b895:	83 e0 01             	and    eax,0x1
  21b898:	01 c8                	add    eax,ecx
  21b89a:	89 c1                	mov    ecx,eax
  21b89c:	e9 9c 00 00 00       	jmp    21b93d <__trunctfsf2+0x16d>
    } else if (aAbs >= overflow) {
  21b8a1:	48 c1 ef 30          	shr    rdi,0x30
  21b8a5:	b9 00 00 80 7f       	mov    ecx,0x7f800000
  21b8aa:	48 81 ff 7e 40 00 00 	cmp    rdi,0x407e
  21b8b1:	0f 87 86 00 00 00    	ja     21b93d <__trunctfsf2+0x16d>
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21b8b7:	b8 80 3f 00 00       	mov    eax,0x3f80
  21b8bc:	29 f8                	sub    eax,edi
  21b8be:	31 c9                	xor    ecx,ecx
        if (shift > srcSigBits) {
  21b8c0:	83 f8 6f             	cmp    eax,0x6f
  21b8c3:	77 78                	ja     21b93d <__trunctfsf2+0x16d>
  21b8c5:	b1 30                	mov    cl,0x30
  21b8c7:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
  21b8cc:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  21b8d3:	00 01 00 
  21b8d6:	48 09 cf             	or     rdi,rcx
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  21b8d9:	b9 7f 00 00 00       	mov    ecx,0x7f
  21b8de:	29 c1                	sub    ecx,eax
  21b8e0:	83 e1 7f             	and    ecx,0x7f
  21b8e3:	49 89 f8             	mov    r8,rdi
  21b8e6:	49 0f a5 f0          	shld   r8,rsi,cl
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21b8ea:	83 c0 01             	add    eax,0x1
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  21b8ed:	c4 62 f1 f7 ce       	shlx   r9,rsi,rcx
  21b8f2:	45 31 d2             	xor    r10d,r10d
  21b8f5:	f6 c1 40             	test   cl,0x40
  21b8f8:	4d 0f 45 c1          	cmovne r8,r9
  21b8fc:	4d 0f 45 ca          	cmovne r9,r10
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  21b900:	83 e0 7f             	and    eax,0x7f
  21b903:	89 c1                	mov    ecx,eax
  21b905:	48 0f ad fe          	shrd   rsi,rdi,cl
  21b909:	c4 e2 fb f7 ff       	shrx   rdi,rdi,rax
  21b90e:	a8 40                	test   al,0x40
  21b910:	48 0f 45 f7          	cmovne rsi,rdi
  21b914:	49 0f 45 fa          	cmovne rdi,r10
  21b918:	4c 09 ce             	or     rsi,r9
  21b91b:	4c 09 c7             	or     rdi,r8
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  21b91e:	48 89 f9             	mov    rcx,rdi
  21b921:	48 c1 e9 19          	shr    rcx,0x19
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  21b925:	81 e7 ff ff ff 01    	and    edi,0x1ffffff
            if (roundBits > halfway) {
  21b92b:	48 83 fe 01          	cmp    rsi,0x1
  21b92f:	48 89 f8             	mov    rax,rdi
  21b932:	48 1d 00 00 00 01    	sbb    rax,0x1000000
  21b938:	72 14                	jb     21b94e <__trunctfsf2+0x17e>
                absResult += 1;
  21b93a:	83 c1 01             	add    ecx,0x1
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  21b93d:	48 c1 ea 20          	shr    rdx,0x20
  21b941:	81 e2 00 00 00 80    	and    edx,0x80000000
  21b947:	09 ca                	or     edx,ecx
    return @bitCast(dst_t, result);
  21b949:	c5 f9 6e c2          	vmovd  xmm0,edx
    return truncXfYf2(f32, f128, a);
  21b94d:	c3                   	ret    
            } else if (roundBits == halfway) {
  21b94e:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  21b953:	c4 e1 f9 6e cf       	vmovq  xmm1,rdi
  21b958:	e9 10 ff ff ff       	jmp    21b86d <__trunctfsf2+0x9d>
  21b95d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000021b960 <__fixunssfsi>:

    const implicitBit = (rep_t(1) << significandBits);
    const significandMask = (implicitBit - 1);

    // Break a into sign, exponent, significand
    const aRep: rep_t = @bitCast(rep_t, a);
  21b960:	c5 f9 7e c1          	vmovd  ecx,xmm0
  21b964:	31 c0                	xor    eax,eax
    const absMask = signBit - 1;
    const aAbs: rep_t = aRep & absMask;

    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21b966:	85 c9                	test   ecx,ecx
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
    const significand: rep_t = (aAbs & significandMask) | implicitBit;

    // If either the value or the exponent is negative, the result is zero.
    if (sign == -1 or exponent < 0) return 0;
  21b968:	78 43                	js     21b9ad <__fixunssfsi+0x4d>
  21b96a:	89 ca                	mov    edx,ecx
  21b96c:	c1 ea 17             	shr    edx,0x17
  21b96f:	0f b6 f2             	movzx  esi,dl
  21b972:	83 fe 7f             	cmp    esi,0x7f
  21b975:	72 36                	jb     21b9ad <__fixunssfsi+0x4d>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21b977:	8d 7e 81             	lea    edi,[rsi-0x7f]
  21b97a:	b8 ff ff ff ff       	mov    eax,0xffffffff

    // If the value is too large for the integer type, saturate.
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21b97f:	83 ff 1f             	cmp    edi,0x1f
  21b982:	77 29                	ja     21b9ad <__fixunssfsi+0x4d>
  21b984:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  21b98a:	81 c9 00 00 80 00    	or     ecx,0x800000

    // If 0 <= exponent < significandBits, right shift to get the result.
    // Otherwise, shift left.
    if (exponent < significandBits) {
  21b990:	81 fe 95 00 00 00    	cmp    esi,0x95
  21b996:	77 0d                	ja     21b9a5 <__fixunssfsi+0x45>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21b998:	b8 16 00 00 00       	mov    eax,0x16
  21b99d:	29 d0                	sub    eax,edx
  21b99f:	c4 e2 7b f7 c1       	shrx   eax,ecx,eax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfsi(a: f32) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u32, a);
  21b9a4:	c3                   	ret    
    } else {
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21b9a5:	83 c2 0a             	add    edx,0xa
  21b9a8:	c4 e2 69 f7 c1       	shlx   eax,ecx,edx
  21b9ad:	c3                   	ret    
  21b9ae:	66 90                	xchg   ax,ax

000000000021b9b0 <__fixunssfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21b9b0:	c5 f9 7e c1          	vmovd  ecx,xmm0
  21b9b4:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21b9b6:	85 c9                	test   ecx,ecx
    if (sign == -1 or exponent < 0) return 0;
  21b9b8:	78 47                	js     21ba01 <__fixunssfdi+0x51>
  21b9ba:	89 ca                	mov    edx,ecx
  21b9bc:	c1 ea 17             	shr    edx,0x17
  21b9bf:	0f b6 f2             	movzx  esi,dl
  21b9c2:	83 fe 7f             	cmp    esi,0x7f
  21b9c5:	72 3a                	jb     21ba01 <__fixunssfdi+0x51>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21b9c7:	8d 7e 81             	lea    edi,[rsi-0x7f]
  21b9ca:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21b9d1:	83 ff 3f             	cmp    edi,0x3f
  21b9d4:	77 2b                	ja     21ba01 <__fixunssfdi+0x51>
  21b9d6:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  21b9dc:	81 c9 00 00 80 00    	or     ecx,0x800000
    if (exponent < significandBits) {
  21b9e2:	81 fe 95 00 00 00    	cmp    esi,0x95
  21b9e8:	77 0d                	ja     21b9f7 <__fixunssfdi+0x47>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21b9ea:	b8 16 00 00 00       	mov    eax,0x16
  21b9ef:	29 d0                	sub    eax,edx
  21b9f1:	c4 e2 7b f7 c1       	shrx   eax,ecx,eax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfdi(a: f32) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u64, a);
  21b9f6:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21b9f7:	89 c8                	mov    eax,ecx
  21b9f9:	83 c2 2a             	add    edx,0x2a
  21b9fc:	c4 e2 e9 f7 c0       	shlx   rax,rax,rdx
  21ba01:	c3                   	ret    
  21ba02:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ba09:	1f 84 00 00 00 00 00 

000000000021ba10 <__fixunssfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21ba10:	c5 f9 7e c6          	vmovd  esi,xmm0
  21ba14:	31 d2                	xor    edx,edx
  21ba16:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21ba1b:	85 f6                	test   esi,esi
    if (sign == -1 or exponent < 0) return 0;
  21ba1d:	78 68                	js     21ba87 <__fixunssfti+0x77>
  21ba1f:	89 f1                	mov    ecx,esi
  21ba21:	c1 e9 17             	shr    ecx,0x17
  21ba24:	0f b6 f9             	movzx  edi,cl
  21ba27:	83 ff 7f             	cmp    edi,0x7f
  21ba2a:	72 5b                	jb     21ba87 <__fixunssfti+0x77>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21ba2c:	44 8d 47 81          	lea    r8d,[rdi-0x7f]
  21ba30:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  21ba37:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21ba3e:	41 83 f8 7f          	cmp    r8d,0x7f
  21ba42:	77 43                	ja     21ba87 <__fixunssfti+0x77>
  21ba44:	81 e6 ff ff 7f 00    	and    esi,0x7fffff
  21ba4a:	81 ce 00 00 80 00    	or     esi,0x800000
    if (exponent < significandBits) {
  21ba50:	81 ff 95 00 00 00    	cmp    edi,0x95
  21ba56:	77 0f                	ja     21ba67 <__fixunssfti+0x57>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21ba58:	b8 16 00 00 00       	mov    eax,0x16
  21ba5d:	29 c8                	sub    eax,ecx
  21ba5f:	c4 e2 7b f7 c6       	shrx   eax,esi,eax
  21ba64:	31 d2                	xor    edx,edx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfti(a: f32) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u128, a);
  21ba66:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21ba67:	89 f0                	mov    eax,esi
  21ba69:	83 c1 6a             	add    ecx,0x6a
  21ba6c:	83 e1 7f             	and    ecx,0x7f
  21ba6f:	31 d2                	xor    edx,edx
  21ba71:	48 0f a5 c2          	shld   rdx,rax,cl
  21ba75:	31 f6                	xor    esi,esi
  21ba77:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  21ba7c:	f6 c1 40             	test   cl,0x40
  21ba7f:	48 0f 45 d0          	cmovne rdx,rax
  21ba83:	48 0f 45 c6          	cmovne rax,rsi
  21ba87:	c3                   	ret    
  21ba88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21ba8f:	00 

000000000021ba90 <__fixunsdfsi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21ba90:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  21ba95:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21ba97:	48 85 d2             	test   rdx,rdx
    if (sign == -1 or exponent < 0) return 0;
  21ba9a:	78 4b                	js     21bae7 <__fixunsdfsi+0x57>
  21ba9c:	48 89 d1             	mov    rcx,rdx
  21ba9f:	48 c1 e9 34          	shr    rcx,0x34
  21baa3:	89 ce                	mov    esi,ecx
  21baa5:	81 e6 ff 07 00 00    	and    esi,0x7ff
  21baab:	81 fe ff 03 00 00    	cmp    esi,0x3ff
  21bab1:	72 34                	jb     21bae7 <__fixunsdfsi+0x57>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bab3:	81 c6 01 fc ff ff    	add    esi,0xfffffc01
  21bab9:	b8 ff ff ff ff       	mov    eax,0xffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21babe:	83 fe 1f             	cmp    esi,0x1f
  21bac1:	77 24                	ja     21bae7 <__fixunsdfsi+0x57>
  21bac3:	b0 34                	mov    al,0x34
  21bac5:	c4 e2 f8 f5 c2       	bzhi   rax,rdx,rax
  21baca:	48 ba ff ff ff ff ff 	movabs rdx,0xfffffffffffff
  21bad1:	ff 0f 00 
  21bad4:	48 83 c2 01          	add    rdx,0x1
  21bad8:	48 09 c2             	or     rdx,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21badb:	b8 33 00 00 00       	mov    eax,0x33
  21bae0:	29 c8                	sub    eax,ecx
  21bae2:	c4 e2 fb f7 c2       	shrx   rax,rdx,rax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfsi(a: f64) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u32, a);
  21bae7:	c3                   	ret    
  21bae8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21baef:	00 

000000000021baf0 <__fixunsdfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21baf0:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  21baf5:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21baf7:	48 85 d2             	test   rdx,rdx
    if (sign == -1 or exponent < 0) return 0;
  21bafa:	78 5e                	js     21bb5a <__fixunsdfdi+0x6a>
  21bafc:	48 89 d1             	mov    rcx,rdx
  21baff:	48 c1 e9 34          	shr    rcx,0x34
  21bb03:	89 ce                	mov    esi,ecx
  21bb05:	81 e6 ff 07 00 00    	and    esi,0x7ff
  21bb0b:	81 fe ff 03 00 00    	cmp    esi,0x3ff
  21bb11:	72 47                	jb     21bb5a <__fixunsdfdi+0x6a>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bb13:	8d be 01 fc ff ff    	lea    edi,[rsi-0x3ff]
  21bb19:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bb20:	83 ff 3f             	cmp    edi,0x3f
  21bb23:	77 35                	ja     21bb5a <__fixunsdfdi+0x6a>
  21bb25:	b0 34                	mov    al,0x34
  21bb27:	c4 e2 f8 f5 d2       	bzhi   rdx,rdx,rax
  21bb2c:	48 b8 ff ff ff ff ff 	movabs rax,0xfffffffffffff
  21bb33:	ff 0f 00 
  21bb36:	48 83 c0 01          	add    rax,0x1
  21bb3a:	48 09 d0             	or     rax,rdx
    if (exponent < significandBits) {
  21bb3d:	81 fe 32 04 00 00    	cmp    esi,0x432
  21bb43:	77 0d                	ja     21bb52 <__fixunsdfdi+0x62>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21bb45:	ba 33 00 00 00       	mov    edx,0x33
  21bb4a:	29 ca                	sub    edx,ecx
  21bb4c:	c4 e2 eb f7 c0       	shrx   rax,rax,rdx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfdi(a: f64) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u64, a);
  21bb51:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21bb52:	83 c1 0d             	add    ecx,0xd
  21bb55:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  21bb5a:	c3                   	ret    
  21bb5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000021bb60 <__fixunsdfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bb60:	c4 e1 f9 7e c6       	vmovq  rsi,xmm0
  21bb65:	31 d2                	xor    edx,edx
  21bb67:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21bb6c:	48 85 f6             	test   rsi,rsi
    if (sign == -1 or exponent < 0) return 0;
  21bb6f:	78 7f                	js     21bbf0 <__fixunsdfti+0x90>
  21bb71:	48 89 f1             	mov    rcx,rsi
  21bb74:	48 c1 e9 34          	shr    rcx,0x34
  21bb78:	89 cf                	mov    edi,ecx
  21bb7a:	81 e7 ff 07 00 00    	and    edi,0x7ff
  21bb80:	81 ff ff 03 00 00    	cmp    edi,0x3ff
  21bb86:	72 68                	jb     21bbf0 <__fixunsdfti+0x90>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bb88:	44 8d 87 01 fc ff ff 	lea    r8d,[rdi-0x3ff]
  21bb8f:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  21bb96:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bb9d:	41 83 f8 7f          	cmp    r8d,0x7f
  21bba1:	77 4d                	ja     21bbf0 <__fixunsdfti+0x90>
  21bba3:	b0 34                	mov    al,0x34
  21bba5:	c4 e2 f8 f5 d6       	bzhi   rdx,rsi,rax
  21bbaa:	48 b8 ff ff ff ff ff 	movabs rax,0xfffffffffffff
  21bbb1:	ff 0f 00 
  21bbb4:	48 83 c0 01          	add    rax,0x1
  21bbb8:	48 09 d0             	or     rax,rdx
    if (exponent < significandBits) {
  21bbbb:	81 ff 32 04 00 00    	cmp    edi,0x432
  21bbc1:	77 0f                	ja     21bbd2 <__fixunsdfti+0x72>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21bbc3:	ba 33 00 00 00       	mov    edx,0x33
  21bbc8:	29 ca                	sub    edx,ecx
  21bbca:	c4 e2 eb f7 c0       	shrx   rax,rax,rdx
  21bbcf:	31 d2                	xor    edx,edx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfti(a: f64) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u128, a);
  21bbd1:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21bbd2:	8d 49 4d             	lea    ecx,[rcx+0x4d]
  21bbd5:	83 e1 7f             	and    ecx,0x7f
  21bbd8:	31 d2                	xor    edx,edx
  21bbda:	48 0f a5 c2          	shld   rdx,rax,cl
  21bbde:	31 f6                	xor    esi,esi
  21bbe0:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  21bbe5:	f6 c1 40             	test   cl,0x40
  21bbe8:	48 0f 45 d0          	cmovne rdx,rax
  21bbec:	48 0f 45 c6          	cmovne rax,rsi
  21bbf0:	c3                   	ret    
  21bbf1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21bbf8:	0f 1f 84 00 00 00 00 
  21bbff:	00 

000000000021bc00 <__fixunstfsi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bc00:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  21bc05:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  21bc0a:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21bc0c:	48 85 c9             	test   rcx,rcx
    if (sign == -1 or exponent < 0) return 0;
  21bc0f:	78 5a                	js     21bc6b <__fixunstfsi+0x6b>
  21bc11:	48 89 ca             	mov    rdx,rcx
  21bc14:	48 c1 ea 30          	shr    rdx,0x30
  21bc18:	89 d6                	mov    esi,edx
  21bc1a:	81 e6 ff 7f 00 00    	and    esi,0x7fff
  21bc20:	81 fe ff 3f 00 00    	cmp    esi,0x3fff
  21bc26:	72 43                	jb     21bc6b <__fixunstfsi+0x6b>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bc28:	81 c6 01 c0 ff ff    	add    esi,0xffffc001
  21bc2e:	b8 ff ff ff ff       	mov    eax,0xffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bc33:	83 fe 1f             	cmp    esi,0x1f
  21bc36:	77 33                	ja     21bc6b <__fixunstfsi+0x6b>
  21bc38:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  21bc3d:	b0 30                	mov    al,0x30
  21bc3f:	c4 e2 f8 f5 c1       	bzhi   rax,rcx,rax
  21bc44:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  21bc4b:	00 01 00 
  21bc4e:	48 09 c7             	or     rdi,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21bc51:	b9 6f 00 00 00       	mov    ecx,0x6f
  21bc56:	29 d1                	sub    ecx,edx
  21bc58:	83 e1 7f             	and    ecx,0x7f
  21bc5b:	48 0f ad fe          	shrd   rsi,rdi,cl
  21bc5f:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  21bc64:	f6 c1 40             	test   cl,0x40
  21bc67:	48 0f 44 c6          	cmove  rax,rsi
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfsi(a: f128) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u32, a);
  21bc6b:	c3                   	ret    
  21bc6c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000021bc70 <__fixunstfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bc70:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  21bc75:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  21bc7a:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21bc7c:	48 85 c9             	test   rcx,rcx
    if (sign == -1 or exponent < 0) return 0;
  21bc7f:	78 5c                	js     21bcdd <__fixunstfdi+0x6d>
  21bc81:	48 89 ca             	mov    rdx,rcx
  21bc84:	48 c1 ea 30          	shr    rdx,0x30
  21bc88:	89 d6                	mov    esi,edx
  21bc8a:	81 e6 ff 7f 00 00    	and    esi,0x7fff
  21bc90:	81 fe ff 3f 00 00    	cmp    esi,0x3fff
  21bc96:	72 45                	jb     21bcdd <__fixunstfdi+0x6d>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bc98:	81 c6 01 c0 ff ff    	add    esi,0xffffc001
  21bc9e:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bca5:	83 fe 3f             	cmp    esi,0x3f
  21bca8:	77 33                	ja     21bcdd <__fixunstfdi+0x6d>
  21bcaa:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  21bcaf:	b0 30                	mov    al,0x30
  21bcb1:	c4 e2 f8 f5 c1       	bzhi   rax,rcx,rax
  21bcb6:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  21bcbd:	00 01 00 
  21bcc0:	48 09 c7             	or     rdi,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21bcc3:	b9 6f 00 00 00       	mov    ecx,0x6f
  21bcc8:	29 d1                	sub    ecx,edx
  21bcca:	83 e1 7f             	and    ecx,0x7f
  21bccd:	48 0f ad fe          	shrd   rsi,rdi,cl
  21bcd1:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  21bcd6:	f6 c1 40             	test   cl,0x40
  21bcd9:	48 0f 44 c6          	cmove  rax,rsi
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfdi(a: f128) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u64, a);
  21bcdd:	c3                   	ret    
  21bcde:	66 90                	xchg   ax,ax

000000000021bce0 <__fixunstfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bce0:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  21bce5:	48 8b 74 24 f0       	mov    rsi,QWORD PTR [rsp-0x10]
  21bcea:	31 d2                	xor    edx,edx
  21bcec:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21bcf1:	48 85 f6             	test   rsi,rsi
    if (sign == -1 or exponent < 0) return 0;
  21bcf4:	0f 88 93 00 00 00    	js     21bd8d <__fixunstfti+0xad>
  21bcfa:	48 89 f1             	mov    rcx,rsi
  21bcfd:	48 c1 e9 30          	shr    rcx,0x30
  21bd01:	89 cf                	mov    edi,ecx
  21bd03:	81 e7 ff 7f 00 00    	and    edi,0x7fff
  21bd09:	81 ff ff 3f 00 00    	cmp    edi,0x3fff
  21bd0f:	72 7c                	jb     21bd8d <__fixunstfti+0xad>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bd11:	44 8d 87 01 c0 ff ff 	lea    r8d,[rdi-0x3fff]
  21bd18:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  21bd1f:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bd26:	41 83 f8 7f          	cmp    r8d,0x7f
  21bd2a:	77 61                	ja     21bd8d <__fixunstfti+0xad>
  21bd2c:	48 8b 44 24 e8       	mov    rax,QWORD PTR [rsp-0x18]
  21bd31:	b2 30                	mov    dl,0x30
  21bd33:	c4 e2 e8 f5 f6       	bzhi   rsi,rsi,rdx
  21bd38:	48 ba 00 00 00 00 00 	movabs rdx,0x1000000000000
  21bd3f:	00 01 00 
  21bd42:	48 09 f2             	or     rdx,rsi
    if (exponent < significandBits) {
  21bd45:	81 ff 6e 40 00 00    	cmp    edi,0x406e
  21bd4b:	77 24                	ja     21bd71 <__fixunstfti+0x91>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21bd4d:	be 6f 00 00 00       	mov    esi,0x6f
  21bd52:	29 ce                	sub    esi,ecx
  21bd54:	83 e6 7f             	and    esi,0x7f
  21bd57:	89 f1                	mov    ecx,esi
  21bd59:	48 0f ad d0          	shrd   rax,rdx,cl
  21bd5d:	c4 e2 cb f7 ca       	shrx   rcx,rdx,rsi
  21bd62:	31 d2                	xor    edx,edx
  21bd64:	40 f6 c6 40          	test   sil,0x40
  21bd68:	48 0f 45 c1          	cmovne rax,rcx
  21bd6c:	48 0f 44 d1          	cmove  rdx,rcx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfti(a: f128) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u128, a);
  21bd70:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21bd71:	83 c1 11             	add    ecx,0x11
  21bd74:	83 e1 7f             	and    ecx,0x7f
  21bd77:	48 0f a5 c2          	shld   rdx,rax,cl
  21bd7b:	c4 e2 f1 f7 f0       	shlx   rsi,rax,rcx
  21bd80:	31 c0                	xor    eax,eax
  21bd82:	f6 c1 40             	test   cl,0x40
  21bd85:	48 0f 45 d6          	cmovne rdx,rsi
  21bd89:	48 0f 44 c6          	cmove  rax,rsi
  21bd8d:	c3                   	ret    
  21bd8e:	66 90                	xchg   ax,ax

000000000021bd90 <__udivsi3>:
    const d = __udivsi3(a, b);
    rem.* = @bitCast(u32, @bitCast(i32, a) -% (@bitCast(i32, d) * @bitCast(i32, b)));
    return d;
}

extern fn __udivsi3(n: u32, d: u32) u32 {
  21bd90:	55                   	push   rbp
  21bd91:	41 56                	push   r14
  21bd93:	53                   	push   rbx
  21bd94:	31 c0                	xor    eax,eax
    @setRuntimeSafety(is_test);

    const n_uword_bits: c_uint = u32.bit_count;
    // special cases
    if (d == 0) return 0; // ?!
    if (n == 0) return 0;
  21bd96:	85 ff                	test   edi,edi
    if (d == 0) return 0; // ?!
  21bd98:	74 19                	je     21bdb3 <__udivsi3+0x23>
  21bd9a:	85 f6                	test   esi,esi
  21bd9c:	74 15                	je     21bdb3 <__udivsi3+0x23>
    var sr = @bitCast(c_uint, c_int(@clz(d)) - c_int(@clz(n)));
  21bd9e:	f3 0f bd ce          	lzcnt  ecx,esi
  21bda2:	f3 0f bd d7          	lzcnt  edx,edi
  21bda6:	89 cb                	mov    ebx,ecx
  21bda8:	29 d3                	sub    ebx,edx
    // 0 <= sr <= n_uword_bits - 1 or sr large
    if (sr > n_uword_bits - 1) {
  21bdaa:	83 fb 1f             	cmp    ebx,0x1f
  21bdad:	77 04                	ja     21bdb3 <__udivsi3+0x23>
        // d > r
        return 0;
    }
    if (sr == n_uword_bits - 1) {
  21bdaf:	75 07                	jne    21bdb8 <__udivsi3+0x28>
  21bdb1:	89 f8                	mov    eax,edi
  21bdb3:	5b                   	pop    rbx
  21bdb4:	41 5e                	pop    r14
  21bdb6:	5d                   	pop    rbp
  21bdb7:	c3                   	ret    
        // d == 1
        return n;
    }
    sr += 1;
  21bdb8:	44 8d 4b 01          	lea    r9d,[rbx+0x1]
    // 1 <= sr <= n_uword_bits - 1
    // Not a special case
    var q: u32 = n << @intCast(u5, n_uword_bits - sr);
  21bdbc:	b8 1f 00 00 00       	mov    eax,0x1f
  21bdc1:	29 d8                	sub    eax,ebx
  21bdc3:	c4 e2 79 f7 c7       	shlx   eax,edi,eax
    var r: u32 = n >> @intCast(u5, sr);
  21bdc8:	c4 e2 33 f7 ff       	shrx   edi,edi,r9d
  21bdcd:	44 8d 46 ff          	lea    r8d,[rsi-0x1]
    var carry: u32 = 0;
    while (sr > 0) : (sr -= 1) {
  21bdd1:	41 83 e1 03          	and    r9d,0x3
  21bdd5:	83 fb 03             	cmp    ebx,0x3
  21bdd8:	73 10                	jae    21bdea <__udivsi3+0x5a>
  21bdda:	31 c9                	xor    ecx,ecx
  21bddc:	45 85 c9             	test   r9d,r9d
  21bddf:	0f 85 a6 00 00 00    	jne    21be8b <__udivsi3+0xfb>
  21bde5:	e9 c5 00 00 00       	jmp    21beaf <__udivsi3+0x11f>
  21bdea:	42 8d 14 0a          	lea    edx,[rdx+r9*1]
  21bdee:	83 c2 ff             	add    edx,0xffffffff
  21bdf1:	29 ca                	sub    edx,ecx
  21bdf3:	31 c9                	xor    ecx,ecx
  21bdf5:	41 ba 1e 01 00 00    	mov    r10d,0x11e
  21bdfb:	41 bb 1d 01 00 00    	mov    r11d,0x11d
  21be01:	41 be 1c 01 00 00    	mov    r14d,0x11c
  21be07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21be0e:	00 00 
        // r:q = ((r:q)  << 1) | carry
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21be10:	0f a4 c7 01          	shld   edi,eax,0x1
        q = (q << 1) | carry;
  21be14:	8d 1c 00             	lea    ebx,[rax+rax*1]
  21be17:	09 cb                	or     ebx,ecx
        // if (r.all >= d.all)
        // {
        //      r.all -= d.all;
        //      carry = 1;
        // }
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21be19:	44 89 c1             	mov    ecx,r8d
  21be1c:	29 f9                	sub    ecx,edi
  21be1e:	c1 f9 1f             	sar    ecx,0x1f
        carry = @intCast(u32, s & 1);
  21be21:	89 cd                	mov    ebp,ecx
  21be23:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21be26:	21 f1                	and    ecx,esi
  21be28:	29 cf                	sub    edi,ecx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21be2a:	c4 e2 28 f7 c8       	bextr  ecx,eax,r10d
  21be2f:	8d 0c 79             	lea    ecx,[rcx+rdi*2]
        q = (q << 1) | carry;
  21be32:	8d 7c 5d 00          	lea    edi,[rbp+rbx*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21be36:	44 89 c3             	mov    ebx,r8d
  21be39:	29 cb                	sub    ebx,ecx
  21be3b:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21be3e:	89 dd                	mov    ebp,ebx
  21be40:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21be43:	21 f3                	and    ebx,esi
  21be45:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21be47:	c4 e2 20 f7 d8       	bextr  ebx,eax,r11d
  21be4c:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  21be4f:	8d 5c 7d 00          	lea    ebx,[rbp+rdi*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21be53:	44 89 c7             	mov    edi,r8d
  21be56:	29 cf                	sub    edi,ecx
  21be58:	c1 ff 1f             	sar    edi,0x1f
        carry = @intCast(u32, s & 1);
  21be5b:	89 fd                	mov    ebp,edi
  21be5d:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21be60:	21 f7                	and    edi,esi
  21be62:	29 f9                	sub    ecx,edi
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21be64:	c4 e2 08 f7 c0       	bextr  eax,eax,r14d
  21be69:	8d 3c 48             	lea    edi,[rax+rcx*2]
        q = (q << 1) | carry;
  21be6c:	8d 44 5d 00          	lea    eax,[rbp+rbx*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21be70:	44 89 c3             	mov    ebx,r8d
  21be73:	29 fb                	sub    ebx,edi
  21be75:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21be78:	89 d9                	mov    ecx,ebx
  21be7a:	83 e1 01             	and    ecx,0x1
        r -= d & @bitCast(u32, s);
  21be7d:	21 f3                	and    ebx,esi
  21be7f:	29 df                	sub    edi,ebx
    while (sr > 0) : (sr -= 1) {
  21be81:	83 c2 04             	add    edx,0x4
  21be84:	75 8a                	jne    21be10 <__udivsi3+0x80>
  21be86:	45 85 c9             	test   r9d,r9d
  21be89:	74 24                	je     21beaf <__udivsi3+0x11f>
  21be8b:	41 f7 d9             	neg    r9d
  21be8e:	66 90                	xchg   ax,ax
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21be90:	0f a4 c7 01          	shld   edi,eax,0x1
        q = (q << 1) | carry;
  21be94:	01 c0                	add    eax,eax
  21be96:	09 c8                	or     eax,ecx
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21be98:	44 89 c2             	mov    edx,r8d
  21be9b:	29 fa                	sub    edx,edi
  21be9d:	c1 fa 1f             	sar    edx,0x1f
        carry = @intCast(u32, s & 1);
  21bea0:	89 d1                	mov    ecx,edx
  21bea2:	83 e1 01             	and    ecx,0x1
        r -= d & @bitCast(u32, s);
  21bea5:	21 f2                	and    edx,esi
  21bea7:	29 d7                	sub    edi,edx
    while (sr > 0) : (sr -= 1) {
  21bea9:	41 83 c1 01          	add    r9d,0x1
  21bead:	75 e1                	jne    21be90 <__udivsi3+0x100>
    }
    q = (q << 1) | carry;
  21beaf:	01 c0                	add    eax,eax
  21beb1:	09 c8                	or     eax,ecx
  21beb3:	5b                   	pop    rbx
  21beb4:	41 5e                	pop    r14
  21beb6:	5d                   	pop    rbp
  21beb7:	c3                   	ret    
  21beb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21bebf:	00 

000000000021bec0 <__udivdi3>:
    return __udivmoddi4(a, b, null);
  21bec0:	31 d2                	xor    edx,edx
  21bec2:	e9 a9 e6 ff ff       	jmp    21a570 <__udivmoddi4>
  21bec7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21bece:	00 00 

000000000021bed0 <__umoddi3>:
extern fn __umoddi3(a: u64, b: u64) u64 {
  21bed0:	50                   	push   rax
  21bed1:	48 89 e2             	mov    rdx,rsp
    _ = __udivmoddi4(a, b, &r);
  21bed4:	e8 97 e6 ff ff       	call   21a570 <__udivmoddi4>
    return r;
  21bed9:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  21bedd:	59                   	pop    rcx
  21bede:	c3                   	ret    
  21bedf:	90                   	nop

000000000021bee0 <__udivmodsi4>:
extern fn __udivmodsi4(a: u32, b: u32, rem: *u32) u32 {
  21bee0:	55                   	push   rbp
  21bee1:	41 57                	push   r15
  21bee3:	41 56                	push   r14
  21bee5:	41 55                	push   r13
  21bee7:	41 54                	push   r12
  21bee9:	53                   	push   rbx
  21beea:	31 c0                	xor    eax,eax
    if (n == 0) return 0;
  21beec:	85 ff                	test   edi,edi
    if (d == 0) return 0; // ?!
  21beee:	0f 84 33 01 00 00    	je     21c027 <__udivmodsi4+0x147>
  21bef4:	85 f6                	test   esi,esi
  21bef6:	0f 84 2b 01 00 00    	je     21c027 <__udivmodsi4+0x147>
    var sr = @bitCast(c_uint, c_int(@clz(d)) - c_int(@clz(n)));
  21befc:	f3 44 0f bd de       	lzcnt  r11d,esi
  21bf01:	f3 0f bd df          	lzcnt  ebx,edi
  21bf05:	44 89 dd             	mov    ebp,r11d
  21bf08:	29 dd                	sub    ebp,ebx
    if (sr > n_uword_bits - 1) {
  21bf0a:	83 fd 1f             	cmp    ebp,0x1f
  21bf0d:	0f 87 14 01 00 00    	ja     21c027 <__udivmodsi4+0x147>
  21bf13:	89 f8                	mov    eax,edi
    if (sr == n_uword_bits - 1) {
  21bf15:	0f 84 0c 01 00 00    	je     21c027 <__udivmodsi4+0x147>
    sr += 1;
  21bf1b:	44 8d 4d 01          	lea    r9d,[rbp+0x1]
    var q: u32 = n << @intCast(u5, n_uword_bits - sr);
  21bf1f:	b8 1f 00 00 00       	mov    eax,0x1f
  21bf24:	29 e8                	sub    eax,ebp
  21bf26:	c4 e2 79 f7 c7       	shlx   eax,edi,eax
    var r: u32 = n >> @intCast(u5, sr);
  21bf2b:	c4 e2 33 f7 cf       	shrx   ecx,edi,r9d
  21bf30:	44 8d 46 ff          	lea    r8d,[rsi-0x1]
    while (sr > 0) : (sr -= 1) {
  21bf34:	41 83 e1 03          	and    r9d,0x3
  21bf38:	83 fd 03             	cmp    ebp,0x3
  21bf3b:	73 11                	jae    21bf4e <__udivmodsi4+0x6e>
  21bf3d:	45 31 db             	xor    r11d,r11d
  21bf40:	45 85 c9             	test   r9d,r9d
  21bf43:	0f 85 aa 00 00 00    	jne    21bff3 <__udivmodsi4+0x113>
  21bf49:	e9 d4 00 00 00       	jmp    21c022 <__udivmodsi4+0x142>
  21bf4e:	46 8d 14 0b          	lea    r10d,[rbx+r9*1]
  21bf52:	41 83 c2 ff          	add    r10d,0xffffffff
  21bf56:	45 29 da             	sub    r10d,r11d
  21bf59:	45 31 db             	xor    r11d,r11d
  21bf5c:	41 be 1e 01 00 00    	mov    r14d,0x11e
  21bf62:	41 bf 1d 01 00 00    	mov    r15d,0x11d
  21bf68:	41 bc 1c 01 00 00    	mov    r12d,0x11c
  21bf6e:	66 90                	xchg   ax,ax
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21bf70:	0f a4 c1 01          	shld   ecx,eax,0x1
        q = (q << 1) | carry;
  21bf74:	44 8d 2c 00          	lea    r13d,[rax+rax*1]
  21bf78:	45 09 dd             	or     r13d,r11d
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21bf7b:	44 89 c3             	mov    ebx,r8d
  21bf7e:	29 cb                	sub    ebx,ecx
  21bf80:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21bf83:	89 dd                	mov    ebp,ebx
  21bf85:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21bf88:	21 f3                	and    ebx,esi
  21bf8a:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21bf8c:	c4 e2 08 f7 d8       	bextr  ebx,eax,r14d
  21bf91:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  21bf94:	46 8d 5c 6d 00       	lea    r11d,[rbp+r13*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21bf99:	44 89 c3             	mov    ebx,r8d
  21bf9c:	29 cb                	sub    ebx,ecx
  21bf9e:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21bfa1:	89 dd                	mov    ebp,ebx
  21bfa3:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21bfa6:	21 f3                	and    ebx,esi
  21bfa8:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21bfaa:	c4 e2 00 f7 d8       	bextr  ebx,eax,r15d
  21bfaf:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  21bfb2:	46 8d 5c 5d 00       	lea    r11d,[rbp+r11*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21bfb7:	44 89 c3             	mov    ebx,r8d
  21bfba:	29 cb                	sub    ebx,ecx
  21bfbc:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21bfbf:	89 dd                	mov    ebp,ebx
  21bfc1:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21bfc4:	21 f3                	and    ebx,esi
  21bfc6:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21bfc8:	c4 e2 18 f7 c0       	bextr  eax,eax,r12d
  21bfcd:	8d 0c 48             	lea    ecx,[rax+rcx*2]
        q = (q << 1) | carry;
  21bfd0:	42 8d 44 5d 00       	lea    eax,[rbp+r11*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21bfd5:	44 89 c3             	mov    ebx,r8d
  21bfd8:	29 cb                	sub    ebx,ecx
  21bfda:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21bfdd:	41 89 db             	mov    r11d,ebx
  21bfe0:	41 83 e3 01          	and    r11d,0x1
        r -= d & @bitCast(u32, s);
  21bfe4:	21 f3                	and    ebx,esi
  21bfe6:	29 d9                	sub    ecx,ebx
    while (sr > 0) : (sr -= 1) {
  21bfe8:	41 83 c2 04          	add    r10d,0x4
  21bfec:	75 82                	jne    21bf70 <__udivmodsi4+0x90>
  21bfee:	45 85 c9             	test   r9d,r9d
  21bff1:	74 2f                	je     21c022 <__udivmodsi4+0x142>
  21bff3:	41 f7 d9             	neg    r9d
  21bff6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21bffd:	00 00 00 
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c000:	0f a4 c1 01          	shld   ecx,eax,0x1
        q = (q << 1) | carry;
  21c004:	01 c0                	add    eax,eax
  21c006:	44 09 d8             	or     eax,r11d
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c009:	44 89 c5             	mov    ebp,r8d
  21c00c:	29 cd                	sub    ebp,ecx
  21c00e:	c1 fd 1f             	sar    ebp,0x1f
        carry = @intCast(u32, s & 1);
  21c011:	41 89 eb             	mov    r11d,ebp
  21c014:	41 83 e3 01          	and    r11d,0x1
        r -= d & @bitCast(u32, s);
  21c018:	21 f5                	and    ebp,esi
  21c01a:	29 e9                	sub    ecx,ebp
    while (sr > 0) : (sr -= 1) {
  21c01c:	41 83 c1 01          	add    r9d,0x1
  21c020:	75 de                	jne    21c000 <__udivmodsi4+0x120>
    q = (q << 1) | carry;
  21c022:	01 c0                	add    eax,eax
  21c024:	44 09 d8             	or     eax,r11d
    rem.* = @bitCast(u32, @bitCast(i32, a) -% (@bitCast(i32, d) * @bitCast(i32, b)));
  21c027:	0f af f0             	imul   esi,eax
  21c02a:	29 f7                	sub    edi,esi
  21c02c:	89 3a                	mov    DWORD PTR [rdx],edi
    return d;
  21c02e:	5b                   	pop    rbx
  21c02f:	41 5c                	pop    r12
  21c031:	41 5d                	pop    r13
  21c033:	41 5e                	pop    r14
  21c035:	41 5f                	pop    r15
  21c037:	5d                   	pop    rbp
  21c038:	c3                   	ret    
  21c039:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021c040 <__divti3>:
const compiler_rt = @import("index.zig");

pub extern fn __divti3(a: i128, b: i128) i128 {
    @setRuntimeSafety(builtin.is_test);

    const s_a = a >> (i128.bit_count - 1);
  21c040:	41 56                	push   r14
  21c042:	53                   	push   rbx
  21c043:	50                   	push   rax
  21c044:	48 89 f0             	mov    rax,rsi
  21c047:	48 c1 f8 3f          	sar    rax,0x3f
    const s_b = b >> (i128.bit_count - 1);
  21c04b:	49 89 ce             	mov    r14,rcx
  21c04e:	49 31 f6             	xor    r14,rsi
  21c051:	48 89 cb             	mov    rbx,rcx
  21c054:	48 c1 fb 3f          	sar    rbx,0x3f

    const an = (a ^ s_a) -% s_a;
  21c058:	48 31 c6             	xor    rsi,rax
  21c05b:	48 31 c7             	xor    rdi,rax
  21c05e:	48 29 c7             	sub    rdi,rax
  21c061:	48 19 c6             	sbb    rsi,rax
    const bn = (b ^ s_b) -% s_b;
  21c064:	48 31 d9             	xor    rcx,rbx
  21c067:	48 31 da             	xor    rdx,rbx
  21c06a:	48 29 da             	sub    rdx,rbx
  21c06d:	48 19 d9             	sbb    rcx,rbx

    const r = udivmod(u128, @bitCast(u128, an), @bitCast(u128, bn), null);
  21c070:	45 31 c0             	xor    r8d,r8d
  21c073:	e8 18 00 00 00       	call   21c090 <udivmod.14>
    const s = s_a ^ s_b;
  21c078:	49 c1 fe 3f          	sar    r14,0x3f
    return (@bitCast(i128, r) ^ s) -% s;
  21c07c:	4c 31 f2             	xor    rdx,r14
  21c07f:	4c 31 f0             	xor    rax,r14
  21c082:	4c 29 f0             	sub    rax,r14
  21c085:	4c 19 f2             	sbb    rdx,r14
  21c088:	48 83 c4 08          	add    rsp,0x8
  21c08c:	5b                   	pop    rbx
  21c08d:	41 5e                	pop    r14
  21c08f:	c3                   	ret    

000000000021c090 <udivmod.14>:
pub fn udivmod(comptime DoubleInt: type, a: DoubleInt, b: DoubleInt, maybe_rem: ?*DoubleInt) DoubleInt {
  21c090:	55                   	push   rbp
  21c091:	41 57                	push   r15
  21c093:	41 56                	push   r14
  21c095:	41 55                	push   r13
  21c097:	41 54                	push   r12
  21c099:	53                   	push   rbx
  21c09a:	49 89 d1             	mov    r9,rdx
    if (n[high] == 0) {
  21c09d:	48 85 f6             	test   rsi,rsi
  21c0a0:	74 38                	je     21c0da <udivmod.14+0x4a>
    if (d[low] == 0) {
  21c0a2:	4d 85 c9             	test   r9,r9
  21c0a5:	74 55                	je     21c0fc <udivmod.14+0x6c>
  21c0a7:	48 85 c9             	test   rcx,rcx
        if (d[high] == 0) {
  21c0aa:	0f 84 af 00 00 00    	je     21c15f <udivmod.14+0xcf>
            sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  21c0b0:	f3 48 0f bd c1       	lzcnt  rax,rcx
  21c0b5:	f3 48 0f bd d6       	lzcnt  rdx,rsi
  21c0ba:	29 d0                	sub    eax,edx
            if (sr > SingleInt.bit_count - 1) {
  21c0bc:	83 f8 40             	cmp    eax,0x40
  21c0bf:	0f 82 23 01 00 00    	jb     21c1e8 <udivmod.14+0x158>
  21c0c5:	4d 85 c0             	test   r8,r8
  21c0c8:	0f 84 3f 01 00 00    	je     21c20d <udivmod.14+0x17d>
  21c0ce:	49 89 38             	mov    QWORD PTR [r8],rdi
  21c0d1:	49 89 70 08          	mov    QWORD PTR [r8+0x8],rsi
  21c0d5:	e9 33 01 00 00       	jmp    21c20d <udivmod.14+0x17d>
        if (d[high] == 0) {
  21c0da:	48 85 c9             	test   rcx,rcx
  21c0dd:	0f 84 df 00 00 00    	je     21c1c2 <udivmod.14+0x132>
  21c0e3:	4d 85 c0             	test   r8,r8
        if (maybe_rem) |rem| {
  21c0e6:	0f 84 21 01 00 00    	je     21c20d <udivmod.14+0x17d>
            rem.* = n[low];
  21c0ec:	49 89 38             	mov    QWORD PTR [r8],rdi
  21c0ef:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  21c0f6:	00 
  21c0f7:	e9 11 01 00 00       	jmp    21c20d <udivmod.14+0x17d>
  21c0fc:	48 85 c9             	test   rcx,rcx
        if (d[high] == 0) {
  21c0ff:	0f 84 fa 00 00 00    	je     21c1ff <udivmod.14+0x16f>
        if (n[low] == 0) {
  21c105:	48 85 ff             	test   rdi,rdi
  21c108:	0f 84 6e 02 00 00    	je     21c37c <udivmod.14+0x2ec>
        if ((d[high] & (d[high] - 1)) == 0) {
  21c10e:	48 8d 41 ff          	lea    rax,[rcx-0x1]
  21c112:	48 85 c8             	test   rax,rcx
  21c115:	0f 84 c3 02 00 00    	je     21c3de <udivmod.14+0x34e>
        sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  21c11b:	f3 4c 0f bd d1       	lzcnt  r10,rcx
  21c120:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21c125:	41 29 c2             	sub    r10d,eax
        if (sr > SingleInt.bit_count - 2) {
  21c128:	41 83 fa 3f          	cmp    r10d,0x3f
  21c12c:	73 97                	jae    21c0c5 <udivmod.14+0x35>
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21c12e:	b8 3f 00 00 00       	mov    eax,0x3f
  21c133:	44 29 d0             	sub    eax,r10d
        sr += 1;
  21c136:	41 83 c2 01          	add    r10d,0x1
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21c13a:	83 e0 3f             	and    eax,0x3f
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21c13d:	44 89 d5             	mov    ebp,r10d
  21c140:	83 e5 3f             	and    ebp,0x3f
  21c143:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21c148:	c4 e2 f9 f7 de       	shlx   rbx,rsi,rax
  21c14d:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21c152:	c4 e2 f9 f7 ff       	shlx   rdi,rdi,rax
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21c157:	48 09 de             	or     rsi,rbx
  21c15a:	e9 de 00 00 00       	jmp    21c23d <udivmod.14+0x1ad>
            if ((d[low] & (d[low] - 1)) == 0) {
  21c15f:	49 8d 41 ff          	lea    rax,[r9-0x1]
  21c163:	4c 85 c8             	test   rax,r9
  21c166:	0f 84 36 02 00 00    	je     21c3a2 <udivmod.14+0x312>
            sr = 1 + SingleInt.bit_count + c_uint(@clz(d[low])) - c_uint(@clz(n[high]));
  21c16c:	f3 4d 0f bd d1       	lzcnt  r10,r9
  21c171:	41 83 c2 41          	add    r10d,0x41
  21c175:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21c17a:	41 29 c2             	sub    r10d,eax
            if (sr == SingleInt.bit_count) {
  21c17d:	41 83 fa 40          	cmp    r10d,0x40
  21c181:	74 6f                	je     21c1f2 <udivmod.14+0x162>
  21c183:	44 89 d3             	mov    ebx,r10d
  21c186:	f7 db                	neg    ebx
  21c188:	83 e3 3f             	and    ebx,0x3f
  21c18b:	c4 62 e1 f7 e7       	shlx   r12,rdi,rbx
            } else if (sr < SingleInt.bit_count) {
  21c190:	41 83 fa 40          	cmp    r10d,0x40
  21c194:	0f 83 90 02 00 00    	jae    21c42a <udivmod.14+0x39a>
  21c19a:	31 ed                	xor    ebp,ebp
    while (sr > 0) : (sr -= 1) {
  21c19c:	45 85 d2             	test   r10d,r10d
  21c19f:	0f 84 de 02 00 00    	je     21c483 <udivmod.14+0x3f3>
  21c1a5:	44 89 d5             	mov    ebp,r10d
  21c1a8:	83 e5 3f             	and    ebp,0x3f
  21c1ab:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
  21c1b0:	c4 e2 e1 f7 de       	shlx   rbx,rsi,rbx
  21c1b5:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
  21c1ba:	48 09 de             	or     rsi,rbx
  21c1bd:	4c 89 e7             	mov    rdi,r12
  21c1c0:	eb 7b                	jmp    21c23d <udivmod.14+0x1ad>
  21c1c2:	4d 85 c0             	test   r8,r8
            if (maybe_rem) |rem| {
  21c1c5:	0f 84 40 02 00 00    	je     21c40b <udivmod.14+0x37b>
  21c1cb:	48 89 f8             	mov    rax,rdi
  21c1ce:	4c 09 c8             	or     rax,r9
  21c1d1:	48 c1 e8 20          	shr    rax,0x20
  21c1d5:	0f 84 1e 02 00 00    	je     21c3f9 <udivmod.14+0x369>
  21c1db:	31 d2                	xor    edx,edx
  21c1dd:	48 89 f8             	mov    rax,rdi
  21c1e0:	49 f7 f1             	div    r9
  21c1e3:	e9 18 02 00 00       	jmp    21c400 <udivmod.14+0x370>
            sr += 1;
  21c1e8:	44 8d 50 01          	lea    r10d,[rax+0x1]
            if (sr == SingleInt.bit_count) {
  21c1ec:	41 83 fa 40          	cmp    r10d,0x40
  21c1f0:	75 24                	jne    21c216 <udivmod.14+0x186>
  21c1f2:	41 ba 40 00 00 00    	mov    r10d,0x40
  21c1f8:	45 31 e4             	xor    r12d,r12d
  21c1fb:	31 d2                	xor    edx,edx
  21c1fd:	eb 41                	jmp    21c240 <udivmod.14+0x1b0>
            if (maybe_rem) |rem| {
  21c1ff:	4d 85 c0             	test   r8,r8
  21c202:	74 09                	je     21c20d <udivmod.14+0x17d>
                rem.* = n[high] % d[low];
  21c204:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21c208:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
  21c20d:	31 ff                	xor    edi,edi
  21c20f:	31 f6                	xor    esi,esi
  21c211:	e9 5b 01 00 00       	jmp    21c371 <udivmod.14+0x2e1>
                r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21c216:	44 89 d5             	mov    ebp,r10d
  21c219:	83 e5 3f             	and    ebp,0x3f
  21c21c:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
  21c221:	bb 3f 00 00 00       	mov    ebx,0x3f
                r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21c226:	29 c3                	sub    ebx,eax
  21c228:	83 e3 3f             	and    ebx,0x3f
  21c22b:	c4 e2 e1 f7 c6       	shlx   rax,rsi,rbx
  21c230:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
  21c235:	48 09 c6             	or     rsi,rax
                q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21c238:	c4 e2 e1 f7 ff       	shlx   rdi,rdi,rbx
  21c23d:	45 31 e4             	xor    r12d,r12d
  21c240:	4d 89 cf             	mov    r15,r9
  21c243:	49 83 c7 ff          	add    r15,0xffffffffffffffff
  21c247:	49 89 cb             	mov    r11,rcx
  21c24a:	49 83 d3 ff          	adc    r11,0xffffffffffffffff
    while (sr > 0) : (sr -= 1) {
  21c24e:	44 89 d0             	mov    eax,r10d
  21c251:	83 e0 01             	and    eax,0x1
  21c254:	31 ed                	xor    ebp,ebp
  21c256:	41 83 fa 01          	cmp    r10d,0x1
  21c25a:	75 0f                	jne    21c26b <udivmod.14+0x1db>
  21c25c:	31 db                	xor    ebx,ebx
  21c25e:	85 c0                	test   eax,eax
  21c260:	0f 85 ac 00 00 00    	jne    21c312 <udivmod.14+0x282>
  21c266:	e9 da 00 00 00       	jmp    21c345 <udivmod.14+0x2b5>
  21c26b:	4c 89 44 24 f8       	mov    QWORD PTR [rsp-0x8],r8
  21c270:	89 44 24 f4          	mov    DWORD PTR [rsp-0xc],eax
  21c274:	41 89 c5             	mov    r13d,eax
  21c277:	45 29 d5             	sub    r13d,r10d
  21c27a:	41 ba 3e 01 00 00    	mov    r10d,0x13e
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21c280:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21c285:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21c28a:	48 89 f8             	mov    rax,rdi
  21c28d:	4c 0f a4 e0 01       	shld   rax,r12,0x1
        q[low] = (q[low] << 1) | carry;
  21c292:	4b 8d 1c 24          	lea    rbx,[r12+r12*1]
  21c296:	89 ed                	mov    ebp,ebp
  21c298:	48 09 dd             	or     rbp,rbx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21c29b:	49 39 f7             	cmp    r15,rsi
  21c29e:	4c 89 db             	mov    rbx,r11
  21c2a1:	48 19 d3             	sbb    rbx,rdx
  21c2a4:	48 c1 fb 3f          	sar    rbx,0x3f
        carry = @intCast(u32, s & 1);
  21c2a8:	41 89 de             	mov    r14d,ebx
  21c2ab:	41 83 e6 01          	and    r14d,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  21c2af:	49 89 d8             	mov    r8,rbx
  21c2b2:	49 21 c8             	and    r8,rcx
  21c2b5:	4c 21 cb             	and    rbx,r9
  21c2b8:	48 29 de             	sub    rsi,rbx
  21c2bb:	4c 19 c2             	sbb    rdx,r8
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21c2be:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21c2c3:	c4 e2 a8 f7 ff       	bextr  rdi,rdi,r10
  21c2c8:	48 8d 34 77          	lea    rsi,[rdi+rsi*2]
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21c2cc:	c4 c2 a8 f7 fc       	bextr  rdi,r12,r10
  21c2d1:	48 8d 3c 47          	lea    rdi,[rdi+rax*2]
        q[low] = (q[low] << 1) | carry;
  21c2d5:	4d 8d 24 6e          	lea    r12,[r14+rbp*2]
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21c2d9:	49 39 f7             	cmp    r15,rsi
  21c2dc:	4c 89 d8             	mov    rax,r11
  21c2df:	48 19 d0             	sbb    rax,rdx
  21c2e2:	48 c1 f8 3f          	sar    rax,0x3f
        carry = @intCast(u32, s & 1);
  21c2e6:	89 c5                	mov    ebp,eax
  21c2e8:	83 e5 01             	and    ebp,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  21c2eb:	48 89 c3             	mov    rbx,rax
  21c2ee:	48 21 cb             	and    rbx,rcx
  21c2f1:	4c 21 c8             	and    rax,r9
  21c2f4:	48 29 c6             	sub    rsi,rax
  21c2f7:	48 19 da             	sbb    rdx,rbx
    while (sr > 0) : (sr -= 1) {
  21c2fa:	41 83 c5 02          	add    r13d,0x2
  21c2fe:	75 80                	jne    21c280 <udivmod.14+0x1f0>
  21c300:	89 eb                	mov    ebx,ebp
  21c302:	49 89 f2             	mov    r10,rsi
  21c305:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
  21c30a:	8b 44 24 f4          	mov    eax,DWORD PTR [rsp-0xc]
  21c30e:	85 c0                	test   eax,eax
  21c310:	74 33                	je     21c345 <udivmod.14+0x2b5>
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21c312:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21c317:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21c31c:	49 39 f7             	cmp    r15,rsi
  21c31f:	49 19 d3             	sbb    r11,rdx
  21c322:	49 c1 fb 3f          	sar    r11,0x3f
        r_all -= b & @bitCast(DoubleInt, s);
  21c326:	4c 21 d9             	and    rcx,r11
  21c329:	4d 21 d9             	and    r9,r11
  21c32c:	4c 29 ce             	sub    rsi,r9
  21c32f:	48 19 ca             	sbb    rdx,rcx
        carry = @intCast(u32, s & 1);
  21c332:	41 83 e3 01          	and    r11d,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21c336:	4c 0f a4 e7 01       	shld   rdi,r12,0x1
        q[low] = (q[low] << 1) | carry;
  21c33b:	4e 8d 24 63          	lea    r12,[rbx+r12*2]
  21c33f:	44 89 dd             	mov    ebp,r11d
  21c342:	49 89 f2             	mov    r10,rsi
  21c345:	48 89 f8             	mov    rax,rdi
    const q_all = ((@ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*) << 1) | carry; // TODO issue #421
  21c348:	89 ed                	mov    ebp,ebp
  21c34a:	31 c9                	xor    ecx,ecx
  21c34c:	4c 89 e7             	mov    rdi,r12
  21c34f:	31 f6                	xor    esi,esi
  21c351:	49 89 c4             	mov    r12,rax
  21c354:	4c 09 e6             	or     rsi,r12
  21c357:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  21c35c:	48 09 ce             	or     rsi,rcx
  21c35f:	48 01 ff             	add    rdi,rdi
  21c362:	48 09 ef             	or     rdi,rbp
    if (maybe_rem) |rem| {
  21c365:	4d 85 c0             	test   r8,r8
  21c368:	74 07                	je     21c371 <udivmod.14+0x2e1>
        rem.* = r_all;
  21c36a:	4d 89 10             	mov    QWORD PTR [r8],r10
  21c36d:	49 89 50 08          	mov    QWORD PTR [r8+0x8],rdx
        return 0;
  21c371:	48 89 f8             	mov    rax,rdi
  21c374:	48 89 f2             	mov    rdx,rsi
  21c377:	e9 fc 00 00 00       	jmp    21c478 <udivmod.14+0x3e8>
            if (maybe_rem) |rem| {
  21c37c:	4d 85 c0             	test   r8,r8
  21c37f:	0f 84 d5 00 00 00    	je     21c45a <udivmod.14+0x3ca>
  21c385:	48 89 f0             	mov    rax,rsi
  21c388:	48 09 c8             	or     rax,rcx
  21c38b:	48 c1 e8 20          	shr    rax,0x20
  21c38f:	0f 84 b4 00 00 00    	je     21c449 <udivmod.14+0x3b9>
  21c395:	31 d2                	xor    edx,edx
  21c397:	48 89 f0             	mov    rax,rsi
  21c39a:	48 f7 f1             	div    rcx
  21c39d:	e9 ad 00 00 00       	jmp    21c44f <udivmod.14+0x3bf>
                if (maybe_rem) |rem| {
  21c3a2:	4d 85 c0             	test   r8,r8
  21c3a5:	74 0e                	je     21c3b5 <udivmod.14+0x325>
                    rem.* = n[low] & (d[low] - 1);
  21c3a7:	48 21 f8             	and    rax,rdi
  21c3aa:	49 89 00             	mov    QWORD PTR [r8],rax
  21c3ad:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  21c3b4:	00 
                if (d[low] == 1) {
  21c3b5:	49 83 f9 01          	cmp    r9,0x1
  21c3b9:	74 b6                	je     21c371 <udivmod.14+0x2e1>
                sr = @ctz(d[low]);
  21c3bb:	f3 49 0f bc c1       	tzcnt  rax,r9
                q[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21c3c0:	89 c1                	mov    ecx,eax
  21c3c2:	83 e1 3f             	and    ecx,0x3f
  21c3c5:	c4 e2 f3 f7 d6       	shrx   rdx,rsi,rcx
                q[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21c3ca:	f7 d8                	neg    eax
  21c3cc:	c4 e2 f9 f7 f6       	shlx   rsi,rsi,rax
  21c3d1:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  21c3d6:	48 09 f0             	or     rax,rsi
  21c3d9:	e9 9a 00 00 00       	jmp    21c478 <udivmod.14+0x3e8>
            if (maybe_rem) |rem| {
  21c3de:	4d 85 c0             	test   r8,r8
  21c3e1:	74 0a                	je     21c3ed <udivmod.14+0x35d>
                r[high] = n[high] & (d[high] - 1);
  21c3e3:	48 21 f0             	and    rax,rsi
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21c3e6:	49 89 38             	mov    QWORD PTR [r8],rdi
  21c3e9:	49 89 40 08          	mov    QWORD PTR [r8+0x8],rax
            return n[high] >> @intCast(Log2SingleInt, @ctz(d[high]));
  21c3ed:	f3 48 0f bc c1       	tzcnt  rax,rcx
  21c3f2:	c4 e2 fb f7 c6       	shrx   rax,rsi,rax
  21c3f7:	eb 7d                	jmp    21c476 <udivmod.14+0x3e6>
  21c3f9:	31 d2                	xor    edx,edx
  21c3fb:	89 f8                	mov    eax,edi
  21c3fd:	41 f7 f1             	div    r9d
                rem.* = n[low] % d[low];
  21c400:	49 89 10             	mov    QWORD PTR [r8],rdx
  21c403:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  21c40a:	00 
  21c40b:	48 89 f8             	mov    rax,rdi
  21c40e:	4c 09 c8             	or     rax,r9
  21c411:	48 c1 e8 20          	shr    rax,0x20
  21c415:	74 0a                	je     21c421 <udivmod.14+0x391>
  21c417:	31 d2                	xor    edx,edx
  21c419:	48 89 f8             	mov    rax,rdi
  21c41c:	49 f7 f1             	div    r9
  21c41f:	eb 55                	jmp    21c476 <udivmod.14+0x3e6>
  21c421:	31 d2                	xor    edx,edx
  21c423:	89 f8                	mov    eax,edi
  21c425:	41 f7 f1             	div    r9d
  21c428:	eb 4c                	jmp    21c476 <udivmod.14+0x3e6>
                q[high] = (n[high] << @intCast(Log2SingleInt, DoubleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count));
  21c42a:	c4 e2 e1 f7 d6       	shlx   rdx,rsi,rbx
  21c42f:	44 89 d5             	mov    ebp,r10d
  21c432:	83 e5 3f             	and    ebp,0x3f
  21c435:	c4 e2 d3 f7 ff       	shrx   rdi,rdi,rbp
  21c43a:	48 09 d7             	or     rdi,rdx
                r[low] = n[high] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count);
  21c43d:	c4 e2 d3 f7 f6       	shrx   rsi,rsi,rbp
  21c442:	31 d2                	xor    edx,edx
  21c444:	e9 f7 fd ff ff       	jmp    21c240 <udivmod.14+0x1b0>
  21c449:	31 d2                	xor    edx,edx
  21c44b:	89 f0                	mov    eax,esi
  21c44d:	f7 f1                	div    ecx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21c44f:	49 89 50 08          	mov    QWORD PTR [r8+0x8],rdx
  21c453:	49 c7 00 00 00 00 00 	mov    QWORD PTR [r8],0x0
  21c45a:	48 89 f0             	mov    rax,rsi
  21c45d:	48 09 c8             	or     rax,rcx
  21c460:	48 c1 e8 20          	shr    rax,0x20
  21c464:	74 0a                	je     21c470 <udivmod.14+0x3e0>
  21c466:	31 d2                	xor    edx,edx
  21c468:	48 89 f0             	mov    rax,rsi
  21c46b:	48 f7 f1             	div    rcx
  21c46e:	eb 06                	jmp    21c476 <udivmod.14+0x3e6>
  21c470:	31 d2                	xor    edx,edx
  21c472:	89 f0                	mov    eax,esi
  21c474:	f7 f1                	div    ecx
  21c476:	31 d2                	xor    edx,edx
  21c478:	5b                   	pop    rbx
  21c479:	41 5c                	pop    r12
  21c47b:	41 5d                	pop    r13
  21c47d:	41 5e                	pop    r14
  21c47f:	41 5f                	pop    r15
  21c481:	5d                   	pop    rbp
  21c482:	c3                   	ret    
  21c483:	31 c9                	xor    ecx,ecx
  21c485:	31 ff                	xor    edi,edi
  21c487:	31 f6                	xor    esi,esi
  21c489:	e9 c6 fe ff ff       	jmp    21c354 <udivmod.14+0x2c4>
  21c48e:	66 90                	xchg   ax,ax

000000000021c490 <__muloti4>:
const udivmod = @import("udivmod.zig").udivmod;
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __muloti4(a: i128, b: i128, overflow: *c_int) i128 {
  21c490:	55                   	push   rbp
  21c491:	41 57                	push   r15
  21c493:	41 56                	push   r14
  21c495:	41 55                	push   r13
  21c497:	41 54                	push   r12
  21c499:	53                   	push   rbx
  21c49a:	48 83 ec 28          	sub    rsp,0x28
  21c49e:	4d 89 c7             	mov    r15,r8
  21c4a1:	48 89 d5             	mov    rbp,rdx
  21c4a4:	49 89 f4             	mov    r12,rsi
  21c4a7:	48 89 fb             	mov    rbx,rdi
  21c4aa:	c4 c1 f9 6e c4       	vmovq  xmm0,r12
  21c4af:	c4 e1 f9 6e cb       	vmovq  xmm1,rbx
  21c4b4:	c5 f1 6c c0          	vpunpcklqdq xmm0,xmm1,xmm0
    @setRuntimeSafety(builtin.is_test);

    const min = @bitCast(i128, u128(1 << (i128.bit_count - 1)));
    const max = ~min;
    overflow.* = 0;
  21c4b8:	41 c7 07 00 00 00 00 	mov    DWORD PTR [r15],0x0

    const r = a *% b;
  21c4bf:	48 89 e8             	mov    rax,rbp
  21c4c2:	49 0f af c4          	imul   rax,r12
  21c4c6:	c4 e2 8b f6 d3       	mulx   rdx,r14,rbx
  21c4cb:	48 01 c2             	add    rdx,rax
  21c4ce:	49 89 cd             	mov    r13,rcx
  21c4d1:	4c 0f af eb          	imul   r13,rbx
  21c4d5:	49 01 d5             	add    r13,rdx
    if (a == min) {
  21c4d8:	48 be 00 00 00 00 00 	movabs rsi,0x8000000000000000
  21c4df:	00 00 80 
  21c4e2:	c4 e1 f9 6e ce       	vmovq  xmm1,rsi
  21c4e7:	c5 e9 73 f9 08       	vpslldq xmm2,xmm1,0x8
  21c4ec:	c5 f9 74 c2          	vpcmpeqb xmm0,xmm0,xmm2
  21c4f0:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21c4f4:	3d ff ff 00 00       	cmp    eax,0xffff
  21c4f9:	75 13                	jne    21c50e <__muloti4+0x7e>
        if (b != 0 and b != 1) {
  21c4fb:	48 83 fd 02          	cmp    rbp,0x2
  21c4ff:	48 83 d9 00          	sbb    rcx,0x0
  21c503:	0f 83 b7 00 00 00    	jae    21c5c0 <__muloti4+0x130>
  21c509:	e9 b9 00 00 00       	jmp    21c5c7 <__muloti4+0x137>
            overflow.* = 1;
        }
        return r;
    }
    if (b == min) {
  21c50e:	c4 e1 f9 6e c5       	vmovq  xmm0,rbp
  21c513:	c4 e1 f9 6e c9       	vmovq  xmm1,rcx
  21c518:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  21c51c:	c5 f9 74 c2          	vpcmpeqb xmm0,xmm0,xmm2
  21c520:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21c524:	3d ff ff 00 00       	cmp    eax,0xffff
  21c529:	75 13                	jne    21c53e <__muloti4+0xae>
        if (a != 0 and a != 1) {
  21c52b:	48 83 fb 02          	cmp    rbx,0x2
  21c52f:	49 83 dc 00          	sbb    r12,0x0
  21c533:	0f 83 87 00 00 00    	jae    21c5c0 <__muloti4+0x130>
  21c539:	e9 89 00 00 00       	jmp    21c5c7 <__muloti4+0x137>
            overflow.* = 1;
        }
        return r;
    }

    const sa = a >> (i128.bit_count - 1);
  21c53e:	4c 89 e0             	mov    rax,r12
  21c541:	48 c1 f8 3f          	sar    rax,0x3f
    const abs_a = (a ^ sa) -% sa;
  21c545:	49 31 c4             	xor    r12,rax
  21c548:	48 31 c3             	xor    rbx,rax
  21c54b:	48 29 c3             	sub    rbx,rax
  21c54e:	49 19 c4             	sbb    r12,rax
    const sb = b >> (i128.bit_count - 1);
  21c551:	48 89 ca             	mov    rdx,rcx
  21c554:	48 c1 fa 3f          	sar    rdx,0x3f
    const abs_b = (b ^ sb) -% sb;
  21c558:	48 31 d1             	xor    rcx,rdx
  21c55b:	48 31 d5             	xor    rbp,rdx
  21c55e:	48 29 d5             	sub    rbp,rdx
  21c561:	48 19 d1             	sbb    rcx,rdx

    if (abs_a < 2 or abs_b < 2) {
  21c564:	48 83 fb 02          	cmp    rbx,0x2
  21c568:	4c 89 e7             	mov    rdi,r12
  21c56b:	48 83 df 00          	sbb    rdi,0x0
  21c56f:	7c 56                	jl     21c5c7 <__muloti4+0x137>
  21c571:	48 83 fd 02          	cmp    rbp,0x2
  21c575:	48 89 cf             	mov    rdi,rcx
  21c578:	48 83 df 00          	sbb    rdi,0x0
  21c57c:	7c 49                	jl     21c5c7 <__muloti4+0x137>
        return r;
    }

    if (sa == sb) {
  21c57e:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  21c583:	c5 f9 6c c0          	vpunpcklqdq xmm0,xmm0,xmm0
  21c587:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  21c58c:	c5 f1 6c c9          	vpunpcklqdq xmm1,xmm1,xmm1
  21c590:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  21c594:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21c598:	3d ff ff 00 00       	cmp    eax,0xffff
  21c59d:	75 3d                	jne    21c5dc <__muloti4+0x14c>
  21c59f:	48 be ff ff ff ff ff 	movabs rsi,0x7fffffffffffffff
  21c5a6:	ff ff 7f 
  21c5a9:	48 c7 c7 ff ff ff ff 	mov    rdi,0xffffffffffffffff
  21c5b0:	48 89 ea             	mov    rdx,rbp
  21c5b3:	e8 a8 00 00 00       	call   21c660 <__udivti3>
        if (abs_a > @divFloor(max, abs_b)) {
  21c5b8:	48 39 d8             	cmp    rax,rbx
  21c5bb:	4c 19 e2             	sbb    rdx,r12
  21c5be:	7d 07                	jge    21c5c7 <__muloti4+0x137>
  21c5c0:	41 c7 07 01 00 00 00 	mov    DWORD PTR [r15],0x1
        return r;
  21c5c7:	4c 89 f0             	mov    rax,r14
  21c5ca:	4c 89 ea             	mov    rdx,r13
  21c5cd:	48 83 c4 28          	add    rsp,0x28
  21c5d1:	5b                   	pop    rbx
  21c5d2:	41 5c                	pop    r12
  21c5d4:	41 5d                	pop    r13
  21c5d6:	41 5e                	pop    r14
  21c5d8:	41 5f                	pop    r15
  21c5da:	5d                   	pop    rbp
  21c5db:	c3                   	ret    
  21c5dc:	31 c0                	xor    eax,eax
            overflow.* = 1;
        }
    } else {
        if (abs_a > @divFloor(min, -abs_b)) {
  21c5de:	48 f7 dd             	neg    rbp
  21c5e1:	48 19 c8             	sbb    rax,rcx
  21c5e4:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21c5e9:	31 ff                	xor    edi,edi
  21c5eb:	48 89 ea             	mov    rdx,rbp
  21c5ee:	48 89 c1             	mov    rcx,rax
  21c5f1:	c5 f9 7f 54 24 10    	vmovdqa XMMWORD PTR [rsp+0x10],xmm2
  21c5f7:	e8 44 fa ff ff       	call   21c040 <__divti3>
  21c5fc:	48 89 d1             	mov    rcx,rdx
  21c5ff:	48 85 c9             	test   rcx,rcx
  21c602:	41 0f 98 c0          	sets   r8b
  21c606:	48 89 c2             	mov    rdx,rax
  21c609:	c4 e2 eb f6 fd       	mulx   rdi,rdx,rbp
  21c60e:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  21c613:	48 0f af f0          	imul   rsi,rax
  21c617:	48 01 f7             	add    rdi,rsi
  21c61a:	48 0f af e9          	imul   rbp,rcx
  21c61e:	48 01 fd             	add    rbp,rdi
  21c621:	c4 e1 f9 6e c5       	vmovq  xmm0,rbp
  21c626:	c4 e1 f9 6e ca       	vmovq  xmm1,rdx
  21c62b:	c5 f1 6c c0          	vpunpcklqdq xmm0,xmm1,xmm0
  21c62f:	c5 f9 74 44 24 10    	vpcmpeqb xmm0,xmm0,XMMWORD PTR [rsp+0x10]
  21c635:	c5 f9 d7 d0          	vpmovmskb edx,xmm0
  21c639:	81 fa ff ff 00 00    	cmp    edx,0xffff
  21c63f:	0f 95 c2             	setne  dl
  21c642:	44 20 c2             	and    dl,r8b
  21c645:	0f b6 d2             	movzx  edx,dl
  21c648:	48 29 d0             	sub    rax,rdx
  21c64b:	48 83 d9 00          	sbb    rcx,0x0
  21c64f:	48 39 d8             	cmp    rax,rbx
  21c652:	4c 19 e1             	sbb    rcx,r12
  21c655:	0f 8c 65 ff ff ff    	jl     21c5c0 <__muloti4+0x130>
  21c65b:	e9 67 ff ff ff       	jmp    21c5c7 <__muloti4+0x137>

000000000021c660 <__udivti3>:
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __udivmodti4(a: u128, b: u128, maybe_rem: ?*u128) u128 {
    @setRuntimeSafety(builtin.is_test);
    return udivmod(u128, a, b, maybe_rem);
  21c660:	45 31 c0             	xor    r8d,r8d
  21c663:	e9 28 fa ff ff       	jmp    21c090 <udivmod.14>
  21c668:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21c66f:	00 

000000000021c670 <__udivmodti4>:
  21c670:	e9 1b fa ff ff       	jmp    21c090 <udivmod.14>
  21c675:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c67c:	00 00 00 00 

000000000021c680 <__umodti3>:
const udivmodti4 = @import("udivmodti4.zig");
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __umodti3(a: u128, b: u128) u128 {
  21c680:	48 83 ec 18          	sub    rsp,0x18
  21c684:	4c 8d 44 24 08       	lea    r8,[rsp+0x8]
  21c689:	e8 02 fa ff ff       	call   21c090 <udivmod.14>
    @setRuntimeSafety(builtin.is_test);
    var r: u128 = undefined;
    _ = udivmodti4.__udivmodti4(a, b, &r);
    return r;
  21c68e:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  21c693:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  21c698:	48 83 c4 18          	add    rsp,0x18
  21c69c:	c3                   	ret    
