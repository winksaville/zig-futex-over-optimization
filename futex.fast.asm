
./zig-cache/test:     file format elf64-x86-64


Disassembly of section .text:

0000000000208000 <assert>:
/// In Debug and ReleaseSafe modes, calls to this function are always
/// generated, and the `unreachable` statement triggers a panic.
/// In ReleaseFast and ReleaseSmall modes, calls to this function can be
/// optimized away.
pub fn assert(ok: bool) void {
    if (!ok) {
  208000:	40 f6 c7 01          	test   dil,0x1
  208004:	74 01                	je     208007 <assert+0x7>
pub fn assert(ok: bool) void {
  208006:	c3                   	ret    
        // In ReleaseFast test mode, we still want assert(false) to crash, so
        // we insert an explicit call to @panic instead of unreachable.
        // TODO we should use `assertOrPanic` in tests and remove this logic.
        if (builtin.is_test) {
            @panic("assertion failure");
  208007:	50                   	push   rax
  208008:	e8 a3 1c 00 00       	call   209cb0 <panic>
  20800d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000208010 <init_vdso_clock_gettime>:
const linux = std.os.linux;
const cstr = std.cstr;
const mem = std.mem;

pub fn lookup(vername: []const u8, name: []const u8) usize {
    const vdso_addr = std.os.linux_aux_raw[std.elf.AT_SYSINFO_EHDR];
  208010:	55                   	push   rbp
  208011:	41 57                	push   r15
  208013:	41 56                	push   r14
  208015:	41 55                	push   r13
  208017:	41 54                	push   r12
  208019:	53                   	push   rbx
  20801a:	4c 8b 0d 4f 91 01 00 	mov    r9,QWORD PTR [rip+0x1914f]        # 221170 <linux_aux_raw+0x108>
    if (vdso_addr == 0) return 0;
  208021:	4d 85 c9             	test   r9,r9
  208024:	0f 84 53 05 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>

    var maybe_dynv: ?[*]usize = null;
    var base: usize = @maxValue(usize);
    {
        var i: usize = 0;
        while (i < eh.e_phnum) : ({
  20802a:	41 0f b7 51 38       	movzx  edx,WORD PTR [r9+0x38]
  20802f:	48 85 d2             	test   rdx,rdx
  208032:	0f 84 45 05 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  208038:	49 8b 59 20          	mov    rbx,QWORD PTR [r9+0x20]
    var ph_addr: usize = vdso_addr + eh.e_phoff;
  20803c:	4c 01 cb             	add    rbx,r9
  20803f:	41 0f b7 49 36       	movzx  ecx,WORD PTR [r9+0x36]
        while (i < eh.e_phnum) : ({
  208044:	48 8d 42 ff          	lea    rax,[rdx-0x1]
  208048:	89 d5                	mov    ebp,edx
  20804a:	83 e5 03             	and    ebp,0x3
  20804d:	48 83 f8 03          	cmp    rax,0x3
  208051:	73 18                	jae    20806b <init_vdso_clock_gettime+0x5b>
  208053:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  20805a:	45 31 f6             	xor    r14d,r14d
            i += 1;
            ph_addr += eh.e_phentsize;
        }) {
            const this_ph = @intToPtr(*elf.Phdr, ph_addr);
            switch (this_ph.p_type) {
  20805d:	48 85 ed             	test   rbp,rbp
  208060:	0f 85 ec 00 00 00    	jne    208152 <init_vdso_clock_gettime+0x142>
  208066:	e9 29 01 00 00       	jmp    208194 <init_vdso_clock_gettime+0x184>
        while (i < eh.e_phnum) : ({
  20806b:	48 89 e8             	mov    rax,rbp
  20806e:	48 29 d0             	sub    rax,rdx
  208071:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  208078:	45 31 f6             	xor    r14d,r14d
  20807b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  208080:	48 89 da             	mov    rdx,rbx
            switch (this_ph.p_type) {
  208083:	8b 1a                	mov    ebx,DWORD PTR [rdx]
  208085:	83 fb 02             	cmp    ebx,0x2
  208088:	74 66                	je     2080f0 <init_vdso_clock_gettime+0xe0>
  20808a:	83 fb 01             	cmp    ebx,0x1
  20808d:	75 0b                	jne    20809a <init_vdso_clock_gettime+0x8a>
  20808f:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  208093:	4d 01 c8             	add    r8,r9
  208096:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20809a:	8b 1c 0a             	mov    ebx,DWORD PTR [rdx+rcx*1]
            ph_addr += eh.e_phentsize;
  20809d:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  2080a0:	83 fb 01             	cmp    ebx,0x1
  2080a3:	74 5d                	je     208102 <init_vdso_clock_gettime+0xf2>
  2080a5:	83 fb 02             	cmp    ebx,0x2
  2080a8:	75 07                	jne    2080b1 <init_vdso_clock_gettime+0xa1>
  2080aa:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  2080ae:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  2080b1:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  2080b4:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  2080b7:	83 fb 01             	cmp    ebx,0x1
  2080ba:	74 5c                	je     208118 <init_vdso_clock_gettime+0x108>
  2080bc:	83 fb 02             	cmp    ebx,0x2
  2080bf:	75 07                	jne    2080c8 <init_vdso_clock_gettime+0xb8>
  2080c1:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  2080c5:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  2080c8:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  2080cb:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  2080ce:	83 fb 01             	cmp    ebx,0x1
  2080d1:	74 5b                	je     20812e <init_vdso_clock_gettime+0x11e>
  2080d3:	83 fb 02             	cmp    ebx,0x2
  2080d6:	75 07                	jne    2080df <init_vdso_clock_gettime+0xcf>
  2080d8:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  2080dc:	4d 01 ce             	add    r14,r9
        while (i < eh.e_phnum) : ({
  2080df:	48 8d 1c 0a          	lea    rbx,[rdx+rcx*1]
  2080e3:	48 83 c0 04          	add    rax,0x4
  2080e7:	75 97                	jne    208080 <init_vdso_clock_gettime+0x70>
  2080e9:	eb 5c                	jmp    208147 <init_vdso_clock_gettime+0x137>
  2080eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  2080f0:	4c 8b 72 08          	mov    r14,QWORD PTR [rdx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  2080f4:	4d 01 ce             	add    r14,r9
            switch (this_ph.p_type) {
  2080f7:	8b 1c 0a             	mov    ebx,DWORD PTR [rdx+rcx*1]
            ph_addr += eh.e_phentsize;
  2080fa:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  2080fd:	83 fb 01             	cmp    ebx,0x1
  208100:	75 a3                	jne    2080a5 <init_vdso_clock_gettime+0x95>
  208102:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  208106:	4d 01 c8             	add    r8,r9
  208109:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  20810d:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  208110:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  208113:	83 fb 01             	cmp    ebx,0x1
  208116:	75 a4                	jne    2080bc <init_vdso_clock_gettime+0xac>
  208118:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  20811c:	4d 01 c8             	add    r8,r9
  20811f:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
            switch (this_ph.p_type) {
  208123:	8b 1c 11             	mov    ebx,DWORD PTR [rcx+rdx*1]
            ph_addr += eh.e_phentsize;
  208126:	48 01 ca             	add    rdx,rcx
            switch (this_ph.p_type) {
  208129:	83 fb 01             	cmp    ebx,0x1
  20812c:	75 a5                	jne    2080d3 <init_vdso_clock_gettime+0xc3>
  20812e:	4c 8b 42 08          	mov    r8,QWORD PTR [rdx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  208132:	4d 01 c8             	add    r8,r9
  208135:	4c 2b 42 10          	sub    r8,QWORD PTR [rdx+0x10]
        while (i < eh.e_phnum) : ({
  208139:	48 8d 1c 0a          	lea    rbx,[rdx+rcx*1]
  20813d:	48 83 c0 04          	add    rax,0x4
  208141:	0f 85 39 ff ff ff    	jne    208080 <init_vdso_clock_gettime+0x70>
  208147:	48 01 ca             	add    rdx,rcx
  20814a:	48 89 d3             	mov    rbx,rdx
            switch (this_ph.p_type) {
  20814d:	48 85 ed             	test   rbp,rbp
  208150:	74 42                	je     208194 <init_vdso_clock_gettime+0x184>
  208152:	48 f7 dd             	neg    rbp
  208155:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20815c:	00 00 00 00 
  208160:	8b 03                	mov    eax,DWORD PTR [rbx]
  208162:	83 f8 01             	cmp    eax,0x1
  208165:	74 19                	je     208180 <init_vdso_clock_gettime+0x170>
  208167:	83 f8 02             	cmp    eax,0x2
  20816a:	75 07                	jne    208173 <init_vdso_clock_gettime+0x163>
  20816c:	4c 8b 73 08          	mov    r14,QWORD PTR [rbx+0x8]
                elf.PT_DYNAMIC => maybe_dynv = @intToPtr([*]usize, vdso_addr + this_ph.p_offset),
  208170:	4d 01 ce             	add    r14,r9
            ph_addr += eh.e_phentsize;
  208173:	48 01 cb             	add    rbx,rcx
        while (i < eh.e_phnum) : ({
  208176:	48 83 c5 01          	add    rbp,0x1
  20817a:	75 e4                	jne    208160 <init_vdso_clock_gettime+0x150>
  20817c:	eb 16                	jmp    208194 <init_vdso_clock_gettime+0x184>
  20817e:	66 90                	xchg   ax,ax
  208180:	4c 8b 43 08          	mov    r8,QWORD PTR [rbx+0x8]
                elf.PT_LOAD => base = vdso_addr + this_ph.p_offset - this_ph.p_vaddr,
  208184:	4d 01 c8             	add    r8,r9
  208187:	4c 2b 43 10          	sub    r8,QWORD PTR [rbx+0x10]
            ph_addr += eh.e_phentsize;
  20818b:	48 01 cb             	add    rbx,rcx
        while (i < eh.e_phnum) : ({
  20818e:	48 83 c5 01          	add    rbp,0x1
  208192:	75 cc                	jne    208160 <init_vdso_clock_gettime+0x150>
                else => {},
            }
        }
    }
    const dynv = maybe_dynv orelse return 0;
    if (base == @maxValue(usize)) return 0;
  208194:	49 83 f8 ff          	cmp    r8,0xffffffffffffffff
    const dynv = maybe_dynv orelse return 0;
  208198:	0f 84 df 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  20819e:	4d 85 f6             	test   r14,r14
  2081a1:	0f 84 d6 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
    var maybe_versym: ?[*]u16 = null;
    var maybe_verdef: ?*elf.Verdef = null;

    {
        var i: usize = 0;
        while (dynv[i] != 0) : (i += 2) {
  2081a7:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  2081aa:	48 85 d2             	test   rdx,rdx
  2081ad:	0f 84 ca 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
            const p = base + dynv[i + 1];
  2081b3:	49 83 c6 10          	add    r14,0x10
  2081b7:	45 31 ff             	xor    r15d,r15d
  2081ba:	45 31 db             	xor    r11d,r11d
  2081bd:	45 31 d2             	xor    r10d,r10d
  2081c0:	31 ed                	xor    ebp,ebp
  2081c2:	45 31 ed             	xor    r13d,r13d
  2081c5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2081cc:	00 00 00 00 
  2081d0:	49 8b 4e f8          	mov    rcx,QWORD PTR [r14-0x8]
  2081d4:	4c 01 c1             	add    rcx,r8
            switch (dynv[i]) {
  2081d7:	48 83 fa 05          	cmp    rdx,0x5
  2081db:	7e 33                	jle    208210 <init_vdso_clock_gettime+0x200>
  2081dd:	48 83 fa 06          	cmp    rdx,0x6
  2081e1:	74 4b                	je     20822e <init_vdso_clock_gettime+0x21e>
  2081e3:	48 81 fa f0 ff ff 6f 	cmp    rdx,0x6ffffff0
  2081ea:	74 53                	je     20823f <init_vdso_clock_gettime+0x22f>
  2081ec:	48 81 fa fc ff ff 6f 	cmp    rdx,0x6ffffffc
  2081f3:	75 2b                	jne    208220 <init_vdso_clock_gettime+0x210>
  2081f5:	49 89 cb             	mov    r11,rcx
        while (dynv[i] != 0) : (i += 2) {
  2081f8:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  2081fb:	49 83 c6 10          	add    r14,0x10
  2081ff:	48 85 d2             	test   rdx,rdx
  208202:	75 cc                	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
  208204:	eb 5d                	jmp    208263 <init_vdso_clock_gettime+0x253>
  208206:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20820d:	00 00 00 
            switch (dynv[i]) {
  208210:	48 83 fa 04          	cmp    rdx,0x4
  208214:	74 3a                	je     208250 <init_vdso_clock_gettime+0x240>
  208216:	48 83 fa 05          	cmp    rdx,0x5
  20821a:	75 04                	jne    208220 <init_vdso_clock_gettime+0x210>
  20821c:	49 89 cf             	mov    r15,rcx
  20821f:	90                   	nop
        while (dynv[i] != 0) : (i += 2) {
  208220:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  208223:	49 83 c6 10          	add    r14,0x10
  208227:	48 85 d2             	test   rdx,rdx
  20822a:	75 a4                	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
  20822c:	eb 35                	jmp    208263 <init_vdso_clock_gettime+0x253>
  20822e:	49 89 cd             	mov    r13,rcx
  208231:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  208234:	49 83 c6 10          	add    r14,0x10
  208238:	48 85 d2             	test   rdx,rdx
  20823b:	75 93                	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
  20823d:	eb 24                	jmp    208263 <init_vdso_clock_gettime+0x253>
  20823f:	49 89 ca             	mov    r10,rcx
  208242:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  208245:	49 83 c6 10          	add    r14,0x10
  208249:	48 85 d2             	test   rdx,rdx
  20824c:	75 82                	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
  20824e:	eb 13                	jmp    208263 <init_vdso_clock_gettime+0x253>
  208250:	48 89 cd             	mov    rbp,rcx
  208253:	49 8b 16             	mov    rdx,QWORD PTR [r14]
  208256:	49 83 c6 10          	add    r14,0x10
  20825a:	48 85 d2             	test   rdx,rdx
  20825d:	0f 85 6d ff ff ff    	jne    2081d0 <init_vdso_clock_gettime+0x1c0>
        }
    }

    const strings = maybe_strings orelse return 0;
    const syms = maybe_syms orelse return 0;
    const hashtab = maybe_hashtab orelse return 0;
  208263:	48 85 ed             	test   rbp,rbp
    const strings = maybe_strings orelse return 0;
  208266:	0f 84 11 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  20826c:	4d 85 ed             	test   r13,r13
  20826f:	0f 84 08 03 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  208275:	4d 85 ff             	test   r15,r15
  208278:	0f 84 ff 02 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
    if (maybe_verdef == null) maybe_versym = null;
  20827e:	4d 85 db             	test   r11,r11
  208281:	4d 0f 44 d3          	cmove  r10,r11

    const OK_TYPES = (1 << elf.STT_NOTYPE | 1 << elf.STT_OBJECT | 1 << elf.STT_FUNC | 1 << elf.STT_COMMON);
    const OK_BINDS = (1 << elf.STB_GLOBAL | 1 << elf.STB_WEAK | 1 << elf.STB_GNU_UNIQUE);

    var i: usize = 0;
    while (i < hashtab[1]) : (i += 1) {
  208285:	44 8b 4d 04          	mov    r9d,DWORD PTR [rbp+0x4]
  208289:	4d 85 c9             	test   r9,r9
  20828c:	0f 84 eb 02 00 00    	je     20857d <init_vdso_clock_gettime+0x56d>
  208292:	31 d2                	xor    edx,edx
  208294:	4d 85 d2             	test   r10,r10
  208297:	0f 84 e5 01 00 00    	je     208482 <init_vdso_clock_gettime+0x472>
  20829d:	41 bc 27 00 00 00    	mov    r12d,0x27
  2082a3:	41 be 06 04 00 00    	mov    r14d,0x406
  2082a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info & 0xf) & OK_TYPES)) continue;
  2082b0:	48 8d 0c 52          	lea    rcx,[rdx+rdx*2]
  2082b4:	41 8a 5c cd 04       	mov    bl,BYTE PTR [r13+rcx*8+0x4]
  2082b9:	89 d8                	mov    eax,ebx
  2082bb:	24 0f                	and    al,0xf
  2082bd:	0f b6 c0             	movzx  eax,al
  2082c0:	41 0f a3 c4          	bt     r12d,eax
  2082c4:	0f 83 a6 01 00 00    	jae    208470 <init_vdso_clock_gettime+0x460>
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info >> 4) & OK_BINDS)) continue;
  2082ca:	c0 eb 04             	shr    bl,0x4
  2082cd:	0f b6 c3             	movzx  eax,bl
  2082d0:	41 0f a3 c6          	bt     r14d,eax
  2082d4:	0f 83 96 01 00 00    	jae    208470 <init_vdso_clock_gettime+0x460>
        if (0 == syms[i].st_shndx) continue;
  2082da:	66 41 83 7c cd 06 00 	cmp    WORD PTR [r13+rcx*8+0x6],0x0
  2082e1:	0f 84 89 01 00 00    	je     208470 <init_vdso_clock_gettime+0x460>
        if (!mem.eql(u8, name, cstr.toSliceConst(strings + syms[i].st_name))) continue;
  2082e7:	41 8b 6c cd 00       	mov    ebp,DWORD PTR [r13+rcx*8+0x0]
  2082ec:	4c 01 fd             	add    rbp,r15
  2082ef:	48 c7 c1 eb ff ff ff 	mov    rcx,0xffffffffffffffeb
  2082f6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2082fd:	00 00 00 
    else => "\n",
};

pub fn len(ptr: [*]const u8) usize {
    var count: usize = 0;
    while (ptr[count] != 0) : (count += 1) {}
  208300:	80 7c 0d 15 00       	cmp    BYTE PTR [rbp+rcx*1+0x15],0x0
  208305:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  208309:	75 f5                	jne    208300 <init_vdso_clock_gettime+0x2f0>
    assert(lessThan(u8, "", "a"));
}

/// Compares two slices and returns whether they are equal.
pub fn eql(comptime T: type, a: []const T, b: []const T) bool {
    if (a.len != b.len) return false;
  20830b:	48 85 c9             	test   rcx,rcx
  20830e:	0f 85 5c 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
    for (a) |item, index| {
        if (b[index] != item) return false;
  208314:	80 7d 00 5f          	cmp    BYTE PTR [rbp+0x0],0x5f
  208318:	0f 85 52 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20831e:	80 7d 01 5f          	cmp    BYTE PTR [rbp+0x1],0x5f
  208322:	0f 85 48 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208328:	80 7d 02 76          	cmp    BYTE PTR [rbp+0x2],0x76
  20832c:	0f 85 3e 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208332:	80 7d 03 64          	cmp    BYTE PTR [rbp+0x3],0x64
  208336:	0f 85 34 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20833c:	80 7d 04 73          	cmp    BYTE PTR [rbp+0x4],0x73
  208340:	0f 85 2a 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208346:	80 7d 05 6f          	cmp    BYTE PTR [rbp+0x5],0x6f
  20834a:	0f 85 20 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208350:	80 7d 06 5f          	cmp    BYTE PTR [rbp+0x6],0x5f
  208354:	0f 85 16 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20835a:	80 7d 07 63          	cmp    BYTE PTR [rbp+0x7],0x63
  20835e:	0f 85 0c 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208364:	80 7d 08 6c          	cmp    BYTE PTR [rbp+0x8],0x6c
  208368:	0f 85 02 01 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20836e:	80 7d 09 6f          	cmp    BYTE PTR [rbp+0x9],0x6f
  208372:	0f 85 f8 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208378:	80 7d 0a 63          	cmp    BYTE PTR [rbp+0xa],0x63
  20837c:	0f 85 ee 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208382:	80 7d 0b 6b          	cmp    BYTE PTR [rbp+0xb],0x6b
  208386:	0f 85 e4 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  20838c:	80 7d 0c 5f          	cmp    BYTE PTR [rbp+0xc],0x5f
  208390:	0f 85 da 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  208396:	80 7d 0d 67          	cmp    BYTE PTR [rbp+0xd],0x67
  20839a:	0f 85 d0 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083a0:	80 7d 0e 65          	cmp    BYTE PTR [rbp+0xe],0x65
  2083a4:	0f 85 c6 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083aa:	80 7d 0f 74          	cmp    BYTE PTR [rbp+0xf],0x74
  2083ae:	0f 85 bc 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083b4:	80 7d 10 74          	cmp    BYTE PTR [rbp+0x10],0x74
  2083b8:	0f 85 b2 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083be:	80 7d 11 69          	cmp    BYTE PTR [rbp+0x11],0x69
  2083c2:	0f 85 a8 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083c8:	80 7d 12 6d          	cmp    BYTE PTR [rbp+0x12],0x6d
  2083cc:	0f 85 9e 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
  2083d2:	80 7d 13 65          	cmp    BYTE PTR [rbp+0x13],0x65
  2083d6:	0f 85 94 00 00 00    	jne    208470 <init_vdso_clock_gettime+0x460>
        if (maybe_versym) |versym| {
            if (!checkver(maybe_verdef.?, versym[i], vername, strings))
  2083dc:	41 0f b7 2c 52       	movzx  ebp,WORD PTR [r10+rdx*2]
  2083e1:	4c 89 d9             	mov    rcx,r11

fn checkver(def_arg: *elf.Verdef, vsym_arg: i32, vername: []const u8, strings: [*]u8) bool {
    var def = def_arg;
    const vsym = @bitCast(u32, vsym_arg) & 0x7fff;
    while (true) {
        if (0 == (def.vd_flags & elf.VER_FLG_BASE) and (def.vd_ndx & 0x7fff) == vsym)
  2083e4:	f6 41 02 01          	test   BYTE PTR [rcx+0x2],0x1
  2083e8:	75 1c                	jne    208406 <init_vdso_clock_gettime+0x3f6>
  2083ea:	eb 09                	jmp    2083f5 <init_vdso_clock_gettime+0x3e5>
            break;
        if (def.vd_next == 0)
            return false;
        def = @intToPtr(*elf.Verdef, @ptrToInt(def) + def.vd_next);
  2083ec:	48 01 d9             	add    rcx,rbx
        if (0 == (def.vd_flags & elf.VER_FLG_BASE) and (def.vd_ndx & 0x7fff) == vsym)
  2083ef:	f6 41 02 01          	test   BYTE PTR [rcx+0x2],0x1
  2083f3:	75 11                	jne    208406 <init_vdso_clock_gettime+0x3f6>
  2083f5:	0f b7 41 04          	movzx  eax,WORD PTR [rcx+0x4]
  2083f9:	66 31 e8             	xor    ax,bp
  2083fc:	25 ff 7f 00 00       	and    eax,0x7fff
  208401:	66 85 c0             	test   ax,ax
  208404:	74 0a                	je     208410 <init_vdso_clock_gettime+0x400>
        if (def.vd_next == 0)
  208406:	8b 59 10             	mov    ebx,DWORD PTR [rcx+0x10]
  208409:	48 85 db             	test   rbx,rbx
  20840c:	75 de                	jne    2083ec <init_vdso_clock_gettime+0x3dc>
  20840e:	eb 60                	jmp    208470 <init_vdso_clock_gettime+0x460>
    }
    const aux = @intToPtr(*elf.Verdaux, @ptrToInt(def) + def.vd_aux);
  208410:	8b 41 0c             	mov    eax,DWORD PTR [rcx+0xc]
    return mem.eql(u8, vername, cstr.toSliceConst(strings + aux.vda_name));
  208413:	8b 2c 08             	mov    ebp,DWORD PTR [rax+rcx*1]
  208416:	4c 01 fd             	add    rbp,r15
  208419:	48 c7 c1 f6 ff ff ff 	mov    rcx,0xfffffffffffffff6
  208420:	80 7c 0d 0a 00       	cmp    BYTE PTR [rbp+rcx*1+0xa],0x0
  208425:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  208429:	75 f5                	jne    208420 <init_vdso_clock_gettime+0x410>
    if (a.len != b.len) return false;
  20842b:	48 85 c9             	test   rcx,rcx
  20842e:	75 40                	jne    208470 <init_vdso_clock_gettime+0x460>
        if (b[index] != item) return false;
  208430:	80 7d 00 4c          	cmp    BYTE PTR [rbp+0x0],0x4c
  208434:	75 3a                	jne    208470 <init_vdso_clock_gettime+0x460>
  208436:	80 7d 01 49          	cmp    BYTE PTR [rbp+0x1],0x49
  20843a:	75 34                	jne    208470 <init_vdso_clock_gettime+0x460>
  20843c:	80 7d 02 4e          	cmp    BYTE PTR [rbp+0x2],0x4e
  208440:	75 2e                	jne    208470 <init_vdso_clock_gettime+0x460>
  208442:	80 7d 03 55          	cmp    BYTE PTR [rbp+0x3],0x55
  208446:	75 28                	jne    208470 <init_vdso_clock_gettime+0x460>
  208448:	80 7d 04 58          	cmp    BYTE PTR [rbp+0x4],0x58
  20844c:	75 22                	jne    208470 <init_vdso_clock_gettime+0x460>
  20844e:	80 7d 05 5f          	cmp    BYTE PTR [rbp+0x5],0x5f
  208452:	75 1c                	jne    208470 <init_vdso_clock_gettime+0x460>
  208454:	80 7d 06 32          	cmp    BYTE PTR [rbp+0x6],0x32
  208458:	75 16                	jne    208470 <init_vdso_clock_gettime+0x460>
  20845a:	80 7d 07 2e          	cmp    BYTE PTR [rbp+0x7],0x2e
  20845e:	75 10                	jne    208470 <init_vdso_clock_gettime+0x460>
  208460:	80 7d 08 36          	cmp    BYTE PTR [rbp+0x8],0x36
            if (!checkver(maybe_verdef.?, versym[i], vername, strings))
  208464:	0f 84 37 01 00 00    	je     2085a1 <init_vdso_clock_gettime+0x591>
  20846a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    while (i < hashtab[1]) : (i += 1) {
  208470:	48 83 c2 01          	add    rdx,0x1
  208474:	4c 39 ca             	cmp    rdx,r9
  208477:	0f 82 33 fe ff ff    	jb     2082b0 <init_vdso_clock_gettime+0x2a0>
  20847d:	e9 fb 00 00 00       	jmp    20857d <init_vdso_clock_gettime+0x56d>
  208482:	bd 27 00 00 00       	mov    ebp,0x27
  208487:	41 ba 06 04 00 00    	mov    r10d,0x406
  20848d:	0f 1f 00             	nop    DWORD PTR [rax]
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info & 0xf) & OK_TYPES)) continue;
  208490:	48 8d 0c 52          	lea    rcx,[rdx+rdx*2]
  208494:	41 8a 44 cd 04       	mov    al,BYTE PTR [r13+rcx*8+0x4]
  208499:	89 c3                	mov    ebx,eax
  20849b:	80 e3 0f             	and    bl,0xf
  20849e:	0f b6 db             	movzx  ebx,bl
  2084a1:	0f a3 dd             	bt     ebp,ebx
  2084a4:	0f 83 c6 00 00 00    	jae    208570 <init_vdso_clock_gettime+0x560>
        if (0 == (u32(1) << @intCast(u5, syms[i].st_info >> 4) & OK_BINDS)) continue;
  2084aa:	c0 e8 04             	shr    al,0x4
  2084ad:	0f b6 c0             	movzx  eax,al
  2084b0:	41 0f a3 c2          	bt     r10d,eax
  2084b4:	0f 83 b6 00 00 00    	jae    208570 <init_vdso_clock_gettime+0x560>
        if (0 == syms[i].st_shndx) continue;
  2084ba:	66 41 83 7c cd 06 00 	cmp    WORD PTR [r13+rcx*8+0x6],0x0
  2084c1:	0f 84 a9 00 00 00    	je     208570 <init_vdso_clock_gettime+0x560>
        if (!mem.eql(u8, name, cstr.toSliceConst(strings + syms[i].st_name))) continue;
  2084c7:	41 8b 5c cd 00       	mov    ebx,DWORD PTR [r13+rcx*8+0x0]
  2084cc:	4c 01 fb             	add    rbx,r15
  2084cf:	48 c7 c1 eb ff ff ff 	mov    rcx,0xffffffffffffffeb
  2084d6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  2084dd:	00 00 00 
  2084e0:	80 7c 0b 15 00       	cmp    BYTE PTR [rbx+rcx*1+0x15],0x0
  2084e5:	48 8d 49 01          	lea    rcx,[rcx+0x1]
  2084e9:	75 f5                	jne    2084e0 <init_vdso_clock_gettime+0x4d0>
    if (a.len != b.len) return false;
  2084eb:	48 85 c9             	test   rcx,rcx
  2084ee:	0f 85 7c 00 00 00    	jne    208570 <init_vdso_clock_gettime+0x560>
        if (b[index] != item) return false;
  2084f4:	80 3b 5f             	cmp    BYTE PTR [rbx],0x5f
  2084f7:	75 77                	jne    208570 <init_vdso_clock_gettime+0x560>
  2084f9:	80 7b 01 5f          	cmp    BYTE PTR [rbx+0x1],0x5f
  2084fd:	75 71                	jne    208570 <init_vdso_clock_gettime+0x560>
  2084ff:	80 7b 02 76          	cmp    BYTE PTR [rbx+0x2],0x76
  208503:	75 6b                	jne    208570 <init_vdso_clock_gettime+0x560>
  208505:	80 7b 03 64          	cmp    BYTE PTR [rbx+0x3],0x64
  208509:	75 65                	jne    208570 <init_vdso_clock_gettime+0x560>
  20850b:	80 7b 04 73          	cmp    BYTE PTR [rbx+0x4],0x73
  20850f:	75 5f                	jne    208570 <init_vdso_clock_gettime+0x560>
  208511:	80 7b 05 6f          	cmp    BYTE PTR [rbx+0x5],0x6f
  208515:	75 59                	jne    208570 <init_vdso_clock_gettime+0x560>
  208517:	80 7b 06 5f          	cmp    BYTE PTR [rbx+0x6],0x5f
  20851b:	75 53                	jne    208570 <init_vdso_clock_gettime+0x560>
  20851d:	80 7b 07 63          	cmp    BYTE PTR [rbx+0x7],0x63
  208521:	75 4d                	jne    208570 <init_vdso_clock_gettime+0x560>
  208523:	80 7b 08 6c          	cmp    BYTE PTR [rbx+0x8],0x6c
  208527:	75 47                	jne    208570 <init_vdso_clock_gettime+0x560>
  208529:	80 7b 09 6f          	cmp    BYTE PTR [rbx+0x9],0x6f
  20852d:	75 41                	jne    208570 <init_vdso_clock_gettime+0x560>
  20852f:	80 7b 0a 63          	cmp    BYTE PTR [rbx+0xa],0x63
  208533:	75 3b                	jne    208570 <init_vdso_clock_gettime+0x560>
  208535:	80 7b 0b 6b          	cmp    BYTE PTR [rbx+0xb],0x6b
  208539:	75 35                	jne    208570 <init_vdso_clock_gettime+0x560>
  20853b:	80 7b 0c 5f          	cmp    BYTE PTR [rbx+0xc],0x5f
  20853f:	75 2f                	jne    208570 <init_vdso_clock_gettime+0x560>
  208541:	80 7b 0d 67          	cmp    BYTE PTR [rbx+0xd],0x67
  208545:	75 29                	jne    208570 <init_vdso_clock_gettime+0x560>
  208547:	80 7b 0e 65          	cmp    BYTE PTR [rbx+0xe],0x65
  20854b:	75 23                	jne    208570 <init_vdso_clock_gettime+0x560>
  20854d:	80 7b 0f 74          	cmp    BYTE PTR [rbx+0xf],0x74
  208551:	75 1d                	jne    208570 <init_vdso_clock_gettime+0x560>
  208553:	80 7b 10 74          	cmp    BYTE PTR [rbx+0x10],0x74
  208557:	75 17                	jne    208570 <init_vdso_clock_gettime+0x560>
  208559:	80 7b 11 69          	cmp    BYTE PTR [rbx+0x11],0x69
  20855d:	75 11                	jne    208570 <init_vdso_clock_gettime+0x560>
  20855f:	80 7b 12 6d          	cmp    BYTE PTR [rbx+0x12],0x6d
  208563:	75 0b                	jne    208570 <init_vdso_clock_gettime+0x560>
  208565:	80 7b 13 65          	cmp    BYTE PTR [rbx+0x13],0x65
  208569:	74 36                	je     2085a1 <init_vdso_clock_gettime+0x591>
  20856b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    while (i < hashtab[1]) : (i += 1) {
  208570:	48 83 c2 01          	add    rdx,0x1
  208574:	4c 39 ca             	cmp    rdx,r9
  208577:	0f 82 13 ff ff ff    	jb     208490 <init_vdso_clock_gettime+0x480>
}
var vdso_clock_gettime = init_vdso_clock_gettime;
extern fn init_vdso_clock_gettime(clk: i32, ts: *timespec) usize {
    const addr = vdso.lookup(VDSO_CGT_VER, VDSO_CGT_SYM);
    var f = @intToPtr(@typeOf(init_vdso_clock_gettime), addr);
    _ = @cmpxchgStrong(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, init_vdso_clock_gettime, f, builtin.AtomicOrder.Monotonic, builtin.AtomicOrder.Monotonic);
  20857d:	48 8d 05 8c fa ff ff 	lea    rax,[rip+0xfffffffffffffa8c]        # 208010 <init_vdso_clock_gettime>
  208584:	31 c9                	xor    ecx,ecx
  208586:	f0 48 0f b1 0d a9 4a 	lock cmpxchg QWORD PTR [rip+0x14aa9],rcx        # 21d038 <vdso_clock_gettime>
  20858d:	01 00 
    if (@ptrToInt(f) == 0) return @bitCast(usize, isize(-ENOSYS));
  20858f:	48 c7 c0 da ff ff ff 	mov    rax,0xffffffffffffffda
  208596:	5b                   	pop    rbx
  208597:	41 5c                	pop    r12
  208599:	41 5d                	pop    r13
  20859b:	41 5e                	pop    r14
  20859d:	41 5f                	pop    r15
  20859f:	5d                   	pop    rbp
  2085a0:	c3                   	ret    
        return base + syms[i].st_value;
  2085a1:	48 8d 04 52          	lea    rax,[rdx+rdx*2]
  2085a5:	4d 03 44 c5 08       	add    r8,QWORD PTR [r13+rax*8+0x8]
    _ = @cmpxchgStrong(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, init_vdso_clock_gettime, f, builtin.AtomicOrder.Monotonic, builtin.AtomicOrder.Monotonic);
  2085aa:	48 8d 05 5f fa ff ff 	lea    rax,[rip+0xfffffffffffffa5f]        # 208010 <init_vdso_clock_gettime>
  2085b1:	f0 4c 0f b1 05 7e 4a 	lock cmpxchg QWORD PTR [rip+0x14a7e],r8        # 21d038 <vdso_clock_gettime>
  2085b8:	01 00 
    if (@ptrToInt(f) == 0) return @bitCast(usize, isize(-ENOSYS));
  2085ba:	4d 85 c0             	test   r8,r8
  2085bd:	74 d0                	je     20858f <init_vdso_clock_gettime+0x57f>
    return f(clk, ts);
  2085bf:	5b                   	pop    rbx
  2085c0:	41 5c                	pop    r12
  2085c2:	41 5d                	pop    r13
  2085c4:	41 5e                	pop    r14
  2085c6:	41 5f                	pop    r15
  2085c8:	5d                   	pop    rbp
  2085c9:	41 ff e0             	jmp    r8
  2085cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000002085d0 <Futex>:
    if (stderr_stream) |st| {
  2085d0:	55                   	push   rbp
  2085d1:	41 57                	push   r15
  2085d3:	41 56                	push   r14
  2085d5:	41 55                	push   r13
  2085d7:	41 54                	push   r12
  2085d9:	53                   	push   rbx
  2085da:	48 81 ec d8 00 00 00 	sub    rsp,0xd8
  2085e1:	48 8b 3d 48 8a 01 00 	mov    rdi,QWORD PTR [rip+0x18a48]        # 221030 <stderr_stream>
  2085e8:	48 85 ff             	test   rdi,rdi
  2085eb:	74 09                	je     2085f6 <Futex+0x26>
        pub const Error = WriteError;

        writeFn: fn (self: *Self, bytes: []const u8) Error!void,

        pub fn print(self: *Self, comptime format: []const u8, args: ...) !void {
            return std.fmt.format(self, Error, self.writeFn, format, args);
  2085ed:	48 8b 05 3c 4a 01 00 	mov    rax,QWORD PTR [rip+0x14a3c]        # 21d030 <stderr_file_out_stream+0x8>
  2085f4:	eb 34                	jmp    20862a <Futex+0x5a>
        stderr_file = try io.getStdErr();
  2085f6:	48 8d 05 23 4a 01 00 	lea    rax,[rip+0x14a23]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  2085fd:	48 89 05 24 4a 01 00 	mov    QWORD PTR [rip+0x14a24],rax        # 21d028 <stderr_file_out_stream>
  208604:	48 8d 05 05 34 00 00 	lea    rax,[rip+0x3405]        # 20ba10 <FileOutStream_writeFn>
  20860b:	48 89 05 1e 4a 01 00 	mov    QWORD PTR [rip+0x14a1e],rax        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  208612:	c7 05 04 4a 01 00 02 	mov    DWORD PTR [rip+0x14a04],0x2        # 21d020 <stderr_file>
  208619:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20861c:	48 8d 3d 0d 4a 01 00 	lea    rdi,[rip+0x14a0d]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  208623:	48 89 3d 06 8a 01 00 	mov    QWORD PTR [rip+0x18a06],rdi        # 221030 <stderr_stream>
        if (state != State.Start) {
            @compileError("Incomplete format string: " ++ fmt);
        }
    }
    if (start_index < fmt.len) {
        try output(context, fmt[start_index..]);
  20862a:	48 8d 35 27 85 01 00 	lea    rsi,[rip+0x18527]        # 220b58 <__unnamed_1>
  208631:	ff d0                	call   rax
    const Self = this;

    counter: u128,

    pub fn init(pSelf: *Self) void {
        pSelf.counter = 0;
  208633:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  208637:	c5 f8 11 05 c1 49 01 	vmovups XMMWORD PTR [rip+0x149c1],xmm0        # 21d000 <gProducer_context>
  20863e:	00 
  20863f:	c5 f8 11 05 c9 49 01 	vmovups XMMWORD PTR [rip+0x149c9],xmm0        # 21d010 <gConsumer_context>
  208646:	00 
                //On Linux, seccomp can do arbitrary things to our ability to call
                //  syscalls, including return any errno value it wants and
                //  inconsistently throwing errors. Since we can't account for
                //  abuses of seccomp in a reasonable way, we'll assume that if
                //  seccomp is going to block us it will at least do so consistently
                var ts: posix.timespec = undefined;
  208647:	c5 f9 10 05 51 7c ff 	vmovupd xmm0,XMMWORD PTR [rip+0xffffffffffff7c51]        # 2002a0 <__unnamed_2>
  20864e:	ff 
  20864f:	c5 f9 29 44 24 30    	vmovapd XMMWORD PTR [rsp+0x30],xmm0
  208655:	4c 8d 7c 24 30       	lea    r15,[rsp+0x30]
        : "rcx", "r11"
    );
}

pub fn syscall2(number: usize, arg1: usize, arg2: usize) usize {
    return asm volatile ("syscall"
  20865a:	b8 e5 00 00 00       	mov    eax,0xe5
  20865f:	bf 01 00 00 00       	mov    edi,0x1
  208664:	4c 89 fe             	mov    rsi,r15
  208667:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  208669:	48 89 c2             	mov    rdx,rax
  20866c:	48 f7 da             	neg    rdx
  20866f:	31 c9                	xor    ecx,ecx
  208671:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  208677:	48 0f 47 ca          	cmova  rcx,rdx
                var result = posix.clock_getres(monotonic_clock_id, &ts);
                var errno = posix.getErrno(result);
                switch (errno) {
  20867b:	48 85 c9             	test   rcx,rcx
  20867e:	74 13                	je     208693 <Futex+0xc3>
  208680:	48 83 f9 16          	cmp    rcx,0x16
  208684:	0f 85 7b 01 00 00    	jne    208805 <Futex+0x235>
  20868a:	66 bb 01 00          	mov    bx,0x1
  20868e:	e9 76 01 00 00       	jmp    208809 <Futex+0x239>
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  208693:	48 8b 05 9e 49 01 00 	mov    rax,QWORD PTR [rip+0x1499e]        # 21d038 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  20869a:	48 85 c0             	test   rax,rax
  20869d:	74 23                	je     2086c2 <Futex+0xf2>
  20869f:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
            const rc = f(clk_id, tp);
  2086a4:	bf 01 00 00 00       	mov    edi,0x1
  2086a9:	ff d0                	call   rax
            switch (rc) {
  2086ab:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  2086af:	0f 84 89 01 00 00    	je     20883e <Futex+0x26e>
  2086b5:	48 85 c0             	test   rax,rax
  2086b8:	c5 f9 10 05 e0 7b ff 	vmovupd xmm0,XMMWORD PTR [rip+0xffffffffffff7be0]        # 2002a0 <__unnamed_2>
  2086bf:	ff 
  2086c0:	74 11                	je     2086d3 <Futex+0x103>
  2086c2:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2086c7:	b8 e4 00 00 00       	mov    eax,0xe4
  2086cc:	bf 01 00 00 00       	mov    edi,0x1
  2086d1:	0f 05                	syscall 
  2086d3:	66 bb 02 00          	mov    bx,0x2
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2086d7:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                }
                self.resolution = @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);

                result = posix.clock_gettime(monotonic_clock_id, &ts);
                errno = posix.getErrno(result);
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  2086dd:	0f 83 26 01 00 00    	jae    208809 <Futex+0x239>
    fn clockDarwin() u64 {
        return darwin.mach_absolute_time();
    }

    fn clockLinux() u64 {
        var ts: posix.timespec = undefined;
  2086e3:	c5 f9 29 44 24 30    	vmovapd XMMWORD PTR [rsp+0x30],xmm0
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  2086e9:	48 8b 05 48 49 01 00 	mov    rax,QWORD PTR [rip+0x14948]        # 21d038 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  2086f0:	48 85 c0             	test   rax,rax
  2086f3:	74 17                	je     20870c <Futex+0x13c>
  2086f5:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
            const rc = f(clk_id, tp);
  2086fa:	bf 01 00 00 00       	mov    edi,0x1
  2086ff:	ff d0                	call   rax
            switch (rc) {
  208701:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  208705:	74 16                	je     20871d <Futex+0x14d>
  208707:	48 85 c0             	test   rax,rax
  20870a:	74 11                	je     20871d <Futex+0x14d>
  20870c:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  208711:	b8 e4 00 00 00       	mov    eax,0xe4
  208716:	bf 01 00 00 00       	mov    edi,0x1
  20871b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20871d:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  208723:	0f 83 89 0f 00 00    	jae    2096b2 <Futex+0x10e2>
    arg3: usize,
    arg4: usize,
    arg5: usize,
    arg6: usize,
) usize {
    return asm volatile ("syscall"
  208729:	b8 09 00 00 00       	mov    eax,0x9
  20872e:	31 ff                	xor    edi,edi
  208730:	be 00 00 80 00       	mov    esi,0x800000
  208735:	ba 03 00 00 00       	mov    edx,0x3
  20873a:	41 ba 22 01 00 00    	mov    r10d,0x122
  208740:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  208747:	45 31 c9             	xor    r9d,r9d
  20874a:	0f 05                	syscall 
  20874c:	48 89 c3             	mov    rbx,rax

    const MAP_GROWSDOWN = if (builtin.os == builtin.Os.linux) linux.MAP_GROWSDOWN else 0;

    const mmap_len = default_stack_size;
    const stack_addr = posix.mmap(null, mmap_len, posix.PROT_READ | posix.PROT_WRITE, posix.MAP_PRIVATE | posix.MAP_ANONYMOUS | MAP_GROWSDOWN, -1, 0);
    if (stack_addr == posix.MAP_FAILED) return error.OutOfMemory;
  20874f:	48 83 fb ff          	cmp    rbx,0xffffffffffffffff
  208753:	0f 84 ad 02 00 00    	je     208a06 <Futex+0x436>
    errdefer assert(posix.munmap(stack_addr, mmap_len) == 0);

    var stack_end: usize = stack_addr + mmap_len;
    var arg: usize = undefined;
    if (@sizeOf(Context) != 0) {
        stack_end -= @sizeOf(Context);
  208759:	48 8d 8b f8 ff 7f 00 	lea    rcx,[rbx+0x7ffff8]
        stack_end -= stack_end % @alignOf(Context);
  208760:	48 83 e1 f8          	and    rcx,0xfffffffffffffff8
        assert(stack_end >= stack_addr);
  208764:	48 39 d9             	cmp    rcx,rbx
  208767:	0f 82 45 0f 00 00    	jb     2096b2 <Futex+0x10e2>
  20876d:	4c 8b 6c 24 30       	mov    r13,QWORD PTR [rsp+0x30]
  208772:	4c 8b 64 24 38       	mov    r12,QWORD PTR [rsp+0x38]
        const context_ptr = @alignCast(@alignOf(Context), @intToPtr(*Context, stack_end));
        context_ptr.* = context;
  208777:	48 8d 05 82 48 01 00 	lea    rax,[rip+0x14882]        # 21d000 <gProducer_context>
  20877e:	48 89 01             	mov    QWORD PTR [rcx],rax
        arg = stack_end;
    }

    stack_end -= @sizeOf(Thread);
  208781:	48 8d 69 e8          	lea    rbp,[rcx-0x18]
    stack_end -= stack_end % @alignOf(Thread);
    assert(stack_end >= stack_addr);
  208785:	48 39 dd             	cmp    rbp,rbx
  208788:	0f 82 24 0f 00 00    	jb     2096b2 <Futex+0x10e2>
    const thread_ptr = @alignCast(@alignOf(Thread), @intToPtr(*Thread, stack_end));

    thread_ptr.data.stack_addr = stack_addr;
  20878e:	48 89 59 f0          	mov    QWORD PTR [rcx-0x10],rbx
    thread_ptr.data.stack_len = mmap_len;
  208792:	48 c7 41 f8 00 00 80 	mov    QWORD PTR [rcx-0x8],0x800000
  208799:	00 
        }
    } else if (builtin.os == builtin.Os.linux) {
        // use linux API directly.  TODO use posix.CLONE_SETTLS and initialize thread local storage correctly
        const flags = posix.CLONE_VM | posix.CLONE_FS | posix.CLONE_FILES | posix.CLONE_SIGHAND | posix.CLONE_THREAD | posix.CLONE_SYSVSEM | posix.CLONE_PARENT_SETTID | posix.CLONE_CHILD_CLEARTID | posix.CLONE_DETACHED;
        const newtls: usize = 0;
        const rc = posix.clone(MainFuncs.linuxThreadMain, stack_end, flags, arg, &thread_ptr.data.handle, newtls, &thread_ptr.data.handle);
  20879a:	48 89 2c 24          	mov    QWORD PTR [rsp],rbp
  20879e:	48 8d 3d 2b 30 00 00 	lea    rdi,[rip+0x302b]        # 20b7d0 <MainFuncs_linuxThreadMain>
  2087a5:	45 31 f6             	xor    r14d,r14d
  2087a8:	ba 00 0f 75 00       	mov    edx,0x750f00
  2087ad:	45 31 c9             	xor    r9d,r9d
  2087b0:	48 89 ee             	mov    rsi,rbp
  2087b3:	49 89 e8             	mov    r8,rbp
  2087b6:	e8 a5 10 01 00       	call   219860 <clone>
  2087bb:	48 89 c1             	mov    rcx,rax
  2087be:	48 f7 d9             	neg    rcx
  2087c1:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2087c7:	49 0f 46 ce          	cmovbe rcx,r14
        const err = posix.getErrno(rc);
        switch (err) {
  2087cb:	48 85 c9             	test   rcx,rcx
  2087ce:	0f 84 84 00 00 00    	je     208858 <Futex+0x288>
    return asm volatile ("syscall"
  2087d4:	b8 0b 00 00 00       	mov    eax,0xb
  2087d9:	be 00 00 80 00       	mov    esi,0x800000
  2087de:	48 89 df             	mov    rdi,rbx
  2087e1:	48 83 f9 0b          	cmp    rcx,0xb
  2087e5:	0f 84 24 02 00 00    	je     208a0f <Futex+0x43f>
  2087eb:	48 83 f9 0c          	cmp    rcx,0xc
  2087ef:	0f 85 2e 02 00 00    	jne    208a23 <Futex+0x453>
  2087f5:	0f 05                	syscall 
  2087f7:	66 bb 04 00          	mov    bx,0x4
  2087fb:	48 85 c0             	test   rax,rax
  2087fe:	74 09                	je     208809 <Futex+0x239>
  208800:	e9 ad 0e 00 00       	jmp    2096b2 <Futex+0x10e2>
  208805:	66 bb 02 00          	mov    bx,0x2
  208809:	48 8b 3d f8 87 01 00 	mov    rdi,QWORD PTR [rip+0x187f8]        # 221008 <gConsumer_wait_count>
  208810:	48 03 3d e9 87 01 00 	add    rdi,QWORD PTR [rip+0x187e9]        # 221000 <gProducer_wait_count>
  208817:	48 8b 35 fa 87 01 00 	mov    rsi,QWORD PTR [rip+0x187fa]        # 221018 <gConsumer_wake_count>
  20881e:	48 03 35 eb 87 01 00 	add    rsi,QWORD PTR [rip+0x187eb]        # 221010 <gProducer_wake_count>
  208825:	e8 46 15 00 00       	call   209d70 <warn.16>
  20882a:	89 d8                	mov    eax,ebx
  20882c:	48 81 c4 d8 00 00 00 	add    rsp,0xd8
  208833:	5b                   	pop    rbx
  208834:	41 5c                	pop    r12
  208836:	41 5d                	pop    r13
  208838:	41 5e                	pop    r14
  20883a:	41 5f                	pop    r15
  20883c:	5d                   	pop    rbp
  20883d:	c3                   	ret    
  20883e:	c5 f9 10 05 5a 7a ff 	vmovupd xmm0,XMMWORD PTR [rip+0xffffffffffff7a5a]        # 2002a0 <__unnamed_2>
  208845:	ff 
  208846:	66 bb 02 00          	mov    bx,0x2
  20884a:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
                if (errno != 0) return std.os.unexpectedErrorPosix(errno);
  208850:	0f 82 8d fe ff ff    	jb     2086e3 <Futex+0x113>
  208856:	eb b1                	jmp    208809 <Futex+0x239>
    return asm volatile ("syscall"
  208858:	b8 09 00 00 00       	mov    eax,0x9
  20885d:	31 ff                	xor    edi,edi
  20885f:	be 00 00 80 00       	mov    esi,0x800000
  208864:	ba 03 00 00 00       	mov    edx,0x3
  208869:	41 ba 22 01 00 00    	mov    r10d,0x122
  20886f:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  208876:	45 31 c9             	xor    r9d,r9d
  208879:	0f 05                	syscall 
  20887b:	48 89 c3             	mov    rbx,rax
    if (stack_addr == posix.MAP_FAILED) return error.OutOfMemory;
  20887e:	48 83 fb ff          	cmp    rbx,0xffffffffffffffff
  208882:	0f 84 7e 01 00 00    	je     208a06 <Futex+0x436>
        stack_end -= @sizeOf(Context);
  208888:	48 8d 8b f8 ff 7f 00 	lea    rcx,[rbx+0x7ffff8]
        stack_end -= stack_end % @alignOf(Context);
  20888f:	48 83 e1 f8          	and    rcx,0xfffffffffffffff8
        assert(stack_end >= stack_addr);
  208893:	48 39 d9             	cmp    rcx,rbx
  208896:	0f 82 16 0e 00 00    	jb     2096b2 <Futex+0x10e2>
  20889c:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
        context_ptr.* = context;
  2088a1:	48 8d 05 68 47 01 00 	lea    rax,[rip+0x14768]        # 21d010 <gConsumer_context>
  2088a8:	48 89 01             	mov    QWORD PTR [rcx],rax
    stack_end -= @sizeOf(Thread);
  2088ab:	4c 8d 71 e8          	lea    r14,[rcx-0x18]
    assert(stack_end >= stack_addr);
  2088af:	49 39 de             	cmp    r14,rbx
  2088b2:	0f 82 fa 0d 00 00    	jb     2096b2 <Futex+0x10e2>
    thread_ptr.data.stack_addr = stack_addr;
  2088b8:	48 89 59 f0          	mov    QWORD PTR [rcx-0x10],rbx
    thread_ptr.data.stack_len = mmap_len;
  2088bc:	48 c7 41 f8 00 00 80 	mov    QWORD PTR [rcx-0x8],0x800000
  2088c3:	00 
        const rc = posix.clone(MainFuncs.linuxThreadMain, stack_end, flags, arg, &thread_ptr.data.handle, newtls, &thread_ptr.data.handle);
  2088c4:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  2088c8:	48 8d 3d 31 30 00 00 	lea    rdi,[rip+0x3031]        # 20b900 <MainFuncs_linuxThreadMain.21>
  2088cf:	45 31 e4             	xor    r12d,r12d
  2088d2:	ba 00 0f 75 00       	mov    edx,0x750f00
  2088d7:	45 31 c9             	xor    r9d,r9d
  2088da:	4c 89 f6             	mov    rsi,r14
  2088dd:	4d 89 f0             	mov    r8,r14
  2088e0:	e8 7b 0f 01 00       	call   219860 <clone>
  2088e5:	48 89 c1             	mov    rcx,rax
  2088e8:	48 f7 d9             	neg    rcx
  2088eb:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2088f1:	49 0f 46 cc          	cmovbe rcx,r12
        switch (err) {
  2088f5:	48 85 c9             	test   rcx,rcx
  2088f8:	74 49                	je     208943 <Futex+0x373>
    return asm volatile ("syscall"
  2088fa:	b8 0b 00 00 00       	mov    eax,0xb
  2088ff:	be 00 00 80 00       	mov    esi,0x800000
  208904:	48 89 df             	mov    rdi,rbx
  208907:	48 83 f9 0b          	cmp    rcx,0xb
  20890b:	0f 84 26 01 00 00    	je     208a37 <Futex+0x467>
  208911:	48 83 f9 0c          	cmp    rcx,0xc
  208915:	0f 85 30 01 00 00    	jne    208a4b <Futex+0x47b>
  20891b:	0f 05                	syscall 
  20891d:	66 bb 04 00          	mov    bx,0x4
  208921:	48 85 c0             	test   rax,rax
  208924:	0f 84 df fe ff ff    	je     208809 <Futex+0x239>
  20892a:	e9 83 0d 00 00       	jmp    2096b2 <Futex+0x10e2>
    return syscall4(SYS_futex, uaddr, futex_op, @bitCast(u32, val), @ptrToInt(timeout));
  20892f:	89 c2                	mov    edx,eax
    return asm volatile ("syscall"
  208931:	b8 ca 00 00 00       	mov    eax,0xca
  208936:	be 00 00 00 00       	mov    esi,0x0
  20893b:	45 31 d2             	xor    r10d,r10d
  20893e:	48 89 ef             	mov    rdi,rbp
  208941:	0f 05                	syscall 
                    const pid_value = @atomicLoad(i32, &self.data.handle, builtin.AtomicOrder.SeqCst);
  208943:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
                    if (pid_value == 0) break;
  208946:	85 c0                	test   eax,eax
  208948:	75 e5                	jne    20892f <Futex+0x35f>
                assert(posix.munmap(self.data.stack_addr, self.data.stack_len) == 0);
  20894a:	48 8b 7d 08          	mov    rdi,QWORD PTR [rbp+0x8]
  20894e:	48 8b 75 10          	mov    rsi,QWORD PTR [rbp+0x10]
    return asm volatile ("syscall"
  208952:	b8 0b 00 00 00       	mov    eax,0xb
  208957:	0f 05                	syscall 
  208959:	48 85 c0             	test   rax,rax
  20895c:	c5 f9 10 05 3c 79 ff 	vmovupd xmm0,XMMWORD PTR [rip+0xffffffffffff793c]        # 2002a0 <__unnamed_2>
  208963:	ff 
  208964:	74 19                	je     20897f <Futex+0x3af>
  208966:	e9 47 0d 00 00       	jmp    2096b2 <Futex+0x10e2>
  20896b:	89 c2                	mov    edx,eax
    return asm volatile ("syscall"
  20896d:	b8 ca 00 00 00       	mov    eax,0xca
  208972:	be 00 00 00 00       	mov    esi,0x0
  208977:	45 31 d2             	xor    r10d,r10d
  20897a:	4c 89 f7             	mov    rdi,r14
  20897d:	0f 05                	syscall 
                    const pid_value = @atomicLoad(i32, &self.data.handle, builtin.AtomicOrder.SeqCst);
  20897f:	41 8b 06             	mov    eax,DWORD PTR [r14]
                    if (pid_value == 0) break;
  208982:	85 c0                	test   eax,eax
  208984:	75 e5                	jne    20896b <Futex+0x39b>
                assert(posix.munmap(self.data.stack_addr, self.data.stack_len) == 0);
  208986:	49 8b 7e 08          	mov    rdi,QWORD PTR [r14+0x8]
  20898a:	49 8b 76 10          	mov    rsi,QWORD PTR [r14+0x10]
    return asm volatile ("syscall"
  20898e:	b8 0b 00 00 00       	mov    eax,0xb
  208993:	0f 05                	syscall 
  208995:	48 85 c0             	test   rax,rax
  208998:	0f 85 14 0d 00 00    	jne    2096b2 <Futex+0x10e2>
        var ts: posix.timespec = undefined;
  20899e:	c5 f9 29 44 24 30    	vmovapd XMMWORD PTR [rsp+0x30],xmm0
        const f = @atomicLoad(@typeOf(init_vdso_clock_gettime), &vdso_clock_gettime, builtin.AtomicOrder.Unordered);
  2089a4:	48 8b 05 8d 46 01 00 	mov    rax,QWORD PTR [rip+0x1468d]        # 21d038 <vdso_clock_gettime>
        if (@ptrToInt(f) != 0) {
  2089ab:	48 85 c0             	test   rax,rax
  2089ae:	74 17                	je     2089c7 <Futex+0x3f7>
  2089b0:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
            const rc = f(clk_id, tp);
  2089b5:	bf 01 00 00 00       	mov    edi,0x1
  2089ba:	ff d0                	call   rax
            switch (rc) {
  2089bc:	48 83 f8 ea          	cmp    rax,0xffffffffffffffea
  2089c0:	74 16                	je     2089d8 <Futex+0x408>
  2089c2:	48 85 c0             	test   rax,rax
  2089c5:	74 11                	je     2089d8 <Futex+0x408>
  2089c7:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2089cc:	b8 e4 00 00 00       	mov    eax,0xe4
  2089d1:	bf 01 00 00 00       	mov    edi,0x1
  2089d6:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2089d8:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
  2089de:	0f 83 ce 0c 00 00    	jae    2096b2 <Futex+0x10e2>
        var result = posix.clock_gettime(monotonic_clock_id, &ts);
        debug.assert(posix.getErrno(result) == 0);
        return @intCast(u64, ts.tv_sec) * u64(ns_per_s) + @intCast(u64, ts.tv_nsec);
  2089e4:	48 8b 6c 24 30       	mov    rbp,QWORD PTR [rsp+0x30]
  2089e9:	48 8b 5c 24 38       	mov    rbx,QWORD PTR [rsp+0x38]
    if (stderr_stream) |st| {
  2089ee:	4c 8b 35 3b 86 01 00 	mov    r14,QWORD PTR [rip+0x1863b]        # 221030 <stderr_stream>
  2089f5:	4d 85 f6             	test   r14,r14
  2089f8:	74 65                	je     208a5f <Futex+0x48f>
  2089fa:	4c 8b 25 2f 46 01 00 	mov    r12,QWORD PTR [rip+0x1462f]        # 21d030 <stderr_file_out_stream+0x8>
  208a01:	e9 8d 00 00 00       	jmp    208a93 <Futex+0x4c3>
  208a06:	66 bb 05 00          	mov    bx,0x5
  208a0a:	e9 fa fd ff ff       	jmp    208809 <Futex+0x239>
  208a0f:	0f 05                	syscall 
  208a11:	66 bb 03 00          	mov    bx,0x3
  208a15:	48 85 c0             	test   rax,rax
    if (!ok) {
  208a18:	0f 84 eb fd ff ff    	je     208809 <Futex+0x239>
  208a1e:	e9 8f 0c 00 00       	jmp    2096b2 <Futex+0x10e2>
  208a23:	0f 05                	syscall 
  208a25:	66 bb 02 00          	mov    bx,0x2
  208a29:	48 85 c0             	test   rax,rax
  208a2c:	0f 84 d7 fd ff ff    	je     208809 <Futex+0x239>
  208a32:	e9 7b 0c 00 00       	jmp    2096b2 <Futex+0x10e2>
  208a37:	0f 05                	syscall 
  208a39:	66 bb 03 00          	mov    bx,0x3
  208a3d:	48 85 c0             	test   rax,rax
  208a40:	0f 84 c3 fd ff ff    	je     208809 <Futex+0x239>
  208a46:	e9 67 0c 00 00       	jmp    2096b2 <Futex+0x10e2>
  208a4b:	0f 05                	syscall 
  208a4d:	66 bb 02 00          	mov    bx,0x2
  208a51:	48 85 c0             	test   rax,rax
  208a54:	0f 84 af fd ff ff    	je     208809 <Futex+0x239>
  208a5a:	e9 53 0c 00 00       	jmp    2096b2 <Futex+0x10e2>
        stderr_file = try io.getStdErr();
  208a5f:	48 8d 05 ba 45 01 00 	lea    rax,[rip+0x145ba]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  208a66:	48 89 05 bb 45 01 00 	mov    QWORD PTR [rip+0x145bb],rax        # 21d028 <stderr_file_out_stream>
  208a6d:	4c 8d 25 9c 2f 00 00 	lea    r12,[rip+0x2f9c]        # 20ba10 <FileOutStream_writeFn>
  208a74:	4c 89 25 b5 45 01 00 	mov    QWORD PTR [rip+0x145b5],r12        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  208a7b:	c7 05 9b 45 01 00 02 	mov    DWORD PTR [rip+0x1459b],0x2        # 21d020 <stderr_file>
  208a82:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  208a85:	4c 8d 35 a4 45 01 00 	lea    r14,[rip+0x145a4]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  208a8c:	4c 89 35 9d 85 01 00 	mov    QWORD PTR [rip+0x1859d],r14        # 221030 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  208a93:	48 8d 35 fe 80 01 00 	lea    rsi,[rip+0x180fe]        # 220b98 <__unnamed_3>
  208a9a:	4c 89 f7             	mov    rdi,r14
  208a9d:	41 ff d4             	call   r12
  208aa0:	66 85 c0             	test   ax,ax
  208aa3:	74 39                	je     208ade <Futex+0x50e>

    var end_time = timer.read();
    var duration = end_time - start_time;
    warn("test Futex: time={.6}\n", @intToFloat(f64, end_time - start_time) / @intToFloat(f64, std.os.time.ns_per_s));

    assert(gCounter == max_counter * 2);
  208aa5:	48 81 3d 70 85 01 00 	cmp    QWORD PTR [rip+0x18570],0x1312d00        # 221020 <gCounter>
  208aac:	00 2d 31 01 
    if (!ok) {
  208ab0:	0f 85 fc 0b 00 00    	jne    2096b2 <Futex+0x10e2>
        gProducer_wait_count + gConsumer_wait_count, gProducer_wake_count + gConsumer_wake_count);
  208ab6:	48 8b 3d 4b 85 01 00 	mov    rdi,QWORD PTR [rip+0x1854b]        # 221008 <gConsumer_wait_count>
  208abd:	48 03 3d 3c 85 01 00 	add    rdi,QWORD PTR [rip+0x1853c]        # 221000 <gProducer_wait_count>
  208ac4:	48 8b 35 4d 85 01 00 	mov    rsi,QWORD PTR [rip+0x1854d]        # 221018 <gConsumer_wake_count>
  208acb:	48 03 35 3e 85 01 00 	add    rsi,QWORD PTR [rip+0x1853e]        # 221010 <gProducer_wake_count>
    defer warn("test Futex:- futex_wait counts={} futex_wake counts={}\n",
  208ad2:	e8 99 12 00 00       	call   209d70 <warn.16>
test "Futex" {
  208ad7:	31 c0                	xor    eax,eax
  208ad9:	e9 4e fd ff ff       	jmp    20882c <Futex+0x25c>
  208ade:	4c 29 ed             	sub    rbp,r13
  208ae1:	48 69 c5 00 ca 9a 3b 	imul   rax,rbp,0x3b9aca00
  208ae8:	48 2b 5c 24 10       	sub    rbx,QWORD PTR [rsp+0x10]
  208aed:	48 01 c3             	add    rbx,rax
  208af0:	c4 e1 f9 6e c3       	vmovq  xmm0,rbx
  208af5:	c5 f9 62 05 a3 76 ff 	vpunpckldq xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff76a3]        # 2001a0 <__unnamed_156-0x10>
  208afc:	ff 
  208afd:	c5 f9 5c 05 cb 7b ff 	vsubpd xmm0,xmm0,XMMWORD PTR [rip+0xffffffffffff7bcb]        # 2006d0 <__unnamed_62+0x10>
  208b04:	ff 
  208b05:	c5 f9 7c c0          	vhaddpd xmm0,xmm0,xmm0
  208b09:	c5 fb 59 0d b7 80 ff 	vmulsd xmm1,xmm0,QWORD PTR [rip+0xffffffffffff80b7]        # 200bc8 <__unnamed_441+0x28>
  208b10:	ff 
    const bits = @bitCast(u32, x);
    return bits >> 31 != 0;
}

fn signbit64(x: f64) bool {
    const bits = @bitCast(u64, x);
  208b11:	c4 e1 f9 7e c8       	vmovq  rax,xmm1
    return bits >> 63 != 0;
  208b16:	48 85 c0             	test   rax,rax
    output: fn (@typeOf(context), []const u8) Errors!void,
) Errors!void {
    var x = f64(value);

    // Errol doesn't handle these special cases.
    if (math.signbit(x)) {
  208b19:	78 44                	js     208b5f <Futex+0x58f>
  208b1b:	48 b8 00 00 00 00 00 	movabs rax,0x7ff0000000000000
  208b22:	00 f0 7f 
        f32 => {
            const bits = @bitCast(u32, x);
            return bits & 0x7FFFFFFF > 0x7F800000;
        },
        f64 => {
            const bits = @bitCast(u64, x);
  208b25:	c4 e1 f9 7e cd       	vmovq  rbp,xmm1
            return (bits & (@maxValue(u64) >> 1)) > (u64(0x7FF) << 52);
  208b2a:	b1 3f                	mov    cl,0x3f
  208b2c:	c4 e2 f0 f5 cd       	bzhi   rcx,rbp,rcx
  208b31:	48 39 c1             	cmp    rcx,rax
        try output(context, "-");
        x = -x;
    }

    if (math.isNan(x)) {
  208b34:	76 09                	jbe    208b3f <Futex+0x56f>
        return output(context, "nan");
  208b36:	48 8d 35 bb 82 01 00 	lea    rsi,[rip+0x182bb]        # 220df8 <__unnamed_4>
  208b3d:	eb 0c                	jmp    208b4b <Futex+0x57b>
        },
        f32 => {
            return @bitCast(u32, x) == 0x7F800000;
        },
        f64 => {
            return @bitCast(u64, x) == 0x7FF << 52;
  208b3f:	48 39 c5             	cmp    rbp,rax
    }
    if (math.isPositiveInf(x)) {
  208b42:	75 51                	jne    208b95 <Futex+0x5c5>
        return output(context, "inf");
  208b44:	48 8d 35 bd 82 01 00 	lea    rsi,[rip+0x182bd]        # 220e08 <__unnamed_5>
  208b4b:	4c 89 f7             	mov    rdi,r14
  208b4e:	41 ff d4             	call   r12
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  208b51:	66 85 c0             	test   ax,ax
  208b54:	0f 85 4b ff ff ff    	jne    208aa5 <Futex+0x4d5>
  208b5a:	e9 35 0b 00 00       	jmp    209694 <Futex+0x10c4>
  208b5f:	c5 f8 29 4c 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm1
        try output(context, "-");
  208b65:	48 8d 35 7c 82 01 00 	lea    rsi,[rip+0x1827c]        # 220de8 <__unnamed_6>
  208b6c:	4c 89 f7             	mov    rdi,r14
  208b6f:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  208b74:	41 ff d4             	call   r12
  208b77:	66 85 c0             	test   ax,ax
  208b7a:	0f 85 06 0b 00 00    	jne    209686 <Futex+0x10b6>
  208b80:	c5 f9 28 4c 24 10    	vmovapd xmm1,XMMWORD PTR [rsp+0x10]
        x = -x;
  208b86:	c5 f1 57 0d 62 7b ff 	vxorpd xmm1,xmm1,XMMWORD PTR [rip+0xffffffffffff7b62]        # 2006f0 <__unnamed_540+0x10>
  208b8d:	ff 
  208b8e:	4c 8b 64 24 08       	mov    r12,QWORD PTR [rsp+0x8]
  208b93:	eb 86                	jmp    208b1b <Futex+0x54b>
    }
    if (x == 0.0) {
  208b95:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  208b99:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  208b9d:	4c 89 64 24 08       	mov    QWORD PTR [rsp+0x8],r12
  208ba2:	0f 85 b2 00 00 00    	jne    208c5a <Futex+0x68a>
  208ba8:	0f 8a ac 00 00 00    	jp     208c5a <Futex+0x68a>
        try output(context, "0");
  208bae:	48 8d 35 73 82 01 00 	lea    rsi,[rip+0x18273]        # 220e28 <__unnamed_7>
  208bb5:	4c 89 f7             	mov    rdi,r14
  208bb8:	41 ff d4             	call   r12
  208bbb:	66 85 c0             	test   ax,ax
  208bbe:	0f 85 c2 0a 00 00    	jne    209686 <Futex+0x10b6>

        if (maybe_precision) |precision| {
            if (precision != 0) {
                try output(context, ".");
  208bc4:	48 8d 35 4d 82 01 00 	lea    rsi,[rip+0x1824d]        # 220e18 <__unnamed_8>
  208bcb:	4c 89 f7             	mov    rdi,r14
  208bce:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  208bd2:	66 85 c0             	test   ax,ax
  208bd5:	0f 85 ab 0a 00 00    	jne    209686 <Futex+0x10b6>
                var i: usize = 0;
                while (i < precision) : (i += 1) {
                    try output(context, "0");
  208bdb:	48 8d 35 46 82 01 00 	lea    rsi,[rip+0x18246]        # 220e28 <__unnamed_7>
  208be2:	4c 89 f7             	mov    rdi,r14
  208be5:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  208be9:	66 85 c0             	test   ax,ax
  208bec:	0f 85 94 0a 00 00    	jne    209686 <Futex+0x10b6>
  208bf2:	48 8d 35 2f 82 01 00 	lea    rsi,[rip+0x1822f]        # 220e28 <__unnamed_7>
  208bf9:	4c 89 f7             	mov    rdi,r14
  208bfc:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  208c00:	66 85 c0             	test   ax,ax
  208c03:	0f 85 7d 0a 00 00    	jne    209686 <Futex+0x10b6>
  208c09:	48 8d 35 18 82 01 00 	lea    rsi,[rip+0x18218]        # 220e28 <__unnamed_7>
  208c10:	4c 89 f7             	mov    rdi,r14
  208c13:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  208c17:	66 85 c0             	test   ax,ax
  208c1a:	0f 85 66 0a 00 00    	jne    209686 <Futex+0x10b6>
  208c20:	48 8d 35 01 82 01 00 	lea    rsi,[rip+0x18201]        # 220e28 <__unnamed_7>
  208c27:	4c 89 f7             	mov    rdi,r14
  208c2a:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  208c2e:	66 85 c0             	test   ax,ax
  208c31:	0f 85 4f 0a 00 00    	jne    209686 <Futex+0x10b6>
  208c37:	48 8d 35 ea 81 01 00 	lea    rsi,[rip+0x181ea]        # 220e28 <__unnamed_7>
  208c3e:	4c 89 f7             	mov    rdi,r14
  208c41:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  208c45:	66 85 c0             	test   ax,ax
  208c48:	0f 85 38 0a 00 00    	jne    209686 <Futex+0x10b6>
  208c4e:	48 8d 35 d3 81 01 00 	lea    rsi,[rip+0x181d3]        # 220e28 <__unnamed_7>
  208c55:	e9 a2 0a 00 00       	jmp    2096fc <Futex+0x112c>
  208c5a:	c5 f8 29 4c 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm1

        return;
    }

    // non-special case, use errol3
    var buffer: [32]u8 = undefined;
  208c60:	c5 fd 10 05 78 80 ff 	vmovupd ymm0,YMMWORD PTR [rip+0xffffffffffff8078]        # 200ce0 <__unnamed_9>
  208c67:	ff 
  208c68:	c5 fd 11 44 24 30    	vmovupd YMMWORD PTR [rsp+0x30],ymm0
    var float_decimal = errol.errol3(x, buffer[0..]);
  208c6e:	4c 89 7c 24 20       	mov    QWORD PTR [rsp+0x20],r15
  208c73:	48 c7 44 24 28 20 00 	mov    QWORD PTR [rsp+0x28],0x20
  208c7a:	00 00 
  208c7c:	b8 b0 01 00 00       	mov    eax,0x1b0
  208c81:	31 d2                	xor    edx,edx
  208c83:	48 8d 0d d6 8c ff ff 	lea    rcx,[rip+0xffffffffffff8cd6]        # 201960 <enum3.12>
fn tableLowerBound(k: u64) usize {
    var i = enum3.len;
    var j: usize = 0;

    while (j < enum3.len) {
        if (enum3[j] < k) {
  208c8a:	48 39 2c d1          	cmp    QWORD PTR [rcx+rdx*8],rbp
  208c8e:	72 15                	jb     208ca5 <Futex+0x6d5>
  208c90:	48 89 d0             	mov    rax,rdx
  208c93:	48 01 d2             	add    rdx,rdx
  208c96:	48 83 c2 01          	add    rdx,0x1
    while (j < enum3.len) {
  208c9a:	48 81 fa b0 01 00 00 	cmp    rdx,0x1b0
  208ca1:	72 e7                	jb     208c8a <Futex+0x6ba>
  208ca3:	eb 10                	jmp    208cb5 <Futex+0x6e5>
  208ca5:	48 01 d2             	add    rdx,rdx
  208ca8:	48 83 c2 02          	add    rdx,0x2
  208cac:	48 81 fa b0 01 00 00 	cmp    rdx,0x1b0
  208cb3:	72 d5                	jb     208c8a <Futex+0x6ba>
    if (i < enum3.len and enum3[i] == bits) {
  208cb5:	48 3d af 01 00 00    	cmp    rax,0x1af
  208cbb:	77 48                	ja     208d05 <Futex+0x735>
  208cbd:	48 39 2c c1          	cmp    QWORD PTR [rcx+rax*8],rbp
  208cc1:	75 42                	jne    208d05 <Futex+0x735>
        const data = enum3_data[i];
  208cc3:	48 8d 04 40          	lea    rax,[rax+rax*2]
  208cc7:	48 8d 0d d2 55 01 00 	lea    rcx,[rip+0x155d2]        # 21e2a0 <enum3_data.13>
  208cce:	48 8b 14 c1          	mov    rdx,QWORD PTR [rcx+rax*8]
  208cd2:	4c 8b 7c c1 08       	mov    r15,QWORD PTR [rcx+rax*8+0x8]
    for (source) |s, i|
  208cd7:	49 8d 7f ff          	lea    rdi,[r15-0x1]
  208cdb:	44 89 fe             	mov    esi,r15d
  208cde:	83 e6 07             	and    esi,0x7
  208ce1:	48 83 ff 07          	cmp    rdi,0x7
  208ce5:	0f 83 6a 04 00 00    	jae    209155 <Futex+0xb85>
  208ceb:	31 ff                	xor    edi,edi
  208ced:	48 8d 6c 24 31       	lea    rbp,[rsp+0x31]
  208cf2:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  208cf7:	48 85 f6             	test   rsi,rsi
  208cfa:	0f 85 bc 04 00 00    	jne    2091bc <Futex+0xbec>
  208d00:	e9 d5 04 00 00       	jmp    2091da <Futex+0xc0a>
  208d05:	c5 f9 28 44 24 10    	vmovapd xmm0,XMMWORD PTR [rsp+0x10]
    if (val > 9.007199254740992e15 and val < 3.40282366920938e+38) {
  208d0b:	c5 f9 2e 05 75 7f ff 	vucomisd xmm0,QWORD PTR [rip+0xffffffffffff7f75]        # 200c88 <app_mask+0x50>
  208d12:	ff 
  208d13:	0f 86 44 02 00 00    	jbe    208f5d <Futex+0x98d>
  208d19:	c5 fb 10 0d 27 7f ff 	vmovsd xmm1,QWORD PTR [rip+0xffffffffffff7f27]        # 200c48 <app_mask+0x10>
  208d20:	ff 
  208d21:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  208d25:	0f 86 32 02 00 00    	jbe    208f5d <Futex+0x98d>
fn errolInt(val: f64, buffer: []u8) FloatDecimal {
    const pow19 = u128(1e19);

    assert((val > 9.007199254740992e15) and val < (3.40282366920938e38));

    var mid = @floatToInt(u128, val);
  208d2b:	c5 f8 77             	vzeroupper 
  208d2e:	e8 fd 2e 01 00       	call   21bc30 <__fixunsdfti>
  208d33:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  208d38:	48 89 54 24 60       	mov    QWORD PTR [rsp+0x60],rdx
        .exp = exp,
    };
}

fn fpnext(val: f64) f64 {
    return @bitCast(f64, @bitCast(u64, val) +% 1);
  208d3d:	48 8d 45 01          	lea    rax,[rbp+0x1]
  208d41:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
    var low: u128 = mid - fpeint((fpnext(val) - val) / 2.0);
  208d46:	c5 fb 5c 44 24 10    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x10]
  208d4c:	c5 fb 59 05 b4 7e ff 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xffffffffffff7eb4]        # 200c08 <__unnamed_441+0x68>
  208d53:	ff 

    return buf_index;
}

fn fpeint(from: f64) u128 {
    const bits = @bitCast(u64, from);
  208d54:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    assert((bits & ((1 << 52) - 1)) == 0);
  208d59:	48 89 c8             	mov    rax,rcx
  208d5c:	48 c1 e0 0c          	shl    rax,0xc
  208d60:	0f 85 4c 09 00 00    	jne    2096b2 <Futex+0x10e2>
  208d66:	48 ba ff ff ff ff ff 	movabs rdx,0xfffffffffffff
  208d6d:	ff 0f 00 
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  208d70:	48 8d 45 ff          	lea    rax,[rbp-0x1]
  208d74:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
    var high: u128 = mid + fpeint((val - fpprev(val)) / 2.0);
  208d79:	c5 f9 28 4c 24 10    	vmovapd xmm1,XMMWORD PTR [rsp+0x10]
  208d7f:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
  208d83:	c5 fb 59 05 7d 7e ff 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xffffffffffff7e7d]        # 200c08 <__unnamed_441+0x68>
  208d8a:	ff 
    const bits = @bitCast(u64, from);
  208d8b:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
    assert((bits & ((1 << 52) - 1)) == 0);
  208d90:	48 85 d0             	test   rax,rdx
  208d93:	0f 85 19 09 00 00    	jne    2096b2 <Futex+0x10e2>

    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  208d99:	48 c1 e9 34          	shr    rcx,0x34
  208d9d:	83 c1 01             	add    ecx,0x1
  208da0:	83 e1 7f             	and    ecx,0x7f
  208da3:	41 b8 01 00 00 00    	mov    r8d,0x1
  208da9:	31 ff                	xor    edi,edi
  208dab:	4c 0f a5 c7          	shld   rdi,r8,cl

    var i: i32 = 0;
    var a_copy = a;
    var b_copy = b;

    if (af != bf) {
  208daf:	31 d2                	xor    edx,edx
    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  208db1:	c4 c2 f1 f7 f0       	shlx   rsi,r8,rcx
  208db6:	f6 c1 40             	test   cl,0x40
  208db9:	48 0f 45 fe          	cmovne rdi,rsi
  208dbd:	48 0f 45 f2          	cmovne rsi,rdx
    if (af != bf) {
  208dc1:	45 31 d2             	xor    r10d,r10d
  208dc4:	4c 8b 7c 24 50       	mov    r15,QWORD PTR [rsp+0x50]
    var low: u128 = mid - fpeint((fpnext(val) - val) / 2.0);
  208dc9:	4c 89 fb             	mov    rbx,r15
  208dcc:	48 29 f3             	sub    rbx,rsi
  208dcf:	4c 8b 4c 24 60       	mov    r9,QWORD PTR [rsp+0x60]
  208dd4:	4c 89 ce             	mov    rsi,r9
  208dd7:	48 19 fe             	sbb    rsi,rdi
    return u128(1) << @truncate(u7, (bits >> 52) -% 1023);
  208dda:	48 c1 e8 34          	shr    rax,0x34
  208dde:	83 c0 01             	add    eax,0x1
  208de1:	83 e0 7f             	and    eax,0x7f
  208de4:	31 ff                	xor    edi,edi
  208de6:	89 c1                	mov    ecx,eax
  208de8:	4c 0f a5 c7          	shld   rdi,r8,cl
  208dec:	c4 c2 f9 f7 c8       	shlx   rcx,r8,rax
  208df1:	a8 40                	test   al,0x40
  208df3:	48 0f 45 f9          	cmovne rdi,rcx
  208df7:	49 0f 45 ca          	cmovne rcx,r10
    if (@bitCast(u64, val) & 0x1 != 0) {
  208dfb:	83 e5 01             	and    ebp,0x1
  208dfe:	31 c0                	xor    eax,eax
  208e00:	48 85 ed             	test   rbp,rbp
  208e03:	0f 94 c0             	sete   al
    var high: u128 = mid + fpeint((val - fpprev(val)) / 2.0);
  208e06:	49 29 ef             	sub    r15,rbp
  208e09:	4c 89 cd             	mov    rbp,r9
  208e0c:	48 83 dd 00          	sbb    rbp,0x0
    if (@bitCast(u64, val) & 0x1 != 0) {
  208e10:	49 01 cf             	add    r15,rcx
  208e13:	48 11 fd             	adc    rbp,rdi
  208e16:	48 29 c3             	sub    rbx,rax
  208e19:	48 83 de 00          	sbb    rsi,0x0
  208e1d:	49 bc 00 00 e8 89 04 	movabs r12,0x8ac7230489e80000
  208e24:	23 c7 8a 
    const lf = @intCast(u64, (low / pow19) % pow19);
  208e27:	31 c9                	xor    ecx,ecx
  208e29:	48 89 df             	mov    rdi,rbx
  208e2c:	4c 89 e2             	mov    rdx,r12
  208e2f:	e8 fc 38 01 00       	call   21c730 <__udivti3>
  208e34:	48 89 c1             	mov    rcx,rax
  208e37:	49 0f af cc          	imul   rcx,r12
  208e3b:	48 29 cb             	sub    rbx,rcx
  208e3e:	31 c9                	xor    ecx,ecx
  208e40:	48 89 c7             	mov    rdi,rax
  208e43:	48 89 d6             	mov    rsi,rdx
  208e46:	4c 89 e2             	mov    rdx,r12
  208e49:	e8 02 39 01 00       	call   21c750 <__umodti3>
  208e4e:	49 89 c5             	mov    r13,rax
    const hf = @intCast(u64, (high / pow19) % pow19);
  208e51:	31 c9                	xor    ecx,ecx
  208e53:	4c 89 ff             	mov    rdi,r15
  208e56:	48 89 ee             	mov    rsi,rbp
  208e59:	4c 89 e2             	mov    rdx,r12
  208e5c:	e8 cf 38 01 00       	call   21c730 <__udivti3>
  208e61:	48 89 c1             	mov    rcx,rax
  208e64:	49 0f af cc          	imul   rcx,r12
  208e68:	49 29 cf             	sub    r15,rcx
  208e6b:	31 c9                	xor    ecx,ecx
  208e6d:	48 89 c7             	mov    rdi,rax
  208e70:	48 89 d6             	mov    rsi,rdx
  208e73:	4c 89 e2             	mov    rdx,r12
  208e76:	e8 d5 38 01 00       	call   21c750 <__umodti3>
    if (lf != hf) {
  208e7b:	49 39 c5             	cmp    r13,rax
  208e7e:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  208e83:	49 0f 45 dd          	cmovne rbx,r13
  208e87:	49 89 c5             	mov    r13,rax
  208e8a:	4c 0f 45 f8          	cmovne r15,rax
  208e8e:	48 b9 bf d5 ed bd ce 	movabs rcx,0xdbe6fecebdedd5bf
  208e95:	fe e6 db 
    const af = a / pow10;
  208e98:	48 89 da             	mov    rdx,rbx
  208e9b:	c4 e2 eb f6 c1       	mulx   rax,rdx,rcx
  208ea0:	48 c1 e8 21          	shr    rax,0x21
    const bf = b / pow10;
  208ea4:	4c 89 fa             	mov    rdx,r15
  208ea7:	c4 e2 eb f6 c9       	mulx   rcx,rdx,rcx
  208eac:	48 c1 e9 21          	shr    rcx,0x21
    if (af != bf) {
  208eb0:	48 39 c8             	cmp    rax,rcx
  208eb3:	bd 0a 00 00 00       	mov    ebp,0xa
  208eb8:	ba 00 00 00 00       	mov    edx,0x0
  208ebd:	0f 44 ea             	cmove  ebp,edx
  208ec0:	48 0f 44 c3          	cmove  rax,rbx
  208ec4:	49 0f 44 cf          	cmove  rcx,r15
  208ec8:	bb 01 00 00 00       	mov    ebx,0x1
        i = 10;
        a_copy = af;
        b_copy = bf;
    }

    while (true) : (i += 1) {
  208ecd:	29 eb                	sub    ebx,ebp
  208ecf:	83 c5 12             	add    ebp,0x12
  208ed2:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  208ed9:	cc cc cc 
        a_copy /= 10;
  208edc:	48 89 c2             	mov    rdx,rax
  208edf:	c4 e2 eb f6 c6       	mulx   rax,rdx,rsi
  208ee4:	48 c1 e8 03          	shr    rax,0x3
        b_copy /= 10;
  208ee8:	48 89 ca             	mov    rdx,rcx
  208eeb:	c4 e2 eb f6 ce       	mulx   rcx,rdx,rsi
  208ef0:	48 c1 e9 03          	shr    rcx,0x3

        if (a_copy == b_copy) return i;
  208ef4:	83 c3 ff             	add    ebx,0xffffffff
  208ef7:	83 c5 01             	add    ebp,0x1
  208efa:	48 39 c8             	cmp    rax,rcx
  208efd:	75 dd                	jne    208edc <Futex+0x90c>
    if (lf != hf) {
  208eff:	4c 39 6c 24 10       	cmp    QWORD PTR [rsp+0x10],r13
  208f04:	74 25                	je     208f2b <Futex+0x95b>
        mid = mid / (pow19 / 10);
  208f06:	48 ba 00 00 64 a7 b3 	movabs rdx,0xde0b6b3a7640000
  208f0d:	b6 e0 0d 
  208f10:	31 c9                	xor    ecx,ecx
  208f12:	48 8b 7c 24 50       	mov    rdi,QWORD PTR [rsp+0x50]
  208f17:	48 8b 74 24 60       	mov    rsi,QWORD PTR [rsp+0x60]
  208f1c:	e8 0f 38 01 00       	call   21c730 <__udivti3>
  208f21:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  208f26:	48 89 54 24 60       	mov    QWORD PTR [rsp+0x60],rdx
        var i: i32 = @boolToInt(lf == hf);
  208f2b:	31 c0                	xor    eax,eax
  208f2d:	4c 39 6c 24 10       	cmp    QWORD PTR [rsp+0x10],r13
  208f32:	0f 94 c0             	sete   al
        while (i < mi) : (i += 1) {
  208f35:	41 89 dc             	mov    r12d,ebx
  208f38:	41 f7 dc             	neg    r12d
  208f3b:	41 39 c4             	cmp    r12d,eax
  208f3e:	0f 86 6f 01 00 00    	jbe    2090b3 <Futex+0xae3>
  208f44:	89 c1                	mov    ecx,eax
  208f46:	f7 d9                	neg    ecx
  208f48:	29 d9                	sub    ecx,ebx
  208f4a:	83 f9 10             	cmp    ecx,0x10
  208f4d:	0f 83 c7 02 00 00    	jae    20921a <Futex+0xc4a>
  208f53:	ba 01 00 00 00       	mov    edx,0x1
  208f58:	e9 68 05 00 00       	jmp    2094c5 <Futex+0xef5>
    } else if (val >= 16.0 and val < 9.007199254740992e15) {
  208f5d:	c5 f9 2e 05 8b 7c ff 	vucomisd xmm0,QWORD PTR [rip+0xffffffffffff7c8b]        # 200bf0 <__unnamed_441+0x50>
  208f64:	ff 
  208f65:	0f 82 54 01 00 00    	jb     2090bf <Futex+0xaef>
  208f6b:	c5 fb 10 0d 15 7d ff 	vmovsd xmm1,QWORD PTR [rip+0xffffffffffff7d15]        # 200c88 <app_mask+0x50>
  208f72:	ff 
  208f73:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  208f77:	0f 86 42 01 00 00    	jbe    2090bf <Futex+0xaef>
    const u = @floatToInt(u64, val);
  208f7d:	c5 fb 10 15 d3 7c ff 	vmovsd xmm2,QWORD PTR [rip+0xffffffffffff7cd3]        # 200c58 <app_mask+0x20>
  208f84:	ff 
  208f85:	c5 fb 5c ca          	vsubsd xmm1,xmm0,xmm2
  208f89:	c4 e1 fb 2c c1       	vcvttsd2si rax,xmm1
  208f8e:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  208f95:	00 00 80 
  208f98:	48 31 c1             	xor    rcx,rax
  208f9b:	c4 e1 fb 2c f8       	vcvttsd2si rdi,xmm0
  208fa0:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  208fa4:	48 0f 43 f9          	cmovae rdi,rcx
    const n = @intToFloat(f64, u);
  208fa8:	c4 e1 f9 6e cf       	vmovq  xmm1,rdi
  208fad:	c5 f1 62 0d eb 71 ff 	vpunpckldq xmm1,xmm1,XMMWORD PTR [rip+0xffffffffffff71eb]        # 2001a0 <__unnamed_156-0x10>
  208fb4:	ff 
  208fb5:	c5 f1 5c 0d 13 77 ff 	vsubpd xmm1,xmm1,XMMWORD PTR [rip+0xffffffffffff7713]        # 2006d0 <__unnamed_62+0x10>
  208fbc:	ff 
  208fbd:	c5 f1 7c c9          	vhaddpd xmm1,xmm1,xmm1
  208fc1:	c5 f9 29 4c 24 60    	vmovapd XMMWORD PTR [rsp+0x60],xmm1
    var mid = val - n;
  208fc7:	c5 fb 5c c1          	vsubsd xmm0,xmm0,xmm1
    var buf_index = u64toa(u, buffer);
  208fcb:	c5 f9 29 44 24 50    	vmovapd XMMWORD PTR [rsp+0x50],xmm0
  208fd1:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
  208fd6:	c5 f8 77             	vzeroupper 
  208fd9:	e8 f2 f2 00 00       	call   2182d0 <u64toa>
  208fde:	49 89 c4             	mov    r12,rax
    buffer[j] = 0;
  208fe1:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  208fe6:	42 c6 04 20 00       	mov    BYTE PTR [rax+r12*1],0x0
    if (mid != 0.0) {
  208feb:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  208fef:	c5 f9 28 4c 24 50    	vmovapd xmm1,XMMWORD PTR [rsp+0x50]
  208ff5:	c5 f9 28 d9          	vmovapd xmm3,xmm1
  208ff9:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  208ffd:	0f 84 55 02 00 00    	je     209258 <Futex+0xc88>
    return @bitCast(f64, @bitCast(u64, val) -% 1);
  209003:	c4 e2 79 59 4c 24 10 	vpbroadcastq xmm1,QWORD PTR [rsp+0x10]
  20900a:	c5 f1 d4 0d 7e 78 ff 	vpaddq xmm1,xmm1,XMMWORD PTR [rip+0xffffffffffff787e]        # 200890 <__unnamed_54+0x10>
  209011:	ff 
    var lo = ((fpprev(val) - n) + mid) / 2.0;
  209012:	c5 fb 12 54 24 60    	vmovddup xmm2,QWORD PTR [rsp+0x60]
  209018:	c5 f1 5c ca          	vsubpd xmm1,xmm1,xmm2
  20901c:	c5 f9 28 eb          	vmovapd xmm5,xmm3
  209020:	c5 fb 12 d5          	vmovddup xmm2,xmm5
  209024:	c5 f1 58 ca          	vaddpd xmm1,xmm1,xmm2
  209028:	c5 f1 59 1d 30 74 ff 	vmulpd xmm3,xmm1,XMMWORD PTR [rip+0xffffffffffff7430]        # 200460 <__unnamed_447+0x10>
  20902f:	ff 
  209030:	c5 f9 28 0d 78 72 ff 	vmovapd xmm1,XMMWORD PTR [rip+0xffffffffffff7278]        # 2002b0 <__unnamed_2+0x10>
  209037:	ff 
  209038:	c5 fb 10 15 80 7b ff 	vmovsd xmm2,QWORD PTR [rip+0xffffffffffff7b80]        # 200bc0 <__unnamed_441+0x20>
  20903f:	ff 
  209040:	4c 89 e1             	mov    rcx,r12
  209043:	48 89 c8             	mov    rax,rcx
            mid *= 10.0;
  209046:	c5 d3 59 e2          	vmulsd xmm4,xmm5,xmm2
            const mdig = @floatToInt(i32, mid);
  20904a:	c5 fb 2c cc          	vcvttsd2si ecx,xmm4
            mid -= @intToFloat(f64, mdig);
  20904e:	c5 cb 2a e9          	vcvtsi2sd xmm5,xmm6,ecx
  209052:	c5 db 5c ed          	vsubsd xmm5,xmm4,xmm5
            buffer[j] = @intCast(u8, mdig + '0');
  209056:	48 8b 54 24 20       	mov    rdx,QWORD PTR [rsp+0x20]
  20905b:	80 c1 30             	add    cl,0x30
  20905e:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            if (hdig != ldig or j > 50) break;
  209061:	48 83 f8 31          	cmp    rax,0x31
  209065:	77 2c                	ja     209093 <Futex+0xac3>
  209067:	c5 e1 59 d9          	vmulpd xmm3,xmm3,xmm1
  20906b:	c5 fb 2c cb          	vcvttsd2si ecx,xmm3
  20906f:	c4 e3 79 05 e3 01    	vpermilpd xmm4,xmm3,0x1
  209075:	c5 fb 2c d4          	vcvttsd2si edx,xmm4
  209079:	39 ca                	cmp    edx,ecx
  20907b:	75 16                	jne    209093 <Futex+0xac3>
            hi -= @intToFloat(f64, hdig);
  20907d:	c5 cb 2a e1          	vcvtsi2sd xmm4,xmm6,ecx
  209081:	48 8d 48 01          	lea    rcx,[rax+0x1]
            lo -= @intToFloat(f64, ldig);
  209085:	c5 fb 12 e4          	vmovddup xmm4,xmm4
  209089:	c5 e1 5c dc          	vsubpd xmm3,xmm3,xmm4
        while (mid != 0.0) {
  20908d:	c5 f9 2e e8          	vucomisd xmm5,xmm0
  209091:	75 b0                	jne    209043 <Futex+0xa73>
        if (mid > 0.5) {
  209093:	4c 8d 78 01          	lea    r15,[rax+0x1]
  209097:	c5 f9 2e 2d 69 7b ff 	vucomisd xmm5,QWORD PTR [rip+0xffffffffffff7b69]        # 200c08 <__unnamed_441+0x68>
  20909e:	ff 
  20909f:	0f 86 f8 01 00 00    	jbe    20929d <Futex+0xccd>
            buffer[j - 1] += 1;
  2090a5:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  2090aa:	80 04 01 01          	add    BYTE PTR [rcx+rax*1],0x1
  2090ae:	e9 30 07 00 00       	jmp    2097e3 <Futex+0x1213>
  2090b3:	31 c9                	xor    ecx,ecx
  2090b5:	ba 01 00 00 00       	mov    edx,0x1
  2090ba:	e9 18 04 00 00       	jmp    2094d7 <Futex+0xf07>
  2090bf:	48 8d bc 24 a8 00 00 	lea    rdi,[rsp+0xa8]
  2090c6:	00 

pub fn frexp(x: var) frexp_result(@typeOf(x)) {
    const T = @typeOf(x);
    return switch (T) {
        f32 => frexp32(x),
        f64 => frexp64(x),
  2090c7:	c5 f8 77             	vzeroupper 
  2090ca:	e8 f1 f8 00 00       	call   2189c0 <frexp64>
    var exp = @floatToInt(i16, math.floor(307 + @intToFloat(f64, e) * 0.30103));
  2090cf:	c5 eb 2a 8c 24 b0 00 	vcvtsi2sd xmm1,xmm2,DWORD PTR [rsp+0xb0]
  2090d6:	00 00 
  2090d8:	c5 fb 10 05 18 7b ff 	vmovsd xmm0,QWORD PTR [rip+0xffffffffffff7b18]        # 200bf8 <__unnamed_441+0x58>
  2090df:	ff 
  2090e0:	c4 e2 f1 a9 05 2f 7b 	vfmadd213sd xmm0,xmm1,QWORD PTR [rip+0xffffffffffff7b2f]        # 200c18 <__unnamed_441+0x78>
  2090e7:	ff ff 
fn floor64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  2090e9:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  2090ed:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  2090f1:	75 06                	jne    2090f9 <Futex+0xb29>
  2090f3:	0f 8b 1a 07 00 00    	jnp    209813 <Futex+0x1243>
  2090f9:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  2090fe:	b9 34 0b 00 00       	mov    ecx,0xb34
  209103:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  209108:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  20910f:	0f 87 fe 06 00 00    	ja     209813 <Futex+0x1243>
        return x;
    }

    if (u >> 63 != 0) {
        @setFloatMode(this, builtin.FloatMode.Strict);
        y = x - math.f64_toint + math.f64_toint - x;
  209115:	c5 fb 10 15 cb 7a ff 	vmovsd xmm2,QWORD PTR [rip+0xffffffffffff7acb]        # 200be8 <__unnamed_441+0x48>
  20911c:	ff 
  20911d:	c5 fb 10 1d fb 7a ff 	vmovsd xmm3,QWORD PTR [rip+0xffffffffffff7afb]        # 200c20 <__unnamed_441+0x80>
  209124:	ff 
    if (u >> 63 != 0) {
  209125:	48 85 c0             	test   rax,rax
  209128:	0f 88 97 01 00 00    	js     2092c5 <Futex+0xcf5>
  20912e:	c5 fb 58 db          	vaddsd xmm3,xmm0,xmm3
  209132:	c5 e3 58 d2          	vaddsd xmm2,xmm3,xmm2
    } else {
        @setFloatMode(this, builtin.FloatMode.Strict);
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  209136:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  20913d:	0f 87 97 01 00 00    	ja     2092da <Futex+0xd0a>
    if (u >> 63 != 0) {
  209143:	48 85 c0             	test   rax,rax
        math.forceEval(y);
        if (u >> 63 != 0) {
  209146:	0f 88 b9 06 00 00    	js     209805 <Futex+0x1235>
  20914c:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  209150:	e9 be 06 00 00       	jmp    209813 <Futex+0x1243>
  209155:	4c 89 fd             	mov    rbp,r15
  209158:	48 29 f5             	sub    rbp,rsi
  20915b:	31 ff                	xor    edi,edi
  20915d:	0f b6 1c 3a          	movzx  ebx,BYTE PTR [rdx+rdi*1]
        dest[i] = s;
  209161:	88 5c 3c 31          	mov    BYTE PTR [rsp+rdi*1+0x31],bl
    for (source) |s, i|
  209165:	0f b6 5c 3a 01       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x1]
        dest[i] = s;
  20916a:	88 5c 3c 32          	mov    BYTE PTR [rsp+rdi*1+0x32],bl
    for (source) |s, i|
  20916e:	0f b6 5c 3a 02       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x2]
        dest[i] = s;
  209173:	88 5c 3c 33          	mov    BYTE PTR [rsp+rdi*1+0x33],bl
    for (source) |s, i|
  209177:	0f b6 5c 3a 03       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x3]
        dest[i] = s;
  20917c:	88 5c 3c 34          	mov    BYTE PTR [rsp+rdi*1+0x34],bl
    for (source) |s, i|
  209180:	0f b6 5c 3a 04       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x4]
        dest[i] = s;
  209185:	88 5c 3c 35          	mov    BYTE PTR [rsp+rdi*1+0x35],bl
    for (source) |s, i|
  209189:	0f b6 5c 3a 05       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x5]
        dest[i] = s;
  20918e:	88 5c 3c 36          	mov    BYTE PTR [rsp+rdi*1+0x36],bl
    for (source) |s, i|
  209192:	0f b6 5c 3a 06       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x6]
        dest[i] = s;
  209197:	88 5c 3c 37          	mov    BYTE PTR [rsp+rdi*1+0x37],bl
    for (source) |s, i|
  20919b:	0f b6 5c 3a 07       	movzx  ebx,BYTE PTR [rdx+rdi*1+0x7]
        dest[i] = s;
  2091a0:	88 5c 3c 38          	mov    BYTE PTR [rsp+rdi*1+0x38],bl
    for (source) |s, i|
  2091a4:	48 83 c7 08          	add    rdi,0x8
  2091a8:	48 39 fd             	cmp    rbp,rdi
  2091ab:	75 b0                	jne    20915d <Futex+0xb8d>
  2091ad:	48 8d 6c 24 31       	lea    rbp,[rsp+0x31]
  2091b2:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
  2091b7:	48 85 f6             	test   rsi,rsi
  2091ba:	74 1e                	je     2091da <Futex+0xc0a>
  2091bc:	48 8d 2c 3c          	lea    rbp,[rsp+rdi*1]
  2091c0:	48 83 c5 31          	add    rbp,0x31
  2091c4:	48 01 fa             	add    rdx,rdi
  2091c7:	31 ff                	xor    edi,edi
  2091c9:	0f b6 1c 3a          	movzx  ebx,BYTE PTR [rdx+rdi*1]
        dest[i] = s;
  2091cd:	88 5c 3d 00          	mov    BYTE PTR [rbp+rdi*1+0x0],bl
    for (source) |s, i|
  2091d1:	48 83 c7 01          	add    rdi,0x1
  2091d5:	48 39 fe             	cmp    rsi,rdi
  2091d8:	75 ef                	jne    2091c9 <Futex+0xbf9>
  2091da:	44 8b 64 c1 10       	mov    r12d,DWORD PTR [rcx+rax*8+0x10]
            if (float_decimal.exp >= 0) {
  2091df:	45 85 e4             	test   r12d,r12d
  2091e2:	0f 89 52 03 00 00    	jns    20953a <Futex+0xf6a>
                const min_exp_required = @intCast(usize, -float_decimal.exp);
  2091e8:	44 89 e0             	mov    eax,r12d
  2091eb:	f7 d8                	neg    eax
                if (precision > min_exp_required) {
  2091ed:	83 f8 05             	cmp    eax,0x5
  2091f0:	77 18                	ja     20920a <Futex+0xc3a>
                const min_exp_required = @intCast(usize, -float_decimal.exp);
  2091f2:	48 98                	cdqe   
                    round_digit = precision - min_exp_required;
  2091f4:	b9 06 00 00 00       	mov    ecx,0x6
  2091f9:	48 29 c1             	sub    rcx,rax
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  2091fc:	4c 39 f9             	cmp    rcx,r15
  2091ff:	0f 82 45 03 00 00    	jb     20954a <Futex+0xf7a>
  209205:	e9 db 03 00 00       	jmp    2095e5 <Futex+0x1015>
  20920a:	31 c9                	xor    ecx,ecx
  20920c:	4c 39 f9             	cmp    rcx,r15
  20920f:	0f 83 d0 03 00 00    	jae    2095e5 <Futex+0x1015>
  209215:	e9 30 03 00 00       	jmp    20954a <Futex+0xf7a>
        while (i < mi) : (i += 1) {
  20921a:	89 ce                	mov    esi,ecx
  20921c:	83 e6 f0             	and    esi,0xfffffff0
  20921f:	8d 7e f0             	lea    edi,[rsi-0x10]
  209222:	89 fa                	mov    edx,edi
  209224:	c1 ea 04             	shr    edx,0x4
  209227:	44 8d 42 01          	lea    r8d,[rdx+0x1]
  20922b:	83 ff 70             	cmp    edi,0x70
  20922e:	0f 83 c5 00 00 00    	jae    2092f9 <Futex+0xd29>
  209234:	c4 e2 7d 59 0d 03 7a 	vpbroadcastq ymm1,QWORD PTR [rip+0xffffffffffff7a03]        # 200c40 <app_mask+0x8>
  20923b:	ff ff 
  20923d:	c5 fd 6f d9          	vmovdqa ymm3,ymm1
  209241:	c5 fd 6f d1          	vmovdqa ymm2,ymm1
  209245:	c5 fd 6f c1          	vmovdqa ymm0,ymm1
  209249:	41 f6 c0 07          	test   r8b,0x7
  20924d:	0f 85 32 01 00 00    	jne    209385 <Futex+0xdb5>
  209253:	e9 a6 01 00 00       	jmp    2093fe <Futex+0xe2e>
        while (buffer[j - 1] == '0') {
  209258:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  20925d:	42 80 7c 21 ff 30    	cmp    BYTE PTR [rcx+r12*1-0x1],0x30
  209263:	0f 85 77 05 00 00    	jne    2097e0 <Futex+0x1210>
  209269:	49 8d 44 24 ff       	lea    rax,[r12-0x1]
  20926e:	4c 01 e1             	add    rcx,r12
  209271:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  209275:	4d 89 e7             	mov    r15,r12
            buffer[j - 1] = 0;
  209278:	c6 01 00             	mov    BYTE PTR [rcx],0x0
        while (buffer[j - 1] == '0') {
  20927b:	48 8b 54 24 20       	mov    rdx,QWORD PTR [rsp+0x20]
  209280:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  209284:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  209288:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20928c:	42 80 7c 3a fe 30    	cmp    BYTE PTR [rdx+r15*1-0x2],0x30
  209292:	4d 8d 7f ff          	lea    r15,[r15-0x1]
  209296:	74 e0                	je     209278 <Futex+0xca8>
  209298:	e9 46 05 00 00       	jmp    2097e3 <Futex+0x1213>
        } else if ((mid == 0.5) and (buffer[j - 1] & 0x1) != 0) {
  20929d:	0f 85 40 05 00 00    	jne    2097e3 <Futex+0x1213>
  2092a3:	0f 8a 3a 05 00 00    	jp     2097e3 <Futex+0x1213>
  2092a9:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  2092ae:	8a 14 01             	mov    dl,BYTE PTR [rcx+rax*1]
  2092b1:	f6 c2 01             	test   dl,0x1
  2092b4:	0f 84 29 05 00 00    	je     2097e3 <Futex+0x1213>
            buffer[j - 1] += 1;
  2092ba:	80 c2 01             	add    dl,0x1
  2092bd:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
  2092c0:	e9 1e 05 00 00       	jmp    2097e3 <Futex+0x1213>
  2092c5:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  2092c9:	c5 eb 58 d3          	vaddsd xmm2,xmm2,xmm3
    if (e <= 0x3FF - 1) {
  2092cd:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  2092d4:	0f 86 69 fe ff ff    	jbe    209143 <Futex+0xb73>
  2092da:	c5 eb 5c c0          	vsubsd xmm0,xmm2,xmm0
            return -1.0;
        } else {
            return 0.0;
        }
    } else if (y > 0) {
  2092de:	c5 e1 57 db          	vxorpd xmm3,xmm3,xmm3
  2092e2:	c5 f9 2e c3          	vucomisd xmm0,xmm3
  2092e6:	0f 86 23 05 00 00    	jbe    20980f <Futex+0x123f>
        return x + y - 1;
  2092ec:	c5 eb 58 05 0c 79 ff 	vaddsd xmm0,xmm2,QWORD PTR [rip+0xffffffffffff790c]        # 200c00 <__unnamed_441+0x60>
  2092f3:	ff 
  2092f4:	e9 1a 05 00 00       	jmp    209813 <Futex+0x1243>
        while (i < mi) : (i += 1) {
  2092f9:	44 89 c7             	mov    edi,r8d
  2092fc:	83 e7 07             	and    edi,0x7
  2092ff:	83 c7 ff             	add    edi,0xffffffff
  209302:	29 d7                	sub    edi,edx
  209304:	c4 e2 7d 59 0d 33 79 	vpbroadcastq ymm1,QWORD PTR [rip+0xffffffffffff7933]        # 200c40 <app_mask+0x8>
  20930b:	ff ff 
  20930d:	c4 e2 7d 59 25 ca 78 	vpbroadcastq ymm4,QWORD PTR [rip+0xffffffffffff78ca]        # 200be0 <__unnamed_441+0x40>
  209314:	ff ff 
  209316:	c5 fd 6f d9          	vmovdqa ymm3,ymm1
  20931a:	c5 fd 6f d1          	vmovdqa ymm2,ymm1
  20931e:	c5 fd 6f c1          	vmovdqa ymm0,ymm1
            x *= 10;
  209322:	c5 f5 f4 ec          	vpmuludq ymm5,ymm1,ymm4
  209326:	c5 f5 73 d1 20       	vpsrlq ymm1,ymm1,0x20
  20932b:	c5 f5 f4 cc          	vpmuludq ymm1,ymm1,ymm4
  20932f:	c5 f5 73 f1 20       	vpsllq ymm1,ymm1,0x20
  209334:	c5 d5 d4 c9          	vpaddq ymm1,ymm5,ymm1
  209338:	c5 e5 f4 ec          	vpmuludq ymm5,ymm3,ymm4
  20933c:	c5 e5 73 d3 20       	vpsrlq ymm3,ymm3,0x20
  209341:	c5 e5 f4 dc          	vpmuludq ymm3,ymm3,ymm4
  209345:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  20934a:	c5 d5 d4 db          	vpaddq ymm3,ymm5,ymm3
  20934e:	c5 ed f4 ec          	vpmuludq ymm5,ymm2,ymm4
  209352:	c5 ed 73 d2 20       	vpsrlq ymm2,ymm2,0x20
  209357:	c5 ed f4 d4          	vpmuludq ymm2,ymm2,ymm4
  20935b:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  209360:	c5 d5 d4 d2          	vpaddq ymm2,ymm5,ymm2
  209364:	c5 fd f4 ec          	vpmuludq ymm5,ymm0,ymm4
  209368:	c5 fd 73 d0 20       	vpsrlq ymm0,ymm0,0x20
  20936d:	c5 fd f4 c4          	vpmuludq ymm0,ymm0,ymm4
  209371:	c5 fd 73 f0 20       	vpsllq ymm0,ymm0,0x20
  209376:	c5 d5 d4 c0          	vpaddq ymm0,ymm5,ymm0
  20937a:	83 c7 08             	add    edi,0x8
  20937d:	75 a3                	jne    209322 <Futex+0xd52>
  20937f:	41 f6 c0 07          	test   r8b,0x7
  209383:	74 79                	je     2093fe <Futex+0xe2e>
  209385:	89 ca                	mov    edx,ecx
  209387:	83 e2 70             	and    edx,0x70
  20938a:	83 c2 f0             	add    edx,0xfffffff0
  20938d:	c1 ea 04             	shr    edx,0x4
  209390:	83 c2 01             	add    edx,0x1
  209393:	83 e2 07             	and    edx,0x7
  209396:	f7 da                	neg    edx
  209398:	c4 e2 7d 59 25 2f 78 	vpbroadcastq ymm4,QWORD PTR [rip+0xffffffffffff782f]        # 200bd0 <__unnamed_441+0x30>
  20939f:	ff ff 
  2093a1:	c5 f5 f4 ec          	vpmuludq ymm5,ymm1,ymm4
  2093a5:	c5 f5 73 d1 20       	vpsrlq ymm1,ymm1,0x20
  2093aa:	c5 f5 f4 cc          	vpmuludq ymm1,ymm1,ymm4
  2093ae:	c5 f5 73 f1 20       	vpsllq ymm1,ymm1,0x20
  2093b3:	c5 d5 d4 c9          	vpaddq ymm1,ymm5,ymm1
  2093b7:	c5 e5 f4 ec          	vpmuludq ymm5,ymm3,ymm4
  2093bb:	c5 e5 73 d3 20       	vpsrlq ymm3,ymm3,0x20
  2093c0:	c5 e5 f4 dc          	vpmuludq ymm3,ymm3,ymm4
  2093c4:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  2093c9:	c5 d5 d4 db          	vpaddq ymm3,ymm5,ymm3
  2093cd:	c5 ed f4 ec          	vpmuludq ymm5,ymm2,ymm4
  2093d1:	c5 ed 73 d2 20       	vpsrlq ymm2,ymm2,0x20
  2093d6:	c5 ed f4 d4          	vpmuludq ymm2,ymm2,ymm4
  2093da:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  2093df:	c5 d5 d4 d2          	vpaddq ymm2,ymm5,ymm2
  2093e3:	c5 fd f4 ec          	vpmuludq ymm5,ymm0,ymm4
  2093e7:	c5 fd 73 d0 20       	vpsrlq ymm0,ymm0,0x20
  2093ec:	c5 fd f4 c4          	vpmuludq ymm0,ymm0,ymm4
  2093f0:	c5 fd 73 f0 20       	vpsllq ymm0,ymm0,0x20
  2093f5:	c5 d5 d4 c0          	vpaddq ymm0,ymm5,ymm0
  2093f9:	83 c2 01             	add    edx,0x1
  2093fc:	75 a3                	jne    2093a1 <Futex+0xdd1>
  2093fe:	c5 dd 73 d3 20       	vpsrlq ymm4,ymm3,0x20
  209403:	c5 dd f4 e1          	vpmuludq ymm4,ymm4,ymm1
  209407:	c5 d5 73 d1 20       	vpsrlq ymm5,ymm1,0x20
  20940c:	c5 e5 f4 ed          	vpmuludq ymm5,ymm3,ymm5
  209410:	c5 d5 d4 e4          	vpaddq ymm4,ymm5,ymm4
  209414:	c5 dd 73 f4 20       	vpsllq ymm4,ymm4,0x20
  209419:	c5 e5 f4 c9          	vpmuludq ymm1,ymm3,ymm1
  20941d:	c5 f5 d4 cc          	vpaddq ymm1,ymm1,ymm4
  209421:	c5 e5 73 d2 20       	vpsrlq ymm3,ymm2,0x20
  209426:	c5 e5 f4 d9          	vpmuludq ymm3,ymm3,ymm1
  20942a:	c5 dd 73 d1 20       	vpsrlq ymm4,ymm1,0x20
  20942f:	c5 ed f4 e4          	vpmuludq ymm4,ymm2,ymm4
  209433:	c5 dd d4 db          	vpaddq ymm3,ymm4,ymm3
  209437:	c5 e5 73 f3 20       	vpsllq ymm3,ymm3,0x20
  20943c:	c5 ed f4 c9          	vpmuludq ymm1,ymm2,ymm1
  209440:	c5 f5 d4 cb          	vpaddq ymm1,ymm1,ymm3
  209444:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  209449:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  20944d:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  209452:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  209456:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  20945a:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  20945f:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  209463:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  209467:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  20946d:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  209472:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  209476:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  20947b:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  20947f:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  209483:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  209488:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  20948c:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  209490:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  209495:	c5 ed 73 d0 20       	vpsrlq ymm2,ymm0,0x20
  20949a:	c5 ed f4 d1          	vpmuludq ymm2,ymm2,ymm1
  20949e:	c5 e5 73 d1 20       	vpsrlq ymm3,ymm1,0x20
  2094a3:	c5 fd f4 db          	vpmuludq ymm3,ymm0,ymm3
  2094a7:	c5 e5 d4 d2          	vpaddq ymm2,ymm3,ymm2
  2094ab:	c5 ed 73 f2 20       	vpsllq ymm2,ymm2,0x20
  2094b0:	c5 fd f4 c1          	vpmuludq ymm0,ymm0,ymm1
  2094b4:	c5 fd d4 c2          	vpaddq ymm0,ymm0,ymm2
  2094b8:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  2094bd:	39 f1                	cmp    ecx,esi
        while (i < mi) : (i += 1) {
  2094bf:	74 14                	je     2094d5 <Futex+0xf05>
  2094c1:	09 c6                	or     esi,eax
  2094c3:	89 f0                	mov    eax,esi
            x *= 10;
  2094c5:	f7 d8                	neg    eax
  2094c7:	29 d8                	sub    eax,ebx
  2094c9:	48 01 d2             	add    rdx,rdx
  2094cc:	48 8d 14 92          	lea    rdx,[rdx+rdx*4]
        while (i < mi) : (i += 1) {
  2094d0:	83 c0 ff             	add    eax,0xffffffff
  2094d3:	75 f4                	jne    2094c9 <Futex+0xef9>
    const m64 = @truncate(u64, @divTrunc(mid, x));
  2094d5:	31 c9                	xor    ecx,ecx
  2094d7:	48 8b 7c 24 50       	mov    rdi,QWORD PTR [rsp+0x50]
  2094dc:	48 8b 74 24 60       	mov    rsi,QWORD PTR [rsp+0x60]
  2094e1:	c5 f8 77             	vzeroupper 
  2094e4:	e8 47 32 01 00       	call   21c730 <__udivti3>
    if (lf != hf) {
  2094e9:	4c 39 6c 24 10       	cmp    QWORD PTR [rsp+0x10],r13
    if (lf != hf) mi += 19;
  2094ee:	44 0f 45 e5          	cmovne r12d,ebp
  2094f2:	48 8d 74 24 20       	lea    rsi,[rsp+0x20]
    var buf_index = u64toa(m64, buffer) - 1;
  2094f7:	48 89 c7             	mov    rdi,rax
  2094fa:	e8 d1 ed 00 00       	call   2182d0 <u64toa>
  2094ff:	49 89 c7             	mov    r15,rax
    if (mi != 0) {
  209502:	45 85 e4             	test   r12d,r12d
  209505:	74 1d                	je     209524 <Futex+0xf54>
  209507:	4c 89 f8             	mov    rax,r15
  20950a:	48 83 c0 ff          	add    rax,0xffffffffffffffff
        buffer[buf_index - 1] += @boolToInt(buffer[buf_index] >= '5');
  20950e:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  209513:	42 80 7c 39 ff 34    	cmp    BYTE PTR [rcx+r15*1-0x1],0x34
  209519:	0f 97 c2             	seta   dl
  20951c:	42 00 54 39 fe       	add    BYTE PTR [rcx+r15*1-0x2],dl
  209521:	49 89 c7             	mov    r15,rax
        .digits = buffer[0..buf_index],
  209524:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        .exp = @intCast(i32, buf_index) + mi,
  209529:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20952e:	45 01 fc             	add    r12d,r15d
            if (float_decimal.exp >= 0) {
  209531:	45 85 e4             	test   r12d,r12d
  209534:	0f 88 ae fc ff ff    	js     2091e8 <Futex+0xc18>
                round_digit = precision + @intCast(usize, float_decimal.exp);
  20953a:	49 63 cc             	movsxd rcx,r12d
  20953d:	48 83 c1 06          	add    rcx,0x6
    if (round_digit < float_decimal.digits.len and float_decimal.digits[round_digit] - '0' >= 5) {
  209541:	4c 39 f9             	cmp    rcx,r15
  209544:	0f 83 9b 00 00 00    	jae    2095e5 <Futex+0x1015>
  20954a:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  20954f:	8a 04 08             	mov    al,BYTE PTR [rax+rcx*1]
  209552:	04 d0                	add    al,0xd0
  209554:	3c 05                	cmp    al,0x5
  209556:	0f 82 89 00 00 00    	jb     2095e5 <Futex+0x1015>
            if (i == 0) {
  20955c:	48 85 c9             	test   rcx,rcx
  20955f:	74 6a                	je     2095cb <Futex+0xffb>
  209561:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  209566:	8a 44 0f ff          	mov    al,BYTE PTR [rdi+rcx*1-0x1]
  20956a:	04 d1                	add    al,0xd1
  20956c:	0f b6 f0             	movzx  esi,al
  20956f:	69 c6 cd 00 00 00    	imul   eax,esi,0xcd
  209575:	ba 0b 05 00 00       	mov    edx,0x50b
  20957a:	c4 e2 68 f7 c0       	bextr  eax,eax,edx
  20957f:	b3 0a                	mov    bl,0xa
  209581:	f6 e3                	mul    bl
  209583:	40 28 c6             	sub    sil,al
            float_decimal.digits[i] = new_value + '0';
  209586:	89 f0                	mov    eax,esi
  209588:	0c 30                	or     al,0x30
  20958a:	88 44 0f ff          	mov    BYTE PTR [rdi+rcx*1-0x1],al
            if (new_value != 0) {
  20958e:	40 84 f6             	test   sil,sil
  209591:	75 52                	jne    2095e5 <Futex+0x1015>
  209593:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
            if (i == 0) {
  209598:	48 83 f9 01          	cmp    rcx,0x1
  20959c:	74 2d                	je     2095cb <Futex+0xffb>
            const new_value = (float_decimal.digits[i] - '0' + 1) % 10;
  20959e:	0f b6 44 0f fe       	movzx  eax,BYTE PTR [rdi+rcx*1-0x2]
  2095a3:	04 d1                	add    al,0xd1
  2095a5:	0f b6 f0             	movzx  esi,al
  2095a8:	69 c6 cd 00 00 00    	imul   eax,esi,0xcd
  2095ae:	c4 e2 68 f7 c0       	bextr  eax,eax,edx
  2095b3:	f6 e3                	mul    bl
  2095b5:	40 28 c6             	sub    sil,al
            float_decimal.digits[i] = new_value + '0';
  2095b8:	89 f0                	mov    eax,esi
  2095ba:	0c 30                	or     al,0x30
  2095bc:	88 44 0f fe          	mov    BYTE PTR [rdi+rcx*1-0x2],al
            if (new_value != 0) {
  2095c0:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  2095c4:	40 84 f6             	test   sil,sil
  2095c7:	74 cf                	je     209598 <Futex+0xfc8>
  2095c9:	eb 1a                	jmp    2095e5 <Futex+0x1015>
                float_decimal.exp += 1;
  2095cb:	41 83 c4 01          	add    r12d,0x1
                float_decimal.digits = one_before[0 .. float_decimal.digits.len + 1];
  2095cf:	49 83 c7 01          	add    r15,0x1
  2095d3:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
                float_decimal.digits[0] = '1';
  2095d8:	c6 40 ff 31          	mov    BYTE PTR [rax-0x1],0x31
                const one_before = @intToPtr([*]u8, @ptrToInt(&float_decimal.digits[0]) - 1);
  2095dc:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  2095e0:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax

    if (maybe_precision) |precision| {
        errol.roundToPrecision(&float_decimal, precision, errol.RoundMode.Decimal);

        // exp < 0 means the leading is always 0 as errol result is normalized.
        var num_digits_whole = if (float_decimal.exp > 0) @intCast(usize, float_decimal.exp) else 0;
  2095e5:	45 31 ed             	xor    r13d,r13d
  2095e8:	45 85 e4             	test   r12d,r12d
  2095eb:	44 89 e0             	mov    eax,r12d
  2095ee:	4c 0f 4f e8          	cmovg  r13,rax
        else => @compileError("unknown floating point type " ++ @typeName(T)),
    };
}

pub fn min(x: var, y: var) @typeOf(x + y) {
    return if (x < y) x else y;
  2095f2:	4d 39 fd             	cmp    r13,r15
  2095f5:	4c 89 f9             	mov    rcx,r15
  2095f8:	49 0f 42 cd          	cmovb  rcx,r13
  2095fc:	45 85 e4             	test   r12d,r12d

        // the actual slice into the buffer, we may need to zero-pad between num_digits_whole and this.
        var num_digits_whole_no_pad = math.min(num_digits_whole, float_decimal.digits.len);

        if (num_digits_whole > 0) {
  2095ff:	48 89 4c 24 50       	mov    QWORD PTR [rsp+0x50],rcx
  209604:	7e 57                	jle    20965d <Futex+0x108d>
            // We may have to zero pad, for instance 1e4 requires zero padding.
            try output(context, float_decimal.digits[0..num_digits_whole_no_pad]);
  209606:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  20960b:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  209612:	00 
  209613:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20961a:	00 
  20961b:	48 8d b4 24 98 00 00 	lea    rsi,[rsp+0x98]
  209622:	00 
  209623:	4c 89 f7             	mov    rdi,r14
  209626:	c5 f8 77             	vzeroupper 
  209629:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  20962d:	66 85 c0             	test   ax,ax
  209630:	75 54                	jne    209686 <Futex+0x10b6>

            var i = num_digits_whole_no_pad;
            while (i < num_digits_whole) : (i += 1) {
  209632:	4d 39 fd             	cmp    r13,r15
  209635:	76 3c                	jbe    209673 <Futex+0x10a3>
  209637:	48 8d 2d ea 77 01 00 	lea    rbp,[rip+0x177ea]        # 220e28 <__unnamed_7>
  20963e:	48 8b 5c 24 50       	mov    rbx,QWORD PTR [rsp+0x50]
                try output(context, "0");
  209643:	4c 89 f7             	mov    rdi,r14
  209646:	48 89 ee             	mov    rsi,rbp
  209649:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  20964d:	66 85 c0             	test   ax,ax
  209650:	75 34                	jne    209686 <Futex+0x10b6>
  209652:	48 83 c3 01          	add    rbx,0x1
            while (i < num_digits_whole) : (i += 1) {
  209656:	4c 39 eb             	cmp    rbx,r13
  209659:	72 e8                	jb     209643 <Futex+0x1073>
  20965b:	eb 16                	jmp    209673 <Futex+0x10a3>
            }
        } else {
            try output(context, "0");
  20965d:	48 8d 35 c4 77 01 00 	lea    rsi,[rip+0x177c4]        # 220e28 <__unnamed_7>
  209664:	4c 89 f7             	mov    rdi,r14
  209667:	c5 f8 77             	vzeroupper 
  20966a:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  20966e:	66 85 c0             	test   ax,ax
  209671:	75 13                	jne    209686 <Futex+0x10b6>
        // {.0} special case doesn't want a trailing '.'
        if (precision == 0) {
            return;
        }

        try output(context, ".");
  209673:	48 8d 35 9e 77 01 00 	lea    rsi,[rip+0x1779e]        # 220e18 <__unnamed_8>
  20967a:	4c 89 f7             	mov    rdi,r14
  20967d:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  209681:	66 85 c0             	test   ax,ax
  209684:	74 31                	je     2096b7 <Futex+0x10e7>
  209686:	4c 8b 64 24 08       	mov    r12,QWORD PTR [rsp+0x8]
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20968b:	66 85 c0             	test   ax,ax
  20968e:	0f 85 11 f4 ff ff    	jne    208aa5 <Futex+0x4d5>
        try output(context, fmt[start_index..]);
  209694:	48 8d 35 0d 75 01 00 	lea    rsi,[rip+0x1750d]        # 220ba8 <__unnamed_10>
  20969b:	4c 89 f7             	mov    rdi,r14
  20969e:	41 ff d4             	call   r12
    assert(gCounter == max_counter * 2);
  2096a1:	48 81 3d 74 79 01 00 	cmp    QWORD PTR [rip+0x17974],0x1312d00        # 221020 <gCounter>
  2096a8:	00 2d 31 01 
  2096ac:	0f 84 04 f4 ff ff    	je     208ab6 <Futex+0x4e6>
            @panic("assertion failure");
  2096b2:	e8 f9 05 00 00       	call   209cb0 <panic>

        // Keep track of fractional count printed for case where we pre-pad then post-pad with 0's.
        var printed: usize = 0;

        // Zero-fill until we reach significant digits or run out of precision.
        if (float_decimal.exp <= 0) {
  2096b7:	45 85 e4             	test   r12d,r12d
  2096ba:	0f 8e b3 00 00 00    	jle    209773 <Futex+0x11a3>
  2096c0:	45 31 e4             	xor    r12d,r12d
            }
        }

        // Remaining fractional portion, zero-padding if insufficient.
        debug.assert(precision >= printed);
        if (num_digits_whole_no_pad + precision - printed < float_decimal.digits.len) {
  2096c3:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  2096c8:	48 8d 40 06          	lea    rax,[rax+0x6]
  2096cc:	4c 29 e0             	sub    rax,r12
  2096cf:	4c 39 f8             	cmp    rax,r15
  2096d2:	73 35                	jae    209709 <Futex+0x1139>
  2096d4:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  2096d9:	48 8b 54 24 50       	mov    rdx,QWORD PTR [rsp+0x50]
            try output(context, float_decimal.digits[num_digits_whole_no_pad .. num_digits_whole_no_pad + precision - printed]);
  2096de:	48 01 d1             	add    rcx,rdx
  2096e1:	48 89 8c 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rcx
  2096e8:	00 
  2096e9:	48 29 d0             	sub    rax,rdx
  2096ec:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  2096f3:	00 
  2096f4:	48 8d b4 24 88 00 00 	lea    rsi,[rsp+0x88]
  2096fb:	00 
  2096fc:	4c 89 f7             	mov    rdi,r14
  2096ff:	4c 8b 64 24 08       	mov    r12,QWORD PTR [rsp+0x8]
  209704:	e9 45 f4 ff ff       	jmp    208b4e <Futex+0x57e>
  209709:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  20970e:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
            return;
        } else {
            try output(context, float_decimal.digits[num_digits_whole_no_pad..]);
  209713:	48 01 c8             	add    rax,rcx
  209716:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  20971b:	49 29 cf             	sub    r15,rcx
  20971e:	4c 89 bc 24 80 00 00 	mov    QWORD PTR [rsp+0x80],r15
  209725:	00 
  209726:	48 8d 74 24 78       	lea    rsi,[rsp+0x78]
  20972b:	4c 89 f7             	mov    rdi,r14
  20972e:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  209732:	66 85 c0             	test   ax,ax
  209735:	0f 85 4b ff ff ff    	jne    209686 <Futex+0x10b6>
            printed += float_decimal.digits.len - num_digits_whole_no_pad;
  20973b:	4d 01 fc             	add    r12,r15

            while (printed < precision) : (printed += 1) {
  20973e:	49 83 fc 05          	cmp    r12,0x5
  209742:	0f 87 83 00 00 00    	ja     2097cb <Futex+0x11fb>
  209748:	48 8d 1d d9 76 01 00 	lea    rbx,[rip+0x176d9]        # 220e28 <__unnamed_7>
                try output(context, "0");
  20974f:	4c 89 f7             	mov    rdi,r14
  209752:	48 89 de             	mov    rsi,rbx
  209755:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  209759:	66 85 c0             	test   ax,ax
  20975c:	0f 85 24 ff ff ff    	jne    209686 <Futex+0x10b6>
  209762:	49 83 c4 01          	add    r12,0x1
  209766:	31 c0                	xor    eax,eax
            while (printed < precision) : (printed += 1) {
  209768:	49 83 fc 05          	cmp    r12,0x5
  20976c:	76 e1                	jbe    20974f <Futex+0x117f>
  20976e:	e9 13 ff ff ff       	jmp    209686 <Futex+0x10b6>
            const zero_digit_count = @intCast(usize, -float_decimal.exp);
  209773:	41 f7 dc             	neg    r12d
  209776:	49 63 c4             	movsxd rax,r12d
  209779:	48 83 f8 06          	cmp    rax,0x6
  20977d:	41 bd 06 00 00 00    	mov    r13d,0x6
  209783:	4c 0f 42 e8          	cmovb  r13,rax
            while (i < zeros_to_print) : (i += 1) {
  209787:	4d 85 ed             	test   r13,r13
  20978a:	0f 84 30 ff ff ff    	je     2096c0 <Futex+0x10f0>
  209790:	48 c7 c5 ff ff ff ff 	mov    rbp,0xffffffffffffffff
  209797:	48 8d 1d 8a 76 01 00 	lea    rbx,[rip+0x1768a]        # 220e28 <__unnamed_7>
                try output(context, "0");
  20979e:	4c 89 f7             	mov    rdi,r14
  2097a1:	48 89 de             	mov    rsi,rbx
  2097a4:	ff 54 24 08          	call   QWORD PTR [rsp+0x8]
  2097a8:	66 85 c0             	test   ax,ax
  2097ab:	0f 85 d5 fe ff ff    	jne    209686 <Futex+0x10b6>
            while (i < zeros_to_print) : (i += 1) {
  2097b1:	4c 8d 65 01          	lea    r12,[rbp+0x1]
  2097b5:	48 83 c5 02          	add    rbp,0x2
  2097b9:	4c 39 ed             	cmp    rbp,r13
  2097bc:	4c 89 e5             	mov    rbp,r12
  2097bf:	72 dd                	jb     20979e <Futex+0x11ce>
            if (printed >= precision) {
  2097c1:	49 83 fc 04          	cmp    r12,0x4
  2097c5:	0f 86 d4 04 00 00    	jbe    209c9f <Futex+0x16cf>
  2097cb:	31 c0                	xor    eax,eax
  2097cd:	4c 8b 64 24 08       	mov    r12,QWORD PTR [rsp+0x8]
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  2097d2:	66 85 c0             	test   ax,ax
  2097d5:	0f 85 ca f2 ff ff    	jne    208aa5 <Futex+0x4d5>
  2097db:	e9 b4 fe ff ff       	jmp    209694 <Futex+0x10c4>
  2097e0:	4d 89 e7             	mov    r15,r12
    buffer[j] = 0;
  2097e3:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  2097e8:	42 c6 04 38 00       	mov    BYTE PTR [rax+r15*1],0x0
        .digits = buffer[0..j],
  2097ed:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  2097f2:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
            if (float_decimal.exp >= 0) {
  2097f7:	45 85 e4             	test   r12d,r12d
  2097fa:	0f 89 3a fd ff ff    	jns    20953a <Futex+0xf6a>
  209800:	e9 e3 f9 ff ff       	jmp    2091e8 <Futex+0xc18>
  209805:	c5 fb 10 05 f3 73 ff 	vmovsd xmm0,QWORD PTR [rip+0xffffffffffff73f3]        # 200c00 <__unnamed_441+0x60>
  20980c:	ff 
  20980d:	eb 04                	jmp    209813 <Futex+0x1243>
  20980f:	c5 f9 28 c2          	vmovapd xmm0,xmm2
    var exp = @floatToInt(i16, math.floor(307 + @intToFloat(f64, e) * 0.30103));
  209813:	c5 fb 2c c0          	vcvttsd2si eax,xmm0
    if (exp < 20) {
  209817:	98                   	cwde   
    } else if (@intCast(usize, exp) >= lookup_table.len) {
  209818:	0f b7 c8             	movzx  ecx,ax
  20981b:	81 f9 57 02 00 00    	cmp    ecx,0x257
  209821:	66 b9 57 02          	mov    cx,0x257
  209825:	66 0f 42 c8          	cmovb  cx,ax
    if (exp < 20) {
  209829:	83 f8 14             	cmp    eax,0x14
  20982c:	66 b8 14 00          	mov    ax,0x14
  209830:	66 0f 4d c1          	cmovge ax,cx
    var mid = lookup_table[@intCast(usize, exp)];
  209834:	0f b7 c8             	movzx  ecx,ax
  209837:	48 c1 e1 04          	shl    rcx,0x4
  20983b:	48 8d 15 06 a2 ff ff 	lea    rdx,[rip+0xffffffffffffa206]        # 203a48 <lookup_table.15>
  209842:	c5 7b 10 04 11       	vmovsd xmm8,QWORD PTR [rcx+rdx*1]
  209847:	c5 f9 28 44 24 10    	vmovapd xmm0,XMMWORD PTR [rsp+0x10]
    const p = in.val * val;
  20984d:	c5 bb 59 d8          	vmulsd xmm3,xmm8,xmm0
        .off = in.off * val + e,
  209851:	c5 fb 59 54 11 08    	vmulsd xmm2,xmm0,QWORD PTR [rcx+rdx*1+0x8]
    exp -= 307;
  209857:	8d 80 cd fe ff ff    	lea    eax,[rax-0x133]
    while (mid.val > 10.0 or (mid.val == 10.0 and mid.off >= 0.0)) {
  20985d:	44 0f bf e0          	movsx  r12d,ax
  209861:	c5 fb 10 35 6f 73 ff 	vmovsd xmm6,QWORD PTR [rip+0xffffffffffff736f]        # 200bd8 <__unnamed_441+0x38>
  209868:	ff 
  209869:	c5 fb 10 05 4f 73 ff 	vmovsd xmm0,QWORD PTR [rip+0xffffffffffff734f]        # 200bc0 <__unnamed_441+0x20>
  209870:	ff 
  209871:	c5 fb 10 2d d7 73 ff 	vmovsd xmm5,QWORD PTR [rip+0xffffffffffff73d7]        # 200c50 <app_mask+0x18>
  209878:	ff 
  209879:	c5 fb 10 3d 8f 73 ff 	vmovsd xmm7,QWORD PTR [rip+0xffffffffffff738f]        # 200c10 <__unnamed_441+0x70>
  209880:	ff 
  209881:	c5 f9 2e d8          	vucomisd xmm3,xmm0
  209885:	76 27                	jbe    2098ae <Futex+0x12de>
    hp.val /= 10.0;
  209887:	c5 e3 59 e5          	vmulsd xmm4,xmm3,xmm5
    hp.off += val / 10.0;
  20988b:	c5 e3 59 df          	vmulsd xmm3,xmm3,xmm7
  20988f:	c4 e2 d1 a9 d3       	vfmadd213sd xmm2,xmm5,xmm3
    hp.val += hp.off;
  209894:	c5 db 58 da          	vaddsd xmm3,xmm4,xmm2
    hp.off += val - hp.val;
  209898:	c5 db 5c e3          	vsubsd xmm4,xmm4,xmm3
  20989c:	c5 eb 58 d4          	vaddsd xmm2,xmm2,xmm4
        ten /= 10.0;
  2098a0:	c5 cb 59 f5          	vmulsd xmm6,xmm6,xmm5
    while (mid.val > 10.0 or (mid.val == 10.0 and mid.off >= 0.0)) {
  2098a4:	41 83 c4 01          	add    r12d,0x1
  2098a8:	c5 f9 2e d8          	vucomisd xmm3,xmm0
  2098ac:	77 d9                	ja     209887 <Futex+0x12b7>
  2098ae:	c5 f9 2e d1          	vucomisd xmm2,xmm1
  2098b2:	72 26                	jb     2098da <Futex+0x130a>
  2098b4:	c5 f9 2e d8          	vucomisd xmm3,xmm0
  2098b8:	75 20                	jne    2098da <Futex+0x130a>
  2098ba:	7b cb                	jnp    209887 <Futex+0x12b7>
  2098bc:	eb 1c                	jmp    2098da <Futex+0x130a>
    hp.val *= 10.0;
  2098be:	c5 e3 59 c8          	vmulsd xmm1,xmm3,xmm0
    hp.off *= 10.0;
  2098c2:	c5 eb 59 d0          	vmulsd xmm2,xmm2,xmm0
    hp.val += hp.off;
  2098c6:	c5 eb 58 d9          	vaddsd xmm3,xmm2,xmm1
    hp.off += val - hp.val;
  2098ca:	c5 f3 5c cb          	vsubsd xmm1,xmm1,xmm3
  2098ce:	c5 eb 58 d1          	vaddsd xmm2,xmm2,xmm1
        ten *= 10.0;
  2098d2:	c5 cb 59 f0          	vmulsd xmm6,xmm6,xmm0
    while (mid.val < 1.0 or (mid.val == 1.0 and mid.off < 0.0)) {
  2098d6:	41 83 c4 ff          	add    r12d,0xffffffff
  2098da:	c5 7b 10 0d f6 72 ff 	vmovsd xmm9,QWORD PTR [rip+0xffffffffffff72f6]        # 200bd8 <__unnamed_441+0x38>
  2098e1:	ff 
  2098e2:	c5 79 2e cb          	vucomisd xmm9,xmm3
  2098e6:	77 d6                	ja     2098be <Futex+0x12ee>
  2098e8:	c5 c1 57 ff          	vxorpd xmm7,xmm7,xmm7
  2098ec:	c5 f9 2e fa          	vucomisd xmm7,xmm2
  2098f0:	76 0c                	jbe    2098fe <Futex+0x132e>
  2098f2:	c5 f9 2e 1d de 72 ff 	vucomisd xmm3,QWORD PTR [rip+0xffffffffffff72de]        # 200bd8 <__unnamed_441+0x38>
  2098f9:	ff 
  2098fa:	75 02                	jne    2098fe <Futex+0x132e>
  2098fc:	7b c0                	jnp    2098be <Futex+0x12ee>
        .off = mid.off + (fpnext(val) - val) * lten * ten / 2.0,
  2098fe:	c5 bb 59 0d 02 73 ff 	vmulsd xmm1,xmm8,QWORD PTR [rip+0xffffffffffff7302]        # 200c08 <__unnamed_441+0x68>
  209905:	ff 
  209906:	c5 f3 59 ce          	vmulsd xmm1,xmm1,xmm6
  20990a:	c5 f9 6f 6c 24 10    	vmovdqa xmm5,XMMWORD PTR [rsp+0x10]
    return @bitCast(f64, @bitCast(u64, val) +% 1);
  209910:	c4 e2 79 59 e5       	vpbroadcastq xmm4,xmm5
  209915:	c5 d9 d4 25 83 6b ff 	vpaddq xmm4,xmm4,XMMWORD PTR [rip+0xffffffffffff6b83]        # 2004a0 <__unnamed_295+0x10>
  20991c:	ff 
        .off = mid.off + (fpnext(val) - val) * lten * ten / 2.0,
  20991d:	c5 fb 12 f5          	vmovddup xmm6,xmm5
  209921:	c5 d9 5c e6          	vsubpd xmm4,xmm4,xmm6
  209925:	c5 fb 12 f1          	vmovddup xmm6,xmm1
  209929:	c5 fb 12 ca          	vmovddup xmm1,xmm2
  20992d:	c4 e2 d9 a8 f1       	vfmadd213pd xmm6,xmm4,xmm1
    hp.val += hp.off;
  209932:	c5 fb 12 cb          	vmovddup xmm1,xmm3
  209936:	c5 f1 58 ce          	vaddpd xmm1,xmm1,xmm6
    hp.off += val - hp.val;
  20993a:	c5 e3 5c d1          	vsubsd xmm2,xmm3,xmm1
  20993e:	c5 cb 58 d2          	vaddsd xmm2,xmm6,xmm2
  209942:	c4 e3 79 05 e1 01    	vpermilpd xmm4,xmm1,0x1
  209948:	c5 e3 5c dc          	vsubsd xmm3,xmm3,xmm4
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  20994c:	c4 e3 79 05 f6 01    	vpermilpd xmm6,xmm6,0x1
  209952:	c5 f9 28 25 46 6a ff 	vmovapd xmm4,XMMWORD PTR [rip+0xffffffffffff6a46]        # 2003a0 <__unnamed_526+0x10>
  209959:	ff 
  20995a:	c5 79 28 05 6e 6c ff 	vmovapd xmm8,XMMWORD PTR [rip+0xffffffffffff6c6e]        # 2005d0 <__unnamed_64+0x10>
  209961:	ff 
    hp.off += val - hp.val;
  209962:	c5 cb 58 db          	vaddsd xmm3,xmm6,xmm3
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  209966:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  20996a:	76 42                	jbe    2099ae <Futex+0x13de>
    hp.val /= 10.0;
  20996c:	c5 f1 59 f4          	vmulpd xmm6,xmm1,xmm4
    hp.off /= 10.0;
  209970:	c5 e9 14 eb          	vunpcklpd xmm5,xmm2,xmm3
    hp.off += val / 10.0;
  209974:	c4 c1 71 59 c8       	vmulpd xmm1,xmm1,xmm8
  209979:	c4 e2 d9 aa e9       	vfmsub213pd xmm5,xmm4,xmm1
    hp.val += hp.off;
  20997e:	c5 c9 58 cd          	vaddpd xmm1,xmm6,xmm5
    hp.off += val - hp.val;
  209982:	c5 cb 5c d1          	vsubsd xmm2,xmm6,xmm1
  209986:	c5 d3 58 d2          	vaddsd xmm2,xmm5,xmm2
  20998a:	c4 e3 79 05 d9 01    	vpermilpd xmm3,xmm1,0x1
  209990:	c4 e3 79 05 f6 01    	vpermilpd xmm6,xmm6,0x1
  209996:	c5 cb 5c db          	vsubsd xmm3,xmm6,xmm3
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  20999a:	c4 e3 79 05 f5 01    	vpermilpd xmm6,xmm5,0x1
  2099a0:	41 83 c4 01          	add    r12d,0x1
    hp.off += val - hp.val;
  2099a4:	c5 cb 58 db          	vaddsd xmm3,xmm6,xmm3
    while (high.val > 10.0 or (high.val == 10.0 and high.off >= 0.0)) {
  2099a8:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  2099ac:	77 be                	ja     20996c <Futex+0x139c>
  2099ae:	c5 f9 2e d7          	vucomisd xmm2,xmm7
  2099b2:	72 08                	jb     2099bc <Futex+0x13ec>
  2099b4:	c5 f9 2e c8          	vucomisd xmm1,xmm0
  2099b8:	75 02                	jne    2099bc <Futex+0x13ec>
  2099ba:	7b b0                	jnp    20996c <Futex+0x139c>
  2099bc:	c4 e3 79 05 e1 01    	vpermilpd xmm4,xmm1,0x1
  2099c2:	c5 c9 57 f6          	vxorpd xmm6,xmm6,xmm6
    while (high.val < 1.0 or (high.val == 1.0 and high.off < 0.0)) {
  2099c6:	c5 79 2e c9          	vucomisd xmm9,xmm1
  2099ca:	76 32                	jbe    2099fe <Futex+0x142e>
    hp.val *= 10.0;
  2099cc:	c5 f3 59 e8          	vmulsd xmm5,xmm1,xmm0
    hp.off *= 10.0;
  2099d0:	c5 eb 59 d0          	vmulsd xmm2,xmm2,xmm0
    hp.val += hp.off;
  2099d4:	c5 eb 58 cd          	vaddsd xmm1,xmm2,xmm5
    hp.off += val - hp.val;
  2099d8:	c5 d3 5c e9          	vsubsd xmm5,xmm5,xmm1
  2099dc:	c5 eb 58 d5          	vaddsd xmm2,xmm2,xmm5
    hp.val *= 10.0;
  2099e0:	c5 db 59 e8          	vmulsd xmm5,xmm4,xmm0
    hp.off *= 10.0;
  2099e4:	c5 e3 59 d8          	vmulsd xmm3,xmm3,xmm0
    hp.val += hp.off;
  2099e8:	c5 e3 58 e5          	vaddsd xmm4,xmm3,xmm5
    hp.off += val - hp.val;
  2099ec:	c5 d3 5c ec          	vsubsd xmm5,xmm5,xmm4
  2099f0:	c5 e3 58 dd          	vaddsd xmm3,xmm3,xmm5
    while (high.val < 1.0 or (high.val == 1.0 and high.off < 0.0)) {
  2099f4:	41 83 c4 ff          	add    r12d,0xffffffff
  2099f8:	c5 79 2e c9          	vucomisd xmm9,xmm1
  2099fc:	77 ce                	ja     2099cc <Futex+0x13fc>
  2099fe:	c5 f9 2e f2          	vucomisd xmm6,xmm2
  209a02:	76 09                	jbe    209a0d <Futex+0x143d>
  209a04:	c4 c1 79 2e c9       	vucomisd xmm1,xmm9
  209a09:	75 02                	jne    209a0d <Futex+0x143d>
  209a0b:	7b bf                	jnp    2099cc <Futex+0x13fc>
  209a0d:	41 bf 01 00 00 00    	mov    r15d,0x1
  209a13:	bf 34 0b 00 00       	mov    edi,0xb34
  209a18:	c5 c1 57 ff          	vxorpd xmm7,xmm7,xmm7
  209a1c:	c5 7b 10 0d c4 71 ff 	vmovsd xmm9,QWORD PTR [rip+0xffffffffffff71c4]        # 200be8 <__unnamed_441+0x48>
  209a23:	ff 
  209a24:	c5 7b 10 15 f4 71 ff 	vmovsd xmm10,QWORD PTR [rip+0xffffffffffff71f4]        # 200c20 <__unnamed_441+0x80>
  209a2b:	ff 
  209a2c:	c5 7b 10 05 cc 71 ff 	vmovsd xmm8,QWORD PTR [rip+0xffffffffffff71cc]        # 200c00 <__unnamed_441+0x60>
  209a33:	ff 
    if (e >= 0x3FF + 52 or x == 0) {
  209a34:	c5 f9 2e cf          	vucomisd xmm1,xmm7
  209a38:	c5 f9 28 e9          	vmovapd xmm5,xmm1
  209a3c:	75 06                	jne    209a44 <Futex+0x1474>
  209a3e:	0f 8b c5 00 00 00    	jnp    209b09 <Futex+0x1539>
  209a44:	c4 e1 f9 7e c9       	vmovq  rcx,xmm1
  209a49:	c4 e2 c0 f7 d1       	bextr  rdx,rcx,rdi
  209a4e:	c5 f9 28 e9          	vmovapd xmm5,xmm1
  209a52:	48 81 fa 32 04 00 00 	cmp    rdx,0x432
  209a59:	0f 87 aa 00 00 00    	ja     209b09 <Futex+0x1539>
    if (u >> 63 != 0) {
  209a5f:	48 85 c9             	test   rcx,rcx
  209a62:	78 26                	js     209a8a <Futex+0x14ba>
  209a64:	c4 c1 73 58 ea       	vaddsd xmm5,xmm1,xmm10
  209a69:	c4 c1 53 58 e9       	vaddsd xmm5,xmm5,xmm9
    if (e <= 0x3FF - 1) {
  209a6e:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  209a75:	77 26                	ja     209a9d <Futex+0x14cd>
        if (u >> 63 != 0) {
  209a77:	c5 79 29 c5          	vmovapd xmm5,xmm8
    if (u >> 63 != 0) {
  209a7b:	48 85 c9             	test   rcx,rcx
        if (u >> 63 != 0) {
  209a7e:	0f 88 85 00 00 00    	js     209b09 <Futex+0x1539>
  209a84:	c5 d1 57 ed          	vxorpd xmm5,xmm5,xmm5
  209a88:	eb 7f                	jmp    209b09 <Futex+0x1539>
  209a8a:	c4 c1 73 58 e9       	vaddsd xmm5,xmm1,xmm9
  209a8f:	c4 c1 53 58 ea       	vaddsd xmm5,xmm5,xmm10
    if (e <= 0x3FF - 1) {
  209a94:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  209a9b:	76 da                	jbe    209a77 <Futex+0x14a7>
  209a9d:	c5 d3 5c f1          	vsubsd xmm6,xmm5,xmm1
    } else if (y > 0) {
  209aa1:	c5 f9 2e f7          	vucomisd xmm6,xmm7
  209aa5:	76 62                	jbe    209b09 <Futex+0x1539>
        return x + y - 1;
  209aa7:	c4 c1 53 58 e8       	vaddsd xmm5,xmm5,xmm8
  209aac:	eb 5b                	jmp    209b09 <Futex+0x1539>
        buffer[buf_index] = hdig + '0';
  209aae:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        high.val -= @intToFloat(f64, hdig);
  209ab3:	0f b6 d1             	movzx  edx,cl
        buffer[buf_index] = hdig + '0';
  209ab6:	80 c1 30             	add    cl,0x30
  209ab9:	42 88 0c 38          	mov    BYTE PTR [rax+r15*1],cl
        buf_index += 1;
  209abd:	49 83 c7 01          	add    r15,0x1
        high.val -= @intToFloat(f64, hdig);
  209ac1:	c5 a3 2a ea          	vcvtsi2sd xmm5,xmm11,edx
  209ac5:	c5 f3 5c cd          	vsubsd xmm1,xmm1,xmm5
        low.val -= @intToFloat(f64, ldig);
  209ac9:	c5 db 5c e5          	vsubsd xmm4,xmm4,xmm5
    hp.val *= 10.0;
  209acd:	c5 f3 59 e8          	vmulsd xmm5,xmm1,xmm0
    hp.off *= 10.0;
  209ad1:	c5 eb 59 d0          	vmulsd xmm2,xmm2,xmm0
    hp.val += hp.off;
  209ad5:	c5 eb 58 cd          	vaddsd xmm1,xmm2,xmm5
    hp.off += val - hp.val;
  209ad9:	c5 d3 5c e9          	vsubsd xmm5,xmm5,xmm1
  209add:	c5 eb 58 d5          	vaddsd xmm2,xmm2,xmm5
    hp.val *= 10.0;
  209ae1:	c5 db 59 e8          	vmulsd xmm5,xmm4,xmm0
    hp.off *= 10.0;
  209ae5:	c5 e3 59 d8          	vmulsd xmm3,xmm3,xmm0
    hp.val += hp.off;
  209ae9:	c5 e3 58 e5          	vaddsd xmm4,xmm3,xmm5
    hp.off += val - hp.val;
  209aed:	c5 d3 5c ec          	vsubsd xmm5,xmm5,xmm4
  209af1:	c5 e3 58 dd          	vaddsd xmm3,xmm3,xmm5
    if (e >= 0x3FF + 52 or x == 0) {
  209af5:	c5 f9 2e cf          	vucomisd xmm1,xmm7
  209af9:	c5 f9 28 e9          	vmovapd xmm5,xmm1
  209afd:	0f 85 41 ff ff ff    	jne    209a44 <Futex+0x1474>
  209b03:	0f 8a 3b ff ff ff    	jp     209a44 <Futex+0x1474>
        var hdig = @floatToInt(u8, math.floor(high.val));
  209b09:	c5 fb 2c cd          	vcvttsd2si ecx,xmm5
        if ((high.val == @intToFloat(f64, hdig)) and (high.off < 0)) hdig -= 1;
  209b0d:	0f b6 c9             	movzx  ecx,cl
  209b10:	c5 a3 2a e9          	vcvtsi2sd xmm5,xmm11,ecx
  209b14:	c5 f9 2e cd          	vucomisd xmm1,xmm5
  209b18:	0f 9b c2             	setnp  dl
  209b1b:	0f 94 c3             	sete   bl
  209b1e:	20 d3                	and    bl,dl
  209b20:	c5 f9 2e fa          	vucomisd xmm7,xmm2
  209b24:	0f 97 c2             	seta   dl
  209b27:	20 da                	and    dl,bl
  209b29:	28 d1                	sub    cl,dl
  209b2b:	c5 f9 2e e7          	vucomisd xmm4,xmm7
  209b2f:	c5 f9 28 ec          	vmovapd xmm5,xmm4
  209b33:	75 02                	jne    209b37 <Futex+0x1567>
  209b35:	7b 60                	jnp    209b97 <Futex+0x15c7>
  209b37:	c4 e1 f9 7e e2       	vmovq  rdx,xmm4
  209b3c:	c4 e2 c0 f7 f2       	bextr  rsi,rdx,rdi
  209b41:	c5 f9 28 ec          	vmovapd xmm5,xmm4
  209b45:	48 81 fe 32 04 00 00 	cmp    rsi,0x432
  209b4c:	77 49                	ja     209b97 <Futex+0x15c7>
    if (u >> 63 != 0) {
  209b4e:	48 85 d2             	test   rdx,rdx
  209b51:	78 22                	js     209b75 <Futex+0x15a5>
  209b53:	c4 c1 5b 58 ea       	vaddsd xmm5,xmm4,xmm10
  209b58:	c4 c1 53 58 e9       	vaddsd xmm5,xmm5,xmm9
    if (e <= 0x3FF - 1) {
  209b5d:	48 81 fe fe 03 00 00 	cmp    rsi,0x3fe
  209b64:	77 22                	ja     209b88 <Futex+0x15b8>
        if (u >> 63 != 0) {
  209b66:	c5 79 29 c5          	vmovapd xmm5,xmm8
    if (u >> 63 != 0) {
  209b6a:	48 85 d2             	test   rdx,rdx
        if (u >> 63 != 0) {
  209b6d:	78 28                	js     209b97 <Futex+0x15c7>
  209b6f:	c5 d1 57 ed          	vxorpd xmm5,xmm5,xmm5
  209b73:	eb 22                	jmp    209b97 <Futex+0x15c7>
  209b75:	c4 c1 5b 58 e9       	vaddsd xmm5,xmm4,xmm9
  209b7a:	c4 c1 53 58 ea       	vaddsd xmm5,xmm5,xmm10
    if (e <= 0x3FF - 1) {
  209b7f:	48 81 fe fe 03 00 00 	cmp    rsi,0x3fe
  209b86:	76 de                	jbe    209b66 <Futex+0x1596>
  209b88:	c5 d3 5c f4          	vsubsd xmm6,xmm5,xmm4
    } else if (y > 0) {
  209b8c:	c5 f9 2e f7          	vucomisd xmm6,xmm7
  209b90:	76 05                	jbe    209b97 <Futex+0x15c7>
        return x + y - 1;
  209b92:	c4 c1 53 58 e8       	vaddsd xmm5,xmm5,xmm8
        var ldig = @floatToInt(u8, math.floor(low.val));
  209b97:	c5 fb 2c d5          	vcvttsd2si edx,xmm5
        if ((low.val == @intToFloat(f64, ldig)) and (low.off < 0)) ldig -= 1;
  209b9b:	0f b6 d2             	movzx  edx,dl
  209b9e:	c5 a3 2a ea          	vcvtsi2sd xmm5,xmm11,edx
  209ba2:	c5 f9 2e e5          	vucomisd xmm4,xmm5
  209ba6:	0f 9b c3             	setnp  bl
  209ba9:	0f 94 c0             	sete   al
  209bac:	20 d8                	and    al,bl
  209bae:	c5 f9 2e fb          	vucomisd xmm7,xmm3
  209bb2:	0f 97 c3             	seta   bl
  209bb5:	20 c3                	and    bl,al
  209bb7:	28 da                	sub    dl,bl
        if (ldig != hdig) break;
  209bb9:	38 ca                	cmp    dl,cl
  209bbb:	0f 84 ed fe ff ff    	je     209aae <Futex+0x14de>
    const tmp = (high.val + low.val) / 2.0;
  209bc1:	c5 db 58 c1          	vaddsd xmm0,xmm4,xmm1
  209bc5:	c5 fb 10 0d 3b 70 ff 	vmovsd xmm1,QWORD PTR [rip+0xffffffffffff703b]        # 200c08 <__unnamed_441+0x68>
  209bcc:	ff 
  209bcd:	c5 fb 59 c1          	vmulsd xmm0,xmm0,xmm1
    var mdig = @floatToInt(u8, math.floor(tmp + 0.5));
  209bd1:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
    if (e >= 0x3FF + 52 or x == 0) {
  209bd5:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  209bd9:	c5 f9 2e ca          	vucomisd xmm1,xmm2
  209bdd:	75 02                	jne    209be1 <Futex+0x1611>
  209bdf:	7b 74                	jnp    209c55 <Futex+0x1685>
  209be1:	c4 e1 f9 7e c8       	vmovq  rax,xmm1
  209be6:	b9 34 0b 00 00       	mov    ecx,0xb34
  209beb:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  209bf0:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  209bf7:	77 5c                	ja     209c55 <Futex+0x1685>
    if (u >> 63 != 0) {
  209bf9:	48 85 c0             	test   rax,rax
  209bfc:	78 1e                	js     209c1c <Futex+0x164c>
  209bfe:	c4 c1 73 58 d2       	vaddsd xmm2,xmm1,xmm10
  209c03:	c4 c1 6b 58 d1       	vaddsd xmm2,xmm2,xmm9
    if (e <= 0x3FF - 1) {
  209c08:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  209c0f:	77 1e                	ja     209c2f <Futex+0x165f>
    if (u >> 63 != 0) {
  209c11:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  209c14:	78 31                	js     209c47 <Futex+0x1677>
  209c16:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  209c1a:	eb 39                	jmp    209c55 <Futex+0x1685>
  209c1c:	c4 c1 73 58 d1       	vaddsd xmm2,xmm1,xmm9
  209c21:	c4 c1 6b 58 d2       	vaddsd xmm2,xmm2,xmm10
    if (e <= 0x3FF - 1) {
  209c26:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  209c2d:	76 e2                	jbe    209c11 <Futex+0x1641>
  209c2f:	c5 eb 5c c9          	vsubsd xmm1,xmm2,xmm1
    } else if (y > 0) {
  209c33:	c5 e1 57 db          	vxorpd xmm3,xmm3,xmm3
  209c37:	c5 f9 2e cb          	vucomisd xmm1,xmm3
  209c3b:	76 14                	jbe    209c51 <Futex+0x1681>
        return x + y - 1;
  209c3d:	c5 eb 58 0d bb 6f ff 	vaddsd xmm1,xmm2,QWORD PTR [rip+0xffffffffffff6fbb]        # 200c00 <__unnamed_441+0x60>
  209c44:	ff 
  209c45:	eb 0e                	jmp    209c55 <Futex+0x1685>
  209c47:	c5 fb 10 0d b1 6f ff 	vmovsd xmm1,QWORD PTR [rip+0xffffffffffff6fb1]        # 200c00 <__unnamed_441+0x60>
  209c4e:	ff 
  209c4f:	eb 04                	jmp    209c55 <Futex+0x1685>
  209c51:	c5 f9 28 ca          	vmovapd xmm1,xmm2
  209c55:	c5 fb 2c c1          	vcvttsd2si eax,xmm1
    if ((@intToFloat(f64, mdig) - tmp) == 0.5 and (mdig & 0x1) != 0) mdig -= 1;
  209c59:	0f b6 c0             	movzx  eax,al
  209c5c:	c5 a3 2a c8          	vcvtsi2sd xmm1,xmm11,eax
  209c60:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
  209c64:	c5 f9 2e 05 9c 6f ff 	vucomisd xmm0,QWORD PTR [rip+0xffffffffffff6f9c]        # 200c08 <__unnamed_441+0x68>
  209c6b:	ff 
  209c6c:	0f 9b c1             	setnp  cl
  209c6f:	0f 94 c2             	sete   dl
  209c72:	20 ca                	and    dl,cl
  209c74:	20 c2                	and    dl,al
    buffer[buf_index] = mdig + '0';
  209c76:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
    if ((@intToFloat(f64, mdig) - tmp) == 0.5 and (mdig & 0x1) != 0) mdig -= 1;
  209c7b:	28 d0                	sub    al,dl
    buffer[buf_index] = mdig + '0';
  209c7d:	04 30                	add    al,0x30
  209c7f:	42 88 04 39          	mov    BYTE PTR [rcx+r15*1],al
        .digits = buffer[1..buf_index],
  209c83:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  209c88:	48 83 c0 01          	add    rax,0x1
  209c8c:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
            if (float_decimal.exp >= 0) {
  209c91:	45 85 e4             	test   r12d,r12d
  209c94:	0f 89 a0 f8 ff ff    	jns    20953a <Futex+0xf6a>
  209c9a:	e9 49 f5 ff ff       	jmp    2091e8 <Futex+0xc18>
  209c9f:	49 83 c4 01          	add    r12,0x1
  209ca3:	e9 1b fa ff ff       	jmp    2096c3 <Futex+0x10f3>
  209ca8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  209caf:	00 

0000000000209cb0 <panic>:
        // TODO: fix panic in zen.
        builtin.Os.freestanding, builtin.Os.zen => {
            while (true) {}
        },
        else => {
            const first_trace_addr = @ptrToInt(@returnAddress());
  209cb0:	48 83 ec 18          	sub    rsp,0x18
  209cb4:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
            std.debug.panicExtra(error_return_trace, first_trace_addr, "{}", msg);
  209cb9:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  209cbe:	c6 44 24 10 01       	mov    BYTE PTR [rsp+0x10],0x1
  209cc3:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
  209cc8:	e8 03 00 00 00       	call   209cd0 <panicExtra>
  209ccd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000209cd0 <panicExtra>:
    panicExtra(null, first_trace_addr, format, args);
}

var panicking: u8 = 0; // TODO make this a bool

pub fn panicExtra(trace: ?*const builtin.StackTrace, first_trace_addr: ?usize, comptime format: []const u8, args: ...) noreturn {
  209cd0:	41 57                	push   r15
  209cd2:	41 56                	push   r14
  209cd4:	53                   	push   rbx
  209cd5:	48 83 ec 10          	sub    rsp,0x10
  209cd9:	b0 01                	mov    al,0x1
    @setCold(true);

    if (@atomicRmw(u8, &panicking, builtin.AtomicRmwOp.Xchg, 1, builtin.AtomicOrder.SeqCst) == 1) {
  209cdb:	86 05 47 73 01 00    	xchg   BYTE PTR [rip+0x17347],al        # 221028 <panicking>
  209ce1:	49 89 fe             	mov    r14,rdi
  209ce4:	3c 01                	cmp    al,0x1
  209ce6:	74 7e                	je     209d66 <panicExtra+0x96>
    if (stderr_stream) |st| {
  209ce8:	48 8b 1d 41 73 01 00 	mov    rbx,QWORD PTR [rip+0x17341]        # 221030 <stderr_stream>
  209cef:	48 85 db             	test   rbx,rbx
  209cf2:	75 36                	jne    209d2a <panicExtra+0x5a>
        stderr_file = try io.getStdErr();
  209cf4:	48 8d 05 25 33 01 00 	lea    rax,[rip+0x13325]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  209cfb:	48 89 05 26 33 01 00 	mov    QWORD PTR [rip+0x13326],rax        # 21d028 <stderr_file_out_stream>
  209d02:	4c 8d 3d 07 1d 00 00 	lea    r15,[rip+0x1d07]        # 20ba10 <FileOutStream_writeFn>
  209d09:	4c 89 3d 20 33 01 00 	mov    QWORD PTR [rip+0x13320],r15        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  209d10:	c7 05 06 33 01 00 02 	mov    DWORD PTR [rip+0x13306],0x2        # 21d020 <stderr_file>
  209d17:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  209d1a:	48 8d 1d 0f 33 01 00 	lea    rbx,[rip+0x1330f]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  209d21:	48 89 1d 08 73 01 00 	mov    QWORD PTR [rip+0x17308],rbx        # 221030 <stderr_stream>
  209d28:	eb 07                	jmp    209d31 <panicExtra+0x61>
  209d2a:	4c 8b 3d ff 32 01 00 	mov    r15,QWORD PTR [rip+0x132ff]        # 21d030 <stderr_file_out_stream+0x8>
                const casted_value = ([]const u8)(value);
  209d31:	c5 f8 10 05 ff 6d 01 	vmovups xmm0,XMMWORD PTR [rip+0x16dff]        # 220b38 <__unnamed_11>
  209d38:	00 
  209d39:	c5 f8 29 04 24       	vmovaps XMMWORD PTR [rsp],xmm0
  209d3e:	48 89 e6             	mov    rsi,rsp
                return output(context, casted_value);
  209d41:	48 89 df             	mov    rdi,rbx
  209d44:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  209d47:	66 85 c0             	test   ax,ax
  209d4a:	75 1a                	jne    209d66 <panicExtra+0x96>
        try output(context, fmt[start_index..]);
  209d4c:	48 8d 35 f5 6d 01 00 	lea    rsi,[rip+0x16df5]        # 220b48 <__unnamed_12>
  209d53:	48 89 df             	mov    rdi,rbx
  209d56:	41 ff d7             	call   r15
        // we would want to return here instead of calling abort, so that the thread
        // which first called panic can finish printing a stack trace.
        os.abort();
    }
    const stderr = getStderrStream() catch os.abort();
    stderr.print(format ++ "\n", args) catch os.abort();
  209d59:	66 85 c0             	test   ax,ax
  209d5c:	75 08                	jne    209d66 <panicExtra+0x96>
    if (trace) |t| {
        dumpStackTrace(t);
    }
    dumpCurrentStackTrace(first_trace_addr);
  209d5e:	4c 89 f7             	mov    rdi,r14
  209d61:	e8 5a 03 00 00       	call   20a0c0 <dumpCurrentStackTrace>
  209d66:	e8 55 02 00 00       	call   209fc0 <abort>
  209d6b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000209d70 <warn.16>:
pub fn warn(comptime fmt: []const u8, args: ...) void {
  209d70:	55                   	push   rbp
  209d71:	41 57                	push   r15
  209d73:	41 56                	push   r14
  209d75:	41 55                	push   r13
  209d77:	41 54                	push   r12
  209d79:	53                   	push   rbx
  209d7a:	48 83 ec 58          	sub    rsp,0x58
  209d7e:	49 89 f7             	mov    r15,rsi
  209d81:	48 89 fd             	mov    rbp,rdi
    if (stderr_stream) |st| {
  209d84:	4c 8b 35 a5 72 01 00 	mov    r14,QWORD PTR [rip+0x172a5]        # 221030 <stderr_stream>
  209d8b:	4d 85 f6             	test   r14,r14
  209d8e:	74 09                	je     209d99 <warn.16+0x29>
  209d90:	4c 8b 25 99 32 01 00 	mov    r12,QWORD PTR [rip+0x13299]        # 21d030 <stderr_file_out_stream+0x8>
  209d97:	eb 34                	jmp    209dcd <warn.16+0x5d>
        stderr_file = try io.getStdErr();
  209d99:	48 8d 05 80 32 01 00 	lea    rax,[rip+0x13280]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  209da0:	48 89 05 81 32 01 00 	mov    QWORD PTR [rip+0x13281],rax        # 21d028 <stderr_file_out_stream>
  209da7:	4c 8d 25 62 1c 00 00 	lea    r12,[rip+0x1c62]        # 20ba10 <FileOutStream_writeFn>
  209dae:	4c 89 25 7b 32 01 00 	mov    QWORD PTR [rip+0x1327b],r12        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  209db5:	c7 05 61 32 01 00 02 	mov    DWORD PTR [rip+0x13261],0x2        # 21d020 <stderr_file>
  209dbc:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  209dbf:	4c 8d 35 6a 32 01 00 	lea    r14,[rip+0x1326a]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  209dc6:	4c 89 35 63 72 01 00 	mov    QWORD PTR [rip+0x17263],r14        # 221030 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  209dcd:	48 8d 35 94 6d 01 00 	lea    rsi,[rip+0x16d94]        # 220b68 <__unnamed_13>
  209dd4:	4c 89 f7             	mov    rdi,r14
  209dd7:	41 ff d4             	call   r12
  209dda:	66 85 c0             	test   ax,ax
  209ddd:	0f 85 c1 01 00 00    	jne    209fa4 <warn.16+0x234>
    comptime Errors: type,
    output: fn (@typeOf(context), []const u8) Errors!void,
) Errors!void {
    // max_int_digits accounts for the minus sign. when printing an unsigned
    // number we don't need to do that.
    var buf: [max_int_digits - 1]u8 = undefined;
  209de3:	c5 fc 10 05 8d d9 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffd98d]        # 207778 <__unnamed_14+0x1f>
  209dea:	ff 
  209deb:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  209df1:	c5 fc 10 05 60 d9 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffd960]        # 207759 <__unnamed_14>
  209df8:	ff 
  209df9:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
    var a = if (@sizeOf(@typeOf(value)) == 1) u8(value) else value;
    var index: usize = buf.len;

    while (true) {
        const digit = a % base;
  209dff:	49 bd cd cc cc cc cc 	movabs r13,0xcccccccccccccccd
  209e06:	cc cc cc 
  209e09:	48 89 ea             	mov    rdx,rbp
  209e0c:	c4 c2 fb f6 cd       	mulx   rcx,rax,r13
  209e11:	c1 e9 02             	shr    ecx,0x2
  209e14:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  209e1a:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  209e1d:	89 e8                	mov    eax,ebp
  209e1f:	29 c8                	sub    eax,ecx
    return value;
}

fn digitToChar(digit: u8, uppercase: bool) u8 {
    return switch (digit) {
        0...9 => digit + '0',
  209e21:	b1 30                	mov    cl,0x30
  209e23:	3c 0a                	cmp    al,0xa
  209e25:	72 02                	jb     209e29 <warn.16+0xb9>
  209e27:	b1 57                	mov    cl,0x57
  209e29:	48 8d 5c 24 4f       	lea    rbx,[rsp+0x4f]
  209e2e:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209e30:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
        if (a == 0) break;
  209e34:	48 83 fd 0a          	cmp    rbp,0xa
  209e38:	73 0a                	jae    209e44 <warn.16+0xd4>
  209e3a:	b8 40 00 00 00       	mov    eax,0x40
  209e3f:	48 89 d9             	mov    rcx,rbx
  209e42:	eb 54                	jmp    209e98 <warn.16+0x128>
  209e44:	48 89 df             	mov    rdi,rbx
  209e47:	b8 40 00 00 00       	mov    eax,0x40
  209e4c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        a /= base;
  209e50:	48 89 ea             	mov    rdx,rbp
  209e53:	c4 c2 f3 f6 d5       	mulx   rdx,rcx,r13
  209e58:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  209e5c:	c4 c2 f3 f6 f5       	mulx   rsi,rcx,r13
  209e61:	c1 ee 02             	shr    esi,0x2
  209e64:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  209e6a:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  209e6d:	89 d1                	mov    ecx,edx
  209e6f:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  209e71:	b3 30                	mov    bl,0x30
  209e73:	80 f9 0a             	cmp    cl,0xa
  209e76:	72 02                	jb     209e7a <warn.16+0x10a>
  209e78:	b3 57                	mov    bl,0x57
  209e7a:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209e7c:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  209e80:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  209e84:	48 83 fd 63          	cmp    rbp,0x63
  209e88:	48 89 d5             	mov    rbp,rdx
  209e8b:	77 c3                	ja     209e50 <warn.16+0xe0>
        const padded_buf = buf[index - padding ..];
  209e8d:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  209e91:	48 83 c1 0f          	add    rcx,0xf
  209e95:	48 89 fb             	mov    rbx,rdi
  209e98:	ba 41 00 00 00       	mov    edx,0x41
  209e9d:	48 29 c2             	sub    rdx,rax
  209ea0:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  209ea4:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  209ea9:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  209eac:	4c 89 f7             	mov    rdi,r14
  209eaf:	c5 f8 77             	vzeroupper 
  209eb2:	41 ff d4             	call   r12
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  209eb5:	66 85 c0             	test   ax,ax
  209eb8:	0f 85 e6 00 00 00    	jne    209fa4 <warn.16+0x234>
                        try output(context, fmt[start_index..i]);
  209ebe:	48 8d 35 b3 6c 01 00 	lea    rsi,[rip+0x16cb3]        # 220b78 <__unnamed_15>
  209ec5:	4c 89 f7             	mov    rdi,r14
  209ec8:	41 ff d4             	call   r12
  209ecb:	66 85 c0             	test   ax,ax
  209ece:	0f 85 d0 00 00 00    	jne    209fa4 <warn.16+0x234>
    var buf: [max_int_digits - 1]u8 = undefined;
  209ed4:	c5 fc 10 05 9c d8 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffd89c]        # 207778 <__unnamed_14+0x1f>
  209edb:	ff 
  209edc:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  209ee2:	c5 fc 10 05 6f d8 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffd86f]        # 207759 <__unnamed_14>
  209ee9:	ff 
  209eea:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        const digit = a % base;
  209ef0:	4c 89 fa             	mov    rdx,r15
  209ef3:	c4 c2 fb f6 cd       	mulx   rcx,rax,r13
  209ef8:	c1 e9 02             	shr    ecx,0x2
  209efb:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  209f01:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  209f04:	44 89 f8             	mov    eax,r15d
  209f07:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  209f09:	b1 30                	mov    cl,0x30
  209f0b:	3c 0a                	cmp    al,0xa
  209f0d:	72 02                	jb     209f11 <warn.16+0x1a1>
  209f0f:	b1 57                	mov    cl,0x57
  209f11:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209f13:	88 4c 24 4f          	mov    BYTE PTR [rsp+0x4f],cl
  209f17:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  209f1c:	49 83 ff 0a          	cmp    r15,0xa
  209f20:	72 53                	jb     209f75 <warn.16+0x205>
  209f22:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  209f29:	1f 84 00 00 00 00 00 
        a /= base;
  209f30:	4c 89 fa             	mov    rdx,r15
  209f33:	c4 c2 f3 f6 d5       	mulx   rdx,rcx,r13
  209f38:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  209f3c:	c4 c2 f3 f6 f5       	mulx   rsi,rcx,r13
  209f41:	c1 ee 02             	shr    esi,0x2
  209f44:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  209f4a:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  209f4d:	89 d1                	mov    ecx,edx
  209f4f:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  209f51:	b3 30                	mov    bl,0x30
  209f53:	80 f9 0a             	cmp    cl,0xa
  209f56:	72 02                	jb     209f5a <warn.16+0x1ea>
  209f58:	b3 57                	mov    bl,0x57
  209f5a:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  209f5c:	88 5c 04 0e          	mov    BYTE PTR [rsp+rax*1+0xe],bl
        if (a == 0) break;
  209f60:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  209f64:	49 83 ff 63          	cmp    r15,0x63
  209f68:	49 89 d7             	mov    r15,rdx
  209f6b:	77 c3                	ja     209f30 <warn.16+0x1c0>
        const padded_buf = buf[index - padding ..];
  209f6d:	48 8d 1c 04          	lea    rbx,[rsp+rax*1]
  209f71:	48 83 c3 0f          	add    rbx,0xf
  209f75:	b9 41 00 00 00       	mov    ecx,0x41
  209f7a:	48 29 c1             	sub    rcx,rax
  209f7d:	48 89 1c 24          	mov    QWORD PTR [rsp],rbx
  209f81:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  209f86:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  209f89:	4c 89 f7             	mov    rdi,r14
  209f8c:	c5 f8 77             	vzeroupper 
  209f8f:	41 ff d4             	call   r12
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  209f92:	66 85 c0             	test   ax,ax
  209f95:	75 0d                	jne    209fa4 <warn.16+0x234>
        try output(context, fmt[start_index..]);
  209f97:	48 8d 35 ea 6b 01 00 	lea    rsi,[rip+0x16bea]        # 220b88 <__unnamed_16>
  209f9e:	4c 89 f7             	mov    rdi,r14
  209fa1:	41 ff d4             	call   r12
    stderr.print(fmt, args) catch return;
  209fa4:	48 83 c4 58          	add    rsp,0x58
  209fa8:	5b                   	pop    rbx
  209fa9:	41 5c                	pop    r12
  209fab:	41 5d                	pop    r13
  209fad:	41 5e                	pop    r14
  209faf:	41 5f                	pop    r15
  209fb1:	5d                   	pop    rbp
  209fb2:	c3                   	ret    
  209fb3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  209fba:	84 00 00 00 00 00 

0000000000209fc0 <abort>:
pub const SIG_DFL = @intToPtr(extern fn (i32) void, 0);
pub const SIG_IGN = @intToPtr(extern fn (i32) void, 1);
pub const empty_sigset = []usize{0} ** sigset_t.len;

pub fn raise(sig: i32) usize {
    var set: sigset_t = undefined;
  209fc0:	50                   	push   rax
  209fc1:	c5 fc 10 05 9f c1 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc19f]        # 206168 <__unnamed_17+0x60>
  209fc8:	ff 
  209fc9:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  209fcf:	c5 fc 10 0d 71 c1 ff 	vmovups ymm1,YMMWORD PTR [rip+0xffffffffffffc171]        # 206148 <__unnamed_17+0x40>
  209fd6:	ff 
  209fd7:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  209fdd:	c5 fc 10 15 43 c1 ff 	vmovups ymm2,YMMWORD PTR [rip+0xffffffffffffc143]        # 206128 <__unnamed_17+0x20>
  209fe4:	ff 
  209fe5:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  209feb:	c5 fc 10 1d 15 c1 ff 	vmovups ymm3,YMMWORD PTR [rip+0xffffffffffffc115]        # 206108 <__unnamed_17>
  209ff2:	ff 
  209ff3:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
    return asm volatile ("syscall"
  209ff9:	4c 8d 0d 38 6c ff ff 	lea    r9,[rip+0xffffffffffff6c38]        # 200c38 <app_mask>
  20a000:	4c 8d 44 24 80       	lea    r8,[rsp-0x80]
  20a005:	b8 0e 00 00 00       	mov    eax,0xe
  20a00a:	bf 00 00 00 00       	mov    edi,0x0
  20a00f:	41 ba 08 00 00 00    	mov    r10d,0x8
  20a015:	4c 89 ce             	mov    rsi,r9
  20a018:	4c 89 c2             	mov    rdx,r8
  20a01b:	0f 05                	syscall 
    return asm volatile ("syscall"
  20a01d:	b8 ba 00 00 00       	mov    eax,0xba
  20a022:	0f 05                	syscall 
    blockAppSignals(&set);
    const tid = @intCast(i32, syscall0(SYS_gettid));
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  20a024:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  20a027:	b8 c8 00 00 00       	mov    eax,0xc8
  20a02c:	be 06 00 00 00       	mov    esi,0x6
  20a031:	0f 05                	syscall 
    return asm volatile ("syscall"
  20a033:	b8 0e 00 00 00       	mov    eax,0xe
  20a038:	bf 02 00 00 00       	mov    edi,0x2
  20a03d:	ba 00 00 00 00       	mov    edx,0x0
  20a042:	41 ba 08 00 00 00    	mov    r10d,0x8
  20a048:	4c 89 c6             	mov    rsi,r8
  20a04b:	0f 05                	syscall 
    var set: sigset_t = undefined;
  20a04d:	c5 fc 11 44 24 e0    	vmovups YMMWORD PTR [rsp-0x20],ymm0
  20a053:	c5 fc 11 4c 24 c0    	vmovups YMMWORD PTR [rsp-0x40],ymm1
  20a059:	c5 fc 11 54 24 a0    	vmovups YMMWORD PTR [rsp-0x60],ymm2
  20a05f:	c5 fc 11 5c 24 80    	vmovups YMMWORD PTR [rsp-0x80],ymm3
  20a065:	b8 0e 00 00 00       	mov    eax,0xe
  20a06a:	bf 00 00 00 00       	mov    edi,0x0
  20a06f:	41 ba 08 00 00 00    	mov    r10d,0x8
  20a075:	4c 89 ce             	mov    rsi,r9
  20a078:	4c 89 c2             	mov    rdx,r8
  20a07b:	0f 05                	syscall 
    return asm volatile ("syscall"
  20a07d:	b8 ba 00 00 00       	mov    eax,0xba
  20a082:	0f 05                	syscall 
    const ret = syscall2(SYS_tkill, @intCast(usize, tid), @intCast(usize, sig));
  20a084:	48 63 f8             	movsxd rdi,eax
    return asm volatile ("syscall"
  20a087:	b8 c8 00 00 00       	mov    eax,0xc8
  20a08c:	be 09 00 00 00       	mov    esi,0x9
  20a091:	0f 05                	syscall 
    return asm volatile ("syscall"
  20a093:	b8 0e 00 00 00       	mov    eax,0xe
  20a098:	bf 02 00 00 00       	mov    edi,0x2
  20a09d:	31 d2                	xor    edx,edx
  20a09f:	41 ba 08 00 00 00    	mov    r10d,0x8
  20a0a5:	4c 89 c6             	mov    rsi,r8
  20a0a8:	0f 05                	syscall 
  20a0aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
            while (true) {}
  20a0b0:	eb fe                	jmp    20a0b0 <abort+0xf0>
  20a0b2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a0b9:	1f 84 00 00 00 00 00 

000000000020a0c0 <dumpCurrentStackTrace>:
pub fn dumpCurrentStackTrace(start_addr: ?usize) void {
  20a0c0:	55                   	push   rbp
  20a0c1:	48 89 e5             	mov    rbp,rsp
  20a0c4:	41 57                	push   r15
  20a0c6:	41 56                	push   r14
  20a0c8:	41 55                	push   r13
  20a0ca:	41 54                	push   r12
  20a0cc:	53                   	push   rbx
  20a0cd:	48 83 e4 e0          	and    rsp,0xffffffffffffffe0
  20a0d1:	48 81 ec a0 01 00 00 	sub    rsp,0x1a0
  20a0d8:	49 89 fe             	mov    r14,rdi
    if (stderr_stream) |st| {
  20a0db:	48 8b 1d 4e 6f 01 00 	mov    rbx,QWORD PTR [rip+0x16f4e]        # 221030 <stderr_stream>
  20a0e2:	48 85 db             	test   rbx,rbx
  20a0e5:	74 39                	je     20a120 <dumpCurrentStackTrace+0x60>
    if (self_debug_info) |info| {
  20a0e7:	48 8b 05 52 6f 01 00 	mov    rax,QWORD PTR [rip+0x16f52]        # 221040 <self_debug_info>
  20a0ee:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20a0f3:	48 85 c0             	test   rax,rax
  20a0f6:	74 6d                	je     20a165 <dumpCurrentStackTrace+0xa5>
// TODO make thread safe
var debug_info_allocator: ?*mem.Allocator = null;
var debug_info_direct_allocator: std.heap.DirectAllocator = undefined;
var debug_info_arena_allocator: std.heap.ArenaAllocator = undefined;
fn getDebugInfoAllocator() *mem.Allocator {
    if (debug_info_allocator) |a| return a;
  20a0f8:	48 83 3d 48 6f 01 00 	cmp    QWORD PTR [rip+0x16f48],0x0        # 221048 <debug_info_allocator>
  20a0ff:	00 
  20a100:	0f 84 4e 01 00 00    	je     20a254 <dumpCurrentStackTrace+0x194>
    for (posix_environ_raw) |ptr| {
  20a106:	48 8b 05 9b 2f 01 00 	mov    rax,QWORD PTR [rip+0x12f9b]        # 21d0a8 <posix_environ_raw+0x8>
  20a10d:	48 85 c0             	test   rax,rax
  20a110:	48 89 5c 24 70       	mov    QWORD PTR [rsp+0x70],rbx
  20a115:	0f 85 a4 01 00 00    	jne    20a2bf <dumpCurrentStackTrace+0x1ff>
  20a11b:	e9 5d 02 00 00       	jmp    20a37d <dumpCurrentStackTrace+0x2bd>
        stderr_file = try io.getStdErr();
  20a120:	48 8d 05 f9 2e 01 00 	lea    rax,[rip+0x12ef9]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a127:	48 89 05 fa 2e 01 00 	mov    QWORD PTR [rip+0x12efa],rax        # 21d028 <stderr_file_out_stream>
  20a12e:	48 8d 05 db 18 00 00 	lea    rax,[rip+0x18db]        # 20ba10 <FileOutStream_writeFn>
  20a135:	48 89 05 f4 2e 01 00 	mov    QWORD PTR [rip+0x12ef4],rax        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  20a13c:	c7 05 da 2e 01 00 02 	mov    DWORD PTR [rip+0x12eda],0x2        # 21d020 <stderr_file>
  20a143:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  20a146:	48 8d 1d e3 2e 01 00 	lea    rbx,[rip+0x12ee3]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  20a14d:	48 89 1d dc 6e 01 00 	mov    QWORD PTR [rip+0x16edc],rbx        # 221030 <stderr_stream>
    if (self_debug_info) |info| {
  20a154:	48 8b 05 e5 6e 01 00 	mov    rax,QWORD PTR [rip+0x16ee5]        # 221040 <self_debug_info>
  20a15b:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20a160:	48 85 c0             	test   rax,rax
  20a163:	75 93                	jne    20a0f8 <dumpCurrentStackTrace+0x38>
    if (debug_info_allocator) |a| return a;
  20a165:	48 8b 35 dc 6e 01 00 	mov    rsi,QWORD PTR [rip+0x16edc]        # 221048 <debug_info_allocator>
  20a16c:	48 85 f6             	test   rsi,rsi
  20a16f:	75 56                	jne    20a1c7 <dumpCurrentStackTrace+0x107>

    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  20a171:	c5 fc 10 05 37 6c 01 	vmovups ymm0,YMMWORD PTR [rip+0x16c37]        # 220db0 <__unnamed_18>
  20a178:	00 
  20a179:	c5 fc 11 05 bf 2e 01 	vmovups YMMWORD PTR [rip+0x12ebf],ymm0        # 21d040 <debug_info_direct_allocator>
  20a180:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  20a181:	c5 fa 6f 05 47 6c 01 	vmovdqu xmm0,XMMWORD PTR [rip+0x16c47]        # 220dd0 <__unnamed_19>
  20a188:	00 
  20a189:	c5 fa 7f 05 cf 2e 01 	vmovdqu XMMWORD PTR [rip+0x12ecf],xmm0        # 21d060 <debug_info_arena_allocator>
  20a190:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  20a191:	48 8d 05 a8 2e 01 00 	lea    rax,[rip+0x12ea8]        # 21d040 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  20a198:	48 8b 0d 41 6c 01 00 	mov    rcx,QWORD PTR [rip+0x16c41]        # 220de0 <__unnamed_19+0x10>
  20a19f:	48 89 0d ca 2e 01 00 	mov    QWORD PTR [rip+0x12eca],rcx        # 21d070 <debug_info_arena_allocator+0x10>
  20a1a6:	48 8d 35 b3 2e 01 00 	lea    rsi,[rip+0x12eb3]        # 21d060 <debug_info_arena_allocator>
  20a1ad:	48 89 05 c4 2e 01 00 	mov    QWORD PTR [rip+0x12ec4],rax        # 21d078 <debug_info_arena_allocator+0x18>
  20a1b4:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20a1b8:	c5 fe 7f 05 c0 2e 01 	vmovdqu YMMWORD PTR [rip+0x12ec0],ymm0        # 21d080 <debug_info_arena_allocator+0x20>
  20a1bf:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  20a1c0:	48 89 35 81 6e 01 00 	mov    QWORD PTR [rip+0x16e81],rsi        # 221048 <debug_info_allocator>
  20a1c7:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
        const info = try openSelfDebugInfo(getDebugInfoAllocator());
  20a1cc:	c5 f8 77             	vzeroupper 
  20a1cf:	e8 2c 19 00 00       	call   20bb00 <openSelfDebugInfo>
  20a1d4:	4c 0f bf 7c 24 30    	movsx  r15,WORD PTR [rsp+0x30]
  20a1da:	4d 85 ff             	test   r15,r15
  20a1dd:	74 56                	je     20a235 <dumpCurrentStackTrace+0x175>
  20a1df:	4c 8b 33             	mov    r14,QWORD PTR [rbx]
                        try output(context, fmt[start_index..i]);
  20a1e2:	48 8d 35 47 6a 01 00 	lea    rsi,[rip+0x16a47]        # 220c30 <__unnamed_20>
  20a1e9:	48 89 df             	mov    rdi,rbx
  20a1ec:	41 ff d6             	call   r14
  20a1ef:	66 85 c0             	test   ax,ax
  20a1f2:	0f 85 f9 14 00 00    	jne    20b6f1 <dumpCurrentStackTrace+0x1631>
        stderr.print("Unable to dump stack trace: Unable to open debug info: {}\n", @errorName(err)) catch return;
  20a1f8:	49 c1 e7 04          	shl    r15,0x4
  20a1fc:	48 8d 05 fd 3d 01 00 	lea    rax,[rip+0x13dfd]        # 21e000 <raw+0xf48>
                const casted_value = ([]const u8)(value);
  20a203:	c4 c1 7a 6f 04 07    	vmovdqu xmm0,XMMWORD PTR [r15+rax*1]
  20a209:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
  20a20f:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
                return output(context, casted_value);
  20a214:	48 89 df             	mov    rdi,rbx
  20a217:	41 ff d6             	call   r14
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20a21a:	66 85 c0             	test   ax,ax
  20a21d:	0f 85 ce 14 00 00    	jne    20b6f1 <dumpCurrentStackTrace+0x1631>
        try output(context, fmt[start_index..]);
  20a223:	48 8d 35 16 6a 01 00 	lea    rsi,[rip+0x16a16]        # 220c40 <__unnamed_21>
  20a22a:	48 89 df             	mov    rdi,rbx
  20a22d:	41 ff d6             	call   r14
  20a230:	e9 bc 14 00 00       	jmp    20b6f1 <dumpCurrentStackTrace+0x1631>
        const info = try openSelfDebugInfo(getDebugInfoAllocator());
  20a235:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  20a23a:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
        self_debug_info = info;
  20a23f:	48 89 05 fa 6d 01 00 	mov    QWORD PTR [rip+0x16dfa],rax        # 221040 <self_debug_info>
    if (debug_info_allocator) |a| return a;
  20a246:	48 83 3d fa 6d 01 00 	cmp    QWORD PTR [rip+0x16dfa],0x0        # 221048 <debug_info_allocator>
  20a24d:	00 
  20a24e:	0f 85 b2 fe ff ff    	jne    20a106 <dumpCurrentStackTrace+0x46>
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  20a254:	c5 fc 10 05 54 6b 01 	vmovups ymm0,YMMWORD PTR [rip+0x16b54]        # 220db0 <__unnamed_18>
  20a25b:	00 
  20a25c:	c5 fc 11 05 dc 2d 01 	vmovups YMMWORD PTR [rip+0x12ddc],ymm0        # 21d040 <debug_info_direct_allocator>
  20a263:	00 
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  20a264:	c5 fa 6f 05 64 6b 01 	vmovdqu xmm0,XMMWORD PTR [rip+0x16b64]        # 220dd0 <__unnamed_19>
  20a26b:	00 
  20a26c:	c5 fa 7f 05 ec 2d 01 	vmovdqu XMMWORD PTR [rip+0x12dec],xmm0        # 21d060 <debug_info_arena_allocator>
  20a273:	00 
    debug_info_direct_allocator = std.heap.DirectAllocator.init();
  20a274:	48 8d 05 c5 2d 01 00 	lea    rax,[rip+0x12dc5]        # 21d040 <debug_info_direct_allocator>
    debug_info_arena_allocator = std.heap.ArenaAllocator.init(&debug_info_direct_allocator.allocator);
  20a27b:	48 8b 0d 5e 6b 01 00 	mov    rcx,QWORD PTR [rip+0x16b5e]        # 220de0 <__unnamed_19+0x10>
  20a282:	48 89 0d e7 2d 01 00 	mov    QWORD PTR [rip+0x12de7],rcx        # 21d070 <debug_info_arena_allocator+0x10>
  20a289:	48 8d 0d d0 2d 01 00 	lea    rcx,[rip+0x12dd0]        # 21d060 <debug_info_arena_allocator>
  20a290:	48 89 05 e1 2d 01 00 	mov    QWORD PTR [rip+0x12de1],rax        # 21d078 <debug_info_arena_allocator+0x18>
  20a297:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20a29b:	c5 fe 7f 05 dd 2d 01 	vmovdqu YMMWORD PTR [rip+0x12ddd],ymm0        # 21d080 <debug_info_arena_allocator+0x20>
  20a2a2:	00 
    debug_info_allocator = &debug_info_arena_allocator.allocator;
  20a2a3:	48 89 0d 9e 6d 01 00 	mov    QWORD PTR [rip+0x16d9e],rcx        # 221048 <debug_info_allocator>
  20a2aa:	48 8b 05 f7 2d 01 00 	mov    rax,QWORD PTR [rip+0x12df7]        # 21d0a8 <posix_environ_raw+0x8>
  20a2b1:	48 85 c0             	test   rax,rax
  20a2b4:	48 89 5c 24 70       	mov    QWORD PTR [rsp+0x70],rbx
  20a2b9:	0f 84 be 00 00 00    	je     20a37d <dumpCurrentStackTrace+0x2bd>
  20a2bf:	48 8b 0d da 2d 01 00 	mov    rcx,QWORD PTR [rip+0x12dda]        # 21d0a0 <posix_environ_raw>
  20a2c6:	31 d2                	xor    edx,edx
  20a2c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20a2cf:	00 
  20a2d0:	48 8b 34 d1          	mov    rsi,QWORD PTR [rcx+rdx*8]
  20a2d4:	48 c7 c7 f1 ff ff ff 	mov    rdi,0xfffffffffffffff1
        while (ptr[line_i] != 0 and ptr[line_i] != '=') : (line_i += 1) {}
  20a2db:	8a 5c 3e 0f          	mov    bl,BYTE PTR [rsi+rdi*1+0xf]
  20a2df:	84 db                	test   bl,bl
  20a2e1:	74 1f                	je     20a302 <dumpCurrentStackTrace+0x242>
  20a2e3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a2ea:	84 00 00 00 00 00 
  20a2f0:	80 fb 3d             	cmp    bl,0x3d
  20a2f3:	74 0d                	je     20a302 <dumpCurrentStackTrace+0x242>
  20a2f5:	48 83 c7 01          	add    rdi,0x1
  20a2f9:	0f b6 5c 3e 0f       	movzx  ebx,BYTE PTR [rsi+rdi*1+0xf]
  20a2fe:	84 db                	test   bl,bl
  20a300:	75 ee                	jne    20a2f0 <dumpCurrentStackTrace+0x230>
    if (a.len != b.len) return false;
  20a302:	48 85 ff             	test   rdi,rdi
  20a305:	75 69                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
        if (b[index] != item) return false;
  20a307:	80 3e 5a             	cmp    BYTE PTR [rsi],0x5a
  20a30a:	75 64                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a30c:	80 7e 01 49          	cmp    BYTE PTR [rsi+0x1],0x49
  20a310:	75 5e                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a312:	80 7e 02 47          	cmp    BYTE PTR [rsi+0x2],0x47
  20a316:	75 58                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a318:	80 7e 03 5f          	cmp    BYTE PTR [rsi+0x3],0x5f
  20a31c:	75 52                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a31e:	80 7e 04 44          	cmp    BYTE PTR [rsi+0x4],0x44
  20a322:	75 4c                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a324:	80 7e 05 45          	cmp    BYTE PTR [rsi+0x5],0x45
  20a328:	75 46                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a32a:	80 7e 06 42          	cmp    BYTE PTR [rsi+0x6],0x42
  20a32e:	75 40                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a330:	80 7e 07 55          	cmp    BYTE PTR [rsi+0x7],0x55
  20a334:	75 3a                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a336:	80 7e 08 47          	cmp    BYTE PTR [rsi+0x8],0x47
  20a33a:	75 34                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a33c:	80 7e 09 5f          	cmp    BYTE PTR [rsi+0x9],0x5f
  20a340:	75 2e                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a342:	80 7e 0a 43          	cmp    BYTE PTR [rsi+0xa],0x43
  20a346:	75 28                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a348:	80 7e 0b 4f          	cmp    BYTE PTR [rsi+0xb],0x4f
  20a34c:	75 22                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a34e:	80 7e 0c 4c          	cmp    BYTE PTR [rsi+0xc],0x4c
  20a352:	75 1c                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a354:	80 7e 0d 4f          	cmp    BYTE PTR [rsi+0xd],0x4f
  20a358:	75 16                	jne    20a370 <dumpCurrentStackTrace+0x2b0>
  20a35a:	80 7e 0e 52          	cmp    BYTE PTR [rsi+0xe],0x52
  20a35e:	0f 84 44 14 00 00    	je     20b7a8 <dumpCurrentStackTrace+0x16e8>
  20a364:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a36b:	00 00 00 00 00 
    for (posix_environ_raw) |ptr| {
  20a370:	48 83 c2 01          	add    rdx,0x1
  20a374:	48 39 c2             	cmp    rdx,rax
  20a377:	0f 82 53 ff ff ff    	jb     20a2d0 <dumpCurrentStackTrace+0x210>
    return syscall3(SYS_ioctl, @intCast(usize, fd), TIOCGWINSZ, @ptrToInt(&wsz)) == 0;
  20a37d:	48 63 3d 9c 2c 01 00 	movsxd rdi,DWORD PTR [rip+0x12c9c]        # 21d020 <stderr_file>
  20a384:	48 8d 54 24 30       	lea    rdx,[rsp+0x30]
    return asm volatile ("syscall"
  20a389:	b8 10 00 00 00       	mov    eax,0x10
  20a38e:	be 13 54 00 00       	mov    esi,0x5413
  20a393:	0f 05                	syscall 
  20a395:	48 85 c0             	test   rax,rax
  20a398:	0f 94 44 24 0f       	sete   BYTE PTR [rsp+0xf]
    if (start_addr) |addr| {
  20a39d:	41 80 7e 08 01       	cmp    BYTE PTR [r14+0x8],0x1
  20a3a2:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  20a3a7:	75 0f                	jne    20a3b8 <dumpCurrentStackTrace+0x2f8>
  20a3a9:	49 8b 0e             	mov    rcx,QWORD PTR [r14]
  20a3ac:	b0 01                	mov    al,0x1
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  20a3ae:	48 85 ed             	test   rbp,rbp
  20a3b1:	75 10                	jne    20a3c3 <dumpCurrentStackTrace+0x303>
  20a3b3:	e9 39 13 00 00       	jmp    20b6f1 <dumpCurrentStackTrace+0x1631>
  20a3b8:	31 c0                	xor    eax,eax
  20a3ba:	48 85 ed             	test   rbp,rbp
  20a3bd:	0f 84 2e 13 00 00    	je     20b6f1 <dumpCurrentStackTrace+0x1631>
  20a3c3:	48 89 ea             	mov    rdx,rbp
  20a3c6:	c4 62 7d 59 25 59 68 	vpbroadcastq ymm12,QWORD PTR [rip+0xffffffffffff6859]        # 200c28 <__unnamed_441+0x88>
  20a3cd:	ff ff 
  20a3cf:	c4 62 7d 59 2d a8 68 	vpbroadcastq ymm13,QWORD PTR [rip+0xffffffffffff68a8]        # 200c80 <app_mask+0x48>
  20a3d6:	ff ff 
  20a3d8:	c5 7d 7f a4 24 00 01 	vmovdqa YMMWORD PTR [rsp+0x100],ymm12
  20a3df:	00 00 
  20a3e1:	c5 7d 7f ac 24 e0 00 	vmovdqa YMMWORD PTR [rsp+0xe0],ymm13
  20a3e8:	00 00 
  20a3ea:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  20a3f1:	00 
  20a3f2:	48 89 74 24 28       	mov    QWORD PTR [rsp+0x28],rsi
  20a3f7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a3fe:	00 00 
        const return_address = @intToPtr(*const usize, fp + @sizeOf(usize)).*;
  20a400:	4c 8b 6a 08          	mov    r13,QWORD PTR [rdx+0x8]
                if (return_address == addr) {
  20a404:	49 39 cd             	cmp    r13,rcx
        switch (addr_state) {
  20a407:	74 17                	je     20a420 <dumpCurrentStackTrace+0x360>
  20a409:	f6 d0                	not    al
  20a40b:	a8 01                	test   al,0x1
  20a40d:	b0 01                	mov    al,0x1
  20a40f:	75 0f                	jne    20a420 <dumpCurrentStackTrace+0x360>
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  20a411:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  20a414:	48 85 d2             	test   rdx,rdx
  20a417:	75 e7                	jne    20a400 <dumpCurrentStackTrace+0x340>
  20a419:	e9 d3 12 00 00       	jmp    20b6f1 <dumpCurrentStackTrace+0x1631>
  20a41e:	66 90                	xchg   ax,ax
  20a420:	48 89 94 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rdx
  20a427:	00 
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  20a428:	48 89 b4 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rsi
  20a42f:	00 
  20a430:	48 8d 05 f9 61 00 00 	lea    rax,[rip+0x61f9]        # 210630 <FileInStream_readFn>
  20a437:	48 89 84 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],rax
  20a43e:	00 
        pub fn deinit(self: Self) void {
            self.allocator.free(self.items);
        }

        pub fn toSlice(self: Self) []align(A) T {
            return self.items[0..self.len];
  20a43f:	48 8b 86 b8 00 00 00 	mov    rax,QWORD PTR [rsi+0xb8]
  20a446:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  20a44b:	48 85 c0             	test   rax,rax
  20a44e:	0f 84 6c 04 00 00    	je     20a8c0 <dumpCurrentStackTrace+0x800>
  20a454:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20a459:	4c 8b 88 a8 00 00 00 	mov    r9,QWORD PTR [rax+0xa8]
  20a460:	45 31 e4             	xor    r12d,r12d
  20a463:	e9 08 02 00 00       	jmp    20a670 <dumpCurrentStackTrace+0x5b0>
                result = (result << 8) | b;
            }
        },
        builtin.Endian.Little => {
            const ShiftType = math.Log2Int(T);
            for (bytes) |b, index| {
  20a468:	48 89 c3             	mov    rbx,rax
  20a46b:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  20a46f:	48 8d 73 f0          	lea    rsi,[rbx-0x10]
  20a473:	48 89 f7             	mov    rdi,rsi
  20a476:	48 c1 ef 04          	shr    rdi,0x4
  20a47a:	44 8d 47 01          	lea    r8d,[rdi+0x1]
  20a47e:	41 83 e0 01          	and    r8d,0x1
  20a482:	48 85 f6             	test   rsi,rsi
  20a485:	0f 84 bd 01 00 00    	je     20a648 <dumpCurrentStackTrace+0x588>
  20a48b:	49 8d 70 ff          	lea    rsi,[r8-0x1]
  20a48f:	48 29 fe             	sub    rsi,rdi
  20a492:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20a496:	31 ff                	xor    edi,edi
  20a498:	c5 fd 6f 25 00 68 ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff6800]        # 200ca0 <app_mask+0x68>
  20a49f:	ff 
  20a4a0:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  20a4a4:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20a4a8:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  20a4ac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20a4b0:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  20a4b6:	c4 e2 7d 32 74 39 04 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x4]
  20a4bd:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  20a4c4:	c4 62 7d 32 44 39 0c 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0xc]
  20a4cb:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  20a4d0:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  20a4d5:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  20a4da:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  20a4df:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  20a4e4:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  20a4e8:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  20a4ed:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  20a4f1:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  20a4f6:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  20a4fa:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  20a4ff:	c4 e2 7d 32 74 39 10 	vpmovzxbq ymm6,DWORD PTR [rcx+rdi*1+0x10]
  20a506:	c4 e2 7d 32 7c 39 14 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x14]
  20a50d:	c4 62 7d 32 44 39 18 	vpmovzxbq ymm8,DWORD PTR [rcx+rdi*1+0x18]
  20a514:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  20a518:	c4 e2 7d 32 6c 39 1c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x1c]
  20a51f:	c4 62 7d 59 15 50 67 	vpbroadcastq ymm10,QWORD PTR [rip+0xffffffffffff6750]        # 200c78 <app_mask+0x40>
  20a526:	ff ff 
  20a528:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  20a52d:	c4 62 7d 59 1d 82 66 	vpbroadcastq ymm11,QWORD PTR [rip+0xffffffffffff6682]        # 200bb8 <__unnamed_441+0x18>
  20a534:	ff ff 
  20a536:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  20a53b:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  20a540:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  20a545:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  20a54a:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  20a54e:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  20a553:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  20a557:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  20a55c:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  20a560:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  20a565:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  20a569:	48 83 c7 20          	add    rdi,0x20
  20a56d:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  20a572:	48 83 c6 02          	add    rsi,0x2
  20a576:	0f 85 34 ff ff ff    	jne    20a4b0 <dumpCurrentStackTrace+0x3f0>
  20a57c:	4d 85 c0             	test   r8,r8
  20a57f:	74 53                	je     20a5d4 <dumpCurrentStackTrace+0x514>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20a581:	c4 e2 7d 32 6c 39 0c 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0xc]
  20a588:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  20a58d:	c4 c1 5d d4 f4       	vpaddq ymm6,ymm4,ymm12
  20a592:	c4 c1 4d db f5       	vpand  ymm6,ymm6,ymm13
  20a597:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20a59c:	c4 e2 7d 32 7c 39 08 	vpmovzxbq ymm7,DWORD PTR [rcx+rdi*1+0x8]
  20a5a3:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  20a5a7:	c4 c1 5d db e5       	vpand  ymm4,ymm4,ymm13
  20a5ac:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  20a5b1:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  20a5b5:	c4 e2 7d 32 6c 39 04 	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1+0x4]
  20a5bc:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20a5c1:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  20a5c5:	c4 e2 7d 32 2c 39    	vpmovzxbq ymm5,DWORD PTR [rcx+rdi*1]
  20a5cb:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  20a5d0:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  20a5d4:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  20a5d8:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  20a5dc:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20a5e0:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  20a5e6:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20a5ea:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  20a5ef:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20a5f3:	c4 e1 f9 7e c6       	vmovq  rsi,xmm0
  20a5f8:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  20a5fb:	74 31                	je     20a62e <dumpCurrentStackTrace+0x56e>
  20a5fd:	48 29 d8             	sub    rax,rbx
  20a600:	48 01 d9             	add    rcx,rbx
  20a603:	48 c1 e3 03          	shl    rbx,0x3
  20a607:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20a60e:	00 00 
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20a610:	0f b6 39             	movzx  edi,BYTE PTR [rcx]
  20a613:	89 da                	mov    edx,ebx
  20a615:	80 e2 38             	and    dl,0x38
  20a618:	c4 e2 e9 f7 d7       	shlx   rdx,rdi,rdx
  20a61d:	48 09 d6             	or     rsi,rdx
            for (bytes) |b, index| {
  20a620:	48 83 c3 08          	add    rbx,0x8
  20a624:	48 83 c1 01          	add    rcx,0x1
  20a628:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20a62c:	75 e2                	jne    20a610 <dumpCurrentStackTrace+0x550>
            if (st.debug_ranges) |debug_ranges| {
  20a62e:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20a633:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  20a63a:	48 85 c0             	test   rax,rax
  20a63d:	0f 85 fd 00 00 00    	jne    20a740 <dumpCurrentStackTrace+0x680>
  20a643:	e9 68 02 00 00       	jmp    20a8b0 <dumpCurrentStackTrace+0x7f0>
  20a648:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20a64c:	31 ff                	xor    edi,edi
  20a64e:	c5 fd 6f 25 4a 66 ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff664a]        # 200ca0 <app_mask+0x68>
  20a655:	ff 
  20a656:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  20a65a:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20a65e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  20a662:	4d 85 c0             	test   r8,r8
  20a665:	0f 85 16 ff ff ff    	jne    20a581 <dumpCurrentStackTrace+0x4c1>
  20a66b:	e9 64 ff ff ff       	jmp    20a5d4 <dumpCurrentStackTrace+0x514>
        if (compile_unit.pc_range) |range| {
  20a670:	4f 8d 34 64          	lea    r14,[r12+r12*2]
  20a674:	49 c1 e6 04          	shl    r14,0x4
  20a678:	43 80 7c 31 28 01    	cmp    BYTE PTR [r9+r14*1+0x28],0x1
  20a67e:	75 12                	jne    20a692 <dumpCurrentStackTrace+0x5d2>
            if (target_address >= range.start and target_address < range.end) return compile_unit;
  20a680:	4f 39 6c 31 18       	cmp    QWORD PTR [r9+r14*1+0x18],r13
  20a685:	77 0b                	ja     20a692 <dumpCurrentStackTrace+0x5d2>
  20a687:	4f 39 6c 31 20       	cmp    QWORD PTR [r9+r14*1+0x20],r13
  20a68c:	0f 87 4c 04 00 00    	ja     20aade <dumpCurrentStackTrace+0xa1e>
        if (compile_unit.die.getAttrSecOffset(DW.AT_ranges)) |ranges_offset| {
  20a692:	4b 8b 4c 31 08       	mov    rcx,QWORD PTR [r9+r14*1+0x8]
  20a697:	48 8b 41 20          	mov    rax,QWORD PTR [rcx+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  20a69b:	48 85 c0             	test   rax,rax
  20a69e:	0f 84 0c 02 00 00    	je     20a8b0 <dumpCurrentStackTrace+0x7f0>
  20a6a4:	4b 8d 14 31          	lea    rdx,[r9+r14*1]
  20a6a8:	48 83 c2 08          	add    rdx,0x8
  20a6ac:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  20a6b3:	00 
  20a6b4:	48 8b 49 10          	mov    rcx,QWORD PTR [rcx+0x10]
            if (attr.id == id) return &attr.value;
  20a6b8:	48 83 c1 20          	add    rcx,0x20
  20a6bc:	31 d2                	xor    edx,edx
  20a6be:	66 90                	xchg   ax,ax
  20a6c0:	48 83 79 e0 55       	cmp    QWORD PTR [rcx-0x20],0x55
  20a6c5:	74 19                	je     20a6e0 <dumpCurrentStackTrace+0x620>
        for (self.attrs.toSliceConst()) |*attr| {
  20a6c7:	48 83 c2 01          	add    rdx,0x1
  20a6cb:	48 83 c1 28          	add    rcx,0x28
  20a6cf:	48 39 c2             	cmp    rdx,rax
  20a6d2:	72 ec                	jb     20a6c0 <dumpCurrentStackTrace+0x600>
  20a6d4:	e9 d7 01 00 00       	jmp    20a8b0 <dumpCurrentStackTrace+0x7f0>
  20a6d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  20a6e0:	8a 01                	mov    al,BYTE PTR [rcx]
  20a6e2:	3c 05                	cmp    al,0x5
        return switch (form_value.*) {
  20a6e4:	74 41                	je     20a727 <dumpCurrentStackTrace+0x667>
  20a6e6:	3c 02                	cmp    al,0x2
  20a6e8:	0f 85 d2 01 00 00    	jne    20a8c0 <dumpCurrentStackTrace+0x800>
            FormValue.Const => |value| value.asUnsignedLe(),
  20a6ee:	48 8b 41 f0          	mov    rax,QWORD PTR [rcx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  20a6f2:	48 83 f8 08          	cmp    rax,0x8
  20a6f6:	0f 87 c4 01 00 00    	ja     20a8c0 <dumpCurrentStackTrace+0x800>
            FormValue.Const => |value| value.asUnsignedLe(),
  20a6fc:	8a 51 f8             	mov    dl,BYTE PTR [rcx-0x8]
        if (self.signed) return error.InvalidDebugInfo;
  20a6ff:	84 d2                	test   dl,dl
  20a701:	0f 85 b9 01 00 00    	jne    20a8c0 <dumpCurrentStackTrace+0x800>
  20a707:	48 85 c0             	test   rax,rax
  20a70a:	0f 84 7c 01 00 00    	je     20a88c <dumpCurrentStackTrace+0x7cc>
  20a710:	48 8b 49 e8          	mov    rcx,QWORD PTR [rcx-0x18]
  20a714:	48 83 f8 10          	cmp    rax,0x10
  20a718:	0f 83 4a fd ff ff    	jae    20a468 <dumpCurrentStackTrace+0x3a8>
  20a71e:	31 db                	xor    ebx,ebx
  20a720:	31 f6                	xor    esi,esi
  20a722:	e9 d6 fe ff ff       	jmp    20a5fd <dumpCurrentStackTrace+0x53d>
            FormValue.SecOffset => |value| value,
  20a727:	48 8b 71 e8          	mov    rsi,QWORD PTR [rcx-0x18]
            if (st.debug_ranges) |debug_ranges| {
  20a72b:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20a730:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  20a737:	48 85 c0             	test   rax,rax
  20a73a:	0f 84 70 01 00 00    	je     20a8b0 <dumpCurrentStackTrace+0x7f0>
/// Cast an integer to a different integer type. If the value doesn't fit,
/// return an error.
pub fn cast(comptime T: type, x: var) (error{Overflow}!T) {
    comptime assert(@typeId(T) == builtin.TypeId.Int); // must pass an integer
    comptime assert(@typeId(@typeOf(x)) == builtin.TypeId.Int); // must pass an integer
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  20a740:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  20a744:	0f 88 76 01 00 00    	js     20a8c0 <dumpCurrentStackTrace+0x800>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20a74a:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20a74f:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20a752:	b8 08 00 00 00       	mov    eax,0x8
  20a757:	31 d2                	xor    edx,edx
  20a759:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20a75b:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const ipos = try math.cast(isize, pos);
                const result = posix.lseek(self.handle, ipos, posix.SEEK_SET);
                const err = posix.getErrno(result);
                if (err > 0) {
  20a761:	0f 83 59 01 00 00    	jae    20a8c0 <dumpCurrentStackTrace+0x800>
  20a767:	4c 89 cb             	mov    rbx,r9
            try self.readNoEof(bytes[0..]);
  20a76a:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  20a771:	00 
  20a772:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20a777:	48 c7 44 24 18 08 00 	mov    QWORD PTR [rsp+0x18],0x8
  20a77e:	00 00 
            return self.readFn(self, buffer);
  20a780:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
  20a785:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  20a78c:	00 
  20a78d:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20a792:	c5 f8 77             	vzeroupper 
  20a795:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
            const amt_read = try self.read(buf);
  20a79c:	66 83 7c 24 30 00    	cmp    WORD PTR [rsp+0x30],0x0
  20a7a2:	0f 85 18 01 00 00    	jne    20a8c0 <dumpCurrentStackTrace+0x800>
  20a7a8:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  20a7ad:	0f 1f 00             	nop    DWORD PTR [rax]
            if (amt_read < buf.len) return error.EndOfStream;
  20a7b0:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  20a7b5:	0f 82 05 01 00 00    	jb     20a8c0 <dumpCurrentStackTrace+0x800>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20a7bb:	4c 8b bc 24 b8 00 00 	mov    r15,QWORD PTR [rsp+0xb8]
  20a7c2:	00 
            try self.readNoEof(bytes[0..]);
  20a7c3:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  20a7ca:	00 
  20a7cb:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20a7d0:	48 c7 44 24 18 08 00 	mov    QWORD PTR [rsp+0x18],0x8
  20a7d7:	00 00 
            return self.readFn(self, buffer);
  20a7d9:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
  20a7de:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  20a7e5:	00 
  20a7e6:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20a7eb:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
            const amt_read = try self.read(buf);
  20a7f2:	66 83 7c 24 30 00    	cmp    WORD PTR [rsp+0x30],0x0
  20a7f8:	0f 85 c2 00 00 00    	jne    20a8c0 <dumpCurrentStackTrace+0x800>
  20a7fe:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20a803:	48 39 44 24 38       	cmp    QWORD PTR [rsp+0x38],rax
  20a808:	0f 82 b2 00 00 00    	jb     20a8c0 <dumpCurrentStackTrace+0x800>
  20a80e:	48 8b 84 24 b8 00 00 	mov    rax,QWORD PTR [rsp+0xb8]
  20a815:	00 
                    if (begin_addr == 0 and end_addr == 0) {
  20a816:	48 89 c1             	mov    rcx,rax
  20a819:	4c 09 f9             	or     rcx,r15
  20a81c:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  20a823:	00 00 
  20a825:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  20a82c:	00 00 
  20a82e:	49 89 d9             	mov    r9,rbx
  20a831:	74 7d                	je     20a8b0 <dumpCurrentStackTrace+0x7f0>
                    if (begin_addr == @maxValue(usize)) {
  20a833:	49 83 ff ff          	cmp    r15,0xffffffffffffffff
  20a837:	74 0e                	je     20a847 <dumpCurrentStackTrace+0x787>
                    if (target_address >= begin_addr and target_address < end_addr) {
  20a839:	4d 39 ef             	cmp    r15,r13
  20a83c:	77 09                	ja     20a847 <dumpCurrentStackTrace+0x787>
  20a83e:	4c 39 e8             	cmp    rax,r13
  20a841:	0f 87 8d 02 00 00    	ja     20aad4 <dumpCurrentStackTrace+0xa14>
            try self.readNoEof(bytes[0..]);
  20a847:	48 8d 84 24 b8 00 00 	lea    rax,[rsp+0xb8]
  20a84e:	00 
  20a84f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20a854:	48 c7 44 24 18 08 00 	mov    QWORD PTR [rsp+0x18],0x8
  20a85b:	00 00 
            return self.readFn(self, buffer);
  20a85d:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
  20a862:	48 8d b4 24 d0 00 00 	lea    rsi,[rsp+0xd0]
  20a869:	00 
  20a86a:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20a86f:	c5 f8 77             	vzeroupper 
  20a872:	ff 94 24 d0 00 00 00 	call   QWORD PTR [rsp+0xd0]
  20a879:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  20a87e:	66 83 7c 24 30 00    	cmp    WORD PTR [rsp+0x30],0x0
  20a884:	0f 84 26 ff ff ff    	je     20a7b0 <dumpCurrentStackTrace+0x6f0>
  20a88a:	eb 34                	jmp    20a8c0 <dumpCurrentStackTrace+0x800>
        return switch (form_value.*) {
  20a88c:	31 f6                	xor    esi,esi
            if (st.debug_ranges) |debug_ranges| {
  20a88e:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20a893:	48 8b 80 80 00 00 00 	mov    rax,QWORD PTR [rax+0x80]
  20a89a:	48 85 c0             	test   rax,rax
  20a89d:	0f 85 9d fe ff ff    	jne    20a740 <dumpCurrentStackTrace+0x680>
  20a8a3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a8aa:	84 00 00 00 00 00 
    for (st.compile_unit_list.toSlice()) |*compile_unit| {
  20a8b0:	49 83 c4 01          	add    r12,0x1
  20a8b4:	4c 3b 64 24 78       	cmp    r12,QWORD PTR [rsp+0x78]
  20a8b9:	0f 82 b1 fd ff ff    	jb     20a670 <dumpCurrentStackTrace+0x5b0>
  20a8bf:	90                   	nop
  20a8c0:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
            return std.fmt.format(self, Error, self.writeFn, format, args);
  20a8c5:	4d 8b 34 24          	mov    r14,QWORD PTR [r12]
                if (tty_color) {
  20a8c9:	80 7c 24 0f 00       	cmp    BYTE PTR [rsp+0xf],0x0
  20a8ce:	74 70                	je     20a940 <dumpCurrentStackTrace+0x880>
                        try output(context, fmt[start_index..i]);
  20a8d0:	4c 89 e7             	mov    rdi,r12
  20a8d3:	48 8d 35 96 63 01 00 	lea    rsi,[rip+0x16396]        # 220c70 <__unnamed_22>
  20a8da:	c5 f8 77             	vzeroupper 
  20a8dd:	41 ff d6             	call   r14
  20a8e0:	41 89 c7             	mov    r15d,eax
  20a8e3:	66 45 85 ff          	test   r15w,r15w
  20a8e7:	0f 85 a3 01 00 00    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
    var buf: [max_int_digits - 1]u8 = undefined;
  20a8ed:	c5 fc 10 05 83 ce ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffce83]        # 207778 <__unnamed_14+0x1f>
  20a8f4:	ff 
  20a8f5:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20a8fb:	c5 fe 6f 05 56 ce ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffce56]        # 207759 <__unnamed_14>
  20a902:	ff 
  20a903:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a909:	44 89 e8             	mov    eax,r13d
  20a90c:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  20a90e:	b1 30                	mov    cl,0x30
  20a910:	3c 0a                	cmp    al,0xa
  20a912:	72 02                	jb     20a916 <dumpCurrentStackTrace+0x856>
  20a914:	b1 57                	mov    cl,0x57
  20a916:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a918:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20a91c:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20a921:	49 83 fd 10          	cmp    r13,0x10
  20a925:	73 7e                	jae    20a9a5 <dumpCurrentStackTrace+0x8e5>
  20a927:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20a92c:	e9 af 00 00 00       	jmp    20a9e0 <dumpCurrentStackTrace+0x920>
  20a931:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20a938:	0f 1f 84 00 00 00 00 
  20a93f:	00 
                        try output(context, fmt[start_index..i]);
  20a940:	4c 89 e7             	mov    rdi,r12
  20a943:	48 8d 35 46 63 01 00 	lea    rsi,[rip+0x16346]        # 220c90 <__unnamed_23>
  20a94a:	c5 f8 77             	vzeroupper 
  20a94d:	41 ff d6             	call   r14
  20a950:	41 89 c7             	mov    r15d,eax
  20a953:	66 45 85 ff          	test   r15w,r15w
  20a957:	0f 85 33 01 00 00    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
    var buf: [max_int_digits - 1]u8 = undefined;
  20a95d:	c5 fc 10 05 13 ce ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffce13]        # 207778 <__unnamed_14+0x1f>
  20a964:	ff 
  20a965:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20a96b:	c5 fe 6f 05 e6 cd ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffcde6]        # 207759 <__unnamed_14>
  20a972:	ff 
  20a973:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a979:	44 89 e8             	mov    eax,r13d
  20a97c:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  20a97e:	b1 30                	mov    cl,0x30
  20a980:	3c 0a                	cmp    al,0xa
  20a982:	72 02                	jb     20a986 <dumpCurrentStackTrace+0x8c6>
  20a984:	b1 57                	mov    cl,0x57
  20a986:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a988:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20a98c:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20a991:	49 83 fd 10          	cmp    r13,0x10
  20a995:	0f 83 7e 00 00 00    	jae    20aa19 <dumpCurrentStackTrace+0x959>
  20a99b:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20a9a0:	e9 ab 00 00 00       	jmp    20aa50 <dumpCurrentStackTrace+0x990>
        a /= base;
  20a9a5:	4c 89 e9             	mov    rcx,r13
  20a9a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20a9af:	00 
  20a9b0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a9b4:	89 ca                	mov    edx,ecx
  20a9b6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  20a9b9:	b3 30                	mov    bl,0x30
  20a9bb:	80 fa 0a             	cmp    dl,0xa
  20a9be:	72 02                	jb     20a9c2 <dumpCurrentStackTrace+0x902>
  20a9c0:	b3 57                	mov    bl,0x57
  20a9c2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20a9c4:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20a9c8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20a9cc:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  20a9d3:	49 89 cd             	mov    r13,rcx
  20a9d6:	77 d8                	ja     20a9b0 <dumpCurrentStackTrace+0x8f0>
        const padded_buf = buf[index - padding ..];
  20a9d8:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20a9dc:	48 83 c1 2f          	add    rcx,0x2f
  20a9e0:	ba 41 00 00 00       	mov    edx,0x41
  20a9e5:	48 29 c2             	sub    rdx,rax
  20a9e8:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20a9ed:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20a9f2:	4c 89 e7             	mov    rdi,r12
  20a9f5:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20a9fa:	c5 f8 77             	vzeroupper 
  20a9fd:	41 ff d6             	call   r14
  20aa00:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20aa03:	66 45 85 ff          	test   r15w,r15w
  20aa07:	0f 85 83 00 00 00    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
        try output(context, fmt[start_index..]);
  20aa0d:	4c 89 e7             	mov    rdi,r12
  20aa10:	48 8d 35 69 62 01 00 	lea    rsi,[rip+0x16269]        # 220c80 <__unnamed_24>
  20aa17:	eb 6a                	jmp    20aa83 <dumpCurrentStackTrace+0x9c3>
        a /= base;
  20aa19:	4c 89 e9             	mov    rcx,r13
  20aa1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  20aa20:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20aa24:	89 ca                	mov    edx,ecx
  20aa26:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  20aa29:	b3 30                	mov    bl,0x30
  20aa2b:	80 fa 0a             	cmp    dl,0xa
  20aa2e:	72 02                	jb     20aa32 <dumpCurrentStackTrace+0x972>
  20aa30:	b3 57                	mov    bl,0x57
  20aa32:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20aa34:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20aa38:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20aa3c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  20aa43:	49 89 cd             	mov    r13,rcx
  20aa46:	77 d8                	ja     20aa20 <dumpCurrentStackTrace+0x960>
        const padded_buf = buf[index - padding ..];
  20aa48:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20aa4c:	48 83 c1 2f          	add    rcx,0x2f
  20aa50:	ba 41 00 00 00       	mov    edx,0x41
  20aa55:	48 29 c2             	sub    rdx,rax
  20aa58:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20aa5d:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20aa62:	4c 89 e7             	mov    rdi,r12
  20aa65:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20aa6a:	c5 f8 77             	vzeroupper 
  20aa6d:	41 ff d6             	call   r14
  20aa70:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20aa73:	66 45 85 ff          	test   r15w,r15w
  20aa77:	75 17                	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
        try output(context, fmt[start_index..]);
  20aa79:	4c 89 e7             	mov    rdi,r12
  20aa7c:	48 8d 35 1d 62 01 00 	lea    rsi,[rip+0x1621d]        # 220ca0 <__unnamed_25>
  20aa83:	41 ff d6             	call   r14
  20aa86:	41 89 c7             	mov    r15d,eax
  20aa89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  20aa90:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  20aa97:	00 00 
  20aa99:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  20aaa0:	00 00 
        try printSourceAtAddress(debug_info, out_stream, return_address, tty_color);
  20aaa2:	66 45 85 ff          	test   r15w,r15w
  20aaa6:	0f 85 f8 0b 00 00    	jne    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20aaac:	31 c0                	xor    eax,eax
  20aaae:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  20aab5:	00 
  20aab6:	48 8b 94 24 b0 00 00 	mov    rdx,QWORD PTR [rsp+0xb0]
  20aabd:	00 
  20aabe:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  20aac3:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  20aac6:	48 85 d2             	test   rdx,rdx
  20aac9:	0f 85 31 f9 ff ff    	jne    20a400 <dumpCurrentStackTrace+0x340>
  20aacf:	e9 1d 0c 00 00       	jmp    20b6f1 <dumpCurrentStackTrace+0x1631>
  20aad4:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  20aadb:	00 
  20aadc:	eb 08                	jmp    20aae6 <dumpCurrentStackTrace+0xa26>
            const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  20aade:	4b 8d 04 31          	lea    rax,[r9+r14*1]
  20aae2:	48 83 c0 08          	add    rax,0x8
  20aae6:	48 8b 00             	mov    rax,QWORD PTR [rax]
        }

        pub fn toSliceConst(self: Self) []align(A) const T {
            return self.items[0..self.len];
  20aae9:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  20aaed:	48 85 c9             	test   rcx,rcx
  20aaf0:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
  20aaf5:	0f 84 84 0b 00 00    	je     20b67f <dumpCurrentStackTrace+0x15bf>
  20aafb:	4d 01 f1             	add    r9,r14
  20aafe:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  20ab02:	31 d2                	xor    edx,edx
  20ab04:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ab0b:	00 00 00 00 00 
            if (attr.id == id) return &attr.value;
  20ab10:	48 83 38 03          	cmp    QWORD PTR [rax],0x3
  20ab14:	74 12                	je     20ab28 <dumpCurrentStackTrace+0xa68>
        for (self.attrs.toSliceConst()) |*attr| {
  20ab16:	48 83 c2 01          	add    rdx,0x1
  20ab1a:	48 83 c0 28          	add    rax,0x28
  20ab1e:	48 39 ca             	cmp    rdx,rcx
  20ab21:	72 ed                	jb     20ab10 <dumpCurrentStackTrace+0xa50>
  20ab23:	e9 57 0b 00 00       	jmp    20b67f <dumpCurrentStackTrace+0x15bf>
  20ab28:	8a 50 20             	mov    dl,BYTE PTR [rax+0x20]
  20ab2b:	80 fa 0a             	cmp    dl,0xa
        return switch (form_value.*) {
  20ab2e:	74 2f                	je     20ab5f <dumpCurrentStackTrace+0xa9f>
  20ab30:	48 8d 0d d1 b9 ff ff 	lea    rcx,[rip+0xffffffffffffb9d1]        # 206508 <__unnamed_26>
  20ab37:	80 fa 09             	cmp    dl,0x9
  20ab3a:	0f 85 a4 00 00 00    	jne    20abe4 <dumpCurrentStackTrace+0xb24>
            FormValue.String => |value| value,
  20ab40:	66 c7 44 24 10 00 00 	mov    WORD PTR [rsp+0x10],0x0
  20ab47:	c5 fa 6f 40 08       	vmovdqu xmm0,XMMWORD PTR [rax+0x8]
  20ab4c:	48 8d 44 24 18       	lea    rax,[rsp+0x18]
  20ab51:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
        return switch (form_value.*) {
  20ab55:	48 8d 4c 24 10       	lea    rcx,[rsp+0x10]
  20ab5a:	e9 85 00 00 00       	jmp    20abe4 <dumpCurrentStackTrace+0xb24>
            FormValue.StrPtr => |offset| getString(st, offset),
  20ab5f:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
  20ab63:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
    const pos = st.debug_str.offset + offset;
  20ab68:	48 8b 41 70          	mov    rax,QWORD PTR [rcx+0x70]
  20ab6c:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  20ab70:	78 45                	js     20abb7 <dumpCurrentStackTrace+0xaf7>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20ab72:	48 63 39             	movsxd rdi,DWORD PTR [rcx]
  20ab75:	b8 08 00 00 00       	mov    eax,0x8
  20ab7a:	31 d2                	xor    edx,edx
  20ab7c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20ab7e:	48 89 c1             	mov    rcx,rax
  20ab81:	48 f7 d9             	neg    rcx
  20ab84:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20ab8a:	b8 00 00 00 00       	mov    eax,0x0
  20ab8f:	48 0f 46 c8          	cmovbe rcx,rax
  20ab93:	66 b8 02 00          	mov    ax,0x2
  20ab97:	48 83 f9 1d          	cmp    rcx,0x1d
  20ab9b:	0f 87 a2 09 00 00    	ja     20b543 <dumpCurrentStackTrace+0x1483>
  20aba1:	48 8d 15 58 61 ff ff 	lea    rdx,[rip+0xffffffffffff6158]        # 200d00 <__unnamed_9+0x20>
  20aba8:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  20abac:	48 01 d1             	add    rcx,rdx
  20abaf:	ff e1                	jmp    rcx
  20abb1:	66 b8 22 00          	mov    ax,0x22
  20abb5:	eb 04                	jmp    20abbb <dumpCurrentStackTrace+0xafb>
  20abb7:	66 b8 23 00          	mov    ax,0x23
    try st.self_exe_file.seekTo(pos);
  20abbb:	66 89 44 24 30       	mov    WORD PTR [rsp+0x30],ax
  20abc0:	48 8b 84 24 d6 00 00 	mov    rax,QWORD PTR [rsp+0xd6]
  20abc7:	00 
  20abc8:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20abcd:	48 89 41 d1          	mov    QWORD PTR [rcx-0x2f],rax
  20abd1:	c5 fa 6f 84 24 c8 00 	vmovdqu xmm0,XMMWORD PTR [rsp+0xc8]
  20abd8:	00 00 
  20abda:	c5 fa 7f 41 c3       	vmovdqu XMMWORD PTR [rcx-0x3d],xmm0
        return switch (form_value.*) {
  20abdf:	48 8d 4c 24 30       	lea    rcx,[rsp+0x30]
  20abe4:	44 0f b7 39          	movzx  r15d,WORD PTR [rcx]
  20abe8:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
  20abec:	48 89 84 24 4e 01 00 	mov    QWORD PTR [rsp+0x14e],rax
  20abf3:	00 
  20abf4:	c5 fa 6f 41 02       	vmovdqu xmm0,XMMWORD PTR [rcx+0x2]
  20abf9:	c5 f9 7f 84 24 40 01 	vmovdqa XMMWORD PTR [rsp+0x140],xmm0
  20ac00:	00 00 
            const compile_unit_name = try compile_unit.die.getAttrString(debug_info, DW.AT_name);
  20ac02:	66 45 85 ff          	test   r15w,r15w
  20ac06:	0f 85 98 0a 00 00    	jne    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20ac0c:	48 8d 84 24 46 01 00 	lea    rax,[rsp+0x146]
  20ac13:	00 
  20ac14:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20ac18:	c5 f9 7f 84 24 20 01 	vmovdqa XMMWORD PTR [rsp+0x120],xmm0
  20ac1f:	00 00 
            if (getLineNumberInfo(debug_info, compile_unit, address - 1)) |line_info| {
  20ac21:	49 8d 4d ff          	lea    rcx,[r13-0x1]
  20ac25:	48 8d bc 24 58 01 00 	lea    rdi,[rsp+0x158]
  20ac2c:	00 
  20ac2d:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  20ac32:	4c 89 ca             	mov    rdx,r9
  20ac35:	c5 f8 77             	vzeroupper 
  20ac38:	e8 03 9c 00 00       	call   214840 <getLineNumberInfo>
  20ac3d:	44 0f b7 bc 24 58 01 	movzx  r15d,WORD PTR [rsp+0x158]
  20ac44:	00 00 
  20ac46:	66 45 85 ff          	test   r15w,r15w
  20ac4a:	74 77                	je     20acc3 <dumpCurrentStackTrace+0xc03>
            } else |err| switch (err) {
  20ac4c:	44 89 f8             	mov    eax,r15d
  20ac4f:	25 fe ff 00 00       	and    eax,0xfffe
  20ac54:	83 f8 24             	cmp    eax,0x24
  20ac57:	0f 85 47 0a 00 00    	jne    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20ac5d:	4d 8b 34 24          	mov    r14,QWORD PTR [r12]
                        try output(context, fmt[start_index..i]);
  20ac61:	4c 89 e7             	mov    rdi,r12
  20ac64:	48 8d 35 f5 60 01 00 	lea    rsi,[rip+0x160f5]        # 220d60 <__unnamed_27>
  20ac6b:	41 ff d6             	call   r14
  20ac6e:	41 89 c7             	mov    r15d,eax
  20ac71:	66 45 85 ff          	test   r15w,r15w
  20ac75:	0f 85 15 fe ff ff    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
    var buf: [max_int_digits - 1]u8 = undefined;
  20ac7b:	c5 fc 10 05 f5 ca ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffcaf5]        # 207778 <__unnamed_14+0x1f>
  20ac82:	ff 
  20ac83:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20ac89:	c5 fe 6f 05 c8 ca ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffcac8]        # 207759 <__unnamed_14>
  20ac90:	ff 
  20ac91:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20ac97:	44 89 e8             	mov    eax,r13d
  20ac9a:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  20ac9c:	b1 30                	mov    cl,0x30
  20ac9e:	3c 0a                	cmp    al,0xa
  20aca0:	72 02                	jb     20aca4 <dumpCurrentStackTrace+0xbe4>
  20aca2:	b1 57                	mov    cl,0x57
  20aca4:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20aca6:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20acaa:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20acaf:	49 83 fd 10          	cmp    r13,0x10
  20acb3:	0f 83 b8 04 00 00    	jae    20b171 <dumpCurrentStackTrace+0x10b1>
  20acb9:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20acbe:	e9 ed 04 00 00       	jmp    20b1b0 <dumpCurrentStackTrace+0x10f0>
  20acc3:	48 8d 84 24 60 01 00 	lea    rax,[rsp+0x160]
  20acca:	00 
            if (getLineNumberInfo(debug_info, compile_unit, address - 1)) |line_info| {
  20accb:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  20accf:	c5 fe 7f 84 24 80 00 	vmovdqu YMMWORD PTR [rsp+0x80],ymm0
  20acd6:	00 00 
  20acd8:	48 8b 40 20          	mov    rax,QWORD PTR [rax+0x20]
  20acdc:	48 89 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rax
  20ace3:	00 
  20ace4:	4c 89 e3             	mov    rbx,r12
  20ace7:	4c 8b a4 24 80 00 00 	mov    r12,QWORD PTR [rsp+0x80]
  20acee:	00 
  20acef:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  20acf6:	00 
  20acf7:	48 89 44 24 78       	mov    QWORD PTR [rsp+0x78],rax
  20acfc:	4c 8b 33             	mov    r14,QWORD PTR [rbx]
                if (tty_color) {
  20acff:	80 7c 24 0f 00       	cmp    BYTE PTR [rsp+0xf],0x0
  20ad04:	0f 84 cb 01 00 00    	je     20aed5 <dumpCurrentStackTrace+0xe15>
                        try output(context, fmt[start_index..i]);
  20ad0a:	48 89 df             	mov    rdi,rbx
  20ad0d:	48 8d 35 9c 5f 01 00 	lea    rsi,[rip+0x15f9c]        # 220cb0 <__unnamed_28>
  20ad14:	c5 f8 77             	vzeroupper 
  20ad17:	41 ff d6             	call   r14
  20ad1a:	41 89 c7             	mov    r15d,eax
  20ad1d:	66 45 85 ff          	test   r15w,r15w
  20ad21:	0f 85 dc 09 00 00    	jne    20b703 <dumpCurrentStackTrace+0x1643>
                const casted_value = ([]const u8)(value);
  20ad27:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  20ad2e:	00 
  20ad2f:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20ad33:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  20ad39:	48 89 df             	mov    rdi,rbx
  20ad3c:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20ad41:	41 ff d6             	call   r14
  20ad44:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20ad47:	66 45 85 ff          	test   r15w,r15w
  20ad4b:	0f 85 b2 09 00 00    	jne    20b703 <dumpCurrentStackTrace+0x1643>
                        try output(context, fmt[start_index..i]);
  20ad51:	48 89 df             	mov    rdi,rbx
  20ad54:	48 8d 35 65 5f 01 00 	lea    rsi,[rip+0x15f65]        # 220cc0 <__unnamed_29>
  20ad5b:	41 ff d6             	call   r14
  20ad5e:	41 89 c7             	mov    r15d,eax
  20ad61:	66 45 85 ff          	test   r15w,r15w
  20ad65:	0f 85 c1 09 00 00    	jne    20b72c <dumpCurrentStackTrace+0x166c>
    var buf: [max_int_digits - 1]u8 = undefined;
  20ad6b:	c5 fc 10 05 05 ca ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffca05]        # 207778 <__unnamed_14+0x1f>
  20ad72:	ff 
  20ad73:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20ad79:	c5 fe 6f 05 d8 c9 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc9d8]        # 207759 <__unnamed_14>
  20ad80:	ff 
  20ad81:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        const digit = a % base;
  20ad87:	4c 89 e2             	mov    rdx,r12
  20ad8a:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  20ad91:	cc cc cc 
  20ad94:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  20ad99:	c1 e9 02             	shr    ecx,0x2
  20ad9c:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20ada2:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20ada5:	44 89 e0             	mov    eax,r12d
  20ada8:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20adaa:	b1 30                	mov    cl,0x30
  20adac:	3c 0a                	cmp    al,0xa
  20adae:	72 02                	jb     20adb2 <dumpCurrentStackTrace+0xcf2>
  20adb0:	b1 57                	mov    cl,0x57
  20adb2:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20adb4:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20adb8:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20adbd:	49 83 fc 0a          	cmp    r12,0xa
  20adc1:	73 0d                	jae    20add0 <dumpCurrentStackTrace+0xd10>
  20adc3:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20adc8:	eb 58                	jmp    20ae22 <dumpCurrentStackTrace+0xd62>
  20adca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        a /= base;
  20add0:	4c 89 e2             	mov    rdx,r12
  20add3:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  20adda:	cc cc cc 
  20addd:	48 89 ce             	mov    rsi,rcx
  20ade0:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  20ade5:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20ade9:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  20adee:	c1 ee 02             	shr    esi,0x2
  20adf1:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  20adf7:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  20adfa:	89 d1                	mov    ecx,edx
  20adfc:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  20adfe:	b3 30                	mov    bl,0x30
  20ae00:	80 f9 0a             	cmp    cl,0xa
  20ae03:	72 02                	jb     20ae07 <dumpCurrentStackTrace+0xd47>
  20ae05:	b3 57                	mov    bl,0x57
  20ae07:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20ae09:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20ae0d:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20ae11:	49 83 fc 63          	cmp    r12,0x63
  20ae15:	49 89 d4             	mov    r12,rdx
  20ae18:	77 b6                	ja     20add0 <dumpCurrentStackTrace+0xd10>
        const padded_buf = buf[index - padding ..];
  20ae1a:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20ae1e:	48 83 c1 2f          	add    rcx,0x2f
  20ae22:	ba 41 00 00 00       	mov    edx,0x41
  20ae27:	48 29 c2             	sub    rdx,rax
  20ae2a:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20ae2f:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  20ae34:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        return output(context, padded_buf);
  20ae39:	4c 89 e7             	mov    rdi,r12
  20ae3c:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20ae41:	c5 f8 77             	vzeroupper 
  20ae44:	41 ff d6             	call   r14
  20ae47:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20ae4a:	66 45 85 ff          	test   r15w,r15w
  20ae4e:	0f 85 dd 08 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20ae54:	4c 89 e7             	mov    rdi,r12
  20ae57:	48 8d 35 72 5e 01 00 	lea    rsi,[rip+0x15e72]        # 220cd0 <__unnamed_30>
  20ae5e:	41 ff d6             	call   r14
  20ae61:	41 89 c7             	mov    r15d,eax
  20ae64:	66 45 85 ff          	test   r15w,r15w
  20ae68:	0f 85 c3 08 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
    var buf: [max_int_digits - 1]u8 = undefined;
  20ae6e:	c5 fc 10 05 02 c9 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc902]        # 207778 <__unnamed_14+0x1f>
  20ae75:	ff 
  20ae76:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20ae7c:	c5 fe 6f 05 d5 c8 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc8d5]        # 207759 <__unnamed_14>
  20ae83:	ff 
  20ae84:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
  20ae8a:	48 8b 54 24 78       	mov    rdx,QWORD PTR [rsp+0x78]
        const digit = a % base;
  20ae8f:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  20ae96:	cc cc cc 
  20ae99:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  20ae9e:	c1 e9 02             	shr    ecx,0x2
  20aea1:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20aea7:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20aeaa:	89 d0                	mov    eax,edx
  20aeac:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20aeae:	b1 30                	mov    cl,0x30
  20aeb0:	3c 0a                	cmp    al,0xa
  20aeb2:	72 02                	jb     20aeb6 <dumpCurrentStackTrace+0xdf6>
  20aeb4:	b1 57                	mov    cl,0x57
  20aeb6:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20aeb8:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20aebc:	b9 40 00 00 00       	mov    ecx,0x40
        if (a == 0) break;
  20aec1:	48 83 fa 0a          	cmp    rdx,0xa
  20aec5:	0f 83 62 03 00 00    	jae    20b22d <dumpCurrentStackTrace+0x116d>
  20aecb:	48 8d 44 24 6f       	lea    rax,[rsp+0x6f]
  20aed0:	e9 af 03 00 00       	jmp    20b284 <dumpCurrentStackTrace+0x11c4>
                const casted_value = ([]const u8)(value);
  20aed5:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  20aedc:	00 
  20aedd:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20aee1:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  20aee7:	48 89 df             	mov    rdi,rbx
  20aeea:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20aeef:	c5 f8 77             	vzeroupper 
  20aef2:	41 ff d6             	call   r14
  20aef5:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20aef8:	66 45 85 ff          	test   r15w,r15w
  20aefc:	0f 85 01 08 00 00    	jne    20b703 <dumpCurrentStackTrace+0x1643>
                        try output(context, fmt[start_index..i]);
  20af02:	48 89 df             	mov    rdi,rbx
  20af05:	48 8d 35 04 5e 01 00 	lea    rsi,[rip+0x15e04]        # 220d10 <__unnamed_31>
  20af0c:	41 ff d6             	call   r14
  20af0f:	41 89 c7             	mov    r15d,eax
  20af12:	66 45 85 ff          	test   r15w,r15w
  20af16:	0f 85 f9 07 00 00    	jne    20b715 <dumpCurrentStackTrace+0x1655>
    var buf: [max_int_digits - 1]u8 = undefined;
  20af1c:	c5 fc 10 05 54 c8 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc854]        # 207778 <__unnamed_14+0x1f>
  20af23:	ff 
  20af24:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20af2a:	c5 fe 6f 05 27 c8 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc827]        # 207759 <__unnamed_14>
  20af31:	ff 
  20af32:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        const digit = a % base;
  20af38:	4c 89 e2             	mov    rdx,r12
  20af3b:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  20af42:	cc cc cc 
  20af45:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  20af4a:	c1 e9 02             	shr    ecx,0x2
  20af4d:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20af53:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20af56:	44 89 e0             	mov    eax,r12d
  20af59:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20af5b:	b1 30                	mov    cl,0x30
  20af5d:	3c 0a                	cmp    al,0xa
  20af5f:	72 02                	jb     20af63 <dumpCurrentStackTrace+0xea3>
  20af61:	b1 57                	mov    cl,0x57
  20af63:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20af65:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20af69:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20af6e:	49 83 fc 0a          	cmp    r12,0xa
  20af72:	73 0c                	jae    20af80 <dumpCurrentStackTrace+0xec0>
  20af74:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20af79:	eb 57                	jmp    20afd2 <dumpCurrentStackTrace+0xf12>
  20af7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        a /= base;
  20af80:	4c 89 e2             	mov    rdx,r12
  20af83:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  20af8a:	cc cc cc 
  20af8d:	48 89 ce             	mov    rsi,rcx
  20af90:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  20af95:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20af99:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  20af9e:	c1 ee 02             	shr    esi,0x2
  20afa1:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  20afa7:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  20afaa:	89 d1                	mov    ecx,edx
  20afac:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  20afae:	b3 30                	mov    bl,0x30
  20afb0:	80 f9 0a             	cmp    cl,0xa
  20afb3:	72 02                	jb     20afb7 <dumpCurrentStackTrace+0xef7>
  20afb5:	b3 57                	mov    bl,0x57
  20afb7:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20afb9:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20afbd:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20afc1:	49 83 fc 63          	cmp    r12,0x63
  20afc5:	49 89 d4             	mov    r12,rdx
  20afc8:	77 b6                	ja     20af80 <dumpCurrentStackTrace+0xec0>
        const padded_buf = buf[index - padding ..];
  20afca:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20afce:	48 83 c1 2f          	add    rcx,0x2f
  20afd2:	ba 41 00 00 00       	mov    edx,0x41
  20afd7:	48 29 c2             	sub    rdx,rax
  20afda:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20afdf:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
  20afe4:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        return output(context, padded_buf);
  20afe9:	4c 89 e7             	mov    rdi,r12
  20afec:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20aff1:	c5 f8 77             	vzeroupper 
  20aff4:	41 ff d6             	call   r14
  20aff7:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20affa:	66 45 85 ff          	test   r15w,r15w
  20affe:	0f 85 2d 07 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20b004:	4c 89 e7             	mov    rdi,r12
  20b007:	48 8d 35 12 5d 01 00 	lea    rsi,[rip+0x15d12]        # 220d20 <__unnamed_32>
  20b00e:	41 ff d6             	call   r14
  20b011:	41 89 c7             	mov    r15d,eax
  20b014:	66 45 85 ff          	test   r15w,r15w
  20b018:	0f 85 13 07 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
    var buf: [max_int_digits - 1]u8 = undefined;
  20b01e:	c5 fc 10 05 52 c7 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc752]        # 207778 <__unnamed_14+0x1f>
  20b025:	ff 
  20b026:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20b02c:	c5 fe 6f 05 25 c7 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc725]        # 207759 <__unnamed_14>
  20b033:	ff 
  20b034:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
  20b03a:	48 8b 7c 24 78       	mov    rdi,QWORD PTR [rsp+0x78]
        const digit = a % base;
  20b03f:	48 89 fa             	mov    rdx,rdi
  20b042:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  20b049:	cc cc cc 
  20b04c:	c4 e2 fb f6 c8       	mulx   rcx,rax,rax
  20b051:	c1 e9 02             	shr    ecx,0x2
  20b054:	81 e1 fe ff ff 3f    	and    ecx,0x3ffffffe
  20b05a:	8d 0c 89             	lea    ecx,[rcx+rcx*4]
  20b05d:	89 f8                	mov    eax,edi
  20b05f:	29 c8                	sub    eax,ecx
        0...9 => digit + '0',
  20b061:	b1 30                	mov    cl,0x30
  20b063:	3c 0a                	cmp    al,0xa
  20b065:	72 02                	jb     20b069 <dumpCurrentStackTrace+0xfa9>
  20b067:	b1 57                	mov    cl,0x57
  20b069:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b06b:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20b06f:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20b074:	48 83 ff 0a          	cmp    rdi,0xa
  20b078:	73 16                	jae    20b090 <dumpCurrentStackTrace+0xfd0>
  20b07a:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20b07f:	eb 61                	jmp    20b0e2 <dumpCurrentStackTrace+0x1022>
  20b081:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b088:	0f 1f 84 00 00 00 00 
  20b08f:	00 
        a /= base;
  20b090:	48 89 fa             	mov    rdx,rdi
  20b093:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  20b09a:	cc cc cc 
  20b09d:	48 89 ce             	mov    rsi,rcx
  20b0a0:	c4 e2 f3 f6 d6       	mulx   rdx,rcx,rsi
  20b0a5:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20b0a9:	c4 e2 f3 f6 f6       	mulx   rsi,rcx,rsi
  20b0ae:	c1 ee 02             	shr    esi,0x2
  20b0b1:	81 e6 fe ff ff 3f    	and    esi,0x3ffffffe
  20b0b7:	8d 34 b6             	lea    esi,[rsi+rsi*4]
  20b0ba:	89 d1                	mov    ecx,edx
  20b0bc:	29 f1                	sub    ecx,esi
        0...9 => digit + '0',
  20b0be:	b3 30                	mov    bl,0x30
  20b0c0:	80 f9 0a             	cmp    cl,0xa
  20b0c3:	72 02                	jb     20b0c7 <dumpCurrentStackTrace+0x1007>
  20b0c5:	b3 57                	mov    bl,0x57
  20b0c7:	00 cb                	add    bl,cl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b0c9:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20b0cd:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20b0d1:	48 83 ff 63          	cmp    rdi,0x63
  20b0d5:	48 89 d7             	mov    rdi,rdx
  20b0d8:	77 b6                	ja     20b090 <dumpCurrentStackTrace+0xfd0>
        const padded_buf = buf[index - padding ..];
  20b0da:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20b0de:	48 83 c1 2f          	add    rcx,0x2f
  20b0e2:	ba 41 00 00 00       	mov    edx,0x41
  20b0e7:	48 29 c2             	sub    rdx,rax
  20b0ea:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20b0ef:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20b0f4:	4c 89 e7             	mov    rdi,r12
  20b0f7:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20b0fc:	c5 f8 77             	vzeroupper 
  20b0ff:	41 ff d6             	call   r14
  20b102:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b105:	66 45 85 ff          	test   r15w,r15w
  20b109:	0f 85 22 06 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20b10f:	4c 89 e7             	mov    rdi,r12
  20b112:	48 8d 35 17 5c 01 00 	lea    rsi,[rip+0x15c17]        # 220d30 <__unnamed_33>
  20b119:	41 ff d6             	call   r14
  20b11c:	41 89 c7             	mov    r15d,eax
  20b11f:	66 45 85 ff          	test   r15w,r15w
  20b123:	0f 85 08 06 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
    var buf: [max_int_digits - 1]u8 = undefined;
  20b129:	c5 fc 10 05 47 c6 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc647]        # 207778 <__unnamed_14+0x1f>
  20b130:	ff 
  20b131:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20b137:	c5 fe 6f 05 1a c6 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc61a]        # 207759 <__unnamed_14>
  20b13e:	ff 
  20b13f:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b145:	44 89 e8             	mov    eax,r13d
  20b148:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  20b14a:	b1 30                	mov    cl,0x30
  20b14c:	3c 0a                	cmp    al,0xa
  20b14e:	72 02                	jb     20b152 <dumpCurrentStackTrace+0x1092>
  20b150:	b1 57                	mov    cl,0x57
  20b152:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b154:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20b158:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20b15d:	49 83 fd 10          	cmp    r13,0x10
  20b161:	0f 83 ac 01 00 00    	jae    20b313 <dumpCurrentStackTrace+0x1253>
  20b167:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20b16c:	e9 df 01 00 00       	jmp    20b350 <dumpCurrentStackTrace+0x1290>
        a /= base;
  20b171:	4c 89 e9             	mov    rcx,r13
  20b174:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b17b:	00 00 00 00 00 
  20b180:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b184:	89 ca                	mov    edx,ecx
  20b186:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  20b189:	b3 30                	mov    bl,0x30
  20b18b:	80 fa 0a             	cmp    dl,0xa
  20b18e:	72 02                	jb     20b192 <dumpCurrentStackTrace+0x10d2>
  20b190:	b3 57                	mov    bl,0x57
  20b192:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b194:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20b198:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20b19c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  20b1a3:	49 89 cd             	mov    r13,rcx
  20b1a6:	77 d8                	ja     20b180 <dumpCurrentStackTrace+0x10c0>
        const padded_buf = buf[index - padding ..];
  20b1a8:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20b1ac:	48 83 c1 2f          	add    rcx,0x2f
  20b1b0:	ba 41 00 00 00       	mov    edx,0x41
  20b1b5:	48 29 c2             	sub    rdx,rax
  20b1b8:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20b1bd:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20b1c2:	4c 89 e7             	mov    rdi,r12
  20b1c5:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20b1ca:	c5 f8 77             	vzeroupper 
  20b1cd:	41 ff d6             	call   r14
  20b1d0:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20b1d3:	66 45 85 ff          	test   r15w,r15w
  20b1d7:	0f 85 b3 f8 ff ff    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
                        try output(context, fmt[start_index..i]);
  20b1dd:	4c 89 e7             	mov    rdi,r12
  20b1e0:	48 8d 35 89 5b 01 00 	lea    rsi,[rip+0x15b89]        # 220d70 <__unnamed_34>
  20b1e7:	41 ff d6             	call   r14
  20b1ea:	41 89 c7             	mov    r15d,eax
  20b1ed:	66 45 85 ff          	test   r15w,r15w
  20b1f1:	0f 85 99 f8 ff ff    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
                const casted_value = ([]const u8)(value);
  20b1f7:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  20b1fe:	00 00 
  20b200:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  20b206:	4c 89 e7             	mov    rdi,r12
  20b209:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b20e:	41 ff d6             	call   r14
  20b211:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b214:	66 45 85 ff          	test   r15w,r15w
  20b218:	0f 85 72 f8 ff ff    	jne    20aa90 <dumpCurrentStackTrace+0x9d0>
        try output(context, fmt[start_index..]);
  20b21e:	4c 89 e7             	mov    rdi,r12
  20b221:	48 8d 35 58 5b 01 00 	lea    rsi,[rip+0x15b58]        # 220d80 <__unnamed_35>
  20b228:	e9 56 f8 ff ff       	jmp    20aa83 <dumpCurrentStackTrace+0x9c3>
  20b22d:	48 89 d0             	mov    rax,rdx
        a /= base;
  20b230:	48 89 c2             	mov    rdx,rax
  20b233:	48 be cd cc cc cc cc 	movabs rsi,0xcccccccccccccccd
  20b23a:	cc cc cc 
  20b23d:	48 89 f7             	mov    rdi,rsi
  20b240:	c4 e2 cb f6 d7       	mulx   rdx,rsi,rdi
  20b245:	48 c1 ea 03          	shr    rdx,0x3
        const digit = a % base;
  20b249:	c4 e2 cb f6 ff       	mulx   rdi,rsi,rdi
  20b24e:	c1 ef 02             	shr    edi,0x2
  20b251:	81 e7 fe ff ff 3f    	and    edi,0x3ffffffe
  20b257:	8d 3c bf             	lea    edi,[rdi+rdi*4]
  20b25a:	89 d6                	mov    esi,edx
  20b25c:	29 fe                	sub    esi,edi
        0...9 => digit + '0',
  20b25e:	b3 30                	mov    bl,0x30
  20b260:	40 80 fe 0a          	cmp    sil,0xa
  20b264:	72 02                	jb     20b268 <dumpCurrentStackTrace+0x11a8>
  20b266:	b3 57                	mov    bl,0x57
  20b268:	40 00 f3             	add    bl,sil
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b26b:	88 5c 0c 2e          	mov    BYTE PTR [rsp+rcx*1+0x2e],bl
        if (a == 0) break;
  20b26f:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  20b273:	48 83 f8 63          	cmp    rax,0x63
  20b277:	48 89 d0             	mov    rax,rdx
  20b27a:	77 b4                	ja     20b230 <dumpCurrentStackTrace+0x1170>
        const padded_buf = buf[index - padding ..];
  20b27c:	48 8d 04 0c          	lea    rax,[rsp+rcx*1]
  20b280:	48 83 c0 2f          	add    rax,0x2f
  20b284:	ba 41 00 00 00       	mov    edx,0x41
  20b289:	48 29 ca             	sub    rdx,rcx
  20b28c:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20b291:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20b296:	4c 89 e7             	mov    rdi,r12
  20b299:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20b29e:	c5 f8 77             	vzeroupper 
  20b2a1:	41 ff d6             	call   r14
  20b2a4:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b2a7:	66 45 85 ff          	test   r15w,r15w
  20b2ab:	0f 85 80 04 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20b2b1:	4c 89 e7             	mov    rdi,r12
  20b2b4:	48 8d 35 25 5a 01 00 	lea    rsi,[rip+0x15a25]        # 220ce0 <__unnamed_36>
  20b2bb:	41 ff d6             	call   r14
  20b2be:	41 89 c7             	mov    r15d,eax
  20b2c1:	66 45 85 ff          	test   r15w,r15w
  20b2c5:	0f 85 66 04 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
    var buf: [max_int_digits - 1]u8 = undefined;
  20b2cb:	c5 fc 10 05 a5 c4 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffc4a5]        # 207778 <__unnamed_14+0x1f>
  20b2d2:	ff 
  20b2d3:	c5 fc 11 44 24 4f    	vmovups YMMWORD PTR [rsp+0x4f],ymm0
  20b2d9:	c5 fe 6f 05 78 c4 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffc478]        # 207759 <__unnamed_14>
  20b2e0:	ff 
  20b2e1:	c5 fe 7f 44 24 30    	vmovdqu YMMWORD PTR [rsp+0x30],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b2e7:	44 89 e8             	mov    eax,r13d
  20b2ea:	24 0f                	and    al,0xf
        0...9 => digit + '0',
  20b2ec:	b1 30                	mov    cl,0x30
  20b2ee:	3c 0a                	cmp    al,0xa
  20b2f0:	72 02                	jb     20b2f4 <dumpCurrentStackTrace+0x1234>
  20b2f2:	b1 57                	mov    cl,0x57
  20b2f4:	00 c1                	add    cl,al
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b2f6:	88 4c 24 6f          	mov    BYTE PTR [rsp+0x6f],cl
  20b2fa:	b8 40 00 00 00       	mov    eax,0x40
        if (a == 0) break;
  20b2ff:	49 83 fd 10          	cmp    r13,0x10
  20b303:	0f 83 d4 00 00 00    	jae    20b3dd <dumpCurrentStackTrace+0x131d>
  20b309:	48 8d 4c 24 6f       	lea    rcx,[rsp+0x6f]
  20b30e:	e9 fd 00 00 00       	jmp    20b410 <dumpCurrentStackTrace+0x1350>
        a /= base;
  20b313:	4c 89 e9             	mov    rcx,r13
  20b316:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20b31d:	00 00 00 
  20b320:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b324:	89 ca                	mov    edx,ecx
  20b326:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  20b329:	b3 30                	mov    bl,0x30
  20b32b:	80 fa 0a             	cmp    dl,0xa
  20b32e:	72 02                	jb     20b332 <dumpCurrentStackTrace+0x1272>
  20b330:	b3 57                	mov    bl,0x57
  20b332:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b334:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20b338:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20b33c:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  20b343:	49 89 cd             	mov    r13,rcx
  20b346:	77 d8                	ja     20b320 <dumpCurrentStackTrace+0x1260>
        const padded_buf = buf[index - padding ..];
  20b348:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20b34c:	48 83 c1 2f          	add    rcx,0x2f
  20b350:	ba 41 00 00 00       	mov    edx,0x41
  20b355:	48 29 c2             	sub    rdx,rax
  20b358:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20b35d:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20b362:	4c 89 e7             	mov    rdi,r12
  20b365:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20b36a:	c5 f8 77             	vzeroupper 
  20b36d:	41 ff d6             	call   r14
  20b370:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20b373:	66 45 85 ff          	test   r15w,r15w
  20b377:	0f 85 b4 03 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20b37d:	4c 89 e7             	mov    rdi,r12
  20b380:	48 8d 35 b9 59 01 00 	lea    rsi,[rip+0x159b9]        # 220d40 <__unnamed_37>
  20b387:	41 ff d6             	call   r14
  20b38a:	41 89 c7             	mov    r15d,eax
  20b38d:	66 45 85 ff          	test   r15w,r15w
  20b391:	0f 85 9a 03 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                const casted_value = ([]const u8)(value);
  20b397:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  20b39e:	00 00 
  20b3a0:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  20b3a6:	4c 89 e7             	mov    rdi,r12
  20b3a9:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b3ae:	41 ff d6             	call   r14
  20b3b1:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b3b4:	66 45 85 ff          	test   r15w,r15w
  20b3b8:	0f 85 73 03 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
        try output(context, fmt[start_index..]);
  20b3be:	4c 89 e7             	mov    rdi,r12
  20b3c1:	48 8d 35 88 59 01 00 	lea    rsi,[rip+0x15988]        # 220d50 <__unnamed_38>
  20b3c8:	41 ff d6             	call   r14
  20b3cb:	41 89 c7             	mov    r15d,eax
                    try out_stream.print(
  20b3ce:	66 45 85 ff          	test   r15w,r15w
  20b3d2:	0f 84 3e 02 00 00    	je     20b616 <dumpCurrentStackTrace+0x1556>
  20b3d8:	e9 54 03 00 00       	jmp    20b731 <dumpCurrentStackTrace+0x1671>
        a /= base;
  20b3dd:	4c 89 e9             	mov    rcx,r13
  20b3e0:	48 c1 e9 04          	shr    rcx,0x4
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b3e4:	89 ca                	mov    edx,ecx
  20b3e6:	80 e2 0f             	and    dl,0xf
        0...9 => digit + '0',
  20b3e9:	b3 30                	mov    bl,0x30
  20b3eb:	80 fa 0a             	cmp    dl,0xa
  20b3ee:	72 02                	jb     20b3f2 <dumpCurrentStackTrace+0x1332>
  20b3f0:	b3 57                	mov    bl,0x57
  20b3f2:	00 d3                	add    bl,dl
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  20b3f4:	88 5c 04 2e          	mov    BYTE PTR [rsp+rax*1+0x2e],bl
        if (a == 0) break;
  20b3f8:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  20b3fc:	49 81 fd ff 00 00 00 	cmp    r13,0xff
  20b403:	49 89 cd             	mov    r13,rcx
  20b406:	77 d8                	ja     20b3e0 <dumpCurrentStackTrace+0x1320>
        const padded_buf = buf[index - padding ..];
  20b408:	48 8d 0c 04          	lea    rcx,[rsp+rax*1]
  20b40c:	48 83 c1 2f          	add    rcx,0x2f
  20b410:	ba 41 00 00 00       	mov    edx,0x41
  20b415:	48 29 c2             	sub    rdx,rax
  20b418:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  20b41d:	48 89 54 24 18       	mov    QWORD PTR [rsp+0x18],rdx
        return output(context, padded_buf);
  20b422:	4c 89 e7             	mov    rdi,r12
  20b425:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
  20b42a:	c5 f8 77             	vzeroupper 
  20b42d:	41 ff d6             	call   r14
  20b430:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[s..i], context, Errors, output);
  20b433:	66 45 85 ff          	test   r15w,r15w
  20b437:	0f 85 f4 02 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                        try output(context, fmt[start_index..i]);
  20b43d:	4c 89 e7             	mov    rdi,r12
  20b440:	48 8d 35 a9 58 01 00 	lea    rsi,[rip+0x158a9]        # 220cf0 <__unnamed_39>
  20b447:	41 ff d6             	call   r14
  20b44a:	41 89 c7             	mov    r15d,eax
  20b44d:	66 45 85 ff          	test   r15w,r15w
  20b451:	0f 85 da 02 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
                const casted_value = ([]const u8)(value);
  20b457:	c5 f9 6f 84 24 20 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x120]
  20b45e:	00 00 
  20b460:	c5 f9 7f 44 24 30    	vmovdqa XMMWORD PTR [rsp+0x30],xmm0
                return output(context, casted_value);
  20b466:	4c 89 e7             	mov    rdi,r12
  20b469:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b46e:	41 ff d6             	call   r14
  20b471:	41 89 c7             	mov    r15d,eax
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b474:	66 45 85 ff          	test   r15w,r15w
  20b478:	0f 85 b3 02 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
        try output(context, fmt[start_index..]);
  20b47e:	4c 89 e7             	mov    rdi,r12
  20b481:	48 8d 35 78 58 01 00 	lea    rsi,[rip+0x15878]        # 220d00 <__unnamed_40>
  20b488:	41 ff d6             	call   r14
  20b48b:	41 89 c7             	mov    r15d,eax
                    try out_stream.print(
  20b48e:	66 45 85 ff          	test   r15w,r15w
  20b492:	0f 85 99 02 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
  20b498:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20b49d:	48 8b b8 a0 00 00 00 	mov    rdi,QWORD PTR [rax+0xa0]
                    if (printLineFromFile(debug_info.allocator(), out_stream, line_info)) {
  20b4a4:	4c 89 e6             	mov    rsi,r12
  20b4a7:	48 8d 94 24 80 00 00 	lea    rdx,[rsp+0x80]
  20b4ae:	00 
  20b4af:	e8 bc b3 00 00       	call   216870 <printLineFromFile>
  20b4b4:	41 89 c7             	mov    r15d,eax
  20b4b7:	41 0f b7 c7          	movzx  eax,r15w
  20b4bb:	83 f8 26             	cmp    eax,0x26
  20b4be:	0f 84 52 01 00 00    	je     20b616 <dumpCurrentStackTrace+0x1556>
  20b4c4:	66 45 85 ff          	test   r15w,r15w
  20b4c8:	0f 85 84 00 00 00    	jne    20b552 <dumpCurrentStackTrace+0x1492>
  20b4ce:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
                        if (line_info.column == 0) {
  20b4d3:	48 85 c0             	test   rax,rax
  20b4d6:	0f 84 1f 01 00 00    	je     20b5fb <dumpCurrentStackTrace+0x153b>
  20b4dc:	48 83 f8 01          	cmp    rax,0x1
  20b4e0:	74 41                	je     20b523 <dumpCurrentStackTrace+0x1463>
  20b4e2:	bb 01 00 00 00       	mov    ebx,0x1
  20b4e7:	c6 44 24 10 20       	mov    BYTE PTR [rsp+0x10],0x20
        pub fn write(self: *Self, bytes: []const u8) !void {
            return self.writeFn(self, bytes);
        }

        pub fn writeByte(self: *Self, byte: u8) !void {
            const slice = (*[1]u8)(&byte)[0..];
  20b4ec:	48 8d 44 24 10       	lea    rax,[rsp+0x10]
  20b4f1:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20b4f6:	48 c7 44 24 38 01 00 	mov    QWORD PTR [rsp+0x38],0x1
  20b4fd:	00 00 
            return self.writeFn(self, slice);
  20b4ff:	4c 89 e7             	mov    rdi,r12
  20b502:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b507:	41 ff 14 24          	call   QWORD PTR [r12]
  20b50b:	41 89 c7             	mov    r15d,eax
                                    try out_stream.writeByte(' ');
  20b50e:	66 45 85 ff          	test   r15w,r15w
  20b512:	0f 85 19 02 00 00    	jne    20b731 <dumpCurrentStackTrace+0x1671>
  20b518:	48 83 c3 01          	add    rbx,0x1
                                while (col_i < line_info.column) : (col_i += 1) {
  20b51c:	48 3b 5c 24 78       	cmp    rbx,QWORD PTR [rsp+0x78]
  20b521:	72 c4                	jb     20b4e7 <dumpCurrentStackTrace+0x1427>
            return self.writeFn(self, bytes);
  20b523:	4c 89 e7             	mov    rdi,r12
  20b526:	48 8d 35 33 57 01 00 	lea    rsi,[rip+0x15733]        # 220c60 <__unnamed_41>
  20b52d:	41 ff 14 24          	call   QWORD PTR [r12]
  20b531:	41 89 c7             	mov    r15d,eax
  20b534:	66 45 85 ff          	test   r15w,r15w
  20b538:	0f 84 d8 00 00 00    	je     20b616 <dumpCurrentStackTrace+0x1556>
  20b53e:	e9 29 02 00 00       	jmp    20b76c <dumpCurrentStackTrace+0x16ac>
  20b543:	48 83 f9 4b          	cmp    rcx,0x4b
  20b547:	0f 85 6e f6 ff ff    	jne    20abbb <dumpCurrentStackTrace+0xafb>
  20b54d:	e9 5f f6 ff ff       	jmp    20abb1 <dumpCurrentStackTrace+0xaf1>
        const bytes = @sliceToBytes(memory);
  20b552:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20b559:	00 
        if (bytes.len == 0) return;
  20b55a:	48 85 c0             	test   rax,rax
  20b55d:	0f 84 2d f5 ff ff    	je     20aa90 <dumpCurrentStackTrace+0x9d0>
  20b563:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  20b56a:	00 
        const bytes = @sliceToBytes(memory);
  20b56b:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20b572:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b573:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b577:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  20b57c:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  20b581:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b586:	ff d2                	call   rdx
  20b588:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  20b58f:	00 00 
  20b591:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  20b598:	00 00 
        try printSourceAtAddress(debug_info, out_stream, return_address, tty_color);
  20b59a:	66 45 85 ff          	test   r15w,r15w
  20b59e:	0f 84 08 f5 ff ff    	je     20aaac <dumpCurrentStackTrace+0x9ec>
  20b5a4:	e9 fb 00 00 00       	jmp    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20b5a9:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  20b5ae:	48 89 8c 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],rcx
  20b5b5:	00 
  20b5b6:	48 8d 05 73 50 00 00 	lea    rax,[rip+0x5073]        # 210630 <FileInStream_readFn>
  20b5bd:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  20b5c4:	00 
  20b5c5:	48 8b b1 a0 00 00 00 	mov    rsi,QWORD PTR [rcx+0xa0]
  20b5cc:	4c 8d 74 24 30       	lea    r14,[rsp+0x30]
            return readStringRaw(self.allocator(), in_stream);
  20b5d1:	4c 89 f7             	mov    rdi,r14
  20b5d4:	48 8d 94 24 c0 00 00 	lea    rdx,[rsp+0xc0]
  20b5db:	00 
  20b5dc:	4c 89 cb             	mov    rbx,r9
  20b5df:	c5 f8 77             	vzeroupper 
  20b5e2:	e8 09 8e 00 00       	call   2143f0 <readStringRaw>
  20b5e7:	49 89 d9             	mov    r9,rbx
        return switch (form_value.*) {
  20b5ea:	4c 89 f1             	mov    rcx,r14
  20b5ed:	e9 f2 f5 ff ff       	jmp    20abe4 <dumpCurrentStackTrace+0xb24>
  20b5f2:	66 b8 1e 00          	mov    ax,0x1e
  20b5f6:	e9 c0 f5 ff ff       	jmp    20abbb <dumpCurrentStackTrace+0xafb>
  20b5fb:	4c 89 e7             	mov    rdi,r12
  20b5fe:	48 8d 35 4b 56 01 00 	lea    rsi,[rip+0x1564b]        # 220c50 <__unnamed_42>
  20b605:	41 ff 14 24          	call   QWORD PTR [r12]
  20b609:	41 89 c7             	mov    r15d,eax
  20b60c:	66 45 85 ff          	test   r15w,r15w
  20b610:	0f 85 56 01 00 00    	jne    20b76c <dumpCurrentStackTrace+0x16ac>
        const bytes = @sliceToBytes(memory);
  20b616:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20b61d:	00 
        if (bytes.len == 0) return;
  20b61e:	48 85 c0             	test   rax,rax
  20b621:	74 25                	je     20b648 <dumpCurrentStackTrace+0x1588>
  20b623:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  20b62a:	00 
        const bytes = @sliceToBytes(memory);
  20b62b:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20b632:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b633:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b637:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  20b63c:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  20b641:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b646:	ff d2                	call   rdx
  20b648:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  20b64f:	00 
  20b650:	48 8b 94 24 b0 00 00 	mov    rdx,QWORD PTR [rsp+0xb0]
  20b657:	00 
  20b658:	c5 7d 6f a4 24 00 01 	vmovdqa ymm12,YMMWORD PTR [rsp+0x100]
  20b65f:	00 00 
  20b661:	c5 7d 6f ac 24 e0 00 	vmovdqa ymm13,YMMWORD PTR [rsp+0xe0]
  20b668:	00 00 
  20b66a:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  20b66f:	31 c0                	xor    eax,eax
    while (fp != 0) : (fp = @intToPtr(*const usize, fp).*) {
  20b671:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  20b674:	48 85 d2             	test   rdx,rdx
  20b677:	0f 85 83 ed ff ff    	jne    20a400 <dumpCurrentStackTrace+0x340>
  20b67d:	eb 72                	jmp    20b6f1 <dumpCurrentStackTrace+0x1631>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  20b67f:	48 8b 05 7a ae ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffae7a]        # 206500 <__unnamed_43+0x10>
  20b686:	48 89 84 24 4e 01 00 	mov    QWORD PTR [rsp+0x14e],rax
  20b68d:	00 
  20b68e:	c5 fa 6f 05 5c ae ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffffae5c]        # 2064f2 <__unnamed_43+0x2>
  20b695:	ff 
  20b696:	c5 f9 7f 84 24 40 01 	vmovdqa XMMWORD PTR [rsp+0x140],xmm0
  20b69d:	00 00 
  20b69f:	66 41 bf 24 00       	mov    r15w,0x24
            return std.fmt.format(self, Error, self.writeFn, format, args);
  20b6a4:	49 8b 1c 24          	mov    rbx,QWORD PTR [r12]
                        try output(context, fmt[start_index..i]);
  20b6a8:	48 8d 35 e1 56 01 00 	lea    rsi,[rip+0x156e1]        # 220d90 <__unnamed_44>
  20b6af:	4c 89 e7             	mov    rdi,r12
  20b6b2:	c5 f8 77             	vzeroupper 
  20b6b5:	ff d3                	call   rbx
  20b6b7:	66 85 c0             	test   ax,ax
  20b6ba:	75 35                	jne    20b6f1 <dumpCurrentStackTrace+0x1631>
        stderr.print("Unable to dump stack trace: {}\n", @errorName(err)) catch return;
  20b6bc:	49 0f bf c7          	movsx  rax,r15w
  20b6c0:	48 c1 e0 04          	shl    rax,0x4
  20b6c4:	48 8d 0d 35 29 01 00 	lea    rcx,[rip+0x12935]        # 21e000 <raw+0xf48>
                const casted_value = ([]const u8)(value);
  20b6cb:	c5 f8 10 04 08       	vmovups xmm0,XMMWORD PTR [rax+rcx*1]
  20b6d0:	c5 f8 29 44 24 30    	vmovaps XMMWORD PTR [rsp+0x30],xmm0
  20b6d6:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
                return output(context, casted_value);
  20b6db:	4c 89 e7             	mov    rdi,r12
  20b6de:	ff d3                	call   rbx
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  20b6e0:	66 85 c0             	test   ax,ax
  20b6e3:	75 0c                	jne    20b6f1 <dumpCurrentStackTrace+0x1631>
        try output(context, fmt[start_index..]);
  20b6e5:	48 8d 35 b4 56 01 00 	lea    rsi,[rip+0x156b4]        # 220da0 <__unnamed_45>
  20b6ec:	4c 89 e7             	mov    rdi,r12
  20b6ef:	ff d3                	call   rbx
    const stderr = getStderrStream() catch return;
  20b6f1:	48 8d 65 d8          	lea    rsp,[rbp-0x28]
  20b6f5:	5b                   	pop    rbx
  20b6f6:	41 5c                	pop    r12
  20b6f8:	41 5d                	pop    r13
  20b6fa:	41 5e                	pop    r14
  20b6fc:	41 5f                	pop    r15
  20b6fe:	5d                   	pop    rbp
  20b6ff:	c5 f8 77             	vzeroupper 
  20b702:	c3                   	ret    
  20b703:	49 89 dc             	mov    r12,rbx
        const bytes = @sliceToBytes(memory);
  20b706:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20b70d:	00 
        if (bytes.len == 0) return;
  20b70e:	48 85 c0             	test   rax,rax
  20b711:	75 2f                	jne    20b742 <dumpCurrentStackTrace+0x1682>
  20b713:	eb 8f                	jmp    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20b715:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        const bytes = @sliceToBytes(memory);
  20b71a:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20b721:	00 
        if (bytes.len == 0) return;
  20b722:	48 85 c0             	test   rax,rax
  20b725:	75 1b                	jne    20b742 <dumpCurrentStackTrace+0x1682>
  20b727:	e9 78 ff ff ff       	jmp    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20b72c:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
        const bytes = @sliceToBytes(memory);
  20b731:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20b738:	00 
        if (bytes.len == 0) return;
  20b739:	48 85 c0             	test   rax,rax
  20b73c:	0f 84 62 ff ff ff    	je     20b6a4 <dumpCurrentStackTrace+0x15e4>
  20b742:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  20b749:	00 
        const bytes = @sliceToBytes(memory);
  20b74a:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20b751:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b752:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b756:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  20b75b:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  20b760:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b765:	ff d2                	call   rdx
  20b767:	e9 38 ff ff ff       	jmp    20b6a4 <dumpCurrentStackTrace+0x15e4>
        const bytes = @sliceToBytes(memory);
  20b76c:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  20b773:	00 
        if (bytes.len == 0) return;
  20b774:	48 85 c0             	test   rax,rax
  20b777:	74 25                	je     20b79e <dumpCurrentStackTrace+0x16de>
  20b779:	48 8b bc 24 a0 00 00 	mov    rdi,QWORD PTR [rsp+0xa0]
  20b780:	00 
        const bytes = @sliceToBytes(memory);
  20b781:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  20b788:	00 
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20b789:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20b78d:	48 89 4c 24 30       	mov    QWORD PTR [rsp+0x30],rcx
  20b792:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
  20b797:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20b79c:	ff d2                	call   rdx
  20b79e:	4c 8b 64 24 70       	mov    r12,QWORD PTR [rsp+0x70]
  20b7a3:	e9 fc fe ff ff       	jmp    20b6a4 <dumpCurrentStackTrace+0x15e4>
  20b7a8:	48 c7 c0 fe ff ff ff 	mov    rax,0xfffffffffffffffe
        while (ptr[end_i] != 0) : (end_i += 1) {}
  20b7af:	80 7c 06 11 00       	cmp    BYTE PTR [rsi+rax*1+0x11],0x0
  20b7b4:	48 8d 40 01          	lea    rax,[rax+0x1]
  20b7b8:	75 f5                	jne    20b7af <dumpCurrentStackTrace+0x16ef>
  20b7ba:	c6 44 24 0f 01       	mov    BYTE PTR [rsp+0xf],0x1
        const addr = @ptrToInt(self.buffer.ptr) + self.end_index;
        const rem = @rem(addr, alignment);
        const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
        const adjusted_index = self.end_index + march_forward_bytes;
        const new_end_index = adjusted_index + n;
        if (new_end_index > self.buffer.len) {
  20b7bf:	48 3d 81 00 00 00    	cmp    rax,0x81
        if (n == 0) {
  20b7c5:	0f 83 b2 eb ff ff    	jae    20a37d <dumpCurrentStackTrace+0x2bd>
  20b7cb:	e9 cd eb ff ff       	jmp    20a39d <dumpCurrentStackTrace+0x2dd>

000000000020b7d0 <MainFuncs_linuxThreadMain>:
            const arg = if (@sizeOf(Context) == 0) {} else @intToPtr(*const Context, ctx_addr).*;
  20b7d0:	4c 8b 07             	mov    r8,QWORD PTR [rdi]
    while (pContext.counter < max_counter) {
  20b7d3:	b8 7f 96 98 00       	mov    eax,0x98967f
  20b7d8:	31 c9                	xor    ecx,ecx
  20b7da:	49 3b 00             	cmp    rax,QWORD PTR [r8]
  20b7dd:	49 8b 40 08          	mov    rax,QWORD PTR [r8+0x8]
  20b7e1:	48 19 c1             	sbb    rcx,rax
  20b7e4:	0f 82 0c 01 00 00    	jb     20b8f6 <MainFuncs_linuxThreadMain+0x126>
  20b7ea:	48 8d 3d 47 58 01 00 	lea    rdi,[rip+0x15847]        # 221038 <produce>
  20b7f1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b7f8:	0f 1f 84 00 00 00 00 
  20b7ff:	00 
    var val = @atomicLoad(u32, pValue, AtomicOrder.Acquire);
  20b800:	8b 05 32 58 01 00    	mov    eax,DWORD PTR [rip+0x15832]        # 221038 <produce>
    while ((val == desiredValue) and (count > 0)) {
  20b806:	85 c0                	test   eax,eax
  20b808:	75 36                	jne    20b840 <MainFuncs_linuxThreadMain+0x70>
  20b80a:	48 c7 c1 f1 d8 ff ff 	mov    rcx,0xffffffffffffd8f1
  20b811:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b818:	0f 1f 84 00 00 00 00 
  20b81f:	00 
        val = @atomicLoad(u32, pValue, AtomicOrder.Acquire);
  20b820:	8b 05 12 58 01 00    	mov    eax,DWORD PTR [rip+0x15812]        # 221038 <produce>
    while ((val == desiredValue) and (count > 0)) {
  20b826:	48 85 c9             	test   rcx,rcx
  20b829:	74 15                	je     20b840 <MainFuncs_linuxThreadMain+0x70>
  20b82b:	48 83 c1 01          	add    rcx,0x1
  20b82f:	85 c0                	test   eax,eax
  20b831:	74 ed                	je     20b820 <MainFuncs_linuxThreadMain+0x50>
  20b833:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b83a:	84 00 00 00 00 00 
        while (produce_val != produceSignal) {
  20b840:	83 f8 01             	cmp    eax,0x1
  20b843:	74 2a                	je     20b86f <MainFuncs_linuxThreadMain+0x9f>
  20b845:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b84c:	00 00 00 00 
            gProducer_wait_count += 1;
  20b850:	48 83 05 a8 57 01 00 	add    QWORD PTR [rip+0x157a8],0x1        # 221000 <gProducer_wait_count>
  20b857:	01 
        : "rcx", "r11"
    );
}

pub fn syscall4(number: usize, arg1: usize, arg2: usize, arg3: usize, arg4: usize) usize {
    return asm volatile ("syscall"
  20b858:	b8 ca 00 00 00       	mov    eax,0xca
  20b85d:	31 f6                	xor    esi,esi
  20b85f:	31 d2                	xor    edx,edx
  20b861:	45 31 d2             	xor    r10d,r10d
  20b864:	0f 05                	syscall 
        while (produce_val != produceSignal) {
  20b866:	83 3d cb 57 01 00 01 	cmp    DWORD PTR [rip+0x157cb],0x1        # 221038 <produce>
  20b86d:	75 e1                	jne    20b850 <MainFuncs_linuxThreadMain+0x80>
        _ = @atomicRmw(@typeOf(gCounter), &gCounter, AtomicRmwOp.Add, 1, AtomicOrder.SeqCst);
  20b86f:	f0 48 81 05 a5 57 01 	lock add QWORD PTR [rip+0x157a5],0x1        # 221020 <gCounter>
  20b876:	00 01 00 00 00 
        pContext.counter += 1;
  20b87b:	49 83 00 01          	add    QWORD PTR [r8],0x1
  20b87f:	49 83 50 08 00       	adc    QWORD PTR [r8+0x8],0x0
        _ = @atomicRmw(@typeOf(produce), &produce, AtomicRmwOp.Xchg, consumeSignal, AtomicOrder.SeqCst);
  20b884:	31 c0                	xor    eax,eax
  20b886:	87 05 ac 57 01 00    	xchg   DWORD PTR [rip+0x157ac],eax        # 221038 <produce>
    var val = @atomicLoad(u32, pValue, AtomicOrder.Acquire);
  20b88c:	8b 05 a6 57 01 00    	mov    eax,DWORD PTR [rip+0x157a6]        # 221038 <produce>
    while ((val == desiredValue) and (count > 0)) {
  20b892:	85 c0                	test   eax,eax
  20b894:	75 2a                	jne    20b8c0 <MainFuncs_linuxThreadMain+0xf0>
  20b896:	48 c7 c1 f1 d8 ff ff 	mov    rcx,0xffffffffffffd8f1
  20b89d:	0f 1f 00             	nop    DWORD PTR [rax]
        val = @atomicLoad(u32, pValue, AtomicOrder.Acquire);
  20b8a0:	8b 05 92 57 01 00    	mov    eax,DWORD PTR [rip+0x15792]        # 221038 <produce>
    while ((val == desiredValue) and (count > 0)) {
  20b8a6:	48 85 c9             	test   rcx,rcx
  20b8a9:	74 15                	je     20b8c0 <MainFuncs_linuxThreadMain+0xf0>
  20b8ab:	48 83 c1 01          	add    rcx,0x1
  20b8af:	85 c0                	test   eax,eax
  20b8b1:	74 ed                	je     20b8a0 <MainFuncs_linuxThreadMain+0xd0>
  20b8b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b8ba:	84 00 00 00 00 00 
        if (produce_val != produceSignal) {
  20b8c0:	83 f8 01             	cmp    eax,0x1
  20b8c3:	74 1c                	je     20b8e1 <MainFuncs_linuxThreadMain+0x111>
            gProducer_wake_count += 1;
  20b8c5:	48 83 05 43 57 01 00 	add    QWORD PTR [rip+0x15743],0x1        # 221010 <gProducer_wake_count>
  20b8cc:	01 
  20b8cd:	b8 ca 00 00 00       	mov    eax,0xca
  20b8d2:	be 01 00 00 00       	mov    esi,0x1
  20b8d7:	ba 01 00 00 00       	mov    edx,0x1
  20b8dc:	45 31 d2             	xor    r10d,r10d
  20b8df:	0f 05                	syscall 
    while (pContext.counter < max_counter) {
  20b8e1:	49 8b 40 08          	mov    rax,QWORD PTR [r8+0x8]
  20b8e5:	49 81 38 80 96 98 00 	cmp    QWORD PTR [r8],0x989680
  20b8ec:	48 83 d8 00          	sbb    rax,0x0
  20b8f0:	0f 82 0a ff ff ff    	jb     20b800 <MainFuncs_linuxThreadMain+0x30>
                    return 0;
  20b8f6:	31 c0                	xor    eax,eax
  20b8f8:	c3                   	ret    
  20b8f9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000020b900 <MainFuncs_linuxThreadMain.21>:
            const arg = if (@sizeOf(Context) == 0) {} else @intToPtr(*const Context, ctx_addr).*;
  20b900:	4c 8b 07             	mov    r8,QWORD PTR [rdi]
    while (pContext.counter < max_counter) {
  20b903:	b8 7f 96 98 00       	mov    eax,0x98967f
  20b908:	31 c9                	xor    ecx,ecx
  20b90a:	49 3b 00             	cmp    rax,QWORD PTR [r8]
  20b90d:	49 1b 48 08          	sbb    rcx,QWORD PTR [r8+0x8]
  20b911:	0f 82 ed 00 00 00    	jb     20ba04 <MainFuncs_linuxThreadMain.21+0x104>
  20b917:	48 8d 3d 1a 57 01 00 	lea    rdi,[rip+0x1571a]        # 221038 <produce>
  20b91e:	66 90                	xchg   ax,ax
        _ = @atomicRmw(@typeOf(produce), &produce, AtomicRmwOp.Xchg, produceSignal, AtomicOrder.SeqCst);
  20b920:	b8 01 00 00 00       	mov    eax,0x1
  20b925:	87 05 0d 57 01 00    	xchg   DWORD PTR [rip+0x1570d],eax        # 221038 <produce>
    var val = @atomicLoad(u32, pValue, AtomicOrder.Acquire);
  20b92b:	8b 05 07 57 01 00    	mov    eax,DWORD PTR [rip+0x15707]        # 221038 <produce>
    while ((val != desiredValue) and (count > 0)) {
  20b931:	85 c0                	test   eax,eax
  20b933:	74 3e                	je     20b973 <MainFuncs_linuxThreadMain.21+0x73>
  20b935:	48 c7 c0 f1 d8 ff ff 	mov    rax,0xffffffffffffd8f1
  20b93c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
        val = @atomicLoad(u32, pValue, AtomicOrder.Acquire);
  20b940:	8b 0d f2 56 01 00    	mov    ecx,DWORD PTR [rip+0x156f2]        # 221038 <produce>
    while ((val != desiredValue) and (count > 0)) {
  20b946:	48 85 c0             	test   rax,rax
  20b949:	74 08                	je     20b953 <MainFuncs_linuxThreadMain.21+0x53>
  20b94b:	48 83 c0 01          	add    rax,0x1
  20b94f:	85 c9                	test   ecx,ecx
  20b951:	75 ed                	jne    20b940 <MainFuncs_linuxThreadMain.21+0x40>
        if (produce_val != consumeSignal) {
  20b953:	85 c9                	test   ecx,ecx
  20b955:	74 1c                	je     20b973 <MainFuncs_linuxThreadMain.21+0x73>
            gConsumer_wake_count += 1;
  20b957:	48 83 05 b9 56 01 00 	add    QWORD PTR [rip+0x156b9],0x1        # 221018 <gConsumer_wake_count>
  20b95e:	01 
  20b95f:	b8 ca 00 00 00       	mov    eax,0xca
  20b964:	be 01 00 00 00       	mov    esi,0x1
  20b969:	ba 01 00 00 00       	mov    edx,0x1
  20b96e:	45 31 d2             	xor    r10d,r10d
  20b971:	0f 05                	syscall 
    var val = @atomicLoad(u32, pValue, AtomicOrder.Acquire);
  20b973:	8b 05 bf 56 01 00    	mov    eax,DWORD PTR [rip+0x156bf]        # 221038 <produce>
    while ((val != desiredValue) and (count > 0)) {
  20b979:	85 c0                	test   eax,eax
  20b97b:	74 55                	je     20b9d2 <MainFuncs_linuxThreadMain.21+0xd2>
  20b97d:	48 c7 c0 f1 d8 ff ff 	mov    rax,0xffffffffffffd8f1
  20b984:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20b98b:	00 00 00 00 00 
        val = @atomicLoad(u32, pValue, AtomicOrder.Acquire);
  20b990:	8b 0d a2 56 01 00    	mov    ecx,DWORD PTR [rip+0x156a2]        # 221038 <produce>
    while ((val != desiredValue) and (count > 0)) {
  20b996:	48 85 c0             	test   rax,rax
  20b999:	74 08                	je     20b9a3 <MainFuncs_linuxThreadMain.21+0xa3>
  20b99b:	48 83 c0 01          	add    rax,0x1
  20b99f:	85 c9                	test   ecx,ecx
  20b9a1:	75 ed                	jne    20b990 <MainFuncs_linuxThreadMain.21+0x90>
        while (produce_val != consumeSignal) {
  20b9a3:	85 c9                	test   ecx,ecx
  20b9a5:	74 2b                	je     20b9d2 <MainFuncs_linuxThreadMain.21+0xd2>
  20b9a7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20b9ae:	00 00 
            gConsumer_wait_count += 1;
  20b9b0:	48 83 05 50 56 01 00 	add    QWORD PTR [rip+0x15650],0x1        # 221008 <gConsumer_wait_count>
  20b9b7:	01 
  20b9b8:	b8 ca 00 00 00       	mov    eax,0xca
  20b9bd:	31 f6                	xor    esi,esi
  20b9bf:	ba 01 00 00 00       	mov    edx,0x1
  20b9c4:	45 31 d2             	xor    r10d,r10d
  20b9c7:	0f 05                	syscall 
        while (produce_val != consumeSignal) {
  20b9c9:	83 3d 68 56 01 00 00 	cmp    DWORD PTR [rip+0x15668],0x0        # 221038 <produce>
  20b9d0:	75 de                	jne    20b9b0 <MainFuncs_linuxThreadMain.21+0xb0>
        _ = @atomicRmw(@typeOf(gCounter), &gCounter, AtomicRmwOp.Add, 1, AtomicOrder.SeqCst);
  20b9d2:	f0 48 81 05 42 56 01 	lock add QWORD PTR [rip+0x15642],0x1        # 221020 <gCounter>
  20b9d9:	00 01 00 00 00 
        pContext.counter += 1;
  20b9de:	49 8b 00             	mov    rax,QWORD PTR [r8]
  20b9e1:	49 8b 48 08          	mov    rcx,QWORD PTR [r8+0x8]
  20b9e5:	48 83 c0 01          	add    rax,0x1
  20b9e9:	48 83 d1 00          	adc    rcx,0x0
  20b9ed:	49 89 00             	mov    QWORD PTR [r8],rax
  20b9f0:	49 89 48 08          	mov    QWORD PTR [r8+0x8],rcx
    while (pContext.counter < max_counter) {
  20b9f4:	48 3d 80 96 98 00    	cmp    rax,0x989680
  20b9fa:	48 83 d9 00          	sbb    rcx,0x0
  20b9fe:	0f 82 1c ff ff ff    	jb     20b920 <MainFuncs_linuxThreadMain.21+0x20>
                    return 0;
  20ba04:	31 c0                	xor    eax,eax
  20ba06:	c3                   	ret    
  20ba07:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20ba0e:	00 00 

000000000020ba10 <FileOutStream_writeFn>:
    fn writeFn(out_stream: *Stream, bytes: []const u8) !void {
  20ba10:	53                   	push   rbx
  20ba11:	49 89 f0             	mov    r8,rsi
    while (index < bytes.len) {
  20ba14:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  20ba18:	48 85 d2             	test   rdx,rdx
  20ba1b:	0f 84 98 00 00 00    	je     20bab9 <FileOutStream_writeFn+0xa9>
        return self.file.write(bytes);
  20ba21:	48 8b 47 f8          	mov    rax,QWORD PTR [rdi-0x8]
  20ba25:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20ba28:	45 31 c9             	xor    r9d,r9d
  20ba2b:	41 ba 00 f0 ff 7f    	mov    r10d,0x7ffff000
  20ba31:	48 8d 1d 40 53 ff ff 	lea    rbx,[rip+0xffffffffffff5340]        # 200d78 <__unnamed_9+0x98>
  20ba38:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20ba3f:	00 
        const amt_to_write = math.min(bytes.len - index, usize(max_bytes_len));
  20ba40:	4c 29 ca             	sub    rdx,r9
    return if (x < y) x else y;
  20ba43:	48 81 fa 00 f0 ff 7f 	cmp    rdx,0x7ffff000
  20ba4a:	49 0f 43 d2          	cmovae rdx,r10
  20ba4e:	49 8b 30             	mov    rsi,QWORD PTR [r8]
        const rc = posix.write(fd, bytes.ptr + index, amt_to_write);
  20ba51:	4c 01 ce             	add    rsi,r9
  20ba54:	b8 01 00 00 00       	mov    eax,0x1
  20ba59:	0f 05                	syscall 
  20ba5b:	48 89 c1             	mov    rcx,rax
  20ba5e:	48 81 f9 00 f0 ff ff 	cmp    rcx,0xfffffffffffff000
  20ba65:	77 39                	ja     20baa0 <FileOutStream_writeFn+0x90>
  20ba67:	31 d2                	xor    edx,edx
        if (write_err > 0) {
  20ba69:	48 83 fa 04          	cmp    rdx,0x4
  20ba6d:	74 3d                	je     20baac <FileOutStream_writeFn+0x9c>
  20ba6f:	48 83 fa 59          	cmp    rdx,0x59
  20ba73:	77 48                	ja     20babd <FileOutStream_writeFn+0xad>
  20ba75:	66 b8 09 00          	mov    ax,0x9
  20ba79:	48 63 14 93          	movsxd rdx,DWORD PTR [rbx+rdx*4]
  20ba7d:	48 01 da             	add    rdx,rbx
  20ba80:	ff e2                	jmp    rdx
        index += rc;
  20ba82:	49 01 c9             	add    r9,rcx
    while (index < bytes.len) {
  20ba85:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  20ba89:	31 c0                	xor    eax,eax
  20ba8b:	4c 39 ca             	cmp    rdx,r9
  20ba8e:	77 b0                	ja     20ba40 <FileOutStream_writeFn+0x30>
  20ba90:	eb 25                	jmp    20bab7 <FileOutStream_writeFn+0xa7>
  20ba92:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20ba99:	1f 84 00 00 00 00 00 
  20baa0:	48 89 ca             	mov    rdx,rcx
  20baa3:	48 f7 da             	neg    rdx
        if (write_err > 0) {
  20baa6:	48 83 fa 04          	cmp    rdx,0x4
  20baaa:	75 c3                	jne    20ba6f <FileOutStream_writeFn+0x5f>
    while (index < bytes.len) {
  20baac:	49 8b 50 08          	mov    rdx,QWORD PTR [r8+0x8]
  20bab0:	4c 39 ca             	cmp    rdx,r9
  20bab3:	77 8b                	ja     20ba40 <FileOutStream_writeFn+0x30>
  20bab5:	31 c0                	xor    eax,eax
  20bab7:	5b                   	pop    rbx
  20bab8:	c3                   	ret    
  20bab9:	31 c0                	xor    eax,eax
  20babb:	5b                   	pop    rbx
  20babc:	c3                   	ret    
        if (write_err > 0) {
  20babd:	48 83 fa 7a          	cmp    rdx,0x7a
  20bac1:	75 06                	jne    20bac9 <FileOutStream_writeFn+0xb9>
  20bac3:	66 b8 0c 00          	mov    ax,0xc
  20bac7:	5b                   	pop    rbx
  20bac8:	c3                   	ret    
  20bac9:	66 b8 02 00          	mov    ax,0x2
  20bacd:	5b                   	pop    rbx
  20bace:	c3                   	ret    
  20bacf:	66 b8 10 00          	mov    ax,0x10
  20bad3:	5b                   	pop    rbx
  20bad4:	c3                   	ret    
  20bad5:	66 b8 0e 00          	mov    ax,0xe
  20bad9:	5b                   	pop    rbx
  20bada:	c3                   	ret    
  20badb:	66 b8 0a 00          	mov    ax,0xa
  20badf:	5b                   	pop    rbx
  20bae0:	c3                   	ret    
  20bae1:	66 b8 0d 00          	mov    ax,0xd
  20bae5:	5b                   	pop    rbx
  20bae6:	c3                   	ret    
  20bae7:	66 b8 0f 00          	mov    ax,0xf
  20baeb:	5b                   	pop    rbx
  20baec:	c3                   	ret    
  20baed:	66 b8 08 00          	mov    ax,0x8
  20baf1:	5b                   	pop    rbx
  20baf2:	c3                   	ret    
  20baf3:	66 b8 0b 00          	mov    ax,0xb
  20baf7:	5b                   	pop    rbx
  20baf8:	c3                   	ret    
  20baf9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000020bb00 <openSelfDebugInfo>:
            return Self{
  20bb00:	55                   	push   rbp
  20bb01:	41 57                	push   r15
  20bb03:	41 56                	push   r14
  20bb05:	41 55                	push   r13
  20bb07:	41 54                	push   r12
  20bb09:	53                   	push   rbx
  20bb0a:	48 81 ec 28 05 00 00 	sub    rsp,0x528
  20bb11:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  20bb15:	c5 f8 29 84 24 90 03 	vmovaps XMMWORD PTR [rsp+0x390],xmm0
  20bb1c:	00 00 
  20bb1e:	c5 f8 29 84 24 70 03 	vmovaps XMMWORD PTR [rsp+0x370],xmm0
  20bb25:	00 00 
  20bb27:	49 89 f7             	mov    r15,rsi
  20bb2a:	49 89 fe             	mov    r14,rdi
            const st = try allocator.create(ElfStackTrace{
  20bb2d:	c5 fc 10 05 53 a6 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffa653]        # 206188 <__unnamed_46>
  20bb34:	ff 
  20bb35:	c5 fc 11 84 24 b0 04 	vmovups YMMWORD PTR [rsp+0x4b0],ymm0
  20bb3c:	00 00 
  20bb3e:	48 c7 84 24 a0 03 00 	mov    QWORD PTR [rsp+0x3a0],0x0
  20bb45:	00 00 00 00 00 
  20bb4a:	c5 fc 10 05 56 a6 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffffa656]        # 2061a8 <__unnamed_46+0x20>
  20bb51:	ff 
  20bb52:	c5 fc 11 84 24 d0 04 	vmovups YMMWORD PTR [rsp+0x4d0],ymm0
  20bb59:	00 00 
  20bb5b:	48 c7 84 24 80 03 00 	mov    QWORD PTR [rsp+0x380],0x0
  20bb62:	00 00 00 00 00 
  20bb67:	c5 fe 6f 05 51 a6 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffffa651]        # 2061c0 <__unnamed_46+0x38>
  20bb6e:	ff 
  20bb6f:	c5 fe 7f 84 24 e8 04 	vmovdqu YMMWORD PTR [rsp+0x4e8],ymm0
  20bb76:	00 00 
  20bb78:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20bb7f:	00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20bb80:	ba c8 00 00 00       	mov    edx,0xc8
  20bb85:	b9 04 00 00 00       	mov    ecx,0x4
  20bb8a:	c5 f8 77             	vzeroupper 
  20bb8d:	41 ff 17             	call   QWORD PTR [r15]
  20bb90:	0f b7 84 24 a0 00 00 	movzx  eax,WORD PTR [rsp+0xa0]
  20bb97:	00 
  20bb98:	66 85 c0             	test   ax,ax
  20bb9b:	74 19                	je     20bbb6 <openSelfDebugInfo+0xb6>
  20bb9d:	66 41 89 06          	mov    WORD PTR [r14],ax
  20bba1:	48 8b 84 24 1a 04 00 	mov    rax,QWORD PTR [rsp+0x41a]
  20bba8:	00 
  20bba9:	48 8b 8c 24 20 04 00 	mov    rcx,QWORD PTR [rsp+0x420]
  20bbb0:	00 
  20bbb1:	e9 40 0c 00 00       	jmp    20c7f6 <openSelfDebugInfo+0xcf6>
        assert(byte_slice.len == byte_count);
  20bbb6:	48 81 bc 24 b0 00 00 	cmp    QWORD PTR [rsp+0xb0],0xc8
  20bbbd:	00 c8 00 00 00 
    if (!ok) {
  20bbc2:	0f 85 0a 36 00 00    	jne    20f1d2 <openSelfDebugInfo+0x36d2>
  20bbc8:	48 8b 9c 24 a8 00 00 	mov    rbx,QWORD PTR [rsp+0xa8]
  20bbcf:	00 
        ptr.* = init;
  20bbd0:	c5 fc 10 84 24 a8 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4a8]
  20bbd7:	00 00 
  20bbd9:	c5 fe 6f 8c 24 c8 04 	vmovdqu ymm1,YMMWORD PTR [rsp+0x4c8]
  20bbe0:	00 00 
  20bbe2:	c5 fe 6f 94 24 e8 04 	vmovdqu ymm2,YMMWORD PTR [rsp+0x4e8]
  20bbe9:	00 00 
  20bbeb:	c5 fe 6f 9c 24 08 05 	vmovdqu ymm3,YMMWORD PTR [rsp+0x508]
  20bbf2:	00 00 
  20bbf4:	c5 fe 7f 5b 60       	vmovdqu YMMWORD PTR [rbx+0x60],ymm3
  20bbf9:	c5 fe 7f 53 40       	vmovdqu YMMWORD PTR [rbx+0x40],ymm2
  20bbfe:	c5 fe 7f 4b 20       	vmovdqu YMMWORD PTR [rbx+0x20],ymm1
  20bc03:	c5 fc 11 03          	vmovups YMMWORD PTR [rbx],ymm0
  20bc07:	48 c7 83 80 00 00 00 	mov    QWORD PTR [rbx+0x80],0x0
  20bc0e:	00 00 00 00 
  20bc12:	48 8b 84 24 a0 03 00 	mov    rax,QWORD PTR [rsp+0x3a0]
  20bc19:	00 
  20bc1a:	48 89 83 98 00 00 00 	mov    QWORD PTR [rbx+0x98],rax
  20bc21:	c5 f8 28 84 24 90 03 	vmovaps xmm0,XMMWORD PTR [rsp+0x390]
  20bc28:	00 00 
  20bc2a:	c5 f8 11 83 88 00 00 	vmovups XMMWORD PTR [rbx+0x88],xmm0
  20bc31:	00 
  20bc32:	4c 89 bb a0 00 00 00 	mov    QWORD PTR [rbx+0xa0],r15
  20bc39:	48 8b 84 24 80 03 00 	mov    rax,QWORD PTR [rsp+0x380]
  20bc40:	00 
  20bc41:	48 89 83 b8 00 00 00 	mov    QWORD PTR [rbx+0xb8],rax
  20bc48:	c5 f8 28 84 24 70 03 	vmovaps xmm0,XMMWORD PTR [rsp+0x370]
  20bc4f:	00 00 
  20bc51:	c5 f8 11 83 a8 00 00 	vmovups XMMWORD PTR [rbx+0xa8],xmm0
  20bc58:	00 
  20bc59:	4c 89 bb c0 00 00 00 	mov    QWORD PTR [rbx+0xc0],r15
            var fixed_buffer_mem: [proc_file_path.len + 1]u8 = undefined;
  20bc60:	48 8b 05 ba a5 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffa5ba]        # 206221 <__unnamed_47+0x7>
  20bc67:	48 89 44 24 67       	mov    QWORD PTR [rsp+0x67],rax
  20bc6c:	48 8b 05 a7 a5 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffa5a7]        # 20621a <__unnamed_47>
  20bc73:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
            var fixed_allocator = std.heap.FixedBufferAllocator.init(fixed_buffer_mem[0..]);
  20bc78:	c5 fa 6f 05 98 4f 01 	vmovdqu xmm0,XMMWORD PTR [rip+0x14f98]        # 220c18 <__unnamed_48>
  20bc7f:	00 
  20bc80:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  20bc87:	00 00 
  20bc89:	48 8b 05 98 4f 01 00 	mov    rax,QWORD PTR [rip+0x14f98]        # 220c28 <__unnamed_48+0x10>
  20bc90:	48 89 84 24 b0 00 00 	mov    QWORD PTR [rsp+0xb0],rax
  20bc97:	00 
  20bc98:	48 c7 84 24 b8 00 00 	mov    QWORD PTR [rsp+0xb8],0x0
  20bc9f:	00 00 00 00 00 
  20bca4:	48 8d 44 24 60       	lea    rax,[rsp+0x60]
  20bca9:	48 89 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rax
  20bcb0:	00 
  20bcb1:	48 c7 84 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],0xf
  20bcb8:	00 0f 00 00 00 
            return os.File.openRead(&fixed_allocator.allocator, proc_file_path);
  20bcbd:	48 8d 15 44 4f 01 00 	lea    rdx,[rip+0x14f44]        # 220c08 <__unnamed_49>
  20bcc4:	48 8d bc 24 b8 02 00 	lea    rdi,[rsp+0x2b8]
  20bccb:	00 
  20bccc:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20bcd3:	00 
  20bcd4:	c5 f8 77             	vzeroupper 
  20bcd7:	e8 64 42 00 00       	call   20ff40 <File_openRead>
  20bcdc:	48 8b ac 24 b8 02 00 	mov    rbp,QWORD PTR [rsp+0x2b8]
  20bce3:	00 
            st.self_exe_file = try os.openSelfExe();
  20bce4:	66 85 ed             	test   bp,bp
  20bce7:	74 3e                	je     20bd27 <openSelfDebugInfo+0x227>
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20bce9:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20bced:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20bcf4:	00 
  20bcf5:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20bcfc:	00 c8 00 00 00 
  20bd01:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20bd08:	00 
  20bd09:	4c 89 ff             	mov    rdi,r15
  20bd0c:	ff d0                	call   rax
  20bd0e:	66 41 89 2e          	mov    WORD PTR [r14],bp
  20bd12:	48 8b 84 24 0c 04 00 	mov    rax,QWORD PTR [rsp+0x40c]
  20bd19:	00 
  20bd1a:	48 8b 8c 24 12 04 00 	mov    rcx,QWORD PTR [rsp+0x412]
  20bd21:	00 
  20bd22:	e9 cf 0a 00 00       	jmp    20c7f6 <openSelfDebugInfo+0xcf6>
  20bd27:	48 c1 ed 20          	shr    rbp,0x20
  20bd2b:	89 2b                	mov    DWORD PTR [rbx],ebp
            try st.elf.openFile(allocator, &st.self_exe_file);
  20bd2d:	4c 8d 63 08          	lea    r12,[rbx+0x8]
        elf.auto_close_stream = true;
    }

    /// Call close when done.
    pub fn openFile(elf: *Elf, allocator: *mem.Allocator, file: *os.File) !void {
        elf.allocator = allocator;
  20bd31:	4c 89 7b 50          	mov    QWORD PTR [rbx+0x50],r15
        elf.in_file = file;
  20bd35:	48 89 5b 08          	mov    QWORD PTR [rbx+0x8],rbx
        elf.auto_close_stream = false;
  20bd39:	c6 43 10 00          	mov    BYTE PTR [rbx+0x10],0x0

        var file_stream = io.FileInStream.init(elf.in_file);
  20bd3d:	48 89 5c 24 20       	mov    QWORD PTR [rsp+0x20],rbx
  20bd42:	48 8d 05 e7 48 00 00 	lea    rax,[rip+0x48e7]        # 210630 <FileInStream_readFn>
  20bd49:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20bd4e:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  20bd55:	00 
        const in = &file_stream.stream;

        var magic: [4]u8 = undefined;
        try in.readNoEof(magic[0..]);
  20bd56:	48 89 84 24 b8 02 00 	mov    QWORD PTR [rsp+0x2b8],rax
  20bd5d:	00 
  20bd5e:	48 c7 84 24 c0 02 00 	mov    QWORD PTR [rsp+0x2c0],0x4
  20bd65:	00 04 00 00 00 
        return self.file.read(buffer);
  20bd6a:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  20bd6f:	4c 8d ac 24 a0 00 00 	lea    r13,[rsp+0xa0]
  20bd76:	00 
  20bd77:	48 8d 94 24 b8 02 00 	lea    rdx,[rsp+0x2b8]
  20bd7e:	00 
  20bd7f:	4c 89 ef             	mov    rdi,r13
  20bd82:	e8 99 47 00 00       	call   210520 <File_read>
  20bd87:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20bd8e:	00 
            const amt_read = try self.read(buf);
  20bd8f:	66 85 ed             	test   bp,bp
  20bd92:	75 16                	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20bd94:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20bd9b:	00 
  20bd9c:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20bda0:	48 3b 84 24 c0 02 00 	cmp    rax,QWORD PTR [rsp+0x2c0]
  20bda7:	00 
  20bda8:	73 50                	jae    20bdfa <openSelfDebugInfo+0x2fa>
  20bdaa:	66 85 ed             	test   bp,bp
  20bdad:	0f 84 77 06 00 00    	je     20c42a <openSelfDebugInfo+0x92a>
  20bdb3:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20bdb6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  20bdbd:	00 00 00 
    return asm volatile ("syscall"
  20bdc0:	b8 03 00 00 00       	mov    eax,0x3
  20bdc5:	0f 05                	syscall 
            switch (err) {
  20bdc7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20bdcb:	74 f3                	je     20bdc0 <openSelfDebugInfo+0x2c0>
        /// Remove and return the first node in the list.
        ///
        /// Returns:
        ///     A pointer to the first node in the list.
        pub fn popFirst(list: *Self) ?*Node {
            const first = list.first orelse return null;
  20bdcd:	48 8b 05 7c 52 01 00 	mov    rax,QWORD PTR [rip+0x1527c]        # 221050 <emfile_promise_queue>
  20bdd4:	48 85 c0             	test   rax,rax
  20bdd7:	0f 84 2b 01 00 00    	je     20bf08 <openSelfDebugInfo+0x408>
            if (node.prev) |prev_node| {
  20bddd:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20bde0:	48 85 c9             	test   rcx,rcx
  20bde3:	0f 84 b5 00 00 00    	je     20be9e <openSelfDebugInfo+0x39e>
                prev_node.next = node.next;
  20bde9:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20bded:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20bdf1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20bdf5:	e9 af 00 00 00       	jmp    20bea9 <openSelfDebugInfo+0x3a9>
        if (b[index] != item) return false;
  20bdfa:	80 bc 24 50 01 00 00 	cmp    BYTE PTR [rsp+0x150],0x7f
  20be01:	7f 
  20be02:	0f 85 15 06 00 00    	jne    20c41d <openSelfDebugInfo+0x91d>
  20be08:	80 bc 24 51 01 00 00 	cmp    BYTE PTR [rsp+0x151],0x45
  20be0f:	45 
  20be10:	0f 85 07 06 00 00    	jne    20c41d <openSelfDebugInfo+0x91d>
  20be16:	80 bc 24 52 01 00 00 	cmp    BYTE PTR [rsp+0x152],0x4c
  20be1d:	4c 
  20be1e:	0f 85 f9 05 00 00    	jne    20c41d <openSelfDebugInfo+0x91d>
  20be24:	80 bc 24 53 01 00 00 	cmp    BYTE PTR [rsp+0x153],0x46
  20be2b:	46 
  20be2c:	0f 85 17 01 00 00    	jne    20bf49 <openSelfDebugInfo+0x449>
  20be32:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20be37:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
            try self.readNoEof(result[0..]);
  20be3c:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20be41:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  20be48:	00 00 
  20be4a:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20be51:	00 
  20be52:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20be57:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20be5b:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20be62:	00 
            const amt_read = try self.read(buf);
  20be63:	66 85 ed             	test   bp,bp
  20be66:	0f 85 3e ff ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20be6c:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20be73:	00 
  20be74:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20be78:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20be7d:	0f 82 27 ff ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
            return result[0];
  20be83:	8a 44 24 07          	mov    al,BYTE PTR [rsp+0x7]
        if (!mem.eql(u8, magic, "\x7fELF")) return error.InvalidFormat;

        elf.is_64 = switch (try in.readByte()) {
  20be87:	3c 01                	cmp    al,0x1
  20be89:	0f 84 cc 00 00 00    	je     20bf5b <openSelfDebugInfo+0x45b>
  20be8f:	3c 02                	cmp    al,0x2
  20be91:	0f 85 86 05 00 00    	jne    20c41d <openSelfDebugInfo+0x91d>
  20be97:	b0 01                	mov    al,0x1
  20be99:	e9 bf 00 00 00       	jmp    20bf5d <openSelfDebugInfo+0x45d>
                list.first = node.next;
  20be9e:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20bea2:	48 89 0d a7 51 01 00 	mov    QWORD PTR [rip+0x151a7],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20bea9:	48 85 c9             	test   rcx,rcx
  20beac:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20beaf:	48 8d 35 a2 51 01 00 	lea    rsi,[rip+0x151a2]        # 221058 <emfile_promise_queue+0x8>
  20beb6:	48 0f 45 f1          	cmovne rsi,rcx
  20beba:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20bebd:	48 83 05 9b 51 01 00 	add    QWORD PTR [rip+0x1519b],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20bec4:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20bec5:	74 1e                	je     20bee5 <openSelfDebugInfo+0x3e5>
  20bec7:	48 83 3d 81 51 01 00 	cmp    QWORD PTR [rip+0x15181],0x0        # 221050 <emfile_promise_queue>
  20bece:	00 
  20becf:	0f 84 fd 32 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20bed5:	48 8b 0d 7c 51 01 00 	mov    rcx,QWORD PTR [rip+0x1517c]        # 221058 <emfile_promise_queue+0x8>
  20bedc:	48 85 c9             	test   rcx,rcx
  20bedf:	0f 84 ed 32 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20bee5:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20bee9:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20beed:	0f 1f 00             	nop    DWORD PTR [rax]
  20bef0:	48 89 c1             	mov    rcx,rax
  20bef3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20bef7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20befd:	75 f1                	jne    20bef0 <openSelfDebugInfo+0x3f0>
  20beff:	a8 01                	test   al,0x1
  20bf01:	75 05                	jne    20bf08 <openSelfDebugInfo+0x408>
  20bf03:	c5 f8 77             	vzeroupper 
  20bf06:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20bf08:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20bf0c:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20bf13:	00 
  20bf14:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20bf1b:	00 c8 00 00 00 
  20bf20:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20bf27:	00 
  20bf28:	4c 89 ff             	mov    rdi,r15
  20bf2b:	c5 f8 77             	vzeroupper 
  20bf2e:	ff d0                	call   rax
  20bf30:	66 41 89 2e          	mov    WORD PTR [r14],bp
  20bf34:	48 8b 84 24 fe 03 00 	mov    rax,QWORD PTR [rsp+0x3fe]
  20bf3b:	00 
  20bf3c:	48 8b 8c 24 04 04 00 	mov    rcx,QWORD PTR [rsp+0x404]
  20bf43:	00 
  20bf44:	e9 ad 08 00 00       	jmp    20c7f6 <openSelfDebugInfo+0xcf6>
  20bf49:	66 bd 21 00          	mov    bp,0x21
  20bf4d:	66 85 ed             	test   bp,bp
  20bf50:	0f 85 5d fe ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
  20bf56:	e9 cf 04 00 00       	jmp    20c42a <openSelfDebugInfo+0x92a>
  20bf5b:	31 c0                	xor    eax,eax
  20bf5d:	88 43 11             	mov    BYTE PTR [rbx+0x11],al
            try self.readNoEof(result[0..]);
  20bf60:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20bf65:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20bf6a:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  20bf71:	00 00 
  20bf73:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20bf7a:	00 
  20bf7b:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20bf80:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20bf85:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20bf89:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20bf90:	00 
            const amt_read = try self.read(buf);
  20bf91:	66 85 ed             	test   bp,bp
  20bf94:	0f 85 10 fe ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20bf9a:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20bfa1:	00 
  20bfa2:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20bfa6:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20bfab:	0f 82 f9 fd ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
            return result[0];
  20bfb1:	8a 44 24 07          	mov    al,BYTE PTR [rsp+0x7]
            1 => false,
            2 => true,
            else => return error.InvalidFormat,
        };

        elf.endian = switch (try in.readByte()) {
  20bfb5:	3c 01                	cmp    al,0x1
  20bfb7:	74 0c                	je     20bfc5 <openSelfDebugInfo+0x4c5>
  20bfb9:	3c 02                	cmp    al,0x2
  20bfbb:	0f 85 5c 04 00 00    	jne    20c41d <openSelfDebugInfo+0x91d>
  20bfc1:	31 c0                	xor    eax,eax
  20bfc3:	eb 02                	jmp    20bfc7 <openSelfDebugInfo+0x4c7>
  20bfc5:	b0 01                	mov    al,0x1
  20bfc7:	48 8d 4b 12          	lea    rcx,[rbx+0x12]
  20bfcb:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  20bfd0:	88 01                	mov    BYTE PTR [rcx],al
            try self.readNoEof(result[0..]);
  20bfd2:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20bfd7:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20bfdc:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  20bfe3:	00 00 
  20bfe5:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20bfec:	00 
  20bfed:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20bff2:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20bff7:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20bffb:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20c002:	00 
            const amt_read = try self.read(buf);
  20c003:	66 85 ed             	test   bp,bp
  20c006:	0f 85 9e fd ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20c00c:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20c013:	00 
  20c014:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20c018:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20c01d:	0f 82 87 fd ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
            2 => builtin.Endian.Big,
            else => return error.InvalidFormat,
        };

        const version_byte = try in.readByte();
        if (version_byte != 1) return error.InvalidFormat;
  20c023:	80 7c 24 07 01       	cmp    BYTE PTR [rsp+0x7],0x1
  20c028:	0f 85 ef 03 00 00    	jne    20c41d <openSelfDebugInfo+0x91d>

        // skip over padding
        try elf.in_file.seekForward(9);
  20c02e:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20c032:	48 63 38             	movsxd rdi,DWORD PTR [rax]
    return asm volatile ("syscall"
  20c035:	b8 08 00 00 00       	mov    eax,0x8
  20c03a:	be 09 00 00 00       	mov    esi,0x9
  20c03f:	ba 01 00 00 00       	mov    edx,0x1
  20c044:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20c046:	48 89 c2             	mov    rdx,rax
  20c049:	48 f7 da             	neg    rdx
  20c04c:	31 c9                	xor    ecx,ecx
  20c04e:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20c054:	48 0f 47 ca          	cmova  rcx,rdx
                if (err > 0) {
  20c058:	48 83 f9 1d          	cmp    rcx,0x1d
  20c05c:	0f 87 4b 31 00 00    	ja     20f1ad <openSelfDebugInfo+0x36ad>
  20c062:	48 8d 05 77 4e ff ff 	lea    rax,[rip+0xffffffffffff4e77]        # 200ee0 <__unnamed_9+0x200>
  20c069:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  20c06d:	48 01 c1             	add    rcx,rax
  20c070:	66 bd 02 00          	mov    bp,0x2
  20c074:	ff e1                	jmp    rcx
  20c076:	66 bd 22 00          	mov    bp,0x22
  20c07a:	66 85 ed             	test   bp,bp
  20c07d:	0f 85 30 fd ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
  20c083:	e9 a2 03 00 00       	jmp    20c42a <openSelfDebugInfo+0x92a>

        elf.file_type = switch (try in.readInt(elf.endian, u16)) {
  20c088:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
  20c08b:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20c08f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            try self.readNoEof(bytes[0..]);
  20c094:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20c099:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20c0a0:	00 00 
  20c0a2:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20c0a9:	00 
  20c0aa:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20c0af:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20c0b4:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20c0b8:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20c0bf:	00 
            const amt_read = try self.read(buf);
  20c0c0:	66 85 ed             	test   bp,bp
  20c0c3:	0f 85 e1 fc ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20c0c9:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20c0d0:	00 
  20c0d1:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20c0d5:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20c0da:	0f 82 ca fc ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
  20c0e0:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20c0e5:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20c0ea:	89 ca                	mov    edx,ecx
  20c0ec:	c1 e2 08             	shl    edx,0x8
  20c0ef:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20c0f1:	c1 e0 08             	shl    eax,0x8
  20c0f4:	09 c8                	or     eax,ecx
    switch (endian) {
  20c0f6:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20c0fb:	66 0f 45 c2          	cmovne ax,dx
  20c0ff:	83 c0 ff             	add    eax,0xffffffff
  20c102:	0f b7 c8             	movzx  ecx,ax
  20c105:	83 f9 03             	cmp    ecx,0x3
  20c108:	0f 87 0f 03 00 00    	ja     20c41d <openSelfDebugInfo+0x91d>
  20c10e:	24 03                	and    al,0x3
  20c110:	88 43 13             	mov    BYTE PTR [rbx+0x13],al
            3 => FileType.Shared,
            4 => FileType.Core,
            else => return error.InvalidFormat,
        };

        elf.arch = switch (try in.readInt(elf.endian, u16)) {
  20c113:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  20c116:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20c11a:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20c11f:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20c124:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20c12b:	00 00 
  20c12d:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20c134:	00 
  20c135:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20c13a:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20c13f:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20c143:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20c14a:	00 
            const amt_read = try self.read(buf);
  20c14b:	66 85 ed             	test   bp,bp
  20c14e:	0f 85 56 fc ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20c154:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20c15b:	00 
  20c15c:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20c160:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20c165:	0f 82 3f fc ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
  20c16b:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20c170:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20c175:	89 ca                	mov    edx,ecx
  20c177:	c1 e2 08             	shl    edx,0x8
  20c17a:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20c17c:	c1 e0 08             	shl    eax,0x8
  20c17f:	09 c8                	or     eax,ecx
    switch (endian) {
  20c181:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20c186:	66 0f 45 c2          	cmovne ax,dx
  20c18a:	8d 48 fe             	lea    ecx,[rax-0x2]
  20c18d:	0f b7 c9             	movzx  ecx,cx
  20c190:	83 f9 3c             	cmp    ecx,0x3c
  20c193:	77 1a                	ja     20c1af <openSelfDebugInfo+0x6af>
  20c195:	31 c0                	xor    eax,eax
  20c197:	48 8d 15 ba 4d ff ff 	lea    rdx,[rip+0xffffffffffff4dba]        # 200f58 <__unnamed_9+0x278>
  20c19e:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  20c1a2:	48 01 d1             	add    rcx,rdx
  20c1a5:	66 bd 21 00          	mov    bp,0x21
  20c1a9:	ff e1                	jmp    rcx
  20c1ab:	b0 01                	mov    al,0x1
  20c1ad:	eb 28                	jmp    20c1d7 <openSelfDebugInfo+0x6d7>
  20c1af:	0f b7 c0             	movzx  eax,ax
  20c1b2:	3d b7 00 00 00       	cmp    eax,0xb7
  20c1b7:	0f 85 60 02 00 00    	jne    20c41d <openSelfDebugInfo+0x91d>
  20c1bd:	b0 08                	mov    al,0x8
  20c1bf:	eb 16                	jmp    20c1d7 <openSelfDebugInfo+0x6d7>
  20c1c1:	b0 06                	mov    al,0x6
  20c1c3:	eb 12                	jmp    20c1d7 <openSelfDebugInfo+0x6d7>
  20c1c5:	b0 07                	mov    al,0x7
  20c1c7:	eb 0e                	jmp    20c1d7 <openSelfDebugInfo+0x6d7>
  20c1c9:	b0 02                	mov    al,0x2
  20c1cb:	eb 0a                	jmp    20c1d7 <openSelfDebugInfo+0x6d7>
  20c1cd:	b0 04                	mov    al,0x4
  20c1cf:	eb 06                	jmp    20c1d7 <openSelfDebugInfo+0x6d7>
  20c1d1:	b0 03                	mov    al,0x3
  20c1d3:	eb 02                	jmp    20c1d7 <openSelfDebugInfo+0x6d7>
  20c1d5:	b0 05                	mov    al,0x5
  20c1d7:	24 0f                	and    al,0xf
  20c1d9:	88 43 14             	mov    BYTE PTR [rbx+0x14],al
            0x3E => Arch.x86_64,
            0xb7 => Arch.AArch64,
            else => return error.InvalidFormat,
        };

        const elf_version = try in.readInt(elf.endian, u32);
  20c1dc:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  20c1df:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20c1e3:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20c1e8:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20c1ed:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20c1f4:	00 00 
  20c1f6:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20c1fd:	00 
  20c1fe:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20c203:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20c208:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20c20c:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20c213:	00 
            const amt_read = try self.read(buf);
  20c214:	66 85 ed             	test   bp,bp
  20c217:	0f 85 8d fb ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20c21d:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20c224:	00 
  20c225:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20c229:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20c22e:	0f 82 76 fb ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
  20c234:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20c239:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20c23e:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20c243:	74 23                	je     20c268 <openSelfDebugInfo+0x768>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20c245:	c1 e1 08             	shl    ecx,0x8
  20c248:	09 c1                	or     ecx,eax
  20c24a:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20c24f:	c1 e2 10             	shl    edx,0x10
  20c252:	09 ca                	or     edx,ecx
  20c254:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20c259:	c1 e0 18             	shl    eax,0x18
  20c25c:	09 d0                	or     eax,edx
        if (elf_version != 1) return error.InvalidFormat;
  20c25e:	83 f8 01             	cmp    eax,0x1
  20c261:	74 27                	je     20c28a <openSelfDebugInfo+0x78a>
  20c263:	e9 b5 01 00 00       	jmp    20c41d <openSelfDebugInfo+0x91d>
                result = (result << 8) | b;
  20c268:	c1 e0 08             	shl    eax,0x8
  20c26b:	09 c8                	or     eax,ecx
  20c26d:	c1 e0 08             	shl    eax,0x8
  20c270:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20c275:	09 c1                	or     ecx,eax
  20c277:	c1 e1 08             	shl    ecx,0x8
  20c27a:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20c27f:	09 c8                	or     eax,ecx
  20c281:	83 f8 01             	cmp    eax,0x1
  20c284:	0f 85 93 01 00 00    	jne    20c41d <openSelfDebugInfo+0x91d>
  20c28a:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]

        if (elf.is_64) {
  20c28d:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20c291:	80 7b 11 01          	cmp    BYTE PTR [rbx+0x11],0x1
  20c295:	0f 85 58 23 00 00    	jne    20e5f3 <openSelfDebugInfo+0x2af3>
            elf.entry_addr = try in.readInt(elf.endian, u64);
  20c29b:	0f b6 54 24 38       	movzx  edx,BYTE PTR [rsp+0x38]
  20c2a0:	48 8d bc 24 28 04 00 	lea    rdi,[rsp+0x428]
  20c2a7:	00 
  20c2a8:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20c2ad:	e8 3e 41 00 00       	call   2103f0 <InStream(ReadError)_readInt.33>
  20c2b2:	0f b7 ac 24 28 04 00 	movzx  ebp,WORD PTR [rsp+0x428]
  20c2b9:	00 
  20c2ba:	66 85 ed             	test   bp,bp
  20c2bd:	0f 85 e7 fa ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20c2c3:	48 8b 84 24 30 04 00 	mov    rax,QWORD PTR [rsp+0x430]
  20c2ca:	00 
  20c2cb:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
            elf.program_header_offset = try in.readInt(elf.endian, u64);
  20c2cf:	0f b6 53 12          	movzx  edx,BYTE PTR [rbx+0x12]
  20c2d3:	48 8d bc 24 10 02 00 	lea    rdi,[rsp+0x210]
  20c2da:	00 
  20c2db:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20c2e0:	e8 0b 41 00 00       	call   2103f0 <InStream(ReadError)_readInt.33>
  20c2e5:	0f b7 ac 24 10 02 00 	movzx  ebp,WORD PTR [rsp+0x210]
  20c2ec:	00 
  20c2ed:	66 85 ed             	test   bp,bp
  20c2f0:	0f 85 b4 fa ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20c2f6:	48 8b 84 24 18 02 00 	mov    rax,QWORD PTR [rsp+0x218]
  20c2fd:	00 
  20c2fe:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
            elf.section_header_offset = try in.readInt(elf.endian, u64);
  20c302:	0f b6 53 12          	movzx  edx,BYTE PTR [rbx+0x12]
  20c306:	48 8d bc 24 e0 01 00 	lea    rdi,[rsp+0x1e0]
  20c30d:	00 
  20c30e:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20c313:	e8 d8 40 00 00       	call   2103f0 <InStream(ReadError)_readInt.33>
  20c318:	0f b7 ac 24 e0 01 00 	movzx  ebp,WORD PTR [rsp+0x1e0]
  20c31f:	00 
  20c320:	66 85 ed             	test   bp,bp
  20c323:	0f 85 81 fa ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20c329:	48 8b 84 24 e8 01 00 	mov    rax,QWORD PTR [rsp+0x1e8]
  20c330:	00 
  20c331:	48 89 43 28          	mov    QWORD PTR [rbx+0x28],rax
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
        }

        // skip over flags
        try elf.in_file.seekForward(4);
  20c335:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20c339:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20c33c:	b8 08 00 00 00       	mov    eax,0x8
  20c341:	be 04 00 00 00       	mov    esi,0x4
  20c346:	ba 01 00 00 00       	mov    edx,0x1
  20c34b:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20c34d:	48 89 c2             	mov    rdx,rax
  20c350:	48 f7 da             	neg    rdx
  20c353:	31 c9                	xor    ecx,ecx
  20c355:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20c35b:	48 0f 47 ca          	cmova  rcx,rdx
  20c35f:	48 83 f9 1d          	cmp    rcx,0x1d
  20c363:	0f 87 44 2e 00 00    	ja     20f1ad <openSelfDebugInfo+0x36ad>
  20c369:	48 8d 05 dc 4c ff ff 	lea    rax,[rip+0xffffffffffff4cdc]        # 20104c <__unnamed_9+0x36c>
  20c370:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  20c374:	48 01 c1             	add    rcx,rax
  20c377:	66 bd 02 00          	mov    bp,0x2
  20c37b:	ff e1                	jmp    rcx

        const header_size = try in.readInt(elf.endian, u16);
  20c37d:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20c382:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20c384:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20c388:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20c38d:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20c392:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20c399:	00 00 
  20c39b:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20c3a2:	00 
  20c3a3:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20c3a8:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20c3ad:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20c3b1:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20c3b8:	00 
            const amt_read = try self.read(buf);
  20c3b9:	66 85 ed             	test   bp,bp
  20c3bc:	0f 85 e8 f9 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20c3c2:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20c3c9:	00 
  20c3ca:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20c3ce:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20c3d3:	0f 82 d1 f9 ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
  20c3d9:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20c3de:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20c3e3:	89 ca                	mov    edx,ecx
  20c3e5:	c1 e2 08             	shl    edx,0x8
  20c3e8:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20c3ea:	c1 e0 08             	shl    eax,0x8
  20c3ed:	09 c8                	or     eax,ecx
    switch (endian) {
  20c3ef:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20c3f4:	66 0f 45 c2          	cmovne ax,dx
        if ((elf.is_64 and header_size != 64) or (!elf.is_64 and header_size != 52)) {
  20c3f8:	8a 4b 11             	mov    cl,BYTE PTR [rbx+0x11]
  20c3fb:	80 f9 01             	cmp    cl,0x1
  20c3fe:	75 08                	jne    20c408 <openSelfDebugInfo+0x908>
  20c400:	0f b7 d0             	movzx  edx,ax
  20c403:	83 fa 40             	cmp    edx,0x40
  20c406:	75 15                	jne    20c41d <openSelfDebugInfo+0x91d>
  20c408:	0f b7 c0             	movzx  eax,ax
  20c40b:	83 f8 34             	cmp    eax,0x34
  20c40e:	0f 84 c2 23 00 00    	je     20e7d6 <openSelfDebugInfo+0x2cd6>
  20c414:	80 f1 01             	xor    cl,0x1
  20c417:	0f 84 b9 23 00 00    	je     20e7d6 <openSelfDebugInfo+0x2cd6>
  20c41d:	66 bd 21 00          	mov    bp,0x21
  20c421:	66 85 ed             	test   bp,bp
  20c424:	0f 85 89 f9 ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
            st.debug_info = (try st.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  20c42a:	48 8d 15 87 47 01 00 	lea    rdx,[rip+0x14787]        # 220bb8 <__unnamed_50>
  20c431:	48 8d bc 24 a8 02 00 	lea    rdi,[rsp+0x2a8]
  20c438:	00 
  20c439:	4c 89 e6             	mov    rsi,r12
  20c43c:	c5 f8 77             	vzeroupper 
  20c43f:	e8 ac 38 00 00       	call   20fcf0 <Elf_findSection>
  20c444:	66 83 bc 24 a8 02 00 	cmp    WORD PTR [rsp+0x2a8],0x0
  20c44b:	00 00 
  20c44d:	74 7b                	je     20c4ca <openSelfDebugInfo+0x9ca>
        const bytes = @sliceToBytes(memory);
  20c44f:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20c453:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20c457:	74 26                	je     20c47f <openSelfDebugInfo+0x97f>
  20c459:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20c45d:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20c461:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20c465:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20c46c:	00 
  20c46d:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20c474:	00 
  20c475:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c47c:	00 
  20c47d:	ff d2                	call   rdx
    }

    pub fn close(elf: *Elf) void {
        elf.allocator.free(elf.section_headers);

        if (elf.auto_close_stream) elf.in_file.close();
  20c47f:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20c483:	0f 85 8c 02 00 00    	jne    20c715 <openSelfDebugInfo+0xc15>
  20c489:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c48d:	48 63 38             	movsxd rdi,DWORD PTR [rax]
    return asm volatile ("syscall"
  20c490:	b8 03 00 00 00       	mov    eax,0x3
  20c495:	0f 05                	syscall 
            switch (err) {
  20c497:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c49b:	74 f3                	je     20c490 <openSelfDebugInfo+0x990>
            const first = list.first orelse return null;
  20c49d:	48 8b 05 ac 4b 01 00 	mov    rax,QWORD PTR [rip+0x14bac]        # 221050 <emfile_promise_queue>
  20c4a4:	48 85 c0             	test   rax,rax
  20c4a7:	0f 84 68 02 00 00    	je     20c715 <openSelfDebugInfo+0xc15>
            if (node.prev) |prev_node| {
  20c4ad:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c4b0:	48 85 c9             	test   rcx,rcx
  20c4b3:	0f 84 f8 01 00 00    	je     20c6b1 <openSelfDebugInfo+0xbb1>
                prev_node.next = node.next;
  20c4b9:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c4bd:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c4c1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c4c5:	e9 f2 01 00 00       	jmp    20c6bc <openSelfDebugInfo+0xbbc>
  20c4ca:	48 8b 84 24 b0 02 00 	mov    rax,QWORD PTR [rsp+0x2b0]
  20c4d1:	00 
  20c4d2:	48 85 c0             	test   rax,rax
  20c4d5:	0f 84 a5 00 00 00    	je     20c580 <openSelfDebugInfo+0xa80>
  20c4db:	48 89 43 60          	mov    QWORD PTR [rbx+0x60],rax
            st.debug_abbrev = (try st.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  20c4df:	48 8d 15 e2 46 01 00 	lea    rdx,[rip+0x146e2]        # 220bc8 <__unnamed_51>
  20c4e6:	48 8d bc 24 98 02 00 	lea    rdi,[rsp+0x298]
  20c4ed:	00 
  20c4ee:	4c 89 e6             	mov    rsi,r12
  20c4f1:	e8 fa 37 00 00       	call   20fcf0 <Elf_findSection>
  20c4f6:	66 83 bc 24 98 02 00 	cmp    WORD PTR [rsp+0x298],0x0
  20c4fd:	00 00 
  20c4ff:	0f 84 f6 00 00 00    	je     20c5fb <openSelfDebugInfo+0xafb>
        const bytes = @sliceToBytes(memory);
  20c505:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20c509:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20c50d:	74 26                	je     20c535 <openSelfDebugInfo+0xa35>
  20c50f:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20c513:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20c517:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20c51b:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20c522:	00 
  20c523:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20c52a:	00 
  20c52b:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c532:	00 
  20c533:	ff d2                	call   rdx
  20c535:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20c539:	0f 85 69 04 00 00    	jne    20c9a8 <openSelfDebugInfo+0xea8>
  20c53f:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c543:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20c546:	b8 03 00 00 00       	mov    eax,0x3
  20c54b:	0f 05                	syscall 
  20c54d:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c551:	74 f3                	je     20c546 <openSelfDebugInfo+0xa46>
            const first = list.first orelse return null;
  20c553:	48 8b 05 f6 4a 01 00 	mov    rax,QWORD PTR [rip+0x14af6]        # 221050 <emfile_promise_queue>
  20c55a:	48 85 c0             	test   rax,rax
  20c55d:	0f 84 45 04 00 00    	je     20c9a8 <openSelfDebugInfo+0xea8>
            if (node.prev) |prev_node| {
  20c563:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c566:	48 85 c9             	test   rcx,rcx
  20c569:	0f 84 d5 03 00 00    	je     20c944 <openSelfDebugInfo+0xe44>
                prev_node.next = node.next;
  20c56f:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c573:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c577:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c57b:	e9 cf 03 00 00       	jmp    20c94f <openSelfDebugInfo+0xe4f>
        const bytes = @sliceToBytes(memory);
  20c580:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20c584:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20c588:	74 26                	je     20c5b0 <openSelfDebugInfo+0xab0>
  20c58a:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20c58e:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20c592:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20c596:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20c59d:	00 
  20c59e:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20c5a5:	00 
  20c5a6:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c5ad:	00 
  20c5ae:	ff d2                	call   rdx
  20c5b0:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20c5b4:	0f 85 33 05 00 00    	jne    20caed <openSelfDebugInfo+0xfed>
  20c5ba:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c5be:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20c5c1:	b8 03 00 00 00       	mov    eax,0x3
  20c5c6:	0f 05                	syscall 
  20c5c8:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c5cc:	74 f3                	je     20c5c1 <openSelfDebugInfo+0xac1>
            const first = list.first orelse return null;
  20c5ce:	48 8b 05 7b 4a 01 00 	mov    rax,QWORD PTR [rip+0x14a7b]        # 221050 <emfile_promise_queue>
  20c5d5:	48 85 c0             	test   rax,rax
  20c5d8:	0f 84 0f 05 00 00    	je     20caed <openSelfDebugInfo+0xfed>
            if (node.prev) |prev_node| {
  20c5de:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c5e1:	48 85 c9             	test   rcx,rcx
  20c5e4:	0f 84 9f 04 00 00    	je     20ca89 <openSelfDebugInfo+0xf89>
                prev_node.next = node.next;
  20c5ea:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c5ee:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c5f2:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c5f6:	e9 99 04 00 00       	jmp    20ca94 <openSelfDebugInfo+0xf94>
  20c5fb:	48 8b 84 24 a0 02 00 	mov    rax,QWORD PTR [rsp+0x2a0]
  20c602:	00 
  20c603:	48 85 c0             	test   rax,rax
  20c606:	0f 84 07 02 00 00    	je     20c813 <openSelfDebugInfo+0xd13>
  20c60c:	48 89 43 68          	mov    QWORD PTR [rbx+0x68],rax
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  20c610:	48 8d 15 c1 45 01 00 	lea    rdx,[rip+0x145c1]        # 220bd8 <__unnamed_52>
  20c617:	48 8d bc 24 88 02 00 	lea    rdi,[rsp+0x288]
  20c61e:	00 
  20c61f:	4c 89 e6             	mov    rsi,r12
  20c622:	e8 c9 36 00 00       	call   20fcf0 <Elf_findSection>
  20c627:	66 83 bc 24 88 02 00 	cmp    WORD PTR [rsp+0x288],0x0
  20c62e:	00 00 
  20c630:	0f 84 58 02 00 00    	je     20c88e <openSelfDebugInfo+0xd8e>
        const bytes = @sliceToBytes(memory);
  20c636:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20c63a:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20c63e:	74 26                	je     20c666 <openSelfDebugInfo+0xb66>
  20c640:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20c644:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20c648:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20c64c:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20c653:	00 
  20c654:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20c65b:	00 
  20c65c:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c663:	00 
  20c664:	ff d2                	call   rdx
  20c666:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20c66a:	0f 85 df 06 00 00    	jne    20cd4f <openSelfDebugInfo+0x124f>
  20c670:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c674:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20c677:	b8 03 00 00 00       	mov    eax,0x3
  20c67c:	0f 05                	syscall 
  20c67e:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c682:	74 f3                	je     20c677 <openSelfDebugInfo+0xb77>
            const first = list.first orelse return null;
  20c684:	48 8b 05 c5 49 01 00 	mov    rax,QWORD PTR [rip+0x149c5]        # 221050 <emfile_promise_queue>
  20c68b:	48 85 c0             	test   rax,rax
  20c68e:	0f 84 bb 06 00 00    	je     20cd4f <openSelfDebugInfo+0x124f>
            if (node.prev) |prev_node| {
  20c694:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c697:	48 85 c9             	test   rcx,rcx
  20c69a:	0f 84 4b 06 00 00    	je     20cceb <openSelfDebugInfo+0x11eb>
                prev_node.next = node.next;
  20c6a0:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c6a4:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c6a8:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c6ac:	e9 45 06 00 00       	jmp    20ccf6 <openSelfDebugInfo+0x11f6>
                list.first = node.next;
  20c6b1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c6b5:	48 89 0d 94 49 01 00 	mov    QWORD PTR [rip+0x14994],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20c6bc:	48 85 c9             	test   rcx,rcx
  20c6bf:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20c6c2:	48 8d 35 8f 49 01 00 	lea    rsi,[rip+0x1498f]        # 221058 <emfile_promise_queue+0x8>
  20c6c9:	48 0f 45 f1          	cmovne rsi,rcx
  20c6cd:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20c6d0:	48 83 05 88 49 01 00 	add    QWORD PTR [rip+0x14988],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20c6d7:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20c6d8:	74 1e                	je     20c6f8 <openSelfDebugInfo+0xbf8>
  20c6da:	48 83 3d 6e 49 01 00 	cmp    QWORD PTR [rip+0x1496e],0x0        # 221050 <emfile_promise_queue>
  20c6e1:	00 
  20c6e2:	0f 84 ea 2a 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20c6e8:	48 8b 0d 69 49 01 00 	mov    rcx,QWORD PTR [rip+0x14969]        # 221058 <emfile_promise_queue+0x8>
  20c6ef:	48 85 c9             	test   rcx,rcx
  20c6f2:	0f 84 da 2a 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20c6f8:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20c6fc:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20c700:	48 89 c1             	mov    rcx,rax
  20c703:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20c707:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20c70d:	75 f1                	jne    20c700 <openSelfDebugInfo+0xc00>
  20c70f:	a8 01                	test   al,0x1
  20c711:	75 02                	jne    20c715 <openSelfDebugInfo+0xc15>
  20c713:	ff 17                	call   QWORD PTR [rdi]
  20c715:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20c718:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20c71f:	00 
  20c720:	b8 03 00 00 00       	mov    eax,0x3
  20c725:	0f 05                	syscall 
            switch (err) {
  20c727:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c72b:	74 f3                	je     20c720 <openSelfDebugInfo+0xc20>
            const first = list.first orelse return null;
  20c72d:	48 8b 05 1c 49 01 00 	mov    rax,QWORD PTR [rip+0x1491c]        # 221050 <emfile_promise_queue>
  20c734:	48 85 c0             	test   rax,rax
  20c737:	74 7c                	je     20c7b5 <openSelfDebugInfo+0xcb5>
            if (node.prev) |prev_node| {
  20c739:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c73c:	48 85 c9             	test   rcx,rcx
  20c73f:	74 0e                	je     20c74f <openSelfDebugInfo+0xc4f>
                prev_node.next = node.next;
  20c741:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c745:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c749:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c74d:	eb 0b                	jmp    20c75a <openSelfDebugInfo+0xc5a>
                list.first = node.next;
  20c74f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c753:	48 89 0d f6 48 01 00 	mov    QWORD PTR [rip+0x148f6],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20c75a:	48 85 c9             	test   rcx,rcx
  20c75d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20c760:	48 8d 35 f1 48 01 00 	lea    rsi,[rip+0x148f1]        # 221058 <emfile_promise_queue+0x8>
  20c767:	48 0f 45 f1          	cmovne rsi,rcx
  20c76b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20c76e:	48 83 05 ea 48 01 00 	add    QWORD PTR [rip+0x148ea],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20c775:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20c776:	74 1e                	je     20c796 <openSelfDebugInfo+0xc96>
  20c778:	48 83 3d d0 48 01 00 	cmp    QWORD PTR [rip+0x148d0],0x0        # 221050 <emfile_promise_queue>
  20c77f:	00 
  20c780:	0f 84 4c 2a 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20c786:	48 8b 0d cb 48 01 00 	mov    rcx,QWORD PTR [rip+0x148cb]        # 221058 <emfile_promise_queue+0x8>
  20c78d:	48 85 c9             	test   rcx,rcx
  20c790:	0f 84 3c 2a 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20c796:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20c79a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20c79e:	66 90                	xchg   ax,ax
  20c7a0:	48 89 c1             	mov    rcx,rax
  20c7a3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20c7a7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20c7ad:	75 f1                	jne    20c7a0 <openSelfDebugInfo+0xca0>
  20c7af:	a8 01                	test   al,0x1
  20c7b1:	75 02                	jne    20c7b5 <openSelfDebugInfo+0xcb5>
  20c7b3:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20c7b5:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20c7b9:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20c7c0:	00 
  20c7c1:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20c7c8:	00 c8 00 00 00 
  20c7cd:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c7d4:	00 
  20c7d5:	4c 89 ff             	mov    rdi,r15
  20c7d8:	ff d0                	call   rax
            st.debug_info = (try st.elf.findSection(".debug_info")) orelse return error.MissingDebugInfo;
  20c7da:	0f b7 84 24 a8 02 00 	movzx  eax,WORD PTR [rsp+0x2a8]
  20c7e1:	00 
  20c7e2:	66 41 89 06          	mov    WORD PTR [r14],ax
  20c7e6:	48 8b 84 24 f0 03 00 	mov    rax,QWORD PTR [rsp+0x3f0]
  20c7ed:	00 
  20c7ee:	48 8b 8c 24 f6 03 00 	mov    rcx,QWORD PTR [rsp+0x3f6]
  20c7f5:	00 
  20c7f6:	49 89 4e 08          	mov    QWORD PTR [r14+0x8],rcx
  20c7fa:	49 89 46 02          	mov    QWORD PTR [r14+0x2],rax
  20c7fe:	48 81 c4 28 05 00 00 	add    rsp,0x528
  20c805:	5b                   	pop    rbx
  20c806:	41 5c                	pop    r12
  20c808:	41 5d                	pop    r13
  20c80a:	41 5e                	pop    r14
  20c80c:	41 5f                	pop    r15
  20c80e:	5d                   	pop    rbp
  20c80f:	c5 f8 77             	vzeroupper 
  20c812:	c3                   	ret    
        const bytes = @sliceToBytes(memory);
  20c813:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20c817:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20c81b:	74 26                	je     20c843 <openSelfDebugInfo+0xd43>
  20c81d:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20c821:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20c825:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20c829:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20c830:	00 
  20c831:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20c838:	00 
  20c839:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c840:	00 
  20c841:	ff d2                	call   rdx
  20c843:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20c847:	0f 85 42 06 00 00    	jne    20ce8f <openSelfDebugInfo+0x138f>
  20c84d:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c851:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20c854:	b8 03 00 00 00       	mov    eax,0x3
  20c859:	0f 05                	syscall 
            switch (err) {
  20c85b:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c85f:	74 f3                	je     20c854 <openSelfDebugInfo+0xd54>
            const first = list.first orelse return null;
  20c861:	48 8b 05 e8 47 01 00 	mov    rax,QWORD PTR [rip+0x147e8]        # 221050 <emfile_promise_queue>
  20c868:	48 85 c0             	test   rax,rax
  20c86b:	0f 84 1e 06 00 00    	je     20ce8f <openSelfDebugInfo+0x138f>
            if (node.prev) |prev_node| {
  20c871:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c874:	48 85 c9             	test   rcx,rcx
  20c877:	0f 84 ae 05 00 00    	je     20ce2b <openSelfDebugInfo+0x132b>
                prev_node.next = node.next;
  20c87d:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c881:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c885:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c889:	e9 a8 05 00 00       	jmp    20ce36 <openSelfDebugInfo+0x1336>
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  20c88e:	48 8b 84 24 90 02 00 	mov    rax,QWORD PTR [rsp+0x290]
  20c895:	00 
  20c896:	48 85 c0             	test   rax,rax
  20c899:	0f 84 1b 03 00 00    	je     20cbba <openSelfDebugInfo+0x10ba>
  20c89f:	48 89 43 70          	mov    QWORD PTR [rbx+0x70],rax
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  20c8a3:	48 8d 15 3e 43 01 00 	lea    rdx,[rip+0x1433e]        # 220be8 <__unnamed_53>
  20c8aa:	48 8d bc 24 78 02 00 	lea    rdi,[rsp+0x278]
  20c8b1:	00 
  20c8b2:	4c 89 e6             	mov    rsi,r12
  20c8b5:	e8 36 34 00 00       	call   20fcf0 <Elf_findSection>
  20c8ba:	66 83 bc 24 78 02 00 	cmp    WORD PTR [rsp+0x278],0x0
  20c8c1:	00 00 
  20c8c3:	0f 84 6c 03 00 00    	je     20cc35 <openSelfDebugInfo+0x1135>
        const bytes = @sliceToBytes(memory);
  20c8c9:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20c8cd:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20c8d1:	74 26                	je     20c8f9 <openSelfDebugInfo+0xdf9>
  20c8d3:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20c8d7:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20c8db:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20c8df:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20c8e6:	00 
  20c8e7:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20c8ee:	00 
  20c8ef:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20c8f6:	00 
  20c8f7:	ff d2                	call   rdx
  20c8f9:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20c8fd:	0f 85 d8 14 00 00    	jne    20dddb <openSelfDebugInfo+0x22db>
  20c903:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20c907:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20c90a:	b8 03 00 00 00       	mov    eax,0x3
  20c90f:	0f 05                	syscall 
  20c911:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c915:	74 f3                	je     20c90a <openSelfDebugInfo+0xe0a>
            const first = list.first orelse return null;
  20c917:	48 8b 05 32 47 01 00 	mov    rax,QWORD PTR [rip+0x14732]        # 221050 <emfile_promise_queue>
  20c91e:	48 85 c0             	test   rax,rax
  20c921:	0f 84 b4 14 00 00    	je     20dddb <openSelfDebugInfo+0x22db>
            if (node.prev) |prev_node| {
  20c927:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c92a:	48 85 c9             	test   rcx,rcx
  20c92d:	0f 84 44 14 00 00    	je     20dd77 <openSelfDebugInfo+0x2277>
                prev_node.next = node.next;
  20c933:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c937:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c93b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c93f:	e9 3e 14 00 00       	jmp    20dd82 <openSelfDebugInfo+0x2282>
                list.first = node.next;
  20c944:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c948:	48 89 0d 01 47 01 00 	mov    QWORD PTR [rip+0x14701],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20c94f:	48 85 c9             	test   rcx,rcx
  20c952:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20c955:	48 8d 35 fc 46 01 00 	lea    rsi,[rip+0x146fc]        # 221058 <emfile_promise_queue+0x8>
  20c95c:	48 0f 45 f1          	cmovne rsi,rcx
  20c960:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20c963:	48 83 05 f5 46 01 00 	add    QWORD PTR [rip+0x146f5],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20c96a:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20c96b:	74 1e                	je     20c98b <openSelfDebugInfo+0xe8b>
  20c96d:	48 83 3d db 46 01 00 	cmp    QWORD PTR [rip+0x146db],0x0        # 221050 <emfile_promise_queue>
  20c974:	00 
  20c975:	0f 84 57 28 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20c97b:	48 8b 0d d6 46 01 00 	mov    rcx,QWORD PTR [rip+0x146d6]        # 221058 <emfile_promise_queue+0x8>
  20c982:	48 85 c9             	test   rcx,rcx
  20c985:	0f 84 47 28 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20c98b:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20c98f:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20c993:	48 89 c1             	mov    rcx,rax
  20c996:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20c99a:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20c9a0:	75 f1                	jne    20c993 <openSelfDebugInfo+0xe93>
  20c9a2:	a8 01                	test   al,0x1
  20c9a4:	75 02                	jne    20c9a8 <openSelfDebugInfo+0xea8>
  20c9a6:	ff 17                	call   QWORD PTR [rdi]
  20c9a8:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20c9ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  20c9b0:	b8 03 00 00 00       	mov    eax,0x3
  20c9b5:	0f 05                	syscall 
            switch (err) {
  20c9b7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20c9bb:	74 f3                	je     20c9b0 <openSelfDebugInfo+0xeb0>
            const first = list.first orelse return null;
  20c9bd:	48 8b 05 8c 46 01 00 	mov    rax,QWORD PTR [rip+0x1468c]        # 221050 <emfile_promise_queue>
  20c9c4:	48 85 c0             	test   rax,rax
  20c9c7:	74 7a                	je     20ca43 <openSelfDebugInfo+0xf43>
            if (node.prev) |prev_node| {
  20c9c9:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20c9cc:	48 85 c9             	test   rcx,rcx
  20c9cf:	74 0e                	je     20c9df <openSelfDebugInfo+0xedf>
                prev_node.next = node.next;
  20c9d1:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20c9d5:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20c9d9:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c9dd:	eb 0b                	jmp    20c9ea <openSelfDebugInfo+0xeea>
                list.first = node.next;
  20c9df:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20c9e3:	48 89 0d 66 46 01 00 	mov    QWORD PTR [rip+0x14666],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20c9ea:	48 85 c9             	test   rcx,rcx
  20c9ed:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20c9f0:	48 8d 35 61 46 01 00 	lea    rsi,[rip+0x14661]        # 221058 <emfile_promise_queue+0x8>
  20c9f7:	48 0f 45 f1          	cmovne rsi,rcx
  20c9fb:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20c9fe:	48 83 05 5a 46 01 00 	add    QWORD PTR [rip+0x1465a],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20ca05:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20ca06:	74 1e                	je     20ca26 <openSelfDebugInfo+0xf26>
  20ca08:	48 83 3d 40 46 01 00 	cmp    QWORD PTR [rip+0x14640],0x0        # 221050 <emfile_promise_queue>
  20ca0f:	00 
  20ca10:	0f 84 bc 27 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20ca16:	48 8b 0d 3b 46 01 00 	mov    rcx,QWORD PTR [rip+0x1463b]        # 221058 <emfile_promise_queue+0x8>
  20ca1d:	48 85 c9             	test   rcx,rcx
  20ca20:	0f 84 ac 27 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20ca26:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20ca2a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20ca2e:	48 89 c1             	mov    rcx,rax
  20ca31:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20ca35:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20ca3b:	75 f1                	jne    20ca2e <openSelfDebugInfo+0xf2e>
  20ca3d:	a8 01                	test   al,0x1
  20ca3f:	75 02                	jne    20ca43 <openSelfDebugInfo+0xf43>
  20ca41:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20ca43:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20ca47:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20ca4e:	00 
  20ca4f:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20ca56:	00 c8 00 00 00 
  20ca5b:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20ca62:	00 
  20ca63:	4c 89 ff             	mov    rdi,r15
  20ca66:	ff d0                	call   rax
            st.debug_abbrev = (try st.elf.findSection(".debug_abbrev")) orelse return error.MissingDebugInfo;
  20ca68:	0f b7 84 24 98 02 00 	movzx  eax,WORD PTR [rsp+0x298]
  20ca6f:	00 
  20ca70:	66 41 89 06          	mov    WORD PTR [r14],ax
  20ca74:	48 8b 84 24 e2 03 00 	mov    rax,QWORD PTR [rsp+0x3e2]
  20ca7b:	00 
  20ca7c:	48 8b 8c 24 e8 03 00 	mov    rcx,QWORD PTR [rsp+0x3e8]
  20ca83:	00 
  20ca84:	e9 6d fd ff ff       	jmp    20c7f6 <openSelfDebugInfo+0xcf6>
                list.first = node.next;
  20ca89:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20ca8d:	48 89 0d bc 45 01 00 	mov    QWORD PTR [rip+0x145bc],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20ca94:	48 85 c9             	test   rcx,rcx
  20ca97:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20ca9a:	48 8d 35 b7 45 01 00 	lea    rsi,[rip+0x145b7]        # 221058 <emfile_promise_queue+0x8>
  20caa1:	48 0f 45 f1          	cmovne rsi,rcx
  20caa5:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20caa8:	48 83 05 b0 45 01 00 	add    QWORD PTR [rip+0x145b0],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20caaf:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20cab0:	74 1e                	je     20cad0 <openSelfDebugInfo+0xfd0>
  20cab2:	48 83 3d 96 45 01 00 	cmp    QWORD PTR [rip+0x14596],0x0        # 221050 <emfile_promise_queue>
  20cab9:	00 
  20caba:	0f 84 12 27 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20cac0:	48 8b 0d 91 45 01 00 	mov    rcx,QWORD PTR [rip+0x14591]        # 221058 <emfile_promise_queue+0x8>
  20cac7:	48 85 c9             	test   rcx,rcx
  20caca:	0f 84 02 27 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20cad0:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20cad4:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20cad8:	48 89 c1             	mov    rcx,rax
  20cadb:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20cadf:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20cae5:	75 f1                	jne    20cad8 <openSelfDebugInfo+0xfd8>
  20cae7:	a8 01                	test   al,0x1
  20cae9:	75 02                	jne    20caed <openSelfDebugInfo+0xfed>
  20caeb:	ff 17                	call   QWORD PTR [rdi]
  20caed:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20caf0:	b8 03 00 00 00       	mov    eax,0x3
  20caf5:	0f 05                	syscall 
            switch (err) {
  20caf7:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20cafb:	74 f3                	je     20caf0 <openSelfDebugInfo+0xff0>
            const first = list.first orelse return null;
  20cafd:	48 8b 05 4c 45 01 00 	mov    rax,QWORD PTR [rip+0x1454c]        # 221050 <emfile_promise_queue>
  20cb04:	48 85 c0             	test   rax,rax
  20cb07:	74 7a                	je     20cb83 <openSelfDebugInfo+0x1083>
            if (node.prev) |prev_node| {
  20cb09:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20cb0c:	48 85 c9             	test   rcx,rcx
  20cb0f:	74 0e                	je     20cb1f <openSelfDebugInfo+0x101f>
                prev_node.next = node.next;
  20cb11:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20cb15:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20cb19:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cb1d:	eb 0b                	jmp    20cb2a <openSelfDebugInfo+0x102a>
                list.first = node.next;
  20cb1f:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cb23:	48 89 0d 26 45 01 00 	mov    QWORD PTR [rip+0x14526],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20cb2a:	48 85 c9             	test   rcx,rcx
  20cb2d:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20cb30:	48 8d 35 21 45 01 00 	lea    rsi,[rip+0x14521]        # 221058 <emfile_promise_queue+0x8>
  20cb37:	48 0f 45 f1          	cmovne rsi,rcx
  20cb3b:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20cb3e:	48 83 05 1a 45 01 00 	add    QWORD PTR [rip+0x1451a],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20cb45:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20cb46:	74 1e                	je     20cb66 <openSelfDebugInfo+0x1066>
  20cb48:	48 83 3d 00 45 01 00 	cmp    QWORD PTR [rip+0x14500],0x0        # 221050 <emfile_promise_queue>
  20cb4f:	00 
  20cb50:	0f 84 7c 26 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20cb56:	48 8b 0d fb 44 01 00 	mov    rcx,QWORD PTR [rip+0x144fb]        # 221058 <emfile_promise_queue+0x8>
  20cb5d:	48 85 c9             	test   rcx,rcx
  20cb60:	0f 84 6c 26 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20cb66:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20cb6a:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20cb6e:	48 89 c1             	mov    rcx,rax
  20cb71:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20cb75:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20cb7b:	75 f1                	jne    20cb6e <openSelfDebugInfo+0x106e>
  20cb7d:	a8 01                	test   al,0x1
  20cb7f:	75 02                	jne    20cb83 <openSelfDebugInfo+0x1083>
  20cb81:	ff 17                	call   QWORD PTR [rdi]
  20cb83:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20cb87:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20cb8e:	00 
  20cb8f:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20cb96:	00 c8 00 00 00 
  20cb9b:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20cba2:	00 
  20cba3:	4c 89 ff             	mov    rdi,r15
  20cba6:	ff d0                	call   rax
  20cba8:	c5 fa 6f 05 d0 3c ff 	vmovdqu xmm0,XMMWORD PTR [rip+0xffffffffffff3cd0]        # 200880 <__unnamed_54>
  20cbaf:	ff 
  20cbb0:	c4 c1 7a 7f 06       	vmovdqu XMMWORD PTR [r14],xmm0
  20cbb5:	e9 44 fc ff ff       	jmp    20c7fe <openSelfDebugInfo+0xcfe>
        const bytes = @sliceToBytes(memory);
  20cbba:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20cbbe:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20cbc2:	74 26                	je     20cbea <openSelfDebugInfo+0x10ea>
  20cbc4:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20cbc8:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20cbcc:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20cbd0:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20cbd7:	00 
  20cbd8:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20cbdf:	00 
  20cbe0:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20cbe7:	00 
  20cbe8:	ff d2                	call   rdx
  20cbea:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20cbee:	0f 85 27 13 00 00    	jne    20df1b <openSelfDebugInfo+0x241b>
  20cbf4:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20cbf8:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20cbfb:	b8 03 00 00 00       	mov    eax,0x3
  20cc00:	0f 05                	syscall 
            switch (err) {
  20cc02:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20cc06:	74 f3                	je     20cbfb <openSelfDebugInfo+0x10fb>
            const first = list.first orelse return null;
  20cc08:	48 8b 05 41 44 01 00 	mov    rax,QWORD PTR [rip+0x14441]        # 221050 <emfile_promise_queue>
  20cc0f:	48 85 c0             	test   rax,rax
  20cc12:	0f 84 03 13 00 00    	je     20df1b <openSelfDebugInfo+0x241b>
            if (node.prev) |prev_node| {
  20cc18:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20cc1b:	48 85 c9             	test   rcx,rcx
  20cc1e:	0f 84 93 12 00 00    	je     20deb7 <openSelfDebugInfo+0x23b7>
                prev_node.next = node.next;
  20cc24:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20cc28:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20cc2c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cc30:	e9 8d 12 00 00       	jmp    20dec2 <openSelfDebugInfo+0x23c2>
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  20cc35:	48 8b 84 24 80 02 00 	mov    rax,QWORD PTR [rsp+0x280]
  20cc3c:	00 
  20cc3d:	48 85 c0             	test   rax,rax
  20cc40:	0f 84 e2 02 00 00    	je     20cf28 <openSelfDebugInfo+0x1428>
  20cc46:	48 89 43 78          	mov    QWORD PTR [rbx+0x78],rax
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  20cc4a:	48 8d 15 a7 3f 01 00 	lea    rdx,[rip+0x13fa7]        # 220bf8 <__unnamed_55>
  20cc51:	48 8d bc 24 68 02 00 	lea    rdi,[rsp+0x268]
  20cc58:	00 
  20cc59:	4c 89 e6             	mov    rsi,r12
  20cc5c:	e8 8f 30 00 00       	call   20fcf0 <Elf_findSection>
  20cc61:	66 83 bc 24 68 02 00 	cmp    WORD PTR [rsp+0x268],0x0
  20cc68:	00 00 
  20cc6a:	0f 84 33 03 00 00    	je     20cfa3 <openSelfDebugInfo+0x14a3>
        const bytes = @sliceToBytes(memory);
  20cc70:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20cc74:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20cc78:	74 26                	je     20cca0 <openSelfDebugInfo+0x11a0>
  20cc7a:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20cc7e:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20cc82:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20cc86:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20cc8d:	00 
  20cc8e:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20cc95:	00 
  20cc96:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20cc9d:	00 
  20cc9e:	ff d2                	call   rdx
  20cca0:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20cca4:	0f 85 a2 13 00 00    	jne    20e04c <openSelfDebugInfo+0x254c>
  20ccaa:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20ccae:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20ccb1:	b8 03 00 00 00       	mov    eax,0x3
  20ccb6:	0f 05                	syscall 
  20ccb8:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20ccbc:	74 f3                	je     20ccb1 <openSelfDebugInfo+0x11b1>
            const first = list.first orelse return null;
  20ccbe:	48 8b 05 8b 43 01 00 	mov    rax,QWORD PTR [rip+0x1438b]        # 221050 <emfile_promise_queue>
  20ccc5:	48 85 c0             	test   rax,rax
  20ccc8:	0f 84 7e 13 00 00    	je     20e04c <openSelfDebugInfo+0x254c>
            if (node.prev) |prev_node| {
  20ccce:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20ccd1:	48 85 c9             	test   rcx,rcx
  20ccd4:	0f 84 0e 13 00 00    	je     20dfe8 <openSelfDebugInfo+0x24e8>
                prev_node.next = node.next;
  20ccda:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20ccde:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20cce2:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cce6:	e9 08 13 00 00       	jmp    20dff3 <openSelfDebugInfo+0x24f3>
                list.first = node.next;
  20cceb:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20ccef:	48 89 0d 5a 43 01 00 	mov    QWORD PTR [rip+0x1435a],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20ccf6:	48 85 c9             	test   rcx,rcx
  20ccf9:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20ccfc:	48 8d 35 55 43 01 00 	lea    rsi,[rip+0x14355]        # 221058 <emfile_promise_queue+0x8>
  20cd03:	48 0f 45 f1          	cmovne rsi,rcx
  20cd07:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20cd0a:	48 83 05 4e 43 01 00 	add    QWORD PTR [rip+0x1434e],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20cd11:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20cd12:	74 1e                	je     20cd32 <openSelfDebugInfo+0x1232>
  20cd14:	48 83 3d 34 43 01 00 	cmp    QWORD PTR [rip+0x14334],0x0        # 221050 <emfile_promise_queue>
  20cd1b:	00 
  20cd1c:	0f 84 b0 24 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20cd22:	48 8b 0d 2f 43 01 00 	mov    rcx,QWORD PTR [rip+0x1432f]        # 221058 <emfile_promise_queue+0x8>
  20cd29:	48 85 c9             	test   rcx,rcx
  20cd2c:	0f 84 a0 24 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20cd32:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20cd36:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20cd3a:	48 89 c1             	mov    rcx,rax
  20cd3d:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20cd41:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20cd47:	75 f1                	jne    20cd3a <openSelfDebugInfo+0x123a>
  20cd49:	a8 01                	test   al,0x1
  20cd4b:	75 02                	jne    20cd4f <openSelfDebugInfo+0x124f>
  20cd4d:	ff 17                	call   QWORD PTR [rdi]
  20cd4f:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20cd52:	b8 03 00 00 00       	mov    eax,0x3
  20cd57:	0f 05                	syscall 
            switch (err) {
  20cd59:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20cd5d:	74 f3                	je     20cd52 <openSelfDebugInfo+0x1252>
            const first = list.first orelse return null;
  20cd5f:	48 8b 05 ea 42 01 00 	mov    rax,QWORD PTR [rip+0x142ea]        # 221050 <emfile_promise_queue>
  20cd66:	48 85 c0             	test   rax,rax
  20cd69:	74 7a                	je     20cde5 <openSelfDebugInfo+0x12e5>
            if (node.prev) |prev_node| {
  20cd6b:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20cd6e:	48 85 c9             	test   rcx,rcx
  20cd71:	74 0e                	je     20cd81 <openSelfDebugInfo+0x1281>
                prev_node.next = node.next;
  20cd73:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20cd77:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20cd7b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cd7f:	eb 0b                	jmp    20cd8c <openSelfDebugInfo+0x128c>
                list.first = node.next;
  20cd81:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cd85:	48 89 0d c4 42 01 00 	mov    QWORD PTR [rip+0x142c4],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20cd8c:	48 85 c9             	test   rcx,rcx
  20cd8f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20cd92:	48 8d 35 bf 42 01 00 	lea    rsi,[rip+0x142bf]        # 221058 <emfile_promise_queue+0x8>
  20cd99:	48 0f 45 f1          	cmovne rsi,rcx
  20cd9d:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20cda0:	48 83 05 b8 42 01 00 	add    QWORD PTR [rip+0x142b8],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20cda7:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20cda8:	74 1e                	je     20cdc8 <openSelfDebugInfo+0x12c8>
  20cdaa:	48 83 3d 9e 42 01 00 	cmp    QWORD PTR [rip+0x1429e],0x0        # 221050 <emfile_promise_queue>
  20cdb1:	00 
  20cdb2:	0f 84 1a 24 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20cdb8:	48 8b 0d 99 42 01 00 	mov    rcx,QWORD PTR [rip+0x14299]        # 221058 <emfile_promise_queue+0x8>
  20cdbf:	48 85 c9             	test   rcx,rcx
  20cdc2:	0f 84 0a 24 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20cdc8:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20cdcc:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20cdd0:	48 89 c1             	mov    rcx,rax
  20cdd3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20cdd7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20cddd:	75 f1                	jne    20cdd0 <openSelfDebugInfo+0x12d0>
  20cddf:	a8 01                	test   al,0x1
  20cde1:	75 02                	jne    20cde5 <openSelfDebugInfo+0x12e5>
  20cde3:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20cde5:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20cde9:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20cdf0:	00 
  20cdf1:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20cdf8:	00 c8 00 00 00 
  20cdfd:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20ce04:	00 
  20ce05:	4c 89 ff             	mov    rdi,r15
  20ce08:	ff d0                	call   rax
            st.debug_str = (try st.elf.findSection(".debug_str")) orelse return error.MissingDebugInfo;
  20ce0a:	0f b7 84 24 88 02 00 	movzx  eax,WORD PTR [rsp+0x288]
  20ce11:	00 
  20ce12:	66 41 89 06          	mov    WORD PTR [r14],ax
  20ce16:	48 8b 84 24 d4 03 00 	mov    rax,QWORD PTR [rsp+0x3d4]
  20ce1d:	00 
  20ce1e:	48 8b 8c 24 da 03 00 	mov    rcx,QWORD PTR [rsp+0x3da]
  20ce25:	00 
  20ce26:	e9 cb f9 ff ff       	jmp    20c7f6 <openSelfDebugInfo+0xcf6>
                list.first = node.next;
  20ce2b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20ce2f:	48 89 0d 1a 42 01 00 	mov    QWORD PTR [rip+0x1421a],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20ce36:	48 85 c9             	test   rcx,rcx
  20ce39:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20ce3c:	48 8d 35 15 42 01 00 	lea    rsi,[rip+0x14215]        # 221058 <emfile_promise_queue+0x8>
  20ce43:	48 0f 45 f1          	cmovne rsi,rcx
  20ce47:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20ce4a:	48 83 05 0e 42 01 00 	add    QWORD PTR [rip+0x1420e],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20ce51:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20ce52:	74 1e                	je     20ce72 <openSelfDebugInfo+0x1372>
  20ce54:	48 83 3d f4 41 01 00 	cmp    QWORD PTR [rip+0x141f4],0x0        # 221050 <emfile_promise_queue>
  20ce5b:	00 
  20ce5c:	0f 84 70 23 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20ce62:	48 8b 0d ef 41 01 00 	mov    rcx,QWORD PTR [rip+0x141ef]        # 221058 <emfile_promise_queue+0x8>
  20ce69:	48 85 c9             	test   rcx,rcx
  20ce6c:	0f 84 60 23 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20ce72:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20ce76:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20ce7a:	48 89 c1             	mov    rcx,rax
  20ce7d:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20ce81:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20ce87:	75 f1                	jne    20ce7a <openSelfDebugInfo+0x137a>
  20ce89:	a8 01                	test   al,0x1
  20ce8b:	75 02                	jne    20ce8f <openSelfDebugInfo+0x138f>
  20ce8d:	ff 17                	call   QWORD PTR [rdi]
  20ce8f:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20ce92:	b8 03 00 00 00       	mov    eax,0x3
  20ce97:	0f 05                	syscall 
            switch (err) {
  20ce99:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20ce9d:	74 f3                	je     20ce92 <openSelfDebugInfo+0x1392>
            const first = list.first orelse return null;
  20ce9f:	48 8b 05 aa 41 01 00 	mov    rax,QWORD PTR [rip+0x141aa]        # 221050 <emfile_promise_queue>
  20cea6:	48 85 c0             	test   rax,rax
  20cea9:	0f 84 d4 fc ff ff    	je     20cb83 <openSelfDebugInfo+0x1083>
            if (node.prev) |prev_node| {
  20ceaf:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20ceb2:	48 85 c9             	test   rcx,rcx
  20ceb5:	74 0e                	je     20cec5 <openSelfDebugInfo+0x13c5>
                prev_node.next = node.next;
  20ceb7:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20cebb:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20cebf:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cec3:	eb 0b                	jmp    20ced0 <openSelfDebugInfo+0x13d0>
                list.first = node.next;
  20cec5:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cec9:	48 89 0d 80 41 01 00 	mov    QWORD PTR [rip+0x14180],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20ced0:	48 85 c9             	test   rcx,rcx
  20ced3:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20ced6:	48 8d 35 7b 41 01 00 	lea    rsi,[rip+0x1417b]        # 221058 <emfile_promise_queue+0x8>
  20cedd:	48 0f 45 f1          	cmovne rsi,rcx
  20cee1:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20cee4:	48 83 05 74 41 01 00 	add    QWORD PTR [rip+0x14174],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20ceeb:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20ceec:	74 1e                	je     20cf0c <openSelfDebugInfo+0x140c>
  20ceee:	48 83 3d 5a 41 01 00 	cmp    QWORD PTR [rip+0x1415a],0x0        # 221050 <emfile_promise_queue>
  20cef5:	00 
  20cef6:	0f 84 d6 22 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20cefc:	48 8b 0d 55 41 01 00 	mov    rcx,QWORD PTR [rip+0x14155]        # 221058 <emfile_promise_queue+0x8>
  20cf03:	48 85 c9             	test   rcx,rcx
  20cf06:	0f 84 c6 22 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20cf0c:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20cf10:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20cf14:	48 89 c1             	mov    rcx,rax
  20cf17:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20cf1b:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20cf21:	75 f1                	jne    20cf14 <openSelfDebugInfo+0x1414>
  20cf23:	e9 55 fc ff ff       	jmp    20cb7d <openSelfDebugInfo+0x107d>
        const bytes = @sliceToBytes(memory);
  20cf28:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20cf2c:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20cf30:	74 26                	je     20cf58 <openSelfDebugInfo+0x1458>
  20cf32:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20cf36:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20cf3a:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20cf3e:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20cf45:	00 
  20cf46:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20cf4d:	00 
  20cf4e:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20cf55:	00 
  20cf56:	ff d2                	call   rdx
  20cf58:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20cf5c:	0f 85 2a 12 00 00    	jne    20e18c <openSelfDebugInfo+0x268c>
  20cf62:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20cf66:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20cf69:	b8 03 00 00 00       	mov    eax,0x3
  20cf6e:	0f 05                	syscall 
            switch (err) {
  20cf70:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20cf74:	74 f3                	je     20cf69 <openSelfDebugInfo+0x1469>
            const first = list.first orelse return null;
  20cf76:	48 8b 05 d3 40 01 00 	mov    rax,QWORD PTR [rip+0x140d3]        # 221050 <emfile_promise_queue>
  20cf7d:	48 85 c0             	test   rax,rax
  20cf80:	0f 84 06 12 00 00    	je     20e18c <openSelfDebugInfo+0x268c>
            if (node.prev) |prev_node| {
  20cf86:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20cf89:	48 85 c9             	test   rcx,rcx
  20cf8c:	0f 84 96 11 00 00    	je     20e128 <openSelfDebugInfo+0x2628>
                prev_node.next = node.next;
  20cf92:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20cf96:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20cf9a:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20cf9e:	e9 90 11 00 00       	jmp    20e133 <openSelfDebugInfo+0x2633>
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  20cfa3:	48 8b 84 24 70 02 00 	mov    rax,QWORD PTR [rsp+0x270]
  20cfaa:	00 
  20cfab:	48 89 83 80 00 00 00 	mov    QWORD PTR [rbx+0x80],rax
    const debug_info_end = st.debug_info.offset + st.debug_info.size;
  20cfb2:	48 8b 43 60          	mov    rax,QWORD PTR [rbx+0x60]
  20cfb6:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  20cfba:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  20cfbf:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(&st.self_exe_file);
  20cfc3:	48 89 9c 24 40 01 00 	mov    QWORD PTR [rsp+0x140],rbx
  20cfca:	00 
  20cfcb:	48 8d 05 5e 36 00 00 	lea    rax,[rip+0x365e]        # 210630 <FileInStream_readFn>
  20cfd2:	48 89 84 24 48 01 00 	mov    QWORD PTR [rsp+0x148],rax
  20cfd9:	00 
  20cfda:	48 89 4c 24 50       	mov    QWORD PTR [rsp+0x50],rcx
    while (this_unit_offset < debug_info_end) {
  20cfdf:	48 85 c9             	test   rcx,rcx
  20cfe2:	0f 84 cc 0f 00 00    	je     20dfb4 <openSelfDebugInfo+0x24b4>
  20cfe8:	48 8d 83 88 00 00 00 	lea    rax,[rbx+0x88]
  20cfef:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  20cff4:	48 8d 83 a8 00 00 00 	lea    rax,[rbx+0xa8]
  20cffb:	48 89 84 24 78 01 00 	mov    QWORD PTR [rsp+0x178],rax
  20d002:	00 
  20d003:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  20d008:	48 01 44 24 50       	add    QWORD PTR [rsp+0x50],rax
  20d00d:	66 c7 84 24 9e 00 00 	mov    WORD PTR [rsp+0x9e],0x1e
  20d014:	00 1e 00 
  20d017:	c4 e2 7d 19 05 08 3c 	vbroadcastsd ymm0,QWORD PTR [rip+0xffffffffffff3c08]        # 200c28 <__unnamed_441+0x88>
  20d01e:	ff ff 
  20d020:	c5 fc 11 84 24 80 04 	vmovups YMMWORD PTR [rsp+0x480],ymm0
  20d027:	00 00 
  20d029:	c4 e2 7d 59 05 4e 3c 	vpbroadcastq ymm0,QWORD PTR [rip+0xffffffffffff3c4e]        # 200c80 <app_mask+0x48>
  20d030:	ff ff 
  20d032:	c5 fe 7f 84 24 60 04 	vmovdqu YMMWORD PTR [rsp+0x460],ymm0
  20d039:	00 00 
  20d03b:	66 c7 44 24 04 02 00 	mov    WORD PTR [rsp+0x4],0x2
  20d042:	31 c0                	xor    eax,eax
  20d044:	48 89 84 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rax
  20d04b:	00 
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  20d04c:	48 83 7c 24 38 00    	cmp    QWORD PTR [rsp+0x38],0x0
  20d052:	0f 88 08 14 00 00    	js     20e460 <openSelfDebugInfo+0x2960>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20d058:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
    return asm volatile ("syscall"
  20d05b:	b8 08 00 00 00       	mov    eax,0x8
  20d060:	31 d2                	xor    edx,edx
  20d062:	48 8b 74 24 38       	mov    rsi,QWORD PTR [rsp+0x38]
  20d067:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20d069:	48 89 c1             	mov    rcx,rax
  20d06c:	48 f7 d9             	neg    rcx
  20d06f:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20d075:	b8 00 00 00 00       	mov    eax,0x0
  20d07a:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  20d07e:	48 85 c9             	test   rcx,rcx
  20d081:	0f 85 01 14 00 00    	jne    20e488 <openSelfDebugInfo+0x2988>
            try self.readNoEof(bytes[0..]);
  20d087:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20d08c:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d091:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20d098:	00 00 
            return self.readFn(self, buffer);
  20d09a:	4c 89 ef             	mov    rdi,r13
  20d09d:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  20d0a4:	00 
  20d0a5:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20d0aa:	c5 f8 77             	vzeroupper 
  20d0ad:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  20d0b4:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d0bb:	00 
  20d0bc:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20d0be:	66 85 c9             	test   cx,cx
  20d0c1:	0f 85 51 13 00 00    	jne    20e418 <openSelfDebugInfo+0x2918>
  20d0c7:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20d0ce:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20d0cf:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20d0d4:	0f 82 3a 13 00 00    	jb     20e414 <openSelfDebugInfo+0x2914>
  20d0da:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20d0df:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20d0e4:	48 c1 e1 08          	shl    rcx,0x8
  20d0e8:	48 09 c1             	or     rcx,rax
  20d0eb:	0f b6 44 24 0a       	movzx  eax,BYTE PTR [rsp+0xa]
  20d0f0:	48 c1 e0 10          	shl    rax,0x10
  20d0f4:	48 09 c8             	or     rax,rcx
  20d0f7:	0f b6 4c 24 0b       	movzx  ecx,BYTE PTR [rsp+0xb]
  20d0fc:	48 c1 e1 18          	shl    rcx,0x18
  20d100:	48 09 c1             	or     rcx,rax
  20d103:	48 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],rcx
    is_64.* = (first_32_bits == 0xffffffff);
  20d108:	83 f9 ff             	cmp    ecx,0xffffffff
    if (is_64.*) {
  20d10b:	74 20                	je     20d12d <openSelfDebugInfo+0x162d>
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  20d10d:	83 7c 24 48 ef       	cmp    DWORD PTR [rsp+0x48],0xffffffef
  20d112:	0f 87 5c 13 00 00    	ja     20e474 <openSelfDebugInfo+0x2974>
  20d118:	c7 44 24 40 00 00 00 	mov    DWORD PTR [rsp+0x40],0x0
  20d11f:	00 
        if (unit_length == 0) return;
  20d120:	48 83 7c 24 48 00    	cmp    QWORD PTR [rsp+0x48],0x0
  20d126:	75 77                	jne    20d19f <openSelfDebugInfo+0x169f>
  20d128:	e9 87 0e 00 00       	jmp    20dfb4 <openSelfDebugInfo+0x24b4>
            try self.readNoEof(bytes[0..]);
  20d12d:	48 8d 84 24 b8 02 00 	lea    rax,[rsp+0x2b8]
  20d134:	00 
  20d135:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d13a:	48 c7 44 24 68 08 00 	mov    QWORD PTR [rsp+0x68],0x8
  20d141:	00 00 
            return self.readFn(self, buffer);
  20d143:	4c 89 ef             	mov    rdi,r13
  20d146:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  20d14d:	00 
  20d14e:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20d153:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  20d15a:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d161:	00 
  20d162:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20d164:	66 85 c9             	test   cx,cx
  20d167:	0f 85 ab 12 00 00    	jne    20e418 <openSelfDebugInfo+0x2918>
  20d16d:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20d174:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20d175:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20d17a:	0f 82 94 12 00 00    	jb     20e414 <openSelfDebugInfo+0x2914>
  20d180:	48 8b 84 24 b8 02 00 	mov    rax,QWORD PTR [rsp+0x2b8]
  20d187:	00 
  20d188:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  20d18d:	b0 01                	mov    al,0x1
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  20d18f:	89 44 24 40          	mov    DWORD PTR [rsp+0x40],eax
        if (unit_length == 0) return;
  20d193:	48 83 7c 24 48 00    	cmp    QWORD PTR [rsp+0x48],0x0
  20d199:	0f 84 15 0e 00 00    	je     20dfb4 <openSelfDebugInfo+0x24b4>
        const version = try in_stream.readInt(st.elf.endian, u16);
  20d19f:	40 8a 6b 12          	mov    bpl,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  20d1a3:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20d1a8:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d1ad:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20d1b4:	00 00 
            return self.readFn(self, buffer);
  20d1b6:	4c 89 ef             	mov    rdi,r13
  20d1b9:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  20d1c0:	00 
  20d1c1:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20d1c6:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  20d1cd:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d1d4:	00 
  20d1d5:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20d1d7:	66 85 c9             	test   cx,cx
  20d1da:	0f 85 38 12 00 00    	jne    20e418 <openSelfDebugInfo+0x2918>
  20d1e0:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20d1e7:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20d1e8:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20d1ed:	0f 82 21 12 00 00    	jb     20e414 <openSelfDebugInfo+0x2914>
  20d1f3:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
  20d1f8:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  20d1fd:	89 c1                	mov    ecx,eax
  20d1ff:	c1 e1 08             	shl    ecx,0x8
  20d202:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20d204:	c1 e2 08             	shl    edx,0x8
  20d207:	09 c2                	or     edx,eax
    switch (endian) {
  20d209:	40 f6 c5 01          	test   bpl,0x1
  20d20d:	66 0f 45 d1          	cmovne dx,cx
  20d211:	48 89 94 24 60 02 00 	mov    QWORD PTR [rsp+0x260],rdx
  20d218:	00 
        if (version < 2 or version > 5) return error.InvalidDebugInfo;
  20d219:	8d 42 fe             	lea    eax,[rdx-0x2]
  20d21c:	0f b7 c0             	movzx  eax,ax
  20d21f:	83 f8 03             	cmp    eax,0x3
  20d222:	0f 87 4c 12 00 00    	ja     20e474 <openSelfDebugInfo+0x2974>
  20d228:	40 8a 6b 12          	mov    bpl,BYTE PTR [rbx+0x12]
        const debug_abbrev_offset = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  20d22c:	80 7c 24 40 00       	cmp    BYTE PTR [rsp+0x40],0x0
  20d231:	74 37                	je     20d26a <openSelfDebugInfo+0x176a>
  20d233:	40 0f b6 d5          	movzx  edx,bpl
  20d237:	48 8d bc 24 38 03 00 	lea    rdi,[rsp+0x338]
  20d23e:	00 
  20d23f:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  20d246:	00 
  20d247:	e8 a4 31 00 00       	call   2103f0 <InStream(ReadError)_readInt.33>
  20d24c:	0f b7 bc 24 38 03 00 	movzx  edi,WORD PTR [rsp+0x338]
  20d253:	00 
  20d254:	66 85 ff             	test   di,di
  20d257:	0f 85 f8 0f 00 00    	jne    20e255 <openSelfDebugInfo+0x2755>
  20d25d:	48 8b 84 24 40 03 00 	mov    rax,QWORD PTR [rsp+0x340]
  20d264:	00 
  20d265:	e9 96 00 00 00       	jmp    20d300 <openSelfDebugInfo+0x1800>
            try self.readNoEof(bytes[0..]);
  20d26a:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20d26f:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d274:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20d27b:	00 00 
            return self.readFn(self, buffer);
  20d27d:	4c 89 ef             	mov    rdi,r13
  20d280:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  20d287:	00 
  20d288:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20d28d:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  20d294:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d29b:	00 
  20d29c:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20d29e:	66 85 c9             	test   cx,cx
  20d2a1:	0f 85 71 11 00 00    	jne    20e418 <openSelfDebugInfo+0x2918>
  20d2a7:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20d2ae:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20d2af:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20d2b4:	0f 82 5a 11 00 00    	jb     20e414 <openSelfDebugInfo+0x2914>
  20d2ba:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20d2bf:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20d2c4:	40 f6 c5 01          	test   bpl,0x1
  20d2c8:	74 1b                	je     20d2e5 <openSelfDebugInfo+0x17e5>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20d2ca:	c1 e1 08             	shl    ecx,0x8
  20d2cd:	09 c1                	or     ecx,eax
  20d2cf:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20d2d4:	c1 e2 10             	shl    edx,0x10
  20d2d7:	09 ca                	or     edx,ecx
  20d2d9:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20d2de:	c1 e0 18             	shl    eax,0x18
  20d2e1:	09 d0                	or     eax,edx
  20d2e3:	eb 19                	jmp    20d2fe <openSelfDebugInfo+0x17fe>
                result = (result << 8) | b;
  20d2e5:	c1 e0 08             	shl    eax,0x8
  20d2e8:	09 c8                	or     eax,ecx
  20d2ea:	c1 e0 08             	shl    eax,0x8
  20d2ed:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20d2f2:	09 c1                	or     ecx,eax
  20d2f4:	c1 e1 08             	shl    ecx,0x8
  20d2f7:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20d2fc:	09 c8                	or     eax,ecx
  20d2fe:	89 c0                	mov    eax,eax
  20d300:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
            try self.readNoEof(result[0..]);
  20d305:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20d30a:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20d30f:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  20d316:	00 00 
            return self.readFn(self, buffer);
  20d318:	4c 89 ef             	mov    rdi,r13
  20d31b:	48 8d b4 24 48 01 00 	lea    rsi,[rsp+0x148]
  20d322:	00 
  20d323:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20d328:	ff 94 24 48 01 00 00 	call   QWORD PTR [rsp+0x148]
  20d32f:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d336:	00 
  20d337:	89 c8                	mov    eax,ecx
            const amt_read = try self.read(buf);
  20d339:	66 85 c9             	test   cx,cx
  20d33c:	0f 85 d6 10 00 00    	jne    20e418 <openSelfDebugInfo+0x2918>
  20d342:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20d349:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20d34a:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20d34f:	0f 82 bf 10 00 00    	jb     20e414 <openSelfDebugInfo+0x2914>
        if (address_size != @sizeOf(usize)) return error.InvalidDebugInfo;
  20d355:	80 7c 24 07 08       	cmp    BYTE PTR [rsp+0x7],0x8
  20d35a:	66 bf 25 00          	mov    di,0x25
  20d35e:	0f 85 f1 0e 00 00    	jne    20e255 <openSelfDebugInfo+0x2755>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20d364:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20d367:	b8 08 00 00 00       	mov    eax,0x8
  20d36c:	be 00 00 00 00       	mov    esi,0x0
  20d371:	ba 01 00 00 00       	mov    edx,0x1
  20d376:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20d378:	48 89 c2             	mov    rdx,rax
  20d37b:	48 f7 da             	neg    rdx
  20d37e:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20d383:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20d389:	b9 00 00 00 00       	mov    ecx,0x0
  20d38e:	48 0f 46 d1          	cmovbe rdx,rcx
    pub fn getPos(self: *File) !usize {
        switch (builtin.os) {
            Os.linux, Os.macosx, Os.ios => {
                const result = posix.lseek(self.handle, 0, posix.SEEK_CUR);
                const err = posix.getErrno(result);
                if (err > 0) {
  20d392:	48 85 d2             	test   rdx,rdx
  20d395:	0f 85 16 11 00 00    	jne    20e4b1 <openSelfDebugInfo+0x29b1>
            return self.items[0..self.len];
  20d39b:	48 8b 83 98 00 00 00 	mov    rax,QWORD PTR [rbx+0x98]
    for (st.abbrev_table_list.toSlice()) |*header| {
  20d3a2:	48 85 c0             	test   rax,rax
  20d3a5:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  20d3aa:	74 24                	je     20d3d0 <openSelfDebugInfo+0x18d0>
  20d3ac:	48 8b b3 88 00 00 00 	mov    rsi,QWORD PTR [rbx+0x88]
        if (header.offset == abbrev_offset) {
  20d3b3:	48 83 c6 08          	add    rsi,0x8
  20d3b7:	31 c9                	xor    ecx,ecx
  20d3b9:	48 39 56 f8          	cmp    QWORD PTR [rsi-0x8],rdx
  20d3bd:	0f 84 48 01 00 00    	je     20d50b <openSelfDebugInfo+0x1a0b>
    for (st.abbrev_table_list.toSlice()) |*header| {
  20d3c3:	48 83 c1 01          	add    rcx,0x1
  20d3c7:	48 83 c6 28          	add    rsi,0x28
  20d3cb:	48 39 c1             	cmp    rcx,rax
  20d3ce:	72 e9                	jb     20d3b9 <openSelfDebugInfo+0x18b9>
    try st.self_exe_file.seekTo(st.debug_abbrev.offset + abbrev_offset);
  20d3d0:	48 8b 43 68          	mov    rax,QWORD PTR [rbx+0x68]
  20d3d4:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  20d3d8:	48 01 d6             	add    rsi,rdx
  20d3db:	0f 88 7f 10 00 00    	js     20e460 <openSelfDebugInfo+0x2960>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20d3e1:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20d3e4:	b8 08 00 00 00       	mov    eax,0x8
  20d3e9:	31 d2                	xor    edx,edx
  20d3eb:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20d3ed:	48 89 c1             	mov    rcx,rax
  20d3f0:	48 f7 d9             	neg    rcx
  20d3f3:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20d3f9:	b8 00 00 00 00       	mov    eax,0x0
  20d3fe:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  20d402:	48 85 c9             	test   rcx,rcx
  20d405:	0f 85 2d 11 00 00    	jne    20e538 <openSelfDebugInfo+0x2a38>
        .table = try parseAbbrevTable(st),
  20d40b:	4c 89 ef             	mov    rdi,r13
  20d40e:	48 89 de             	mov    rsi,rbx
  20d411:	e8 4a 32 00 00       	call   210660 <parseAbbrevTable>
  20d416:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d41d:	00 
  20d41e:	89 c8                	mov    eax,ecx
  20d420:	66 85 c9             	test   cx,cx
  20d423:	0f 85 ef 0f 00 00    	jne    20e418 <openSelfDebugInfo+0x2918>
    try st.abbrev_table_list.append(AbbrevTableHeader{
  20d429:	48 8d 84 24 a8 00 00 	lea    rax,[rsp+0xa8]
  20d430:	00 
  20d431:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  20d435:	c5 fe 7f 44 24 60    	vmovdqu YMMWORD PTR [rsp+0x60],ymm0
            }
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
        }

        pub fn addOne(self: *Self) !*T {
            const new_length = self.len + 1;
  20d43b:	48 8b ab 98 00 00 00 	mov    rbp,QWORD PTR [rbx+0x98]
            var better_capacity = self.items.len;
  20d442:	48 8b 8b 90 00 00 00 	mov    rcx,QWORD PTR [rbx+0x90]
            if (better_capacity >= new_capacity) return;
  20d449:	48 39 e9             	cmp    rcx,rbp
  20d44c:	76 05                	jbe    20d453 <openSelfDebugInfo+0x1953>
            try self.ensureCapacity(new_length);
            const result = &self.items[self.len];
  20d44e:	48 89 e8             	mov    rax,rbp
  20d451:	eb 5d                	jmp    20d4b0 <openSelfDebugInfo+0x19b0>
                better_capacity += better_capacity / 2 + 8;
  20d453:	48 89 c8             	mov    rax,rcx
  20d456:	48 d1 e8             	shr    rax,1
  20d459:	48 01 c1             	add    rcx,rax
  20d45c:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20d460:	48 39 e9             	cmp    rcx,rbp
  20d463:	76 ee                	jbe    20d453 <openSelfDebugInfo+0x1953>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20d465:	48 8b b3 a0 00 00 00 	mov    rsi,QWORD PTR [rbx+0xa0]
  20d46c:	48 8d bc 24 b8 02 00 	lea    rdi,[rsp+0x2b8]
  20d473:	00 
  20d474:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
  20d479:	c5 f8 77             	vzeroupper 
  20d47c:	e8 0f 3e 00 00       	call   211290 <Allocator_alignedRealloc.44>
  20d481:	0f b7 8c 24 b8 02 00 	movzx  ecx,WORD PTR [rsp+0x2b8]
  20d488:	00 
  20d489:	89 c8                	mov    eax,ecx
  20d48b:	66 85 c9             	test   cx,cx
  20d48e:	0f 85 84 0f 00 00    	jne    20e418 <openSelfDebugInfo+0x2918>
  20d494:	48 8d 84 24 c0 02 00 	lea    rax,[rsp+0x2c0]
  20d49b:	00 
  20d49c:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20d4a0:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20d4a5:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  20d4a9:	48 8b 83 98 00 00 00 	mov    rax,QWORD PTR [rbx+0x98]
  20d4b0:	48 83 c5 01          	add    rbp,0x1
  20d4b4:	48 8b 8b 88 00 00 00 	mov    rcx,QWORD PTR [rbx+0x88]
            self.len = new_length;
  20d4bb:	48 89 ab 98 00 00 00 	mov    QWORD PTR [rbx+0x98],rbp
            new_item_ptr.* = item;
  20d4c2:	48 8d 04 80          	lea    rax,[rax+rax*4]
  20d4c6:	48 8b 54 24 30       	mov    rdx,QWORD PTR [rsp+0x30]
  20d4cb:	48 89 14 c1          	mov    QWORD PTR [rcx+rax*8],rdx
  20d4cf:	c5 fe 6f 44 24 60    	vmovdqu ymm0,YMMWORD PTR [rsp+0x60]
  20d4d5:	c5 fe 7f 44 c1 08    	vmovdqu YMMWORD PTR [rcx+rax*8+0x8],ymm0
    return &st.abbrev_table_list.items[st.abbrev_table_list.len - 1].table;
  20d4db:	48 8b 83 88 00 00 00 	mov    rax,QWORD PTR [rbx+0x88]
  20d4e2:	48 8b 8b 98 00 00 00 	mov    rcx,QWORD PTR [rbx+0x98]
  20d4e9:	48 8d 0c 89          	lea    rcx,[rcx+rcx*4]
  20d4ed:	48 8d 04 c8          	lea    rax,[rax+rcx*8]
  20d4f1:	48 83 c0 e0          	add    rax,0xffffffffffffffe0
  20d4f5:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20d4fa:	66 bf 23 00          	mov    di,0x23
  20d4fe:	48 83 7c 24 18 00    	cmp    QWORD PTR [rsp+0x18],0x0
  20d504:	79 1a                	jns    20d520 <openSelfDebugInfo+0x1a20>
  20d506:	e9 4a 0d 00 00       	jmp    20e255 <openSelfDebugInfo+0x2755>
  20d50b:	48 89 74 24 30       	mov    QWORD PTR [rsp+0x30],rsi
  20d510:	66 bf 23 00          	mov    di,0x23
  20d514:	48 83 7c 24 18 00    	cmp    QWORD PTR [rsp+0x18],0x0
  20d51a:	0f 88 35 0d 00 00    	js     20e255 <openSelfDebugInfo+0x2755>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20d520:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20d523:	b8 08 00 00 00       	mov    eax,0x8
  20d528:	31 d2                	xor    edx,edx
  20d52a:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
  20d52f:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20d531:	48 89 c1             	mov    rcx,rax
  20d534:	48 f7 d9             	neg    rcx
  20d537:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20d53d:	b8 00 00 00 00       	mov    eax,0x0
  20d542:	48 0f 46 c8          	cmovbe rcx,rax
  20d546:	48 85 c9             	test   rcx,rcx
  20d549:	0f 85 c4 0f 00 00    	jne    20e513 <openSelfDebugInfo+0x2a13>
  20d54f:	48 8b 83 a0 00 00 00 	mov    rax,QWORD PTR [rbx+0xa0]
    var in_file_stream = io.FileInStream.init(in_file);
  20d556:	48 89 84 24 58 02 00 	mov    QWORD PTR [rsp+0x258],rax
  20d55d:	00 
  20d55e:	48 89 9c 24 50 01 00 	mov    QWORD PTR [rsp+0x150],rbx
  20d565:	00 
  20d566:	48 8d 05 c3 30 00 00 	lea    rax,[rip+0x30c3]        # 210630 <FileInStream_readFn>
  20d56d:	48 89 84 24 58 01 00 	mov    QWORD PTR [rsp+0x158],rax
  20d574:	00 
            try self.readNoEof(result[0..]);
  20d575:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20d57a:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20d57f:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20d586:	00 00 
        return self.file.read(buffer);
  20d588:	48 8b b4 24 50 01 00 	mov    rsi,QWORD PTR [rsp+0x150]
  20d58f:	00 
  20d590:	48 8d bc 24 88 01 00 	lea    rdi,[rsp+0x188]
  20d597:	00 
  20d598:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20d59d:	c5 f8 77             	vzeroupper 
  20d5a0:	e8 7b 2f 00 00       	call   210520 <File_read>
  20d5a5:	c5 fa 6f 84 24 88 01 	vmovdqu xmm0,XMMWORD PTR [rsp+0x188]
  20d5ac:	00 00 
  20d5ae:	c5 f9 7f 44 24 20    	vmovdqa XMMWORD PTR [rsp+0x20],xmm0
            return self.readFn(self, buffer);
  20d5b4:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  20d5b9:	66 85 c9             	test   cx,cx
  20d5bc:	0f 85 67 0c 00 00    	jne    20e229 <openSelfDebugInfo+0x2729>
  20d5c2:	0f b6 44 24 40       	movzx  eax,BYTE PTR [rsp+0x40]
  20d5c7:	48 89 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rax
  20d5ce:	00 
  20d5cf:	48 8d 04 c5 04 00 00 	lea    rax,[rax*8+0x4]
  20d5d6:	00 
  20d5d7:	48 89 84 24 50 02 00 	mov    QWORD PTR [rsp+0x250],rax
  20d5de:	00 
  20d5df:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  20d5e4:	31 c9                	xor    ecx,ecx
  20d5e6:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  20d5eb:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  20d5ed:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  20d5f2:	0f 82 2d 0c 00 00    	jb     20e225 <openSelfDebugInfo+0x2725>
            return result[0];
  20d5f8:	0f b6 44 24 07       	movzx  eax,BYTE PTR [rsp+0x7]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  20d5fd:	89 c2                	mov    edx,eax
  20d5ff:	83 e2 7f             	and    edx,0x7f
  20d602:	89 ee                	mov    esi,ebp
  20d604:	83 e6 3f             	and    esi,0x3f
  20d607:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  20d60c:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  20d611:	48 39 d6             	cmp    rsi,rdx
  20d614:	0f 85 13 0c 00 00    	jne    20e22d <openSelfDebugInfo+0x272d>
        result |= operand;
  20d61a:	48 09 4c 24 18       	or     QWORD PTR [rsp+0x18],rcx
        if ((byte & 0b10000000) == 0) return result;
  20d61f:	84 c0                	test   al,al
  20d621:	79 44                	jns    20d667 <openSelfDebugInfo+0x1b67>
        shift += 7;
  20d623:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  20d627:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20d62c:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  20d631:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  20d638:	00 00 
            return self.readFn(self, buffer);
  20d63a:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  20d63f:	48 8d b4 24 58 01 00 	lea    rsi,[rsp+0x158]
  20d646:	00 
  20d647:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  20d64c:	ff 94 24 58 01 00 00 	call   QWORD PTR [rsp+0x158]
  20d653:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  20d658:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  20d65d:	66 85 c9             	test   cx,cx
  20d660:	74 8b                	je     20d5ed <openSelfDebugInfo+0x1aed>
  20d662:	e9 c2 0b 00 00       	jmp    20e229 <openSelfDebugInfo+0x2729>
            return self.items[0..self.len];
  20d667:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  20d66c:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
    for (abbrev_table.toSliceConst()) |*table_entry| {
  20d670:	48 85 c0             	test   rax,rax
  20d673:	0f 84 b1 0d 00 00    	je     20e42a <openSelfDebugInfo+0x292a>
  20d679:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20d67e:	48 8b 29             	mov    rbp,QWORD PTR [rcx]
  20d681:	31 c9                	xor    ecx,ecx
        if (table_entry.abbrev_code == abbrev_code) return table_entry;
  20d683:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  20d688:	48 39 55 08          	cmp    QWORD PTR [rbp+0x8],rdx
  20d68c:	74 12                	je     20d6a0 <openSelfDebugInfo+0x1ba0>
    for (abbrev_table.toSliceConst()) |*table_entry| {
  20d68e:	48 83 c1 01          	add    rcx,0x1
  20d692:	48 83 c5 38          	add    rbp,0x38
  20d696:	48 39 c1             	cmp    rcx,rax
  20d699:	72 e8                	jb     20d683 <openSelfDebugInfo+0x1b83>
  20d69b:	e9 8a 0d 00 00       	jmp    20e42a <openSelfDebugInfo+0x292a>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  20d6a0:	48 85 ed             	test   rbp,rbp
  20d6a3:	0f 84 81 0d 00 00    	je     20e42a <openSelfDebugInfo+0x292a>
        .tag_id = table_entry.tag_id,
  20d6a9:	48 8b 45 10          	mov    rax,QWORD PTR [rbp+0x10]
        .has_children = table_entry.has_children,
  20d6ad:	8a 4d 00             	mov    cl,BYTE PTR [rbp+0x0]
  20d6b0:	48 8b b3 a0 00 00 00 	mov    rsi,QWORD PTR [rbx+0xa0]
  20d6b7:	48 8d 94 24 f7 02 00 	lea    rdx,[rsp+0x2f7]
  20d6be:	00 
    var result = Die{
  20d6bf:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20d6c3:	c5 fa 7f 02          	vmovdqu XMMWORD PTR [rdx],xmm0
  20d6c7:	48 c7 42 10 00 00 00 	mov    QWORD PTR [rdx+0x10],0x0
  20d6ce:	00 
  20d6cf:	48 89 84 24 e0 01 00 	mov    QWORD PTR [rsp+0x1e0],rax
  20d6d6:	00 
  20d6d7:	88 8c 24 e8 01 00 00 	mov    BYTE PTR [rsp+0x1e8],cl
  20d6de:	c5 fa 6f 84 24 f0 02 	vmovdqu xmm0,XMMWORD PTR [rsp+0x2f0]
  20d6e5:	00 00 
  20d6e7:	c5 fa 6f 8c 24 ff 02 	vmovdqu xmm1,XMMWORD PTR [rsp+0x2ff]
  20d6ee:	00 00 
  20d6f0:	48 8d 84 24 e9 01 00 	lea    rax,[rsp+0x1e9]
  20d6f7:	00 
  20d6f8:	c5 fa 7f 48 0f       	vmovdqu XMMWORD PTR [rax+0xf],xmm1
  20d6fd:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
  20d701:	48 89 b4 24 08 02 00 	mov    QWORD PTR [rsp+0x208],rsi
  20d708:	00 
    try result.attrs.resize(table_entry.attrs.len);
  20d709:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
            var better_capacity = self.items.len;
  20d70d:	48 8b 8c 24 f8 01 00 	mov    rcx,QWORD PTR [rsp+0x1f8]
  20d714:	00 
  20d715:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
            if (better_capacity >= new_capacity) return;
  20d71a:	48 39 c1             	cmp    rcx,rax
  20d71d:	73 5a                	jae    20d779 <openSelfDebugInfo+0x1c79>
                better_capacity += better_capacity / 2 + 8;
  20d71f:	48 89 c8             	mov    rax,rcx
  20d722:	48 d1 e8             	shr    rax,1
  20d725:	48 01 c1             	add    rcx,rax
  20d728:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20d72c:	48 3b 4c 24 18       	cmp    rcx,QWORD PTR [rsp+0x18]
  20d731:	72 ec                	jb     20d71f <openSelfDebugInfo+0x1c1f>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20d733:	48 8d bc 24 88 01 00 	lea    rdi,[rsp+0x188]
  20d73a:	00 
  20d73b:	48 8d 94 24 f0 01 00 	lea    rdx,[rsp+0x1f0]
  20d742:	00 
  20d743:	e8 d8 68 00 00       	call   214020 <Allocator_alignedRealloc.47>
  20d748:	0f b7 8c 24 88 01 00 	movzx  ecx,WORD PTR [rsp+0x188]
  20d74f:	00 
  20d750:	89 c8                	mov    eax,ecx
  20d752:	66 85 c9             	test   cx,cx
  20d755:	0f 85 87 0e 00 00    	jne    20e5e2 <openSelfDebugInfo+0x2ae2>
  20d75b:	48 8d 84 24 90 01 00 	lea    rax,[rsp+0x190]
  20d762:	00 
  20d763:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20d767:	48 8d 84 24 f0 01 00 	lea    rax,[rsp+0x1f0]
  20d76e:	00 
  20d76f:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            return self.items[0..self.len];
  20d773:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  20d777:	eb 05                	jmp    20d77e <openSelfDebugInfo+0x1c7e>
  20d779:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20d77e:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  20d785:	00 
            self.len = new_len;
  20d786:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20d78b:	48 89 84 24 00 02 00 	mov    QWORD PTR [rsp+0x200],rax
  20d792:	00 
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  20d793:	48 83 bc 24 68 01 00 	cmp    QWORD PTR [rsp+0x168],0x0
  20d79a:	00 00 
  20d79c:	0f 84 c9 00 00 00    	je     20d86b <openSelfDebugInfo+0x1d6b>
  20d7a2:	48 8b 45 18          	mov    rax,QWORD PTR [rbp+0x18]
  20d7a6:	48 8b ac 24 f0 01 00 	mov    rbp,QWORD PTR [rsp+0x1f0]
  20d7ad:	00 
  20d7ae:	48 83 c0 08          	add    rax,0x8
  20d7b2:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  20d7b7:	48 83 c5 08          	add    rbp,0x8
  20d7bb:	31 c0                	xor    eax,eax
  20d7bd:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20d7c2:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20d7c7:	48 8b 48 f8          	mov    rcx,QWORD PTR [rax-0x8]
  20d7cb:	48 89 8c 24 60 01 00 	mov    QWORD PTR [rsp+0x160],rcx
  20d7d2:	00 
  20d7d3:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20d7d6:	48 8b b3 a0 00 00 00 	mov    rsi,QWORD PTR [rbx+0xa0]
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  20d7dd:	48 8d bc 24 48 03 00 	lea    rdi,[rsp+0x348]
  20d7e4:	00 
  20d7e5:	48 8d 94 24 58 01 00 	lea    rdx,[rsp+0x158]
  20d7ec:	00 
  20d7ed:	4c 8b 84 24 38 01 00 	mov    r8,QWORD PTR [rsp+0x138]
  20d7f4:	00 
  20d7f5:	c5 f8 77             	vzeroupper 
  20d7f8:	e8 23 3d 00 00       	call   211520 <parseFormValue>
  20d7fd:	0f b7 8c 24 48 03 00 	movzx  ecx,WORD PTR [rsp+0x348]
  20d804:	00 
  20d805:	89 c8                	mov    eax,ecx
  20d807:	66 85 c9             	test   cx,cx
  20d80a:	0f 85 cd 0c 00 00    	jne    20e4dd <openSelfDebugInfo+0x29dd>
        result.attrs.items[i] = Die.Attr{
  20d810:	48 8d 84 24 50 03 00 	lea    rax,[rsp+0x350]
  20d817:	00 
  20d818:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  20d81c:	c5 fc 11 84 24 10 03 	vmovups YMMWORD PTR [rsp+0x310],ymm0
  20d823:	00 00 
  20d825:	48 8b 84 24 60 01 00 	mov    rax,QWORD PTR [rsp+0x160]
  20d82c:	00 
  20d82d:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  20d831:	c5 fe 6f 84 24 10 03 	vmovdqu ymm0,YMMWORD PTR [rsp+0x310]
  20d838:	00 00 
  20d83a:	c5 fe 7f 45 00       	vmovdqu YMMWORD PTR [rbp+0x0],ymm0
  20d83f:	48 8b 44 24 30       	mov    rax,QWORD PTR [rsp+0x30]
  20d844:	48 89 c1             	mov    rcx,rax
    for (table_entry.attrs.toSliceConst()) |attr, i| {
  20d847:	48 83 c1 01          	add    rcx,0x1
  20d84b:	48 83 44 24 18 10    	add    QWORD PTR [rsp+0x18],0x10
  20d851:	48 83 c5 28          	add    rbp,0x28
  20d855:	48 89 c8             	mov    rax,rcx
  20d858:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20d85d:	48 3b 8c 24 68 01 00 	cmp    rcx,QWORD PTR [rsp+0x168]
  20d864:	00 
  20d865:	0f 82 57 ff ff ff    	jb     20d7c2 <openSelfDebugInfo+0x1cc2>
    return result;
  20d86b:	c5 fc 10 84 24 e0 01 	vmovups ymm0,YMMWORD PTR [rsp+0x1e0]
  20d872:	00 00 
  20d874:	c5 fc 10 8c 24 f0 01 	vmovups ymm1,YMMWORD PTR [rsp+0x1f0]
  20d87b:	00 00 
  20d87d:	48 8d 84 24 2e 04 00 	lea    rax,[rsp+0x42e]
  20d884:	00 
  20d885:	c5 fc 11 48 10       	vmovups YMMWORD PTR [rax+0x10],ymm1
  20d88a:	c5 fc 11 00          	vmovups YMMWORD PTR [rax],ymm0
  20d88e:	c5 fc 10 84 24 28 04 	vmovups ymm0,YMMWORD PTR [rsp+0x428]
  20d895:	00 00 
  20d897:	c5 fc 10 8c 24 3e 04 	vmovups ymm1,YMMWORD PTR [rsp+0x43e]
  20d89e:	00 00 
  20d8a0:	c5 fc 11 84 24 10 02 	vmovups YMMWORD PTR [rsp+0x210],ymm0
  20d8a7:	00 00 
  20d8a9:	c5 fc 11 8c 24 26 02 	vmovups YMMWORD PTR [rsp+0x226],ymm1
  20d8b0:	00 00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20d8b2:	ba 30 00 00 00       	mov    edx,0x30
  20d8b7:	b9 08 00 00 00       	mov    ecx,0x8
  20d8bc:	4c 89 ef             	mov    rdi,r13
  20d8bf:	48 8b b4 24 58 02 00 	mov    rsi,QWORD PTR [rsp+0x258]
  20d8c6:	00 
  20d8c7:	c5 f8 77             	vzeroupper 
  20d8ca:	ff 16                	call   QWORD PTR [rsi]
  20d8cc:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d8d3:	00 
  20d8d4:	89 c8                	mov    eax,ecx
  20d8d6:	66 85 c9             	test   cx,cx
  20d8d9:	0f 85 39 0b 00 00    	jne    20e418 <openSelfDebugInfo+0x2918>
        assert(byte_slice.len == byte_count);
  20d8df:	48 83 bc 24 b0 00 00 	cmp    QWORD PTR [rsp+0xb0],0x30
  20d8e6:	00 30 
    if (!ok) {
  20d8e8:	0f 85 e4 18 00 00    	jne    20f1d2 <openSelfDebugInfo+0x36d2>
  20d8ee:	48 8b 8c 24 a8 00 00 	mov    rcx,QWORD PTR [rsp+0xa8]
  20d8f5:	00 
  20d8f6:	48 8d 84 24 16 02 00 	lea    rax,[rsp+0x216]
  20d8fd:	00 
        ptr.* = init;
  20d8fe:	c5 fe 6f 00          	vmovdqu ymm0,YMMWORD PTR [rax]
  20d902:	c5 fe 6f 48 10       	vmovdqu ymm1,YMMWORD PTR [rax+0x10]
  20d907:	c5 fe 7f 01          	vmovdqu YMMWORD PTR [rcx],ymm0
  20d90b:	c5 fe 7f 49 10       	vmovdqu YMMWORD PTR [rcx+0x10],ymm1
  20d910:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
        if (compile_unit_die.tag_id != DW.TAG_compile_unit) return error.InvalidDebugInfo;
  20d915:	48 83 39 11          	cmp    QWORD PTR [rcx],0x11
  20d919:	0f 85 55 0b 00 00    	jne    20e474 <openSelfDebugInfo+0x2974>
  20d91f:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20d924:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  20d928:	48 85 c9             	test   rcx,rcx
  20d92b:	74 25                	je     20d952 <openSelfDebugInfo+0x1e52>
  20d92d:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20d932:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  20d936:	48 89 d0             	mov    rax,rdx
  20d939:	31 f6                	xor    esi,esi
            if (attr.id == id) return &attr.value;
  20d93b:	48 83 38 11          	cmp    QWORD PTR [rax],0x11
  20d93f:	0f 84 52 01 00 00    	je     20da97 <openSelfDebugInfo+0x1f97>
        for (self.attrs.toSliceConst()) |*attr| {
  20d945:	48 83 c6 01          	add    rsi,0x1
  20d949:	48 83 c0 28          	add    rax,0x28
  20d94d:	48 39 ce             	cmp    rsi,rcx
  20d950:	72 e9                	jb     20d93b <openSelfDebugInfo+0x1e3b>
        const pc_range = x: {
  20d952:	48 8d 05 6f 89 ff ff 	lea    rax,[rip+0xffffffffffff896f]        # 2062c8 <__unnamed_56>
  20d959:	48 8b 48 10          	mov    rcx,QWORD PTR [rax+0x10]
  20d95d:	48 89 8c 24 b0 01 00 	mov    QWORD PTR [rsp+0x1b0],rcx
  20d964:	00 
  20d965:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20d969:	c5 f9 7f 84 24 a0 01 	vmovdqa XMMWORD PTR [rsp+0x1a0],xmm0
  20d970:	00 00 
            const new_length = self.len + 1;
  20d972:	48 8b ab b8 00 00 00 	mov    rbp,QWORD PTR [rbx+0xb8]
            var better_capacity = self.items.len;
  20d979:	48 8b 8b b0 00 00 00 	mov    rcx,QWORD PTR [rbx+0xb0]
            if (better_capacity >= new_capacity) return;
  20d980:	48 39 e9             	cmp    rcx,rbp
  20d983:	76 05                	jbe    20d98a <openSelfDebugInfo+0x1e8a>
            const result = &self.items[self.len];
  20d985:	48 89 e8             	mov    rax,rbp
  20d988:	eb 5e                	jmp    20d9e8 <openSelfDebugInfo+0x1ee8>
                better_capacity += better_capacity / 2 + 8;
  20d98a:	48 89 c8             	mov    rax,rcx
  20d98d:	48 d1 e8             	shr    rax,1
  20d990:	48 01 c1             	add    rcx,rax
  20d993:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  20d997:	48 39 e9             	cmp    rcx,rbp
  20d99a:	76 ee                	jbe    20d98a <openSelfDebugInfo+0x1e8a>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  20d99c:	48 8b b3 c0 00 00 00 	mov    rsi,QWORD PTR [rbx+0xc0]
  20d9a3:	4c 89 ef             	mov    rdi,r13
  20d9a6:	48 8b 94 24 78 01 00 	mov    rdx,QWORD PTR [rsp+0x178]
  20d9ad:	00 
  20d9ae:	c5 f8 77             	vzeroupper 
  20d9b1:	e8 fa 6b 00 00       	call   2145b0 <Allocator_alignedRealloc.54>
  20d9b6:	0f b7 8c 24 a0 00 00 	movzx  ecx,WORD PTR [rsp+0xa0]
  20d9bd:	00 
  20d9be:	89 c8                	mov    eax,ecx
  20d9c0:	66 85 c9             	test   cx,cx
  20d9c3:	0f 85 4f 0a 00 00    	jne    20e418 <openSelfDebugInfo+0x2918>
  20d9c9:	48 8d 84 24 a8 00 00 	lea    rax,[rsp+0xa8]
  20d9d0:	00 
  20d9d1:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  20d9d5:	48 8b 84 24 78 01 00 	mov    rax,QWORD PTR [rsp+0x178]
  20d9dc:	00 
  20d9dd:	c5 fa 7f 00          	vmovdqu XMMWORD PTR [rax],xmm0
            const result = &self.items[self.len];
  20d9e1:	48 8b 83 b8 00 00 00 	mov    rax,QWORD PTR [rbx+0xb8]
  20d9e8:	48 83 c5 01          	add    rbp,0x1
  20d9ec:	48 8b 8b a8 00 00 00 	mov    rcx,QWORD PTR [rbx+0xa8]
  20d9f3:	48 8d 04 40          	lea    rax,[rax+rax*2]
  20d9f7:	48 c1 e0 04          	shl    rax,0x4
            self.len = new_length;
  20d9fb:	48 89 ab b8 00 00 00 	mov    QWORD PTR [rbx+0xb8],rbp
            new_item_ptr.* = item;
  20da02:	48 8b 94 24 60 02 00 	mov    rdx,QWORD PTR [rsp+0x260]
  20da09:	00 
  20da0a:	66 89 14 01          	mov    WORD PTR [rcx+rax*1],dx
  20da0e:	8b 54 24 40          	mov    edx,DWORD PTR [rsp+0x40]
  20da12:	88 54 01 02          	mov    BYTE PTR [rcx+rax*1+0x2],dl
  20da16:	8a 94 24 77 01 00 00 	mov    dl,BYTE PTR [rsp+0x177]
  20da1d:	88 54 01 07          	mov    BYTE PTR [rcx+rax*1+0x7],dl
  20da21:	8b 94 24 73 01 00 00 	mov    edx,DWORD PTR [rsp+0x173]
  20da28:	89 54 01 03          	mov    DWORD PTR [rcx+rax*1+0x3],edx
  20da2c:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  20da31:	48 89 54 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],rdx
  20da36:	48 8b 94 24 80 01 00 	mov    rdx,QWORD PTR [rsp+0x180]
  20da3d:	00 
  20da3e:	48 89 d6             	mov    rsi,rdx
  20da41:	48 89 74 01 10       	mov    QWORD PTR [rcx+rax*1+0x10],rsi
  20da46:	48 8b 94 24 b0 01 00 	mov    rdx,QWORD PTR [rsp+0x1b0]
  20da4d:	00 
  20da4e:	48 89 54 01 28       	mov    QWORD PTR [rcx+rax*1+0x28],rdx
  20da53:	c5 f9 6f 84 24 a0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1a0]
  20da5a:	00 00 
  20da5c:	c5 fa 7f 44 01 18    	vmovdqu XMMWORD PTR [rcx+rax*1+0x18],xmm0
  20da62:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  20da67:	48 03 44 24 38       	add    rax,QWORD PTR [rsp+0x38]
        this_unit_offset += next_offset;
  20da6c:	48 03 84 24 50 02 00 	add    rax,QWORD PTR [rsp+0x250]
  20da73:	00 
        cu_index += 1;
  20da74:	48 83 c6 01          	add    rsi,0x1
  20da78:	48 89 b4 24 80 01 00 	mov    QWORD PTR [rsp+0x180],rsi
  20da7f:	00 
  20da80:	31 ff                	xor    edi,edi
  20da82:	48 89 44 24 38       	mov    QWORD PTR [rsp+0x38],rax
    while (this_unit_offset < debug_info_end) {
  20da87:	48 3b 44 24 50       	cmp    rax,QWORD PTR [rsp+0x50]
  20da8c:	0f 82 ba f5 ff ff    	jb     20d04c <openSelfDebugInfo+0x154c>
  20da92:	e9 be 07 00 00       	jmp    20e255 <openSelfDebugInfo+0x2755>
        return switch (form_value.*) {
  20da97:	40 8a 78 20          	mov    dil,BYTE PTR [rax+0x20]
  20da9b:	48 8d 35 ae 27 ff ff 	lea    rsi,[rip+0xffffffffffff27ae]        # 200250 <__unnamed_57>
  20daa2:	40 84 ff             	test   dil,dil
  20daa5:	75 19                	jne    20dac0 <openSelfDebugInfo+0x1fc0>
            FormValue.Address => |value| value,
  20daa7:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  20daab:	66 c7 84 24 a0 00 00 	mov    WORD PTR [rsp+0xa0],0x0
  20dab2:	00 00 00 
  20dab5:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20dabc:	00 
  20dabd:	4c 89 ee             	mov    rsi,r13
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  20dac0:	0f b7 3e             	movzx  edi,WORD PTR [rsi]
        const pc_range = x: {
  20dac3:	48 8d 05 fe 87 ff ff 	lea    rax,[rip+0xffffffffffff87fe]        # 2062c8 <__unnamed_56>
  20daca:	89 fd                	mov    ebp,edi
            if (compile_unit_die.getAttrAddr(DW.AT_low_pc)) |low_pc| {
  20dacc:	83 ff 24             	cmp    edi,0x24
  20dacf:	0f 84 84 fe ff ff    	je     20d959 <openSelfDebugInfo+0x1e59>
  20dad5:	89 ef                	mov    edi,ebp
  20dad7:	66 85 ff             	test   di,di
  20dada:	0f 85 75 07 00 00    	jne    20e255 <openSelfDebugInfo+0x2755>
  20dae0:	4c 8b 4e 08          	mov    r9,QWORD PTR [rsi+0x8]
            if (attr.id == id) return &attr.value;
  20dae4:	48 83 c2 20          	add    rdx,0x20
  20dae8:	31 f6                	xor    esi,esi
  20daea:	48 83 7a e0 12       	cmp    QWORD PTR [rdx-0x20],0x12
  20daef:	74 12                	je     20db03 <openSelfDebugInfo+0x2003>
        for (self.attrs.toSliceConst()) |*attr| {
  20daf1:	48 83 c6 01          	add    rsi,0x1
  20daf5:	48 83 c2 28          	add    rdx,0x28
  20daf9:	48 39 ce             	cmp    rsi,rcx
  20dafc:	72 ec                	jb     20daea <openSelfDebugInfo+0x1fea>
  20dafe:	e9 4f fe ff ff       	jmp    20d952 <openSelfDebugInfo+0x1e52>
  20db03:	8a 0a                	mov    cl,BYTE PTR [rdx]
  20db05:	80 f9 02             	cmp    cl,0x2
                    const pc_end = switch (high_pc_value.*) {
  20db08:	74 15                	je     20db1f <openSelfDebugInfo+0x201f>
  20db0a:	66 bf 25 00          	mov    di,0x25
  20db0e:	84 c9                	test   cl,cl
  20db10:	0f 85 3f 07 00 00    	jne    20e255 <openSelfDebugInfo+0x2755>
                        FormValue.Address => |value| value,
  20db16:	48 8b 7a e8          	mov    rdi,QWORD PTR [rdx-0x18]
  20db1a:	e9 33 02 00 00       	jmp    20dd52 <openSelfDebugInfo+0x2252>
                        FormValue.Const => |value| b: {
  20db1f:	48 8b 4a f0          	mov    rcx,QWORD PTR [rdx-0x10]
        if (self.payload.len > @sizeOf(u64)) return error.InvalidDebugInfo;
  20db23:	48 83 f9 08          	cmp    rcx,0x8
  20db27:	0f 87 47 09 00 00    	ja     20e474 <openSelfDebugInfo+0x2974>
  20db2d:	f6 42 f8 01          	test   BYTE PTR [rdx-0x8],0x1
  20db31:	66 bf 25 00          	mov    di,0x25
  20db35:	0f 85 1a 07 00 00    	jne    20e255 <openSelfDebugInfo+0x2755>
  20db3b:	48 85 c9             	test   rcx,rcx
            for (bytes) |b, index| {
  20db3e:	74 13                	je     20db53 <openSelfDebugInfo+0x2053>
  20db40:	48 8b 52 e8          	mov    rdx,QWORD PTR [rdx-0x18]
  20db44:	48 83 f9 10          	cmp    rcx,0x10
  20db48:	73 10                	jae    20db5a <openSelfDebugInfo+0x205a>
  20db4a:	31 c0                	xor    eax,eax
  20db4c:	31 ff                	xor    edi,edi
  20db4e:	e9 d3 01 00 00       	jmp    20dd26 <openSelfDebugInfo+0x2226>
  20db53:	31 ff                	xor    edi,edi
  20db55:	e9 f5 01 00 00       	jmp    20dd4f <openSelfDebugInfo+0x224f>
  20db5a:	48 89 c8             	mov    rax,rcx
  20db5d:	48 83 e0 f0          	and    rax,0xfffffffffffffff0
  20db61:	48 8d 78 f0          	lea    rdi,[rax-0x10]
  20db65:	48 89 fd             	mov    rbp,rdi
  20db68:	48 c1 ed 04          	shr    rbp,0x4
  20db6c:	44 8d 45 01          	lea    r8d,[rbp+0x1]
  20db70:	41 83 e0 01          	and    r8d,0x1
  20db74:	48 85 ff             	test   rdi,rdi
  20db77:	0f 84 01 01 00 00    	je     20dc7e <openSelfDebugInfo+0x217e>
  20db7d:	49 8d 78 ff          	lea    rdi,[r8-0x1]
  20db81:	48 29 ef             	sub    rdi,rbp
  20db84:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20db88:	31 ed                	xor    ebp,ebp
  20db8a:	c5 fd 6f 25 0e 31 ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff310e]        # 200ca0 <app_mask+0x68>
  20db91:	ff 
  20db92:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  20db96:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20db9a:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20db9e:	c4 e2 7d 32 2c 2a    	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1]
  20dba4:	c4 e2 7d 32 74 2a 04 	vpmovzxbq ymm6,DWORD PTR [rdx+rbp*1+0x4]
  20dbab:	c4 e2 7d 32 7c 2a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rbp*1+0x8]
  20dbb2:	c4 62 7d 32 44 2a 0c 	vpmovzxbq ymm8,DWORD PTR [rdx+rbp*1+0xc]
  20dbb9:	c5 b5 73 f4 03       	vpsllq ymm9,ymm4,0x3
  20dbbe:	c5 7e 6f a4 24 80 04 	vmovdqu ymm12,YMMWORD PTR [rsp+0x480]
  20dbc5:	00 00 
  20dbc7:	c4 41 35 d4 d4       	vpaddq ymm10,ymm9,ymm12
  20dbcc:	c5 7e 6f ac 24 60 04 	vmovdqu ymm13,YMMWORD PTR [rsp+0x460]
  20dbd3:	00 00 
  20dbd5:	c4 41 35 db dd       	vpand  ymm11,ymm9,ymm13
  20dbda:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  20dbdf:	c4 c2 d5 47 eb       	vpsllvq ymm5,ymm5,ymm11
  20dbe4:	c5 d5 eb c0          	vpor   ymm0,ymm5,ymm0
  20dbe8:	c4 c2 cd 47 ea       	vpsllvq ymm5,ymm6,ymm10
  20dbed:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  20dbf1:	c4 c2 c5 47 eb       	vpsllvq ymm5,ymm7,ymm11
  20dbf6:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  20dbfa:	c4 c2 bd 47 ea       	vpsllvq ymm5,ymm8,ymm10
  20dbff:	c4 e2 7d 32 74 2a 10 	vpmovzxbq ymm6,DWORD PTR [rdx+rbp*1+0x10]
  20dc06:	c4 e2 7d 32 7c 2a 14 	vpmovzxbq ymm7,DWORD PTR [rdx+rbp*1+0x14]
  20dc0d:	c4 62 7d 32 44 2a 18 	vpmovzxbq ymm8,DWORD PTR [rdx+rbp*1+0x18]
  20dc14:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  20dc18:	c4 e2 7d 32 6c 2a 1c 	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1+0x1c]
  20dc1f:	c4 62 7d 59 15 50 30 	vpbroadcastq ymm10,QWORD PTR [rip+0xffffffffffff3050]        # 200c78 <app_mask+0x40>
  20dc26:	ff ff 
  20dc28:	c4 41 35 d4 d2       	vpaddq ymm10,ymm9,ymm10
  20dc2d:	c4 62 7d 59 1d 82 2f 	vpbroadcastq ymm11,QWORD PTR [rip+0xffffffffffff2f82]        # 200bb8 <__unnamed_441+0x18>
  20dc34:	ff ff 
  20dc36:	c4 41 35 d4 cb       	vpaddq ymm9,ymm9,ymm11
  20dc3b:	c4 41 2d db d5       	vpand  ymm10,ymm10,ymm13
  20dc40:	c4 41 35 db cd       	vpand  ymm9,ymm9,ymm13
  20dc45:	c4 c2 cd 47 f2       	vpsllvq ymm6,ymm6,ymm10
  20dc4a:	c5 cd eb c0          	vpor   ymm0,ymm6,ymm0
  20dc4e:	c4 c2 c5 47 f1       	vpsllvq ymm6,ymm7,ymm9
  20dc53:	c5 cd eb c9          	vpor   ymm1,ymm6,ymm1
  20dc57:	c4 c2 bd 47 f2       	vpsllvq ymm6,ymm8,ymm10
  20dc5c:	c5 cd eb db          	vpor   ymm3,ymm6,ymm3
  20dc60:	c4 c2 d5 47 e9       	vpsllvq ymm5,ymm5,ymm9
  20dc65:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
            for (bytes) |b, index| {
  20dc69:	48 83 c5 20          	add    rbp,0x20
  20dc6d:	c4 c1 5d d4 e4       	vpaddq ymm4,ymm4,ymm12
  20dc72:	48 83 c7 02          	add    rdi,0x2
  20dc76:	0f 85 22 ff ff ff    	jne    20db9e <openSelfDebugInfo+0x209e>
  20dc7c:	eb 1a                	jmp    20dc98 <openSelfDebugInfo+0x2198>
  20dc7e:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  20dc82:	31 ed                	xor    ebp,ebp
  20dc84:	c5 fd 6f 25 14 30 ff 	vmovdqa ymm4,YMMWORD PTR [rip+0xffffffffffff3014]        # 200ca0 <app_mask+0x68>
  20dc8b:	ff 
  20dc8c:	c5 f1 ef c9          	vpxor  xmm1,xmm1,xmm1
  20dc90:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  20dc94:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  20dc98:	4d 85 c0             	test   r8,r8
  20dc9b:	74 60                	je     20dcfd <openSelfDebugInfo+0x21fd>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20dc9d:	c4 e2 7d 32 6c 2a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1+0xc]
  20dca4:	c5 dd 73 f4 03       	vpsllq ymm4,ymm4,0x3
  20dca9:	c5 dd d4 b4 24 80 04 	vpaddq ymm6,ymm4,YMMWORD PTR [rsp+0x480]
  20dcb0:	00 00 
  20dcb2:	c5 7e 6f 84 24 60 04 	vmovdqu ymm8,YMMWORD PTR [rsp+0x460]
  20dcb9:	00 00 
  20dcbb:	c4 c1 4d db f0       	vpand  ymm6,ymm6,ymm8
  20dcc0:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20dcc5:	c4 e2 7d 32 7c 2a 08 	vpmovzxbq ymm7,DWORD PTR [rdx+rbp*1+0x8]
  20dccc:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  20dcd0:	c4 c1 5d db e0       	vpand  ymm4,ymm4,ymm8
  20dcd5:	c4 e2 c5 47 ec       	vpsllvq ymm5,ymm7,ymm4
  20dcda:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  20dcde:	c4 e2 7d 32 6c 2a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1+0x4]
  20dce5:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  20dcea:	c5 d5 eb c9          	vpor   ymm1,ymm5,ymm1
  20dcee:	c4 e2 7d 32 2c 2a    	vpmovzxbq ymm5,DWORD PTR [rdx+rbp*1]
  20dcf4:	c4 e2 d5 47 e4       	vpsllvq ymm4,ymm5,ymm4
  20dcf9:	c5 dd eb c0          	vpor   ymm0,ymm4,ymm0
  20dcfd:	c5 f5 eb ca          	vpor   ymm1,ymm1,ymm2
  20dd01:	c5 fd eb c3          	vpor   ymm0,ymm0,ymm3
  20dd05:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20dd09:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  20dd0f:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20dd13:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  20dd18:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  20dd1c:	c4 e1 f9 7e c7       	vmovq  rdi,xmm0
  20dd21:	48 39 c1             	cmp    rcx,rax
            for (bytes) |b, index| {
  20dd24:	74 29                	je     20dd4f <openSelfDebugInfo+0x224f>
  20dd26:	48 29 c1             	sub    rcx,rax
  20dd29:	48 01 c2             	add    rdx,rax
  20dd2c:	48 c1 e0 03          	shl    rax,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20dd30:	0f b6 2a             	movzx  ebp,BYTE PTR [rdx]
  20dd33:	89 c6                	mov    esi,eax
  20dd35:	40 80 e6 38          	and    sil,0x38
  20dd39:	c4 e2 c9 f7 f5       	shlx   rsi,rbp,rsi
  20dd3e:	48 09 f7             	or     rdi,rsi
            for (bytes) |b, index| {
  20dd41:	48 83 c0 08          	add    rax,0x8
  20dd45:	48 83 c2 01          	add    rdx,0x1
  20dd49:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  20dd4d:	75 e1                	jne    20dd30 <openSelfDebugInfo+0x2230>
                            break :b (low_pc + offset);
  20dd4f:	4c 01 cf             	add    rdi,r9
                    break :x PcRange{
  20dd52:	4c 89 8c 24 c0 01 00 	mov    QWORD PTR [rsp+0x1c0],r9
  20dd59:	00 
  20dd5a:	48 89 bc 24 c8 01 00 	mov    QWORD PTR [rsp+0x1c8],rdi
  20dd61:	00 
  20dd62:	c6 84 24 d0 01 00 00 	mov    BYTE PTR [rsp+0x1d0],0x1
  20dd69:	01 
        const pc_range = x: {
  20dd6a:	48 8d 84 24 c0 01 00 	lea    rax,[rsp+0x1c0]
  20dd71:	00 
  20dd72:	e9 e2 fb ff ff       	jmp    20d959 <openSelfDebugInfo+0x1e59>
                list.first = node.next;
  20dd77:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20dd7b:	48 89 0d ce 32 01 00 	mov    QWORD PTR [rip+0x132ce],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20dd82:	48 85 c9             	test   rcx,rcx
  20dd85:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20dd88:	48 8d 35 c9 32 01 00 	lea    rsi,[rip+0x132c9]        # 221058 <emfile_promise_queue+0x8>
  20dd8f:	48 0f 45 f1          	cmovne rsi,rcx
  20dd93:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20dd96:	48 83 05 c2 32 01 00 	add    QWORD PTR [rip+0x132c2],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20dd9d:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20dd9e:	74 1e                	je     20ddbe <openSelfDebugInfo+0x22be>
  20dda0:	48 83 3d a8 32 01 00 	cmp    QWORD PTR [rip+0x132a8],0x0        # 221050 <emfile_promise_queue>
  20dda7:	00 
  20dda8:	0f 84 24 14 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20ddae:	48 8b 0d a3 32 01 00 	mov    rcx,QWORD PTR [rip+0x132a3]        # 221058 <emfile_promise_queue+0x8>
  20ddb5:	48 85 c9             	test   rcx,rcx
  20ddb8:	0f 84 14 14 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20ddbe:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20ddc2:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20ddc6:	48 89 c1             	mov    rcx,rax
  20ddc9:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20ddcd:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20ddd3:	75 f1                	jne    20ddc6 <openSelfDebugInfo+0x22c6>
  20ddd5:	a8 01                	test   al,0x1
  20ddd7:	75 02                	jne    20dddb <openSelfDebugInfo+0x22db>
  20ddd9:	ff 17                	call   QWORD PTR [rdi]
  20dddb:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
    return asm volatile ("syscall"
  20ddde:	b8 03 00 00 00       	mov    eax,0x3
  20dde3:	0f 05                	syscall 
            switch (err) {
  20dde5:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20dde9:	74 f3                	je     20ddde <openSelfDebugInfo+0x22de>
            const first = list.first orelse return null;
  20ddeb:	48 8b 05 5e 32 01 00 	mov    rax,QWORD PTR [rip+0x1325e]        # 221050 <emfile_promise_queue>
  20ddf2:	48 85 c0             	test   rax,rax
  20ddf5:	74 7a                	je     20de71 <openSelfDebugInfo+0x2371>
            if (node.prev) |prev_node| {
  20ddf7:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20ddfa:	48 85 c9             	test   rcx,rcx
  20ddfd:	74 0e                	je     20de0d <openSelfDebugInfo+0x230d>
                prev_node.next = node.next;
  20ddff:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20de03:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20de07:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20de0b:	eb 0b                	jmp    20de18 <openSelfDebugInfo+0x2318>
                list.first = node.next;
  20de0d:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20de11:	48 89 0d 38 32 01 00 	mov    QWORD PTR [rip+0x13238],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20de18:	48 85 c9             	test   rcx,rcx
  20de1b:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20de1e:	48 8d 35 33 32 01 00 	lea    rsi,[rip+0x13233]        # 221058 <emfile_promise_queue+0x8>
  20de25:	48 0f 45 f1          	cmovne rsi,rcx
  20de29:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20de2c:	48 83 05 2c 32 01 00 	add    QWORD PTR [rip+0x1322c],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20de33:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20de34:	74 1e                	je     20de54 <openSelfDebugInfo+0x2354>
  20de36:	48 83 3d 12 32 01 00 	cmp    QWORD PTR [rip+0x13212],0x0        # 221050 <emfile_promise_queue>
  20de3d:	00 
  20de3e:	0f 84 8e 13 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20de44:	48 8b 0d 0d 32 01 00 	mov    rcx,QWORD PTR [rip+0x1320d]        # 221058 <emfile_promise_queue+0x8>
  20de4b:	48 85 c9             	test   rcx,rcx
  20de4e:	0f 84 7e 13 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20de54:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20de58:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20de5c:	48 89 c1             	mov    rcx,rax
  20de5f:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20de63:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20de69:	75 f1                	jne    20de5c <openSelfDebugInfo+0x235c>
  20de6b:	a8 01                	test   al,0x1
  20de6d:	75 02                	jne    20de71 <openSelfDebugInfo+0x2371>
  20de6f:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20de71:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20de75:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20de7c:	00 
  20de7d:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20de84:	00 c8 00 00 00 
  20de89:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20de90:	00 
  20de91:	4c 89 ff             	mov    rdi,r15
  20de94:	ff d0                	call   rax
            st.debug_line = (try st.elf.findSection(".debug_line")) orelse return error.MissingDebugInfo;
  20de96:	0f b7 84 24 78 02 00 	movzx  eax,WORD PTR [rsp+0x278]
  20de9d:	00 
  20de9e:	66 41 89 06          	mov    WORD PTR [r14],ax
  20dea2:	48 8b 84 24 c6 03 00 	mov    rax,QWORD PTR [rsp+0x3c6]
  20dea9:	00 
  20deaa:	48 8b 8c 24 cc 03 00 	mov    rcx,QWORD PTR [rsp+0x3cc]
  20deb1:	00 
  20deb2:	e9 3f e9 ff ff       	jmp    20c7f6 <openSelfDebugInfo+0xcf6>
                list.first = node.next;
  20deb7:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20debb:	48 89 0d 8e 31 01 00 	mov    QWORD PTR [rip+0x1318e],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20dec2:	48 85 c9             	test   rcx,rcx
  20dec5:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20dec8:	48 8d 35 89 31 01 00 	lea    rsi,[rip+0x13189]        # 221058 <emfile_promise_queue+0x8>
  20decf:	48 0f 45 f1          	cmovne rsi,rcx
  20ded3:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20ded6:	48 83 05 82 31 01 00 	add    QWORD PTR [rip+0x13182],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20dedd:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20dede:	74 1e                	je     20defe <openSelfDebugInfo+0x23fe>
  20dee0:	48 83 3d 68 31 01 00 	cmp    QWORD PTR [rip+0x13168],0x0        # 221050 <emfile_promise_queue>
  20dee7:	00 
  20dee8:	0f 84 e4 12 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20deee:	48 8b 0d 63 31 01 00 	mov    rcx,QWORD PTR [rip+0x13163]        # 221058 <emfile_promise_queue+0x8>
  20def5:	48 85 c9             	test   rcx,rcx
  20def8:	0f 84 d4 12 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20defe:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20df02:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20df06:	48 89 c1             	mov    rcx,rax
  20df09:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20df0d:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20df13:	75 f1                	jne    20df06 <openSelfDebugInfo+0x2406>
  20df15:	a8 01                	test   al,0x1
  20df17:	75 02                	jne    20df1b <openSelfDebugInfo+0x241b>
  20df19:	ff 17                	call   QWORD PTR [rdi]
  20df1b:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20df1e:	b8 03 00 00 00       	mov    eax,0x3
  20df23:	0f 05                	syscall 
            switch (err) {
  20df25:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20df29:	74 f3                	je     20df1e <openSelfDebugInfo+0x241e>
            const first = list.first orelse return null;
  20df2b:	48 8b 05 1e 31 01 00 	mov    rax,QWORD PTR [rip+0x1311e]        # 221050 <emfile_promise_queue>
  20df32:	48 85 c0             	test   rax,rax
  20df35:	0f 84 48 ec ff ff    	je     20cb83 <openSelfDebugInfo+0x1083>
            if (node.prev) |prev_node| {
  20df3b:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20df3e:	48 85 c9             	test   rcx,rcx
  20df41:	74 0e                	je     20df51 <openSelfDebugInfo+0x2451>
                prev_node.next = node.next;
  20df43:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20df47:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20df4b:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20df4f:	eb 0b                	jmp    20df5c <openSelfDebugInfo+0x245c>
                list.first = node.next;
  20df51:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20df55:	48 89 0d f4 30 01 00 	mov    QWORD PTR [rip+0x130f4],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20df5c:	48 85 c9             	test   rcx,rcx
  20df5f:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20df62:	48 8d 35 ef 30 01 00 	lea    rsi,[rip+0x130ef]        # 221058 <emfile_promise_queue+0x8>
  20df69:	48 0f 45 f1          	cmovne rsi,rcx
  20df6d:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20df70:	48 83 05 e8 30 01 00 	add    QWORD PTR [rip+0x130e8],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20df77:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20df78:	74 1e                	je     20df98 <openSelfDebugInfo+0x2498>
  20df7a:	48 83 3d ce 30 01 00 	cmp    QWORD PTR [rip+0x130ce],0x0        # 221050 <emfile_promise_queue>
  20df81:	00 
  20df82:	0f 84 4a 12 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20df88:	48 8b 0d c9 30 01 00 	mov    rcx,QWORD PTR [rip+0x130c9]        # 221058 <emfile_promise_queue+0x8>
  20df8f:	48 85 c9             	test   rcx,rcx
  20df92:	0f 84 3a 12 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20df98:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20df9c:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20dfa0:	48 89 c1             	mov    rcx,rax
  20dfa3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20dfa7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20dfad:	75 f1                	jne    20dfa0 <openSelfDebugInfo+0x24a0>
  20dfaf:	e9 c9 eb ff ff       	jmp    20cb7d <openSelfDebugInfo+0x107d>
  20dfb4:	31 ff                	xor    edi,edi
  20dfb6:	89 fd                	mov    ebp,edi
            try scanAllCompileUnits(st);
  20dfb8:	66 85 ff             	test   di,di
  20dfbb:	0f 85 9f 02 00 00    	jne    20e260 <openSelfDebugInfo+0x2760>
            return st;
  20dfc1:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  20dfc7:	0f b7 84 24 de 01 00 	movzx  eax,WORD PTR [rsp+0x1de]
  20dfce:	00 
  20dfcf:	66 41 89 46 06       	mov    WORD PTR [r14+0x6],ax
  20dfd4:	8b 84 24 da 01 00 00 	mov    eax,DWORD PTR [rsp+0x1da]
  20dfdb:	41 89 46 02          	mov    DWORD PTR [r14+0x2],eax
  20dfdf:	49 89 5e 08          	mov    QWORD PTR [r14+0x8],rbx
  20dfe3:	e9 16 e8 ff ff       	jmp    20c7fe <openSelfDebugInfo+0xcfe>
                list.first = node.next;
  20dfe8:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20dfec:	48 89 0d 5d 30 01 00 	mov    QWORD PTR [rip+0x1305d],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20dff3:	48 85 c9             	test   rcx,rcx
  20dff6:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20dff9:	48 8d 35 58 30 01 00 	lea    rsi,[rip+0x13058]        # 221058 <emfile_promise_queue+0x8>
  20e000:	48 0f 45 f1          	cmovne rsi,rcx
  20e004:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20e007:	48 83 05 51 30 01 00 	add    QWORD PTR [rip+0x13051],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20e00e:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20e00f:	74 1e                	je     20e02f <openSelfDebugInfo+0x252f>
  20e011:	48 83 3d 37 30 01 00 	cmp    QWORD PTR [rip+0x13037],0x0        # 221050 <emfile_promise_queue>
  20e018:	00 
  20e019:	0f 84 b3 11 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20e01f:	48 8b 0d 32 30 01 00 	mov    rcx,QWORD PTR [rip+0x13032]        # 221058 <emfile_promise_queue+0x8>
  20e026:	48 85 c9             	test   rcx,rcx
  20e029:	0f 84 a3 11 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20e02f:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20e033:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20e037:	48 89 c1             	mov    rcx,rax
  20e03a:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20e03e:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20e044:	75 f1                	jne    20e037 <openSelfDebugInfo+0x2537>
  20e046:	a8 01                	test   al,0x1
  20e048:	75 02                	jne    20e04c <openSelfDebugInfo+0x254c>
  20e04a:	ff 17                	call   QWORD PTR [rdi]
  20e04c:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20e04f:	b8 03 00 00 00       	mov    eax,0x3
  20e054:	0f 05                	syscall 
            switch (err) {
  20e056:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20e05a:	74 f3                	je     20e04f <openSelfDebugInfo+0x254f>
            const first = list.first orelse return null;
  20e05c:	48 8b 05 ed 2f 01 00 	mov    rax,QWORD PTR [rip+0x12fed]        # 221050 <emfile_promise_queue>
  20e063:	48 85 c0             	test   rax,rax
  20e066:	74 7a                	je     20e0e2 <openSelfDebugInfo+0x25e2>
            if (node.prev) |prev_node| {
  20e068:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20e06b:	48 85 c9             	test   rcx,rcx
  20e06e:	74 0e                	je     20e07e <openSelfDebugInfo+0x257e>
                prev_node.next = node.next;
  20e070:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20e074:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20e078:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e07c:	eb 0b                	jmp    20e089 <openSelfDebugInfo+0x2589>
                list.first = node.next;
  20e07e:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e082:	48 89 0d c7 2f 01 00 	mov    QWORD PTR [rip+0x12fc7],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20e089:	48 85 c9             	test   rcx,rcx
  20e08c:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20e08f:	48 8d 35 c2 2f 01 00 	lea    rsi,[rip+0x12fc2]        # 221058 <emfile_promise_queue+0x8>
  20e096:	48 0f 45 f1          	cmovne rsi,rcx
  20e09a:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20e09d:	48 83 05 bb 2f 01 00 	add    QWORD PTR [rip+0x12fbb],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20e0a4:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20e0a5:	74 1e                	je     20e0c5 <openSelfDebugInfo+0x25c5>
  20e0a7:	48 83 3d a1 2f 01 00 	cmp    QWORD PTR [rip+0x12fa1],0x0        # 221050 <emfile_promise_queue>
  20e0ae:	00 
  20e0af:	0f 84 1d 11 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20e0b5:	48 8b 0d 9c 2f 01 00 	mov    rcx,QWORD PTR [rip+0x12f9c]        # 221058 <emfile_promise_queue+0x8>
  20e0bc:	48 85 c9             	test   rcx,rcx
  20e0bf:	0f 84 0d 11 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20e0c5:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20e0c9:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20e0cd:	48 89 c1             	mov    rcx,rax
  20e0d0:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20e0d4:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20e0da:	75 f1                	jne    20e0cd <openSelfDebugInfo+0x25cd>
  20e0dc:	a8 01                	test   al,0x1
  20e0de:	75 02                	jne    20e0e2 <openSelfDebugInfo+0x25e2>
  20e0e0:	ff 17                	call   QWORD PTR [rdi]
  20e0e2:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20e0e6:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20e0ed:	00 
  20e0ee:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20e0f5:	00 c8 00 00 00 
  20e0fa:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20e101:	00 
  20e102:	4c 89 ff             	mov    rdi,r15
  20e105:	ff d0                	call   rax
            st.debug_ranges = (try st.elf.findSection(".debug_ranges"));
  20e107:	0f b7 84 24 68 02 00 	movzx  eax,WORD PTR [rsp+0x268]
  20e10e:	00 
  20e10f:	66 41 89 06          	mov    WORD PTR [r14],ax
  20e113:	48 8b 84 24 b8 03 00 	mov    rax,QWORD PTR [rsp+0x3b8]
  20e11a:	00 
  20e11b:	48 8b 8c 24 be 03 00 	mov    rcx,QWORD PTR [rsp+0x3be]
  20e122:	00 
  20e123:	e9 ce e6 ff ff       	jmp    20c7f6 <openSelfDebugInfo+0xcf6>
                list.first = node.next;
  20e128:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e12c:	48 89 0d 1d 2f 01 00 	mov    QWORD PTR [rip+0x12f1d],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20e133:	48 85 c9             	test   rcx,rcx
  20e136:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20e139:	48 8d 35 18 2f 01 00 	lea    rsi,[rip+0x12f18]        # 221058 <emfile_promise_queue+0x8>
  20e140:	48 0f 45 f1          	cmovne rsi,rcx
  20e144:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20e147:	48 83 05 11 2f 01 00 	add    QWORD PTR [rip+0x12f11],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20e14e:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20e14f:	74 1e                	je     20e16f <openSelfDebugInfo+0x266f>
  20e151:	48 83 3d f7 2e 01 00 	cmp    QWORD PTR [rip+0x12ef7],0x0        # 221050 <emfile_promise_queue>
  20e158:	00 
  20e159:	0f 84 73 10 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20e15f:	48 8b 0d f2 2e 01 00 	mov    rcx,QWORD PTR [rip+0x12ef2]        # 221058 <emfile_promise_queue+0x8>
  20e166:	48 85 c9             	test   rcx,rcx
  20e169:	0f 84 63 10 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20e16f:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20e173:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20e177:	48 89 c1             	mov    rcx,rax
  20e17a:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20e17e:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20e184:	75 f1                	jne    20e177 <openSelfDebugInfo+0x2677>
  20e186:	a8 01                	test   al,0x1
  20e188:	75 02                	jne    20e18c <openSelfDebugInfo+0x268c>
  20e18a:	ff 17                	call   QWORD PTR [rdi]
  20e18c:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20e18f:	b8 03 00 00 00       	mov    eax,0x3
  20e194:	0f 05                	syscall 
            switch (err) {
  20e196:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20e19a:	74 f3                	je     20e18f <openSelfDebugInfo+0x268f>
            const first = list.first orelse return null;
  20e19c:	48 8b 05 ad 2e 01 00 	mov    rax,QWORD PTR [rip+0x12ead]        # 221050 <emfile_promise_queue>
  20e1a3:	48 85 c0             	test   rax,rax
  20e1a6:	0f 84 d7 e9 ff ff    	je     20cb83 <openSelfDebugInfo+0x1083>
            if (node.prev) |prev_node| {
  20e1ac:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20e1af:	48 85 c9             	test   rcx,rcx
  20e1b2:	74 0e                	je     20e1c2 <openSelfDebugInfo+0x26c2>
                prev_node.next = node.next;
  20e1b4:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20e1b8:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20e1bc:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e1c0:	eb 0b                	jmp    20e1cd <openSelfDebugInfo+0x26cd>
                list.first = node.next;
  20e1c2:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e1c6:	48 89 0d 83 2e 01 00 	mov    QWORD PTR [rip+0x12e83],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20e1cd:	48 85 c9             	test   rcx,rcx
  20e1d0:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20e1d3:	48 8d 35 7e 2e 01 00 	lea    rsi,[rip+0x12e7e]        # 221058 <emfile_promise_queue+0x8>
  20e1da:	48 0f 45 f1          	cmovne rsi,rcx
  20e1de:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20e1e1:	48 83 05 77 2e 01 00 	add    QWORD PTR [rip+0x12e77],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20e1e8:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20e1e9:	74 1e                	je     20e209 <openSelfDebugInfo+0x2709>
  20e1eb:	48 83 3d 5d 2e 01 00 	cmp    QWORD PTR [rip+0x12e5d],0x0        # 221050 <emfile_promise_queue>
  20e1f2:	00 
  20e1f3:	0f 84 d9 0f 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20e1f9:	48 8b 0d 58 2e 01 00 	mov    rcx,QWORD PTR [rip+0x12e58]        # 221058 <emfile_promise_queue+0x8>
  20e200:	48 85 c9             	test   rcx,rcx
  20e203:	0f 84 c9 0f 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20e209:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20e20d:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20e211:	48 89 c1             	mov    rcx,rax
  20e214:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20e218:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20e21e:	75 f1                	jne    20e211 <openSelfDebugInfo+0x2711>
  20e220:	e9 58 e9 ff ff       	jmp    20cb7d <openSelfDebugInfo+0x107d>
  20e225:	66 b9 20 00          	mov    cx,0x20
  20e229:	89 cf                	mov    edi,ecx
  20e22b:	eb 04                	jmp    20e231 <openSelfDebugInfo+0x2731>
  20e22d:	66 bf 25 00          	mov    di,0x25
    const abbrev_code = try readULeb128(in_stream);
  20e231:	c5 fe 6f 84 24 a0 00 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa0]
  20e238:	00 00 
  20e23a:	c5 fe 6f 8c 24 b6 00 	vmovdqu ymm1,YMMWORD PTR [rsp+0xb6]
  20e241:	00 00 
  20e243:	c5 fe 7f 8c 24 26 02 	vmovdqu YMMWORD PTR [rsp+0x226],ymm1
  20e24a:	00 00 
  20e24c:	c5 fe 7f 84 24 10 02 	vmovdqu YMMWORD PTR [rsp+0x210],ymm0
  20e253:	00 00 
  20e255:	89 fd                	mov    ebp,edi
            try scanAllCompileUnits(st);
  20e257:	66 85 ff             	test   di,di
  20e25a:	0f 84 61 fd ff ff    	je     20dfc1 <openSelfDebugInfo+0x24c1>
        const bytes = @sliceToBytes(memory);
  20e260:	48 8b 43 48          	mov    rax,QWORD PTR [rbx+0x48]
  20e264:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20e268:	74 29                	je     20e293 <openSelfDebugInfo+0x2793>
  20e26a:	48 8b 7b 50          	mov    rdi,QWORD PTR [rbx+0x50]
        const bytes = @sliceToBytes(memory);
  20e26e:	48 8b 4b 40          	mov    rcx,QWORD PTR [rbx+0x40]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20e272:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20e276:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20e27d:	00 
  20e27e:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20e285:	00 
  20e286:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20e28d:	00 
  20e28e:	c5 f8 77             	vzeroupper 
  20e291:	ff d2                	call   rdx
  20e293:	80 7b 10 01          	cmp    BYTE PTR [rbx+0x10],0x1
  20e297:	0f 85 9d 00 00 00    	jne    20e33a <openSelfDebugInfo+0x283a>
  20e29d:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
  20e2a1:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20e2a4:	b8 03 00 00 00       	mov    eax,0x3
  20e2a9:	0f 05                	syscall 
            switch (err) {
  20e2ab:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20e2af:	74 f3                	je     20e2a4 <openSelfDebugInfo+0x27a4>
            const first = list.first orelse return null;
  20e2b1:	48 8b 05 98 2d 01 00 	mov    rax,QWORD PTR [rip+0x12d98]        # 221050 <emfile_promise_queue>
  20e2b8:	48 85 c0             	test   rax,rax
  20e2bb:	74 7d                	je     20e33a <openSelfDebugInfo+0x283a>
            if (node.prev) |prev_node| {
  20e2bd:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20e2c0:	48 85 c9             	test   rcx,rcx
  20e2c3:	74 0e                	je     20e2d3 <openSelfDebugInfo+0x27d3>
                prev_node.next = node.next;
  20e2c5:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20e2c9:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20e2cd:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e2d1:	eb 0b                	jmp    20e2de <openSelfDebugInfo+0x27de>
                list.first = node.next;
  20e2d3:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e2d7:	48 89 0d 72 2d 01 00 	mov    QWORD PTR [rip+0x12d72],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20e2de:	48 85 c9             	test   rcx,rcx
  20e2e1:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20e2e4:	48 8d 35 6d 2d 01 00 	lea    rsi,[rip+0x12d6d]        # 221058 <emfile_promise_queue+0x8>
  20e2eb:	48 0f 45 f1          	cmovne rsi,rcx
  20e2ef:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20e2f2:	48 83 05 66 2d 01 00 	add    QWORD PTR [rip+0x12d66],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20e2f9:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20e2fa:	74 1e                	je     20e31a <openSelfDebugInfo+0x281a>
  20e2fc:	48 83 3d 4c 2d 01 00 	cmp    QWORD PTR [rip+0x12d4c],0x0        # 221050 <emfile_promise_queue>
  20e303:	00 
  20e304:	0f 84 c8 0e 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20e30a:	48 8b 0d 47 2d 01 00 	mov    rcx,QWORD PTR [rip+0x12d47]        # 221058 <emfile_promise_queue+0x8>
  20e311:	48 85 c9             	test   rcx,rcx
  20e314:	0f 84 b8 0e 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20e31a:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20e31e:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20e322:	48 89 c1             	mov    rcx,rax
  20e325:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20e329:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20e32f:	75 f1                	jne    20e322 <openSelfDebugInfo+0x2822>
  20e331:	a8 01                	test   al,0x1
  20e333:	75 05                	jne    20e33a <openSelfDebugInfo+0x283a>
  20e335:	c5 f8 77             	vzeroupper 
  20e338:	ff 17                	call   QWORD PTR [rdi]
  20e33a:	48 63 3b             	movsxd rdi,DWORD PTR [rbx]
  20e33d:	b8 03 00 00 00       	mov    eax,0x3
  20e342:	0f 05                	syscall 
            switch (err) {
  20e344:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  20e348:	74 f3                	je     20e33d <openSelfDebugInfo+0x283d>
            const first = list.first orelse return null;
  20e34a:	48 8b 05 ff 2c 01 00 	mov    rax,QWORD PTR [rip+0x12cff]        # 221050 <emfile_promise_queue>
  20e351:	48 85 c0             	test   rax,rax
  20e354:	74 7d                	je     20e3d3 <openSelfDebugInfo+0x28d3>
            if (node.prev) |prev_node| {
  20e356:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  20e359:	48 85 c9             	test   rcx,rcx
  20e35c:	74 0e                	je     20e36c <openSelfDebugInfo+0x286c>
                prev_node.next = node.next;
  20e35e:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  20e362:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  20e366:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e36a:	eb 0b                	jmp    20e377 <openSelfDebugInfo+0x2877>
                list.first = node.next;
  20e36c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  20e370:	48 89 0d d9 2c 01 00 	mov    QWORD PTR [rip+0x12cd9],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  20e377:	48 85 c9             	test   rcx,rcx
  20e37a:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  20e37d:	48 8d 35 d4 2c 01 00 	lea    rsi,[rip+0x12cd4]        # 221058 <emfile_promise_queue+0x8>
  20e384:	48 0f 45 f1          	cmovne rsi,rcx
  20e388:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  20e38b:	48 83 05 cd 2c 01 00 	add    QWORD PTR [rip+0x12ccd],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  20e392:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  20e393:	74 1e                	je     20e3b3 <openSelfDebugInfo+0x28b3>
  20e395:	48 83 3d b3 2c 01 00 	cmp    QWORD PTR [rip+0x12cb3],0x0        # 221050 <emfile_promise_queue>
  20e39c:	00 
  20e39d:	0f 84 2f 0e 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
  20e3a3:	48 8b 0d ae 2c 01 00 	mov    rcx,QWORD PTR [rip+0x12cae]        # 221058 <emfile_promise_queue+0x8>
  20e3aa:	48 85 c9             	test   rcx,rcx
  20e3ad:	0f 84 1f 0e 00 00    	je     20f1d2 <openSelfDebugInfo+0x36d2>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  20e3b3:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  20e3b7:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20e3bb:	48 89 c1             	mov    rcx,rax
  20e3be:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  20e3c2:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  20e3c8:	75 f1                	jne    20e3bb <openSelfDebugInfo+0x28bb>
  20e3ca:	a8 01                	test   al,0x1
  20e3cc:	75 05                	jne    20e3d3 <openSelfDebugInfo+0x28d3>
  20e3ce:	c5 f8 77             	vzeroupper 
  20e3d1:	ff 17                	call   QWORD PTR [rdi]
        self.freeFn(self, non_const_ptr[0..@sizeOf(@typeOf(ptr).Child)]);
  20e3d3:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  20e3d7:	48 89 9c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rbx
  20e3de:	00 
  20e3df:	48 c7 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],0xc8
  20e3e6:	00 c8 00 00 00 
  20e3eb:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20e3f2:	00 
  20e3f3:	4c 89 ff             	mov    rdi,r15
  20e3f6:	c5 f8 77             	vzeroupper 
  20e3f9:	ff d0                	call   rax
  20e3fb:	66 41 89 2e          	mov    WORD PTR [r14],bp
  20e3ff:	48 8b 84 24 aa 03 00 	mov    rax,QWORD PTR [rsp+0x3aa]
  20e406:	00 
  20e407:	48 8b 8c 24 b0 03 00 	mov    rcx,QWORD PTR [rsp+0x3b0]
  20e40e:	00 
  20e40f:	e9 e2 e3 ff ff       	jmp    20c7f6 <openSelfDebugInfo+0xcf6>
  20e414:	66 b8 20 00          	mov    ax,0x20
  20e418:	89 c7                	mov    edi,eax
  20e41a:	89 fd                	mov    ebp,edi
  20e41c:	66 85 ff             	test   di,di
  20e41f:	0f 85 3b fe ff ff    	jne    20e260 <openSelfDebugInfo+0x2760>
  20e425:	e9 97 fb ff ff       	jmp    20dfc1 <openSelfDebugInfo+0x24c1>
    const table_entry = getAbbrevTableEntry(abbrev_table, abbrev_code) orelse return error.InvalidDebugInfo;
  20e42a:	c5 fc 10 05 56 7f ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff7f56]        # 206388 <__unnamed_58+0x18>
  20e431:	ff 
  20e432:	c5 fc 11 84 24 26 02 	vmovups YMMWORD PTR [rsp+0x226],ymm0
  20e439:	00 00 
  20e43b:	c5 fe 6f 05 2f 7f ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff7f2f]        # 206372 <__unnamed_58+0x2>
  20e442:	ff 
  20e443:	c5 fe 7f 84 24 10 02 	vmovdqu YMMWORD PTR [rsp+0x210],ymm0
  20e44a:	00 00 
  20e44c:	66 bf 25 00          	mov    di,0x25
  20e450:	89 fd                	mov    ebp,edi
            try scanAllCompileUnits(st);
  20e452:	66 85 ff             	test   di,di
  20e455:	0f 85 05 fe ff ff    	jne    20e260 <openSelfDebugInfo+0x2760>
  20e45b:	e9 61 fb ff ff       	jmp    20dfc1 <openSelfDebugInfo+0x24c1>
  20e460:	66 bf 23 00          	mov    di,0x23
  20e464:	89 fd                	mov    ebp,edi
  20e466:	66 85 ff             	test   di,di
  20e469:	0f 85 f1 fd ff ff    	jne    20e260 <openSelfDebugInfo+0x2760>
  20e46f:	e9 4d fb ff ff       	jmp    20dfc1 <openSelfDebugInfo+0x24c1>
  20e474:	66 bf 25 00          	mov    di,0x25
  20e478:	89 fd                	mov    ebp,edi
  20e47a:	66 85 ff             	test   di,di
  20e47d:	0f 85 dd fd ff ff    	jne    20e260 <openSelfDebugInfo+0x2760>
  20e483:	e9 39 fb ff ff       	jmp    20dfc1 <openSelfDebugInfo+0x24c1>
  20e488:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  20e48c:	48 83 f8 17          	cmp    rax,0x17
  20e490:	0f 87 d4 00 00 00    	ja     20e56a <openSelfDebugInfo+0x2a6a>
  20e496:	48 8d 0d 9f 2c ff ff 	lea    rcx,[rip+0xffffffffffff2c9f]        # 20113c <__unnamed_9+0x45c>
  20e49d:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  20e4a1:	48 01 c8             	add    rax,rcx
  20e4a4:	66 c7 44 24 04 22 00 	mov    WORD PTR [rsp+0x4],0x22
  20e4ab:	66 bf 02 00          	mov    di,0x2
  20e4af:	ff e0                	jmp    rax
  20e4b1:	48 8d 4a fa          	lea    rcx,[rdx-0x6]
  20e4b5:	48 83 f9 17          	cmp    rcx,0x17
  20e4b9:	0f 87 c2 00 00 00    	ja     20e581 <openSelfDebugInfo+0x2a81>
  20e4bf:	66 bf 1e 00          	mov    di,0x1e
  20e4c3:	48 8d 05 d2 2c ff ff 	lea    rax,[rip+0xffffffffffff2cd2]        # 20119c <__unnamed_9+0x4bc>
  20e4ca:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  20e4ce:	48 01 c1             	add    rcx,rax
  20e4d1:	66 c7 84 24 9e 00 00 	mov    WORD PTR [rsp+0x9e],0x22
  20e4d8:	00 22 00 
  20e4db:	ff e1                	jmp    rcx
            .value = try parseFormValue(st.allocator(), in_stream, attr.form_id, is_64),
  20e4dd:	c5 fc 10 84 24 b8 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2b8]
  20e4e4:	00 00 
  20e4e6:	c5 fc 10 8c 24 ce 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2ce]
  20e4ed:	00 00 
  20e4ef:	c5 fc 11 8c 24 26 02 	vmovups YMMWORD PTR [rsp+0x226],ymm1
  20e4f6:	00 00 
  20e4f8:	c5 fc 11 84 24 10 02 	vmovups YMMWORD PTR [rsp+0x210],ymm0
  20e4ff:	00 00 
  20e501:	89 c7                	mov    edi,eax
  20e503:	89 fd                	mov    ebp,edi
            try scanAllCompileUnits(st);
  20e505:	66 85 ff             	test   di,di
  20e508:	0f 85 52 fd ff ff    	jne    20e260 <openSelfDebugInfo+0x2760>
  20e50e:	e9 ae fa ff ff       	jmp    20dfc1 <openSelfDebugInfo+0x24c1>
  20e513:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  20e517:	48 83 f8 17          	cmp    rax,0x17
  20e51b:	77 4d                	ja     20e56a <openSelfDebugInfo+0x2a6a>
  20e51d:	48 8d 0d 38 2d ff ff 	lea    rcx,[rip+0xffffffffffff2d38]        # 20125c <__unnamed_9+0x57c>
  20e524:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  20e528:	48 01 c8             	add    rax,rcx
  20e52b:	66 c7 44 24 04 22 00 	mov    WORD PTR [rsp+0x4],0x22
  20e532:	66 bf 02 00          	mov    di,0x2
  20e536:	ff e0                	jmp    rax
  20e538:	66 bf 02 00          	mov    di,0x2
  20e53c:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  20e540:	48 83 f8 17          	cmp    rax,0x17
  20e544:	77 7c                	ja     20e5c2 <openSelfDebugInfo+0x2ac2>
  20e546:	48 8d 0d af 2c ff ff 	lea    rcx,[rip+0xffffffffffff2caf]        # 2011fc <__unnamed_9+0x51c>
  20e54d:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  20e551:	48 01 c8             	add    rax,rcx
  20e554:	ff e0                	jmp    rax
  20e556:	66 bf 22 00          	mov    di,0x22
  20e55a:	89 fd                	mov    ebp,edi
  20e55c:	66 85 ff             	test   di,di
  20e55f:	0f 85 fb fc ff ff    	jne    20e260 <openSelfDebugInfo+0x2760>
  20e565:	e9 57 fa ff ff       	jmp    20dfc1 <openSelfDebugInfo+0x24c1>
  20e56a:	66 c7 44 24 04 22 00 	mov    WORD PTR [rsp+0x4],0x22
  20e571:	66 bf 02 00          	mov    di,0x2
  20e575:	48 83 f9 4b          	cmp    rcx,0x4b
  20e579:	0f 85 d6 fc ff ff    	jne    20e255 <openSelfDebugInfo+0x2755>
  20e57f:	eb 2a                	jmp    20e5ab <openSelfDebugInfo+0x2aab>
  20e581:	66 c7 84 24 9e 00 00 	mov    WORD PTR [rsp+0x9e],0x22
  20e588:	00 22 00 
                if (err > 0) {
  20e58b:	48 83 fa 4b          	cmp    rdx,0x4b
  20e58f:	75 1a                	jne    20e5ab <openSelfDebugInfo+0x2aab>
  20e591:	0f b7 84 24 9e 00 00 	movzx  eax,WORD PTR [rsp+0x9e]
  20e598:	00 
  20e599:	89 c7                	mov    edi,eax
  20e59b:	89 fd                	mov    ebp,edi
  20e59d:	66 85 ff             	test   di,di
  20e5a0:	0f 85 ba fc ff ff    	jne    20e260 <openSelfDebugInfo+0x2760>
  20e5a6:	e9 16 fa ff ff       	jmp    20dfc1 <openSelfDebugInfo+0x24c1>
  20e5ab:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  20e5b0:	89 c7                	mov    edi,eax
  20e5b2:	89 fd                	mov    ebp,edi
  20e5b4:	66 85 ff             	test   di,di
  20e5b7:	0f 85 a3 fc ff ff    	jne    20e260 <openSelfDebugInfo+0x2760>
  20e5bd:	e9 ff f9 ff ff       	jmp    20dfc1 <openSelfDebugInfo+0x24c1>
                if (err > 0) {
  20e5c2:	48 83 f9 4b          	cmp    rcx,0x4b
  20e5c6:	0f 85 89 fc ff ff    	jne    20e255 <openSelfDebugInfo+0x2755>
  20e5cc:	eb 88                	jmp    20e556 <openSelfDebugInfo+0x2a56>
  20e5ce:	66 bf 1e 00          	mov    di,0x1e
  20e5d2:	89 fd                	mov    ebp,edi
  20e5d4:	66 85 ff             	test   di,di
  20e5d7:	0f 85 83 fc ff ff    	jne    20e260 <openSelfDebugInfo+0x2760>
  20e5dd:	e9 df f9 ff ff       	jmp    20dfc1 <openSelfDebugInfo+0x24c1>
    try result.attrs.resize(table_entry.attrs.len);
  20e5e2:	c5 fc 10 44 24 60    	vmovups ymm0,YMMWORD PTR [rsp+0x60]
  20e5e8:	c5 fc 10 4c 24 76    	vmovups ymm1,YMMWORD PTR [rsp+0x76]
  20e5ee:	e9 fc fe ff ff       	jmp    20e4ef <openSelfDebugInfo+0x29ef>
            try self.readNoEof(bytes[0..]);
  20e5f3:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e5f8:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e5fd:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20e604:	00 00 
  20e606:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e60d:	00 
  20e60e:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e613:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e618:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e61c:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e623:	00 
            const amt_read = try self.read(buf);
  20e624:	66 85 ed             	test   bp,bp
  20e627:	0f 85 7d d7 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20e62d:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e634:	00 
  20e635:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e639:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e63e:	0f 82 66 d7 ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
  20e644:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20e649:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20e64e:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e653:	74 1b                	je     20e670 <openSelfDebugInfo+0x2b70>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e655:	c1 e1 08             	shl    ecx,0x8
  20e658:	09 c1                	or     ecx,eax
  20e65a:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20e65f:	c1 e2 10             	shl    edx,0x10
  20e662:	09 ca                	or     edx,ecx
  20e664:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20e669:	c1 e0 18             	shl    eax,0x18
  20e66c:	09 d0                	or     eax,edx
  20e66e:	eb 19                	jmp    20e689 <openSelfDebugInfo+0x2b89>
                result = (result << 8) | b;
  20e670:	c1 e0 08             	shl    eax,0x8
  20e673:	09 c8                	or     eax,ecx
  20e675:	c1 e0 08             	shl    eax,0x8
  20e678:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20e67d:	09 c1                	or     ecx,eax
  20e67f:	c1 e1 08             	shl    ecx,0x8
  20e682:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20e687:	09 c8                	or     eax,ecx
            elf.entry_addr = u64(try in.readInt(elf.endian, u32));
  20e689:	89 c0                	mov    eax,eax
  20e68b:	48 89 43 18          	mov    QWORD PTR [rbx+0x18],rax
            elf.program_header_offset = u64(try in.readInt(elf.endian, u32));
  20e68f:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  20e692:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20e696:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e69b:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e6a0:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20e6a7:	00 00 
  20e6a9:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e6b0:	00 
  20e6b1:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e6b6:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e6bb:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e6bf:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e6c6:	00 
            const amt_read = try self.read(buf);
  20e6c7:	66 85 ed             	test   bp,bp
  20e6ca:	0f 85 da d6 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20e6d0:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e6d7:	00 
  20e6d8:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e6dc:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e6e1:	0f 82 c3 d6 ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
  20e6e7:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20e6ec:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20e6f1:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e6f6:	74 1b                	je     20e713 <openSelfDebugInfo+0x2c13>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e6f8:	c1 e1 08             	shl    ecx,0x8
  20e6fb:	09 c1                	or     ecx,eax
  20e6fd:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20e702:	c1 e2 10             	shl    edx,0x10
  20e705:	09 ca                	or     edx,ecx
  20e707:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20e70c:	c1 e0 18             	shl    eax,0x18
  20e70f:	09 d0                	or     eax,edx
  20e711:	eb 19                	jmp    20e72c <openSelfDebugInfo+0x2c2c>
                result = (result << 8) | b;
  20e713:	c1 e0 08             	shl    eax,0x8
  20e716:	09 c8                	or     eax,ecx
  20e718:	c1 e0 08             	shl    eax,0x8
  20e71b:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20e720:	09 c1                	or     ecx,eax
  20e722:	c1 e1 08             	shl    ecx,0x8
  20e725:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20e72a:	09 c8                	or     eax,ecx
  20e72c:	89 c0                	mov    eax,eax
  20e72e:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
            elf.section_header_offset = u64(try in.readInt(elf.endian, u32));
  20e732:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  20e735:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20e739:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e73e:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e743:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20e74a:	00 00 
  20e74c:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e753:	00 
  20e754:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e759:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e75e:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e762:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e769:	00 
            const amt_read = try self.read(buf);
  20e76a:	66 85 ed             	test   bp,bp
  20e76d:	0f 85 37 d6 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20e773:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e77a:	00 
  20e77b:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e77f:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e784:	0f 82 20 d6 ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
  20e78a:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20e78f:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20e794:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e799:	74 1b                	je     20e7b6 <openSelfDebugInfo+0x2cb6>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e79b:	c1 e1 08             	shl    ecx,0x8
  20e79e:	09 c1                	or     ecx,eax
  20e7a0:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20e7a5:	c1 e2 10             	shl    edx,0x10
  20e7a8:	09 ca                	or     edx,ecx
  20e7aa:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20e7af:	c1 e0 18             	shl    eax,0x18
  20e7b2:	09 d0                	or     eax,edx
  20e7b4:	eb 19                	jmp    20e7cf <openSelfDebugInfo+0x2ccf>
                result = (result << 8) | b;
  20e7b6:	c1 e0 08             	shl    eax,0x8
  20e7b9:	09 c8                	or     eax,ecx
  20e7bb:	c1 e0 08             	shl    eax,0x8
  20e7be:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20e7c3:	09 c1                	or     ecx,eax
  20e7c5:	c1 e1 08             	shl    ecx,0x8
  20e7c8:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20e7cd:	09 c8                	or     eax,ecx
  20e7cf:	89 c0                	mov    eax,eax
  20e7d1:	e9 5b db ff ff       	jmp    20c331 <openSelfDebugInfo+0x831>
        const ph_entry_size = try in.readInt(elf.endian, u16);
  20e7d6:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20e7db:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e7dd:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20e7e1:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e7e6:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e7eb:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20e7f2:	00 00 
  20e7f4:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e7fb:	00 
  20e7fc:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e801:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e806:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e80a:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e811:	00 
            const amt_read = try self.read(buf);
  20e812:	66 85 ed             	test   bp,bp
  20e815:	0f 85 8f d5 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20e81b:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e822:	00 
  20e823:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e827:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e82c:	0f 82 78 d5 ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
  20e832:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e837:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  20e83c:	89 c1                	mov    ecx,eax
  20e83e:	c1 e1 08             	shl    ecx,0x8
  20e841:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20e843:	c1 e2 08             	shl    edx,0x8
  20e846:	09 c2                	or     edx,eax
    switch (endian) {
  20e848:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e84d:	66 0f 45 d1          	cmovne dx,cx
  20e851:	89 54 24 48          	mov    DWORD PTR [rsp+0x48],edx
        const ph_entry_count = try in.readInt(elf.endian, u16);
  20e855:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20e85a:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e85c:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20e860:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e865:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e86a:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20e871:	00 00 
  20e873:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e87a:	00 
  20e87b:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e880:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e885:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e889:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e890:	00 
            const amt_read = try self.read(buf);
  20e891:	66 85 ed             	test   bp,bp
  20e894:	0f 85 10 d5 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20e89a:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e8a1:	00 
  20e8a2:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e8a6:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e8ab:	0f 82 f9 d4 ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
  20e8b1:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e8b6:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  20e8bb:	89 c1                	mov    ecx,eax
  20e8bd:	c1 e1 08             	shl    ecx,0x8
  20e8c0:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20e8c2:	c1 e2 08             	shl    edx,0x8
  20e8c5:	09 c2                	or     edx,eax
    switch (endian) {
  20e8c7:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e8cc:	66 0f 45 d1          	cmovne dx,cx
  20e8d0:	89 54 24 50          	mov    DWORD PTR [rsp+0x50],edx
        const sh_entry_size = try in.readInt(elf.endian, u16);
  20e8d4:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20e8d9:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e8db:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20e8df:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e8e4:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e8e9:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20e8f0:	00 00 
  20e8f2:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e8f9:	00 
  20e8fa:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e8ff:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e904:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e908:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e90f:	00 
            const amt_read = try self.read(buf);
  20e910:	66 85 ed             	test   bp,bp
  20e913:	0f 85 91 d4 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20e919:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e920:	00 
  20e921:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e925:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e92a:	0f 82 7a d4 ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
  20e930:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e935:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  20e93a:	89 c1                	mov    ecx,eax
  20e93c:	c1 e1 08             	shl    ecx,0x8
  20e93f:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20e941:	c1 e2 08             	shl    edx,0x8
  20e944:	09 c2                	or     edx,eax
    switch (endian) {
  20e946:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e94b:	66 0f 45 d1          	cmovne dx,cx
  20e94f:	89 54 24 40          	mov    DWORD PTR [rsp+0x40],edx
        const sh_entry_count = try in.readInt(elf.endian, u16);
  20e953:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20e958:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20e95a:	88 44 24 38          	mov    BYTE PTR [rsp+0x38],al
  20e95e:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e963:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e968:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20e96f:	00 00 
  20e971:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e978:	00 
  20e979:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20e97e:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20e983:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20e987:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20e98e:	00 
            const amt_read = try self.read(buf);
  20e98f:	66 85 ed             	test   bp,bp
  20e992:	0f 85 12 d4 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20e998:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20e99f:	00 
  20e9a0:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20e9a4:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20e9a9:	0f 82 fb d3 ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
  20e9af:	0f b6 54 24 08       	movzx  edx,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20e9b4:	0f b6 44 24 09       	movzx  eax,BYTE PTR [rsp+0x9]
  20e9b9:	89 c1                	mov    ecx,eax
  20e9bb:	c1 e1 08             	shl    ecx,0x8
  20e9be:	09 d1                	or     ecx,edx
                result = (result << 8) | b;
  20e9c0:	c1 e2 08             	shl    edx,0x8
  20e9c3:	09 c2                	or     edx,eax
    switch (endian) {
  20e9c5:	f6 44 24 38 01       	test   BYTE PTR [rsp+0x38],0x1
  20e9ca:	66 0f 45 d1          	cmovne dx,cx
  20e9ce:	89 54 24 38          	mov    DWORD PTR [rsp+0x38],edx
        elf.string_section_index = u64(try in.readInt(elf.endian, u16));
  20e9d2:	8a 43 12             	mov    al,BYTE PTR [rbx+0x12]
            try self.readNoEof(bytes[0..]);
  20e9d5:	88 44 24 30          	mov    BYTE PTR [rsp+0x30],al
  20e9d9:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20e9de:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20e9e3:	48 c7 44 24 68 02 00 	mov    QWORD PTR [rsp+0x68],0x2
  20e9ea:	00 00 
  20e9ec:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20e9f3:	00 
  20e9f4:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20e9f9:	48 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],rdi
            return self.readFn(self, buffer);
  20e9fe:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20ea03:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20ea07:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20ea0e:	00 
            const amt_read = try self.read(buf);
  20ea0f:	66 85 ed             	test   bp,bp
  20ea12:	0f 85 92 d3 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20ea18:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20ea1f:	00 
  20ea20:	66 bd 20 00          	mov    bp,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  20ea24:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20ea29:	0f 82 7b d3 ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
  20ea2f:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20ea34:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
  20ea39:	89 ca                	mov    edx,ecx
  20ea3b:	c1 e2 08             	shl    edx,0x8
  20ea3e:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  20ea40:	c1 e0 08             	shl    eax,0x8
  20ea43:	09 c8                	or     eax,ecx
    switch (endian) {
  20ea45:	f6 44 24 30 01       	test   BYTE PTR [rsp+0x30],0x1
  20ea4a:	66 0f 45 c2          	cmovne ax,dx
  20ea4e:	0f b7 c0             	movzx  eax,ax
  20ea51:	48 89 43 30          	mov    QWORD PTR [rbx+0x30],rax
        if (elf.string_section_index >= sh_entry_count) return error.InvalidFormat;
  20ea55:	66 3b 44 24 38       	cmp    ax,WORD PTR [rsp+0x38]
  20ea5a:	0f 83 bd d9 ff ff    	jae    20c41d <openSelfDebugInfo+0x91d>
  20ea60:	0f b7 4c 24 38       	movzx  ecx,WORD PTR [rsp+0x38]
        const sh_byte_count = u64(sh_entry_size) * u64(sh_entry_count);
  20ea65:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  20ea6a:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  20ea6f:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  20ea74:	48 0f af c1          	imul   rax,rcx
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  20ea78:	48 03 43 28          	add    rax,QWORD PTR [rbx+0x28]
  20ea7c:	73 1f                	jae    20ea9d <openSelfDebugInfo+0x2f9d>
  20ea7e:	48 8d 05 4b 1d ff ff 	lea    rax,[rip+0xffffffffffff1d4b]        # 2007d0 <__unnamed_59>
  20ea85:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  20ea8a:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20ea8f:	0f b7 28             	movzx  ebp,WORD PTR [rax]
        const end_sh = try math.add(u64, elf.section_header_offset, sh_byte_count);
  20ea92:	66 85 ed             	test   bp,bp
  20ea95:	0f 85 0f d3 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20ea9b:	eb 23                	jmp    20eac0 <openSelfDebugInfo+0x2fc0>
  20ea9d:	66 c7 84 24 a0 00 00 	mov    WORD PTR [rsp+0xa0],0x0
  20eaa4:	00 00 00 
  20eaa7:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20eaae:	00 
  20eaaf:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20eab4:	0f b7 28             	movzx  ebp,WORD PTR [rax]
  20eab7:	66 85 ed             	test   bp,bp
  20eaba:	0f 85 ea d2 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20eac0:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20eac5:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
        const ph_byte_count = u64(ph_entry_size) * u64(ph_entry_count);
  20eac9:	0f b7 44 24 48       	movzx  eax,WORD PTR [rsp+0x48]
  20eace:	0f b7 4c 24 50       	movzx  ecx,WORD PTR [rsp+0x50]
  20ead3:	48 0f af c8          	imul   rcx,rax
  20ead7:	48 03 4b 20          	add    rcx,QWORD PTR [rbx+0x20]
  20eadb:	73 15                	jae    20eaf2 <openSelfDebugInfo+0x2ff2>
  20eadd:	48 8d 05 ec 1c ff ff 	lea    rax,[rip+0xffffffffffff1cec]        # 2007d0 <__unnamed_59>
  20eae4:	0f b7 28             	movzx  ebp,WORD PTR [rax]
        const end_ph = try math.add(u64, elf.program_header_offset, ph_byte_count);
  20eae7:	66 85 ed             	test   bp,bp
  20eaea:	0f 85 ba d2 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20eaf0:	eb 26                	jmp    20eb18 <openSelfDebugInfo+0x3018>
  20eaf2:	48 8d 84 24 a0 00 00 	lea    rax,[rsp+0xa0]
  20eaf9:	00 
  20eafa:	66 c7 84 24 a0 00 00 	mov    WORD PTR [rsp+0xa0],0x0
  20eb01:	00 00 00 
  20eb04:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  20eb0b:	00 
  20eb0c:	0f b7 28             	movzx  ebp,WORD PTR [rax]
  20eb0f:	66 85 ed             	test   bp,bp
  20eb12:	0f 85 92 d2 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20eb18:	4c 8b 40 08          	mov    r8,QWORD PTR [rax+0x8]
        const stream_end = try elf.in_file.getEndPos();
  20eb1c:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
pub fn accept4(fd: i32, noalias addr: *sockaddr, noalias len: *socklen_t, flags: u32) usize {
    return syscall4(SYS_accept4, @intCast(usize, fd), @ptrToInt(addr), @ptrToInt(len), flags);
}

pub fn fstat(fd: i32, stat_buf: *Stat) usize {
    return syscall2(SYS_fstat, @intCast(usize, fd), @ptrToInt(stat_buf));
  20eb20:	48 63 38             	movsxd rdi,DWORD PTR [rax]
        }
    }
}

pub fn posixFStat(fd: i32) !posix.Stat {
    var stat: posix.Stat = undefined;
  20eb23:	c5 fc 10 05 7d 77 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff777d]        # 2062a8 <__unnamed_60+0x70>
  20eb2a:	ff 
  20eb2b:	c5 fc 11 84 24 10 01 	vmovups YMMWORD PTR [rsp+0x110],ymm0
  20eb32:	00 00 
  20eb34:	c5 fc 10 05 5c 77 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff775c]        # 206298 <__unnamed_60+0x60>
  20eb3b:	ff 
  20eb3c:	c5 fc 11 84 24 00 01 	vmovups YMMWORD PTR [rsp+0x100],ymm0
  20eb43:	00 00 
  20eb45:	c5 fc 10 05 2b 77 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff772b]        # 206278 <__unnamed_60+0x40>
  20eb4c:	ff 
  20eb4d:	c5 fc 11 84 24 e0 00 	vmovups YMMWORD PTR [rsp+0xe0],ymm0
  20eb54:	00 00 
  20eb56:	c5 fc 10 05 fa 76 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff76fa]        # 206258 <__unnamed_60+0x20>
  20eb5d:	ff 
  20eb5e:	c5 fc 11 84 24 c0 00 	vmovups YMMWORD PTR [rsp+0xc0],ymm0
  20eb65:	00 00 
  20eb67:	c5 fe 6f 05 c9 76 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff76c9]        # 206238 <__unnamed_60>
  20eb6e:	ff 
  20eb6f:	c5 fe 7f 84 24 a0 00 	vmovdqu YMMWORD PTR [rsp+0xa0],ymm0
  20eb76:	00 00 
  20eb78:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20eb7f:	00 
    return asm volatile ("syscall"
  20eb80:	b8 05 00 00 00       	mov    eax,0x5
  20eb85:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20eb87:	48 89 c6             	mov    rsi,rax
  20eb8a:	48 f7 de             	neg    rsi
  20eb8d:	31 c9                	xor    ecx,ecx
  20eb8f:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20eb95:	48 0f 47 ce          	cmova  rcx,rsi
    const err = posix.getErrno(posix.fstat(fd, &stat));
    if (err > 0) {
  20eb99:	48 85 c9             	test   rcx,rcx
  20eb9c:	74 26                	je     20ebc4 <openSelfDebugInfo+0x30c4>
  20eb9e:	48 83 f9 09          	cmp    rcx,0x9
  20eba2:	0f 84 18 06 00 00    	je     20f1c0 <openSelfDebugInfo+0x36c0>
  20eba8:	48 83 f9 0c          	cmp    rcx,0xc
  20ebac:	0f 85 28 06 00 00    	jne    20f1da <openSelfDebugInfo+0x36da>
  20ebb2:	66 bd 04 00          	mov    bp,0x4
            try st.elf.openFile(allocator, &st.self_exe_file);
  20ebb6:	66 85 ed             	test   bp,bp
  20ebb9:	0f 85 f4 d1 ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
  20ebbf:	e9 66 d8 ff ff       	jmp    20c42a <openSelfDebugInfo+0x92a>
            posix.ENOMEM => error.SystemResources,
            else => os.unexpectedErrorPosix(err),
        };
    }

    return stat;
  20ebc4:	48 8b 84 24 d0 00 00 	mov    rax,QWORD PTR [rsp+0xd0]
  20ebcb:	00 
  20ebcc:	48 89 84 24 60 01 00 	mov    QWORD PTR [rsp+0x160],rax
  20ebd3:	00 
  20ebd4:	66 bd 21 00          	mov    bp,0x21
        if (stream_end < end_sh or stream_end < end_ph) {
  20ebd8:	48 39 d0             	cmp    rax,rdx
  20ebdb:	0f 82 c9 d1 ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
  20ebe1:	4c 39 84 24 60 01 00 	cmp    QWORD PTR [rsp+0x160],r8
  20ebe8:	00 
  20ebe9:	0f 82 bb d1 ff ff    	jb     20bdaa <openSelfDebugInfo+0x2aa>
        try elf.in_file.seekTo(elf.section_header_offset);
  20ebef:	48 8b 73 28          	mov    rsi,QWORD PTR [rbx+0x28]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  20ebf3:	48 85 f6             	test   rsi,rsi
  20ebf6:	0f 88 f0 05 00 00    	js     20f1ec <openSelfDebugInfo+0x36ec>
  20ebfc:	49 8b 04 24          	mov    rax,QWORD PTR [r12]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20ec00:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20ec03:	31 ed                	xor    ebp,ebp
    return asm volatile ("syscall"
  20ec05:	b8 08 00 00 00       	mov    eax,0x8
  20ec0a:	31 d2                	xor    edx,edx
  20ec0c:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20ec0e:	48 89 c1             	mov    rcx,rax
  20ec11:	48 f7 d9             	neg    rcx
  20ec14:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20ec1a:	48 0f 46 cd          	cmovbe rcx,rbp
  20ec1e:	48 83 f9 1d          	cmp    rcx,0x1d
  20ec22:	0f 87 85 05 00 00    	ja     20f1ad <openSelfDebugInfo+0x36ad>
  20ec28:	48 8d 05 95 24 ff ff 	lea    rax,[rip+0xffffffffffff2495]        # 2010c4 <__unnamed_9+0x3e4>
  20ec2f:	48 63 0c 88          	movsxd rcx,DWORD PTR [rax+rcx*4]
  20ec33:	48 01 c1             	add    rcx,rax
  20ec36:	66 bd 02 00          	mov    bp,0x2
  20ec3a:	ff e1                	jmp    rcx
        elf.section_headers = try elf.allocator.alloc(SectionHeader, sh_entry_count);
  20ec3c:	48 8b 73 50          	mov    rsi,QWORD PTR [rbx+0x50]
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  20ec40:	48 8b 54 24 38       	mov    rdx,QWORD PTR [rsp+0x38]
  20ec45:	48 c1 e2 06          	shl    rdx,0x6
  20ec49:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20ec50:	00 
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20ec51:	b9 04 00 00 00       	mov    ecx,0x4
  20ec56:	48 89 94 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rdx
  20ec5d:	00 
  20ec5e:	c5 f8 77             	vzeroupper 
  20ec61:	ff 16                	call   QWORD PTR [rsi]
  20ec63:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20ec6a:	00 
  20ec6b:	66 85 ed             	test   bp,bp
  20ec6e:	0f 85 36 d1 ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
        assert(byte_slice.len == byte_count);
  20ec74:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  20ec7b:	00 
  20ec7c:	48 39 84 24 b0 00 00 	cmp    QWORD PTR [rsp+0xb0],rax
  20ec83:	00 
    if (!ok) {
  20ec84:	0f 85 48 05 00 00    	jne    20f1d2 <openSelfDebugInfo+0x36d2>
  20ec8a:	48 8d 43 50          	lea    rax,[rbx+0x50]
  20ec8e:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  20ec93:	48 8d 43 40          	lea    rax,[rbx+0x40]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20ec97:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  20ec9c:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20eca3:	00 
  20eca4:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20eca9:	48 89 43 40          	mov    QWORD PTR [rbx+0x40],rax
  20ecad:	48 8d 43 48          	lea    rax,[rbx+0x48]
  20ecb1:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  20ecb6:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  20ecbb:	48 89 43 48          	mov    QWORD PTR [rbx+0x48],rax
        if (elf.is_64) {
  20ecbf:	80 7b 11 01          	cmp    BYTE PTR [rbx+0x11],0x1
  20ecc3:	0f 85 35 05 00 00    	jne    20f1fe <openSelfDebugInfo+0x36fe>
            if (sh_entry_size != 64) return error.InvalidFormat;
  20ecc9:	83 7c 24 40 40       	cmp    DWORD PTR [rsp+0x40],0x40
  20ecce:	0f 85 a0 0e 00 00    	jne    20fb74 <openSelfDebugInfo+0x4074>
                elf_section.name = try in.readInt(elf.endian, u32);
  20ecd4:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20ecd9:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20ecdb:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20ecdf:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20ece4:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20ece9:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20ecf0:	00 00 
  20ecf2:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20ecf9:	00 
  20ecfa:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20ecff:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20ed04:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20ed08:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20ed0f:	00 
            const amt_read = try self.read(buf);
  20ed10:	66 85 ed             	test   bp,bp
  20ed13:	0f 85 97 0e 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20ed19:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20ed20:	00 
  20ed21:	31 c9                	xor    ecx,ecx
  20ed23:	48 89 8c 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rcx
  20ed2a:	00 
  20ed2b:	b9 38 00 00 00       	mov    ecx,0x38
  20ed30:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  20ed35:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20ed3a:	0f 82 6c 0e 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20ed40:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20ed45:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20ed4a:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20ed4f:	74 1b                	je     20ed6c <openSelfDebugInfo+0x326c>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20ed51:	c1 e1 08             	shl    ecx,0x8
  20ed54:	09 c1                	or     ecx,eax
  20ed56:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20ed5b:	c1 e2 10             	shl    edx,0x10
  20ed5e:	09 ca                	or     edx,ecx
  20ed60:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20ed65:	c1 e0 18             	shl    eax,0x18
  20ed68:	09 d0                	or     eax,edx
  20ed6a:	eb 19                	jmp    20ed85 <openSelfDebugInfo+0x3285>
                result = (result << 8) | b;
  20ed6c:	c1 e0 08             	shl    eax,0x8
  20ed6f:	09 c8                	or     eax,ecx
  20ed71:	c1 e0 08             	shl    eax,0x8
  20ed74:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20ed79:	09 c1                	or     ecx,eax
  20ed7b:	c1 e1 08             	shl    ecx,0x8
  20ed7e:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20ed83:	09 c8                	or     eax,ecx
  20ed85:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20ed8a:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20ed8f:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  20ed93:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20ed98:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20ed9b:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20ed9f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20eda4:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20eda9:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20edb0:	00 00 
            return self.readFn(self, buffer);
  20edb2:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20edb9:	00 
  20edba:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20edbf:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20edc4:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20edc8:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20edcf:	00 
            const amt_read = try self.read(buf);
  20edd0:	66 85 ed             	test   bp,bp
  20edd3:	0f 85 d7 0d 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20edd9:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20ede0:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20ede1:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20ede6:	0f 82 c0 0d 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20edec:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20edf1:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20edf6:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20edfb:	74 1b                	je     20ee18 <openSelfDebugInfo+0x3318>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20edfd:	c1 e1 08             	shl    ecx,0x8
  20ee00:	09 c1                	or     ecx,eax
  20ee02:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20ee07:	c1 e2 10             	shl    edx,0x10
  20ee0a:	09 ca                	or     edx,ecx
  20ee0c:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20ee11:	c1 e0 18             	shl    eax,0x18
  20ee14:	09 d0                	or     eax,edx
  20ee16:	eb 19                	jmp    20ee31 <openSelfDebugInfo+0x3331>
                result = (result << 8) | b;
  20ee18:	c1 e0 08             	shl    eax,0x8
  20ee1b:	09 c8                	or     eax,ecx
  20ee1d:	c1 e0 08             	shl    eax,0x8
  20ee20:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20ee25:	09 c1                	or     ecx,eax
  20ee27:	c1 e1 08             	shl    ecx,0x8
  20ee2a:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20ee2f:	09 c8                	or     eax,ecx
  20ee31:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20ee36:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20ee3b:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = try in.readInt(elf.endian, u64);
  20ee3f:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20ee44:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20ee47:	48 8d bc 24 48 03 00 	lea    rdi,[rsp+0x348]
  20ee4e:	00 
  20ee4f:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20ee54:	e8 97 15 00 00       	call   2103f0 <InStream(ReadError)_readInt.33>
  20ee59:	0f b7 ac 24 48 03 00 	movzx  ebp,WORD PTR [rsp+0x348]
  20ee60:	00 
  20ee61:	66 85 ed             	test   bp,bp
  20ee64:	0f 85 06 0b 00 00    	jne    20f970 <openSelfDebugInfo+0x3e70>
  20ee6a:	48 8b 84 24 50 03 00 	mov    rax,QWORD PTR [rsp+0x350]
  20ee71:	00 
  20ee72:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20ee77:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20ee7c:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = try in.readInt(elf.endian, u64);
  20ee81:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20ee86:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20ee89:	48 8d bc 24 10 03 00 	lea    rdi,[rsp+0x310]
  20ee90:	00 
  20ee91:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20ee96:	e8 55 15 00 00       	call   2103f0 <InStream(ReadError)_readInt.33>
  20ee9b:	0f b7 ac 24 10 03 00 	movzx  ebp,WORD PTR [rsp+0x310]
  20eea2:	00 
  20eea3:	66 85 ed             	test   bp,bp
  20eea6:	0f 85 1a 0b 00 00    	jne    20f9c6 <openSelfDebugInfo+0x3ec6>
  20eeac:	48 8b 84 24 18 03 00 	mov    rax,QWORD PTR [rsp+0x318]
  20eeb3:	00 
  20eeb4:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20eeb9:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20eebe:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = try in.readInt(elf.endian, u64);
  20eec3:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20eec8:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20eecb:	48 8d bc 24 f0 02 00 	lea    rdi,[rsp+0x2f0]
  20eed2:	00 
  20eed3:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20eed8:	e8 13 15 00 00       	call   2103f0 <InStream(ReadError)_readInt.33>
  20eedd:	0f b7 ac 24 f0 02 00 	movzx  ebp,WORD PTR [rsp+0x2f0]
  20eee4:	00 
  20eee5:	66 85 ed             	test   bp,bp
  20eee8:	0f 85 2e 0b 00 00    	jne    20fa1c <openSelfDebugInfo+0x3f1c>
  20eeee:	48 8b 84 24 f8 02 00 	mov    rax,QWORD PTR [rsp+0x2f8]
  20eef5:	00 
  20eef6:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20eefb:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20ef00:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = try in.readInt(elf.endian, u64);
  20ef05:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20ef0a:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20ef0d:	48 8d bc 24 88 01 00 	lea    rdi,[rsp+0x188]
  20ef14:	00 
  20ef15:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20ef1a:	e8 d1 14 00 00       	call   2103f0 <InStream(ReadError)_readInt.33>
  20ef1f:	0f b7 ac 24 88 01 00 	movzx  ebp,WORD PTR [rsp+0x188]
  20ef26:	00 
  20ef27:	66 85 ed             	test   bp,bp
  20ef2a:	0f 85 42 0b 00 00    	jne    20fa72 <openSelfDebugInfo+0x3f72>
  20ef30:	48 8b 84 24 90 01 00 	mov    rax,QWORD PTR [rsp+0x190]
  20ef37:	00 
  20ef38:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20ef3d:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20ef42:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  20ef47:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20ef4c:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20ef4f:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20ef53:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20ef58:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20ef5d:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20ef64:	00 00 
            return self.readFn(self, buffer);
  20ef66:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20ef6d:	00 
  20ef6e:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20ef73:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20ef78:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20ef7c:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20ef83:	00 
            const amt_read = try self.read(buf);
  20ef84:	66 85 ed             	test   bp,bp
  20ef87:	0f 85 23 0c 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20ef8d:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20ef94:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20ef95:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20ef9a:	0f 82 0c 0c 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20efa0:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20efa5:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20efaa:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20efaf:	74 1b                	je     20efcc <openSelfDebugInfo+0x34cc>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20efb1:	c1 e1 08             	shl    ecx,0x8
  20efb4:	09 c1                	or     ecx,eax
  20efb6:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20efbb:	c1 e2 10             	shl    edx,0x10
  20efbe:	09 ca                	or     edx,ecx
  20efc0:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20efc5:	c1 e0 18             	shl    eax,0x18
  20efc8:	09 d0                	or     eax,edx
  20efca:	eb 19                	jmp    20efe5 <openSelfDebugInfo+0x34e5>
                result = (result << 8) | b;
  20efcc:	c1 e0 08             	shl    eax,0x8
  20efcf:	09 c8                	or     eax,ecx
  20efd1:	c1 e0 08             	shl    eax,0x8
  20efd4:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20efd9:	09 c1                	or     ecx,eax
  20efdb:	c1 e1 08             	shl    ecx,0x8
  20efde:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20efe3:	09 c8                	or     eax,ecx
  20efe5:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20efea:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20efef:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  20eff3:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20eff8:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20effb:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20efff:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f004:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f009:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f010:	00 00 
            return self.readFn(self, buffer);
  20f012:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f019:	00 
  20f01a:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f01f:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f024:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f028:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f02f:	00 
            const amt_read = try self.read(buf);
  20f030:	66 85 ed             	test   bp,bp
  20f033:	0f 85 77 0b 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20f039:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f040:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f041:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f046:	0f 82 60 0b 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20f04c:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f051:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f056:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f05b:	74 1b                	je     20f078 <openSelfDebugInfo+0x3578>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f05d:	c1 e1 08             	shl    ecx,0x8
  20f060:	09 c1                	or     ecx,eax
  20f062:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f067:	c1 e2 10             	shl    edx,0x10
  20f06a:	09 ca                	or     edx,ecx
  20f06c:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f071:	c1 e0 18             	shl    eax,0x18
  20f074:	09 d0                	or     eax,edx
  20f076:	eb 19                	jmp    20f091 <openSelfDebugInfo+0x3591>
                result = (result << 8) | b;
  20f078:	c1 e0 08             	shl    eax,0x8
  20f07b:	09 c8                	or     eax,ecx
  20f07d:	c1 e0 08             	shl    eax,0x8
  20f080:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f085:	09 c1                	or     ecx,eax
  20f087:	c1 e1 08             	shl    ecx,0x8
  20f08a:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f08f:	09 c8                	or     eax,ecx
  20f091:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f096:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f09b:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  20f09f:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f0a4:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20f0a7:	48 8d bc 24 c0 01 00 	lea    rdi,[rsp+0x1c0]
  20f0ae:	00 
  20f0af:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f0b4:	e8 37 13 00 00       	call   2103f0 <InStream(ReadError)_readInt.33>
  20f0b9:	0f b7 ac 24 c0 01 00 	movzx  ebp,WORD PTR [rsp+0x1c0]
  20f0c0:	00 
  20f0c1:	66 85 ed             	test   bp,bp
  20f0c4:	0f 85 fe 09 00 00    	jne    20fac8 <openSelfDebugInfo+0x3fc8>
  20f0ca:	48 8b 84 24 c8 01 00 	mov    rax,QWORD PTR [rsp+0x1c8]
  20f0d1:	00 
  20f0d2:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f0d7:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f0dc:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  20f0e1:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f0e6:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  20f0e9:	48 8d bc 24 a0 01 00 	lea    rdi,[rsp+0x1a0]
  20f0f0:	00 
  20f0f1:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f0f6:	e8 f5 12 00 00       	call   2103f0 <InStream(ReadError)_readInt.33>
  20f0fb:	0f b7 ac 24 a0 01 00 	movzx  ebp,WORD PTR [rsp+0x1a0]
  20f102:	00 
  20f103:	66 85 ed             	test   bp,bp
  20f106:	0f 85 12 0a 00 00    	jne    20fb1e <openSelfDebugInfo+0x401e>
  20f10c:	48 8b 84 24 a8 01 00 	mov    rax,QWORD PTR [rsp+0x1a8]
  20f113:	00 
  20f114:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f119:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f11e:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  20f122:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  20f129:	00 
  20f12a:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  20f12d:	48 83 c1 01          	add    rcx,0x1
  20f131:	48 89 c8             	mov    rax,rcx
  20f134:	48 89 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rax
  20f13b:	00 
  20f13c:	48 3b 4c 24 38       	cmp    rcx,QWORD PTR [rsp+0x38]
  20f141:	0f 83 90 0a 00 00    	jae    20fbd7 <openSelfDebugInfo+0x40d7>
  20f147:	48 83 44 24 40 40    	add    QWORD PTR [rsp+0x40],0x40
  20f14d:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  20f152:	48 8b 00             	mov    rax,QWORD PTR [rax]
                elf_section.name = try in.readInt(elf.endian, u32);
  20f155:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20f15a:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f15f:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f162:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f166:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f16b:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f170:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f177:	00 00 
            return self.readFn(self, buffer);
  20f179:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f180:	00 
  20f181:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f186:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f18b:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f18f:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f196:	00 
  20f197:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f19e:	00 
            const amt_read = try self.read(buf);
  20f19f:	66 85 ed             	test   bp,bp
  20f1a2:	0f 84 8d fb ff ff    	je     20ed35 <openSelfDebugInfo+0x3235>
  20f1a8:	e9 03 0a 00 00       	jmp    20fbb0 <openSelfDebugInfo+0x40b0>
  20f1ad:	66 bd 02 00          	mov    bp,0x2
  20f1b1:	48 83 f9 4b          	cmp    rcx,0x4b
  20f1b5:	0f 85 ef cb ff ff    	jne    20bdaa <openSelfDebugInfo+0x2aa>
  20f1bb:	e9 b6 ce ff ff       	jmp    20c076 <openSelfDebugInfo+0x576>
  20f1c0:	66 bd 1e 00          	mov    bp,0x1e
            try st.elf.openFile(allocator, &st.self_exe_file);
  20f1c4:	66 85 ed             	test   bp,bp
  20f1c7:	0f 85 e6 cb ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
  20f1cd:	e9 58 d2 ff ff       	jmp    20c42a <openSelfDebugInfo+0x92a>
            @panic("assertion failure");
  20f1d2:	c5 f8 77             	vzeroupper 
  20f1d5:	e8 d6 aa ff ff       	call   209cb0 <panic>
  20f1da:	66 bd 02 00          	mov    bp,0x2
            try st.elf.openFile(allocator, &st.self_exe_file);
  20f1de:	66 85 ed             	test   bp,bp
  20f1e1:	0f 85 cc cb ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
  20f1e7:	e9 3e d2 ff ff       	jmp    20c42a <openSelfDebugInfo+0x92a>
  20f1ec:	66 bd 23 00          	mov    bp,0x23
  20f1f0:	66 85 ed             	test   bp,bp
  20f1f3:	0f 85 ba cb ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
  20f1f9:	e9 2c d2 ff ff       	jmp    20c42a <openSelfDebugInfo+0x92a>
            if (sh_entry_size != 40) return error.InvalidFormat;
  20f1fe:	83 7c 24 40 28       	cmp    DWORD PTR [rsp+0x40],0x28
  20f203:	0f 85 6b 09 00 00    	jne    20fb74 <openSelfDebugInfo+0x4074>
                elf_section.name = try in.readInt(elf.endian, u32);
  20f209:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f20e:	8a 00                	mov    al,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f210:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f214:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f219:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f21e:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f225:	00 00 
  20f227:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f22e:	00 
  20f22f:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
            return self.readFn(self, buffer);
  20f234:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f239:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f23d:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f244:	00 
            const amt_read = try self.read(buf);
  20f245:	66 85 ed             	test   bp,bp
  20f248:	0f 85 62 09 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20f24e:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f255:	00 
  20f256:	31 c9                	xor    ecx,ecx
  20f258:	48 89 8c 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rcx
  20f25f:	00 
  20f260:	b9 38 00 00 00       	mov    ecx,0x38
  20f265:	48 89 4c 24 40       	mov    QWORD PTR [rsp+0x40],rcx
            if (amt_read < buf.len) return error.EndOfStream;
  20f26a:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f26f:	0f 82 37 09 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20f275:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f27a:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f27f:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f284:	74 1b                	je     20f2a1 <openSelfDebugInfo+0x37a1>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f286:	c1 e1 08             	shl    ecx,0x8
  20f289:	09 c1                	or     ecx,eax
  20f28b:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f290:	c1 e2 10             	shl    edx,0x10
  20f293:	09 ca                	or     edx,ecx
  20f295:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f29a:	c1 e0 18             	shl    eax,0x18
  20f29d:	09 d0                	or     eax,edx
  20f29f:	eb 19                	jmp    20f2ba <openSelfDebugInfo+0x37ba>
                result = (result << 8) | b;
  20f2a1:	c1 e0 08             	shl    eax,0x8
  20f2a4:	09 c8                	or     eax,ecx
  20f2a6:	c1 e0 08             	shl    eax,0x8
  20f2a9:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f2ae:	09 c1                	or     ecx,eax
  20f2b0:	c1 e1 08             	shl    ecx,0x8
  20f2b3:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f2b8:	09 c8                	or     eax,ecx
  20f2ba:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f2bf:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f2c4:	89 44 11 c8          	mov    DWORD PTR [rcx+rdx*1-0x38],eax
                elf_section.sh_type = try in.readInt(elf.endian, u32);
  20f2c8:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f2cd:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f2d0:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f2d4:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f2d9:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f2de:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f2e5:	00 00 
            return self.readFn(self, buffer);
  20f2e7:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f2ee:	00 
  20f2ef:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f2f4:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f2f9:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f2fd:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f304:	00 
            const amt_read = try self.read(buf);
  20f305:	66 85 ed             	test   bp,bp
  20f308:	0f 85 a2 08 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20f30e:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f315:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f316:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f31b:	0f 82 8b 08 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20f321:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f326:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f32b:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f330:	74 1b                	je     20f34d <openSelfDebugInfo+0x384d>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f332:	c1 e1 08             	shl    ecx,0x8
  20f335:	09 c1                	or     ecx,eax
  20f337:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f33c:	c1 e2 10             	shl    edx,0x10
  20f33f:	09 ca                	or     edx,ecx
  20f341:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f346:	c1 e0 18             	shl    eax,0x18
  20f349:	09 d0                	or     eax,edx
  20f34b:	eb 19                	jmp    20f366 <openSelfDebugInfo+0x3866>
                result = (result << 8) | b;
  20f34d:	c1 e0 08             	shl    eax,0x8
  20f350:	09 c8                	or     eax,ecx
  20f352:	c1 e0 08             	shl    eax,0x8
  20f355:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f35a:	09 c1                	or     ecx,eax
  20f35c:	c1 e1 08             	shl    ecx,0x8
  20f35f:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f364:	09 c8                	or     eax,ecx
  20f366:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f36b:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f370:	89 44 11 cc          	mov    DWORD PTR [rcx+rdx*1-0x34],eax
                elf_section.flags = u64(try in.readInt(elf.endian, u32));
  20f374:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f379:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f37c:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f380:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f385:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f38a:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f391:	00 00 
            return self.readFn(self, buffer);
  20f393:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f39a:	00 
  20f39b:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f3a0:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f3a5:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f3a9:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f3b0:	00 
            const amt_read = try self.read(buf);
  20f3b1:	66 85 ed             	test   bp,bp
  20f3b4:	0f 85 f6 07 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20f3ba:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f3c1:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f3c2:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f3c7:	0f 82 df 07 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20f3cd:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f3d2:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f3d7:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f3dc:	74 1b                	je     20f3f9 <openSelfDebugInfo+0x38f9>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f3de:	c1 e1 08             	shl    ecx,0x8
  20f3e1:	09 c1                	or     ecx,eax
  20f3e3:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f3e8:	c1 e2 10             	shl    edx,0x10
  20f3eb:	09 ca                	or     edx,ecx
  20f3ed:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f3f2:	c1 e0 18             	shl    eax,0x18
  20f3f5:	09 d0                	or     eax,edx
  20f3f7:	eb 19                	jmp    20f412 <openSelfDebugInfo+0x3912>
                result = (result << 8) | b;
  20f3f9:	c1 e0 08             	shl    eax,0x8
  20f3fc:	09 c8                	or     eax,ecx
  20f3fe:	c1 e0 08             	shl    eax,0x8
  20f401:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f406:	09 c1                	or     ecx,eax
  20f408:	c1 e1 08             	shl    ecx,0x8
  20f40b:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f410:	09 c8                	or     eax,ecx
  20f412:	89 c0                	mov    eax,eax
  20f414:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f419:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f41e:	48 89 44 11 d0       	mov    QWORD PTR [rcx+rdx*1-0x30],rax
                elf_section.addr = u64(try in.readInt(elf.endian, u32));
  20f423:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f428:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f42b:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f42f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f434:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f439:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f440:	00 00 
            return self.readFn(self, buffer);
  20f442:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f449:	00 
  20f44a:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f44f:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f454:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f458:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f45f:	00 
            const amt_read = try self.read(buf);
  20f460:	66 85 ed             	test   bp,bp
  20f463:	0f 85 47 07 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20f469:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f470:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f471:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f476:	0f 82 30 07 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20f47c:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f481:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f486:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f48b:	74 1b                	je     20f4a8 <openSelfDebugInfo+0x39a8>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f48d:	c1 e1 08             	shl    ecx,0x8
  20f490:	09 c1                	or     ecx,eax
  20f492:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f497:	c1 e2 10             	shl    edx,0x10
  20f49a:	09 ca                	or     edx,ecx
  20f49c:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f4a1:	c1 e0 18             	shl    eax,0x18
  20f4a4:	09 d0                	or     eax,edx
  20f4a6:	eb 19                	jmp    20f4c1 <openSelfDebugInfo+0x39c1>
                result = (result << 8) | b;
  20f4a8:	c1 e0 08             	shl    eax,0x8
  20f4ab:	09 c8                	or     eax,ecx
  20f4ad:	c1 e0 08             	shl    eax,0x8
  20f4b0:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f4b5:	09 c1                	or     ecx,eax
  20f4b7:	c1 e1 08             	shl    ecx,0x8
  20f4ba:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f4bf:	09 c8                	or     eax,ecx
  20f4c1:	89 c0                	mov    eax,eax
  20f4c3:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f4c8:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f4cd:	48 89 44 11 d8       	mov    QWORD PTR [rcx+rdx*1-0x28],rax
                elf_section.offset = u64(try in.readInt(elf.endian, u32));
  20f4d2:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f4d7:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f4da:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f4de:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f4e3:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f4e8:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f4ef:	00 00 
            return self.readFn(self, buffer);
  20f4f1:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f4f8:	00 
  20f4f9:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f4fe:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f503:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f507:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f50e:	00 
            const amt_read = try self.read(buf);
  20f50f:	66 85 ed             	test   bp,bp
  20f512:	0f 85 98 06 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20f518:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f51f:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f520:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f525:	0f 82 81 06 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20f52b:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f530:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f535:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f53a:	74 1b                	je     20f557 <openSelfDebugInfo+0x3a57>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f53c:	c1 e1 08             	shl    ecx,0x8
  20f53f:	09 c1                	or     ecx,eax
  20f541:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f546:	c1 e2 10             	shl    edx,0x10
  20f549:	09 ca                	or     edx,ecx
  20f54b:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f550:	c1 e0 18             	shl    eax,0x18
  20f553:	09 d0                	or     eax,edx
  20f555:	eb 19                	jmp    20f570 <openSelfDebugInfo+0x3a70>
                result = (result << 8) | b;
  20f557:	c1 e0 08             	shl    eax,0x8
  20f55a:	09 c8                	or     eax,ecx
  20f55c:	c1 e0 08             	shl    eax,0x8
  20f55f:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f564:	09 c1                	or     ecx,eax
  20f566:	c1 e1 08             	shl    ecx,0x8
  20f569:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f56e:	09 c8                	or     eax,ecx
  20f570:	89 c0                	mov    eax,eax
  20f572:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f577:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f57c:	48 89 44 11 e0       	mov    QWORD PTR [rcx+rdx*1-0x20],rax
                elf_section.size = u64(try in.readInt(elf.endian, u32));
  20f581:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f586:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f589:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f58d:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f592:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f597:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f59e:	00 00 
            return self.readFn(self, buffer);
  20f5a0:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f5a7:	00 
  20f5a8:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f5ad:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f5b2:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f5b6:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f5bd:	00 
            const amt_read = try self.read(buf);
  20f5be:	66 85 ed             	test   bp,bp
  20f5c1:	0f 85 e9 05 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20f5c7:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f5ce:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f5cf:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f5d4:	0f 82 d2 05 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20f5da:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f5df:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f5e4:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f5e9:	74 1b                	je     20f606 <openSelfDebugInfo+0x3b06>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f5eb:	c1 e1 08             	shl    ecx,0x8
  20f5ee:	09 c1                	or     ecx,eax
  20f5f0:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f5f5:	c1 e2 10             	shl    edx,0x10
  20f5f8:	09 ca                	or     edx,ecx
  20f5fa:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f5ff:	c1 e0 18             	shl    eax,0x18
  20f602:	09 d0                	or     eax,edx
  20f604:	eb 19                	jmp    20f61f <openSelfDebugInfo+0x3b1f>
                result = (result << 8) | b;
  20f606:	c1 e0 08             	shl    eax,0x8
  20f609:	09 c8                	or     eax,ecx
  20f60b:	c1 e0 08             	shl    eax,0x8
  20f60e:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f613:	09 c1                	or     ecx,eax
  20f615:	c1 e1 08             	shl    ecx,0x8
  20f618:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f61d:	09 c8                	or     eax,ecx
  20f61f:	89 c0                	mov    eax,eax
  20f621:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f626:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f62b:	48 89 44 11 e8       	mov    QWORD PTR [rcx+rdx*1-0x18],rax
                elf_section.link = try in.readInt(elf.endian, u32);
  20f630:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f635:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f638:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f63c:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f641:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f646:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f64d:	00 00 
            return self.readFn(self, buffer);
  20f64f:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f656:	00 
  20f657:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f65c:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f661:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f665:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f66c:	00 
            const amt_read = try self.read(buf);
  20f66d:	66 85 ed             	test   bp,bp
  20f670:	0f 85 3a 05 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20f676:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f67d:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f67e:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f683:	0f 82 23 05 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20f689:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f68e:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f693:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f698:	74 1b                	je     20f6b5 <openSelfDebugInfo+0x3bb5>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f69a:	c1 e1 08             	shl    ecx,0x8
  20f69d:	09 c1                	or     ecx,eax
  20f69f:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f6a4:	c1 e2 10             	shl    edx,0x10
  20f6a7:	09 ca                	or     edx,ecx
  20f6a9:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f6ae:	c1 e0 18             	shl    eax,0x18
  20f6b1:	09 d0                	or     eax,edx
  20f6b3:	eb 19                	jmp    20f6ce <openSelfDebugInfo+0x3bce>
                result = (result << 8) | b;
  20f6b5:	c1 e0 08             	shl    eax,0x8
  20f6b8:	09 c8                	or     eax,ecx
  20f6ba:	c1 e0 08             	shl    eax,0x8
  20f6bd:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f6c2:	09 c1                	or     ecx,eax
  20f6c4:	c1 e1 08             	shl    ecx,0x8
  20f6c7:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f6cc:	09 c8                	or     eax,ecx
  20f6ce:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f6d3:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f6d8:	89 44 11 f0          	mov    DWORD PTR [rcx+rdx*1-0x10],eax
                elf_section.info = try in.readInt(elf.endian, u32);
  20f6dc:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f6e1:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f6e4:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f6e8:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f6ed:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f6f2:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f6f9:	00 00 
            return self.readFn(self, buffer);
  20f6fb:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f702:	00 
  20f703:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f708:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f70d:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f711:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f718:	00 
            const amt_read = try self.read(buf);
  20f719:	66 85 ed             	test   bp,bp
  20f71c:	0f 85 8e 04 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20f722:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f729:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f72a:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f72f:	0f 82 77 04 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20f735:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f73a:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f73f:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f744:	74 1b                	je     20f761 <openSelfDebugInfo+0x3c61>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f746:	c1 e1 08             	shl    ecx,0x8
  20f749:	09 c1                	or     ecx,eax
  20f74b:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f750:	c1 e2 10             	shl    edx,0x10
  20f753:	09 ca                	or     edx,ecx
  20f755:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f75a:	c1 e0 18             	shl    eax,0x18
  20f75d:	09 d0                	or     eax,edx
  20f75f:	eb 19                	jmp    20f77a <openSelfDebugInfo+0x3c7a>
                result = (result << 8) | b;
  20f761:	c1 e0 08             	shl    eax,0x8
  20f764:	09 c8                	or     eax,ecx
  20f766:	c1 e0 08             	shl    eax,0x8
  20f769:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f76e:	09 c1                	or     ecx,eax
  20f770:	c1 e1 08             	shl    ecx,0x8
  20f773:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f778:	09 c8                	or     eax,ecx
  20f77a:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f77f:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f784:	89 44 11 f4          	mov    DWORD PTR [rcx+rdx*1-0xc],eax
                elf_section.addr_align = u64(try in.readInt(elf.endian, u32));
  20f788:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f78d:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f790:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f794:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f799:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f79e:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f7a5:	00 00 
            return self.readFn(self, buffer);
  20f7a7:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f7ae:	00 
  20f7af:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f7b4:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f7b9:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f7bd:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f7c4:	00 
            const amt_read = try self.read(buf);
  20f7c5:	66 85 ed             	test   bp,bp
  20f7c8:	0f 85 e2 03 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20f7ce:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f7d5:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f7d6:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f7db:	0f 82 cb 03 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20f7e1:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f7e6:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f7eb:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f7f0:	74 1b                	je     20f80d <openSelfDebugInfo+0x3d0d>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f7f2:	c1 e1 08             	shl    ecx,0x8
  20f7f5:	09 c1                	or     ecx,eax
  20f7f7:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f7fc:	c1 e2 10             	shl    edx,0x10
  20f7ff:	09 ca                	or     edx,ecx
  20f801:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f806:	c1 e0 18             	shl    eax,0x18
  20f809:	09 d0                	or     eax,edx
  20f80b:	eb 19                	jmp    20f826 <openSelfDebugInfo+0x3d26>
                result = (result << 8) | b;
  20f80d:	c1 e0 08             	shl    eax,0x8
  20f810:	09 c8                	or     eax,ecx
  20f812:	c1 e0 08             	shl    eax,0x8
  20f815:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f81a:	09 c1                	or     ecx,eax
  20f81c:	c1 e1 08             	shl    ecx,0x8
  20f81f:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f824:	09 c8                	or     eax,ecx
  20f826:	89 c0                	mov    eax,eax
  20f828:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f82d:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f832:	48 89 44 11 f8       	mov    QWORD PTR [rcx+rdx*1-0x8],rax
                elf_section.ent_size = u64(try in.readInt(elf.endian, u32));
  20f837:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f83c:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f83f:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f843:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f848:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f84d:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f854:	00 00 
            return self.readFn(self, buffer);
  20f856:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f85d:	00 
  20f85e:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f863:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f868:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f86c:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f873:	00 
            const amt_read = try self.read(buf);
  20f874:	66 85 ed             	test   bp,bp
  20f877:	0f 85 33 03 00 00    	jne    20fbb0 <openSelfDebugInfo+0x40b0>
  20f87d:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f884:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  20f885:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  20f88a:	0f 82 1c 03 00 00    	jb     20fbac <openSelfDebugInfo+0x40ac>
  20f890:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  20f895:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  20f89a:	f6 44 24 04 01       	test   BYTE PTR [rsp+0x4],0x1
  20f89f:	74 1b                	je     20f8bc <openSelfDebugInfo+0x3dbc>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  20f8a1:	c1 e1 08             	shl    ecx,0x8
  20f8a4:	09 c1                	or     ecx,eax
  20f8a6:	0f b6 54 24 0a       	movzx  edx,BYTE PTR [rsp+0xa]
  20f8ab:	c1 e2 10             	shl    edx,0x10
  20f8ae:	09 ca                	or     edx,ecx
  20f8b0:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f8b5:	c1 e0 18             	shl    eax,0x18
  20f8b8:	09 d0                	or     eax,edx
  20f8ba:	eb 19                	jmp    20f8d5 <openSelfDebugInfo+0x3dd5>
                result = (result << 8) | b;
  20f8bc:	c1 e0 08             	shl    eax,0x8
  20f8bf:	09 c8                	or     eax,ecx
  20f8c1:	c1 e0 08             	shl    eax,0x8
  20f8c4:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  20f8c9:	09 c1                	or     ecx,eax
  20f8cb:	c1 e1 08             	shl    ecx,0x8
  20f8ce:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  20f8d3:	09 c8                	or     eax,ecx
  20f8d5:	89 c0                	mov    eax,eax
  20f8d7:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20f8dc:	48 8b 54 24 40       	mov    rdx,QWORD PTR [rsp+0x40]
  20f8e1:	48 89 04 11          	mov    QWORD PTR [rcx+rdx*1],rax
  20f8e5:	48 8b 84 24 38 01 00 	mov    rax,QWORD PTR [rsp+0x138]
  20f8ec:	00 
  20f8ed:	48 89 c1             	mov    rcx,rax
            for (elf.section_headers) |*elf_section| {
  20f8f0:	48 83 c1 01          	add    rcx,0x1
  20f8f4:	48 89 c8             	mov    rax,rcx
  20f8f7:	48 89 84 24 38 01 00 	mov    QWORD PTR [rsp+0x138],rax
  20f8fe:	00 
  20f8ff:	48 3b 4c 24 38       	cmp    rcx,QWORD PTR [rsp+0x38]
  20f904:	0f 83 cd 02 00 00    	jae    20fbd7 <openSelfDebugInfo+0x40d7>
  20f90a:	48 83 44 24 40 40    	add    QWORD PTR [rsp+0x40],0x40
  20f910:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  20f915:	48 8b 00             	mov    rax,QWORD PTR [rax]
                elf_section.name = try in.readInt(elf.endian, u32);
  20f918:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  20f91d:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  20f922:	0f b6 00             	movzx  eax,BYTE PTR [rax]
            try self.readNoEof(bytes[0..]);
  20f925:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  20f929:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  20f92e:	48 89 44 24 60       	mov    QWORD PTR [rsp+0x60],rax
  20f933:	48 c7 44 24 68 04 00 	mov    QWORD PTR [rsp+0x68],0x4
  20f93a:	00 00 
            return self.readFn(self, buffer);
  20f93c:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20f943:	00 
  20f944:	48 8d 74 24 28       	lea    rsi,[rsp+0x28]
  20f949:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  20f94e:	ff 54 24 28          	call   QWORD PTR [rsp+0x28]
  20f952:	0f b7 ac 24 a0 00 00 	movzx  ebp,WORD PTR [rsp+0xa0]
  20f959:	00 
  20f95a:	48 8b 84 24 a8 00 00 	mov    rax,QWORD PTR [rsp+0xa8]
  20f961:	00 
            const amt_read = try self.read(buf);
  20f962:	66 85 ed             	test   bp,bp
  20f965:	0f 84 ff f8 ff ff    	je     20f26a <openSelfDebugInfo+0x376a>
  20f96b:	e9 40 02 00 00       	jmp    20fbb0 <openSelfDebugInfo+0x40b0>
        const bytes = @sliceToBytes(memory);
  20f970:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20f975:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f978:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f97c:	0f 84 28 c4 ff ff    	je     20bdaa <openSelfDebugInfo+0x2aa>
  20f982:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20f987:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20f98a:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20f98f:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f992:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20f996:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20f99d:	00 
  20f99e:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20f9a5:	00 
  20f9a6:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20f9ad:	00 
  20f9ae:	ff d2                	call   rdx
                elf_section.flags = try in.readInt(elf.endian, u64);
  20f9b0:	0f b7 ac 24 48 03 00 	movzx  ebp,WORD PTR [rsp+0x348]
  20f9b7:	00 
  20f9b8:	66 85 ed             	test   bp,bp
  20f9bb:	0f 85 f2 c3 ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
  20f9c1:	e9 64 ca ff ff       	jmp    20c42a <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  20f9c6:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20f9cb:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20f9ce:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20f9d2:	0f 84 d2 c3 ff ff    	je     20bdaa <openSelfDebugInfo+0x2aa>
  20f9d8:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20f9dd:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20f9e0:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20f9e5:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20f9e8:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20f9ec:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20f9f3:	00 
  20f9f4:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20f9fb:	00 
  20f9fc:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20fa03:	00 
  20fa04:	ff d2                	call   rdx
                elf_section.addr = try in.readInt(elf.endian, u64);
  20fa06:	0f b7 ac 24 10 03 00 	movzx  ebp,WORD PTR [rsp+0x310]
  20fa0d:	00 
  20fa0e:	66 85 ed             	test   bp,bp
  20fa11:	0f 85 9c c3 ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
  20fa17:	e9 0e ca ff ff       	jmp    20c42a <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  20fa1c:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20fa21:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20fa24:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20fa28:	0f 84 7c c3 ff ff    	je     20bdaa <openSelfDebugInfo+0x2aa>
  20fa2e:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20fa33:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20fa36:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20fa3b:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20fa3e:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20fa42:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20fa49:	00 
  20fa4a:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20fa51:	00 
  20fa52:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20fa59:	00 
  20fa5a:	ff d2                	call   rdx
                elf_section.offset = try in.readInt(elf.endian, u64);
  20fa5c:	0f b7 ac 24 f0 02 00 	movzx  ebp,WORD PTR [rsp+0x2f0]
  20fa63:	00 
  20fa64:	66 85 ed             	test   bp,bp
  20fa67:	0f 85 46 c3 ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
  20fa6d:	e9 b8 c9 ff ff       	jmp    20c42a <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  20fa72:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20fa77:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20fa7a:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20fa7e:	0f 84 26 c3 ff ff    	je     20bdaa <openSelfDebugInfo+0x2aa>
  20fa84:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20fa89:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20fa8c:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20fa91:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20fa94:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20fa98:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20fa9f:	00 
  20faa0:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20faa7:	00 
  20faa8:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20faaf:	00 
  20fab0:	ff d2                	call   rdx
                elf_section.size = try in.readInt(elf.endian, u64);
  20fab2:	0f b7 ac 24 88 01 00 	movzx  ebp,WORD PTR [rsp+0x188]
  20fab9:	00 
  20faba:	66 85 ed             	test   bp,bp
  20fabd:	0f 85 f0 c2 ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
  20fac3:	e9 62 c9 ff ff       	jmp    20c42a <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  20fac8:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20facd:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20fad0:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20fad4:	0f 84 d0 c2 ff ff    	je     20bdaa <openSelfDebugInfo+0x2aa>
  20fada:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20fadf:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20fae2:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20fae7:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20faea:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20faee:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20faf5:	00 
  20faf6:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20fafd:	00 
  20fafe:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20fb05:	00 
  20fb06:	ff d2                	call   rdx
                elf_section.addr_align = try in.readInt(elf.endian, u64);
  20fb08:	0f b7 ac 24 c0 01 00 	movzx  ebp,WORD PTR [rsp+0x1c0]
  20fb0f:	00 
  20fb10:	66 85 ed             	test   bp,bp
  20fb13:	0f 85 9a c2 ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
  20fb19:	e9 0c c9 ff ff       	jmp    20c42a <openSelfDebugInfo+0x92a>
        const bytes = @sliceToBytes(memory);
  20fb1e:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20fb23:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20fb26:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20fb2a:	0f 84 7a c2 ff ff    	je     20bdaa <openSelfDebugInfo+0x2aa>
  20fb30:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20fb35:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20fb38:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20fb3d:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20fb40:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20fb44:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20fb4b:	00 
  20fb4c:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20fb53:	00 
  20fb54:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20fb5b:	00 
  20fb5c:	ff d2                	call   rdx
                elf_section.ent_size = try in.readInt(elf.endian, u64);
  20fb5e:	0f b7 ac 24 a0 01 00 	movzx  ebp,WORD PTR [rsp+0x1a0]
  20fb65:	00 
  20fb66:	66 85 ed             	test   bp,bp
  20fb69:	0f 85 44 c2 ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
  20fb6f:	e9 b6 c8 ff ff       	jmp    20c42a <openSelfDebugInfo+0x92a>
  20fb74:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  20fb79:	48 8b 38             	mov    rdi,QWORD PTR [rax]
  20fb7c:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  20fb80:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  20fb85:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20fb8c:	00 
  20fb8d:	48 8b 8c 24 38 01 00 	mov    rcx,QWORD PTR [rsp+0x138]
  20fb94:	00 
  20fb95:	48 89 8c 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rcx
  20fb9c:	00 
  20fb9d:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20fba4:	00 
  20fba5:	ff d0                	call   rax
  20fba7:	e9 2e 01 00 00       	jmp    20fcda <openSelfDebugInfo+0x41da>
  20fbac:	66 bd 20 00          	mov    bp,0x20
        const bytes = @sliceToBytes(memory);
  20fbb0:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20fbb5:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20fbb8:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20fbbc:	0f 84 f1 c1 ff ff    	je     20bdb3 <openSelfDebugInfo+0x2b3>
  20fbc2:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  20fbc7:	48 8b 39             	mov    rdi,QWORD PTR [rcx]
        const bytes = @sliceToBytes(memory);
  20fbca:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20fbcf:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
  20fbd2:	e9 b4 00 00 00       	jmp    20fc8b <openSelfDebugInfo+0x418b>
        for (elf.section_headers) |*elf_section| {
  20fbd7:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
  20fbdc:	48 8b 00             	mov    rax,QWORD PTR [rax]
  20fbdf:	48 85 c0             	test   rax,rax
  20fbe2:	74 66                	je     20fc4a <openSelfDebugInfo+0x414a>
  20fbe4:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20fbe9:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
  20fbec:	48 8d 51 20          	lea    rdx,[rcx+0x20]
  20fbf0:	31 f6                	xor    esi,esi
  20fbf2:	4c 8d 05 d7 0b ff ff 	lea    r8,[rip+0xffffffffffff0bd7]        # 2007d0 <__unnamed_59>
            if (elf_section.sh_type != SHT_NOBITS) {
  20fbf9:	83 7a e4 08          	cmp    DWORD PTR [rdx-0x1c],0x8
  20fbfd:	74 3c                	je     20fc3b <openSelfDebugInfo+0x413b>
                const file_end_offset = try math.add(u64, elf_section.offset, elf_section.size);
  20fbff:	48 8b 6a f8          	mov    rbp,QWORD PTR [rdx-0x8]
  20fc03:	4c 89 c7             	mov    rdi,r8
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  20fc06:	48 03 2a             	add    rbp,QWORD PTR [rdx]
  20fc09:	72 1a                	jb     20fc25 <openSelfDebugInfo+0x4125>
  20fc0b:	66 c7 84 24 a0 00 00 	mov    WORD PTR [rsp+0xa0],0x0
  20fc12:	00 00 00 
  20fc15:	48 89 ac 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rbp
  20fc1c:	00 
  20fc1d:	48 8d bc 24 a0 00 00 	lea    rdi,[rsp+0xa0]
  20fc24:	00 
  20fc25:	0f b7 2f             	movzx  ebp,WORD PTR [rdi]
  20fc28:	66 85 ed             	test   bp,bp
  20fc2b:	75 4c                	jne    20fc79 <openSelfDebugInfo+0x4179>
                if (stream_end < file_end_offset) return error.InvalidFormat;
  20fc2d:	48 8b ac 24 60 01 00 	mov    rbp,QWORD PTR [rsp+0x160]
  20fc34:	00 
  20fc35:	48 3b 6f 08          	cmp    rbp,QWORD PTR [rdi+0x8]
  20fc39:	72 73                	jb     20fcae <openSelfDebugInfo+0x41ae>
        for (elf.section_headers) |*elf_section| {
  20fc3b:	48 83 c6 01          	add    rsi,0x1
  20fc3f:	48 83 c2 40          	add    rdx,0x40
  20fc43:	48 39 c6             	cmp    rsi,rax
  20fc46:	72 b1                	jb     20fbf9 <openSelfDebugInfo+0x40f9>
  20fc48:	eb 08                	jmp    20fc52 <openSelfDebugInfo+0x4152>
        elf.string_section = &elf.section_headers[elf.string_section_index];
  20fc4a:	48 8b 4c 24 50       	mov    rcx,QWORD PTR [rsp+0x50]
  20fc4f:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
  20fc52:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
  20fc56:	48 c1 e2 06          	shl    rdx,0x6
  20fc5a:	48 8d 34 11          	lea    rsi,[rcx+rdx*1]
  20fc5e:	48 89 73 38          	mov    QWORD PTR [rbx+0x38],rsi
        if (elf.string_section.sh_type != SHT_STRTAB) {
  20fc62:	83 7c 11 04 03       	cmp    DWORD PTR [rcx+rdx*1+0x4],0x3
  20fc67:	75 45                	jne    20fcae <openSelfDebugInfo+0x41ae>
  20fc69:	31 ed                	xor    ebp,ebp
  20fc6b:	66 85 ed             	test   bp,bp
  20fc6e:	0f 85 3f c1 ff ff    	jne    20bdb3 <openSelfDebugInfo+0x2b3>
  20fc74:	e9 b1 c7 ff ff       	jmp    20c42a <openSelfDebugInfo+0x92a>
  20fc79:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20fc7d:	0f 84 30 c1 ff ff    	je     20bdb3 <openSelfDebugInfo+0x2b3>
  20fc83:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20fc88:	48 8b 3a             	mov    rdi,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20fc8b:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20fc8f:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20fc96:	00 
  20fc97:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20fc9e:	00 
  20fc9f:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20fca6:	00 
  20fca7:	ff d2                	call   rdx
  20fca9:	e9 05 c1 ff ff       	jmp    20bdb3 <openSelfDebugInfo+0x2b3>
        const bytes = @sliceToBytes(memory);
  20fcae:	48 c1 e0 06          	shl    rax,0x6
        if (bytes.len == 0) return;
  20fcb2:	74 26                	je     20fcda <openSelfDebugInfo+0x41da>
  20fcb4:	48 8b 54 24 48       	mov    rdx,QWORD PTR [rsp+0x48]
  20fcb9:	48 8b 3a             	mov    rdi,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  20fcbc:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
  20fcc0:	48 89 8c 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],rcx
  20fcc7:	00 
  20fcc8:	48 89 84 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],rax
  20fccf:	00 
  20fcd0:	48 8d b4 24 a0 00 00 	lea    rsi,[rsp+0xa0]
  20fcd7:	00 
  20fcd8:	ff d2                	call   rdx
  20fcda:	66 bd 21 00          	mov    bp,0x21
  20fcde:	e9 d0 c0 ff ff       	jmp    20bdb3 <openSelfDebugInfo+0x2b3>
  20fce3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  20fcea:	84 00 00 00 00 00 

000000000020fcf0 <Elf_findSection>:
    }

    pub fn findSection(elf: *Elf, name: []const u8) !?*SectionHeader {
  20fcf0:	55                   	push   rbp
  20fcf1:	41 57                	push   r15
  20fcf3:	41 56                	push   r14
  20fcf5:	41 55                	push   r13
  20fcf7:	41 54                	push   r12
  20fcf9:	53                   	push   rbx
  20fcfa:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  20fd01:	48 89 d3             	mov    rbx,rdx
  20fd04:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
        var file_stream = io.FileInStream.init(elf.in_file);
  20fd09:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  20fd0c:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  20fd11:	48 8d 05 18 09 00 00 	lea    rax,[rip+0x918]        # 210630 <FileInStream_readFn>
  20fd18:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
        const in = &file_stream.stream;

        section_loop: for (elf.section_headers) |*elf_section| {
  20fd1d:	48 8b 46 40          	mov    rax,QWORD PTR [rsi+0x40]
  20fd21:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
  20fd26:	48 85 c0             	test   rax,rax
  20fd29:	0f 84 37 01 00 00    	je     20fe66 <Elf_findSection+0x176>
  20fd2f:	45 31 e4             	xor    r12d,r12d
  20fd32:	48 89 74 24 20       	mov    QWORD PTR [rsp+0x20],rsi
  20fd37:	4c 8b 76 38          	mov    r14,QWORD PTR [rsi+0x38]
  20fd3b:	4c 89 e0             	mov    rax,r12
  20fd3e:	48 c1 e0 06          	shl    rax,0x6
            if (elf_section.sh_type == SHT_NULL) continue;
  20fd42:	41 83 7c 06 04 00    	cmp    DWORD PTR [r14+rax*1+0x4],0x0
  20fd48:	0f 84 04 01 00 00    	je     20fe52 <Elf_findSection+0x162>
  20fd4e:	49 01 c6             	add    r14,rax
  20fd51:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]

            const name_offset = elf.string_section.offset + elf_section.name;
  20fd56:	48 8b 41 30          	mov    rax,QWORD PTR [rcx+0x30]
  20fd5a:	41 8b 36             	mov    esi,DWORD PTR [r14]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  20fd5d:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  20fd61:	0f 88 3e 01 00 00    	js     20fea5 <Elf_findSection+0x1b5>
            try elf.in_file.seekTo(name_offset);
  20fd67:	48 8b 01             	mov    rax,QWORD PTR [rcx]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  20fd6a:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  20fd6d:	b8 08 00 00 00       	mov    eax,0x8
  20fd72:	31 d2                	xor    edx,edx
  20fd74:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  20fd76:	48 89 c1             	mov    rcx,rax
  20fd79:	48 f7 d9             	neg    rcx
  20fd7c:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  20fd82:	b8 00 00 00 00       	mov    eax,0x0
  20fd87:	48 0f 46 c8          	cmovbe rcx,rax
  20fd8b:	48 85 c9             	test   rcx,rcx
  20fd8e:	0f 85 1c 01 00 00    	jne    20feb0 <Elf_findSection+0x1c0>

            for (name) |expected_c| {
  20fd94:	4c 8b 6b 08          	mov    r13,QWORD PTR [rbx+0x8]
  20fd98:	4d 85 ed             	test   r13,r13
  20fd9b:	74 66                	je     20fe03 <Elf_findSection+0x113>
  20fd9d:	31 ed                	xor    ebp,ebp
  20fd9f:	90                   	nop
  20fda0:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  20fda3:	44 0f b6 3c 28       	movzx  r15d,BYTE PTR [rax+rbp*1]
            try self.readNoEof(result[0..]);
  20fda8:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20fdad:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20fdb2:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20fdb9:	00 00 
            return self.readFn(self, buffer);
  20fdbb:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  20fdc0:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20fdc5:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20fdca:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  20fdce:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  20fdd3:	66 85 c0             	test   ax,ax
  20fdd6:	0f 85 9d 00 00 00    	jne    20fe79 <Elf_findSection+0x189>
  20fddc:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  20fde1:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  20fde6:	0f 82 89 00 00 00    	jb     20fe75 <Elf_findSection+0x185>
            return result[0];
  20fdec:	0f b6 44 24 07       	movzx  eax,BYTE PTR [rsp+0x7]
                const target_c = try in.readByte();
                if (target_c == 0 or expected_c != target_c) continue :section_loop;
  20fdf1:	84 c0                	test   al,al
  20fdf3:	74 5d                	je     20fe52 <Elf_findSection+0x162>
  20fdf5:	41 38 c7             	cmp    r15b,al
  20fdf8:	75 58                	jne    20fe52 <Elf_findSection+0x162>
  20fdfa:	48 83 c5 01          	add    rbp,0x1
            for (name) |expected_c| {
  20fdfe:	4c 39 ed             	cmp    rbp,r13
  20fe01:	72 9d                	jb     20fda0 <Elf_findSection+0xb0>
            try self.readNoEof(result[0..]);
  20fe03:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  20fe08:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  20fe0d:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  20fe14:	00 00 
            return self.readFn(self, buffer);
  20fe16:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  20fe1b:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  20fe20:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  20fe25:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  20fe29:	0f b7 44 24 38       	movzx  eax,WORD PTR [rsp+0x38]
            const amt_read = try self.read(buf);
  20fe2e:	66 85 c0             	test   ax,ax
  20fe31:	0f 85 a6 00 00 00    	jne    20fedd <Elf_findSection+0x1ed>
  20fe37:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
            if (amt_read < buf.len) return error.EndOfStream;
  20fe3c:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  20fe41:	0f 82 92 00 00 00    	jb     20fed9 <Elf_findSection+0x1e9>
            }

            {
                const null_byte = try in.readByte();
                if (null_byte == 0) return elf_section;
  20fe47:	80 7c 24 07 00       	cmp    BYTE PTR [rsp+0x7],0x0
  20fe4c:	0f 84 9f 00 00 00    	je     20fef1 <Elf_findSection+0x201>
        section_loop: for (elf.section_headers) |*elf_section| {
  20fe52:	49 83 c4 01          	add    r12,0x1
  20fe56:	4c 3b 64 24 50       	cmp    r12,QWORD PTR [rsp+0x50]
  20fe5b:	48 8b 74 24 20       	mov    rsi,QWORD PTR [rsp+0x20]
  20fe60:	0f 82 d1 fe ff ff    	jb     20fd37 <Elf_findSection+0x47>
            }
        }

        return null;
  20fe66:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  20fe6a:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  20fe6f:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  20fe73:	eb 1e                	jmp    20fe93 <Elf_findSection+0x1a3>
  20fe75:	66 b8 20 00          	mov    ax,0x20
  20fe79:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const target_c = try in.readByte();
  20fe7e:	66 89 02             	mov    WORD PTR [rdx],ax
  20fe81:	48 8b 44 24 6c       	mov    rax,QWORD PTR [rsp+0x6c]
  20fe86:	48 8b 4c 24 72       	mov    rcx,QWORD PTR [rsp+0x72]
  20fe8b:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  20fe8f:	48 89 42 02          	mov    QWORD PTR [rdx+0x2],rax
  20fe93:	48 81 c4 88 00 00 00 	add    rsp,0x88
  20fe9a:	5b                   	pop    rbx
  20fe9b:	41 5c                	pop    r12
  20fe9d:	41 5d                	pop    r13
  20fe9f:	41 5e                	pop    r14
  20fea1:	41 5f                	pop    r15
  20fea3:	5d                   	pop    rbp
  20fea4:	c3                   	ret    
  20fea5:	66 b8 23 00          	mov    ax,0x23
  20fea9:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  20feae:	eb 72                	jmp    20ff22 <Elf_findSection+0x232>
  20feb0:	66 b8 02 00          	mov    ax,0x2
  20feb4:	48 8d 51 fa          	lea    rdx,[rcx-0x6]
  20feb8:	48 83 fa 17          	cmp    rdx,0x17
  20febc:	77 53                	ja     20ff11 <Elf_findSection+0x221>
  20febe:	48 8d 0d f7 13 ff ff 	lea    rcx,[rip+0xffffffffffff13f7]        # 2012bc <__unnamed_9+0x5dc>
  20fec5:	48 63 14 91          	movsxd rdx,DWORD PTR [rcx+rdx*4]
  20fec9:	48 01 ca             	add    rdx,rcx
  20fecc:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  20fed1:	ff e2                	jmp    rdx
  20fed3:	66 b8 22 00          	mov    ax,0x22
  20fed7:	eb 49                	jmp    20ff22 <Elf_findSection+0x232>
  20fed9:	66 b8 20 00          	mov    ax,0x20
  20fedd:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
                const null_byte = try in.readByte();
  20fee2:	66 89 02             	mov    WORD PTR [rdx],ax
  20fee5:	48 8b 44 24 5e       	mov    rax,QWORD PTR [rsp+0x5e]
  20feea:	48 8b 4c 24 64       	mov    rcx,QWORD PTR [rsp+0x64]
  20feef:	eb 9a                	jmp    20fe8b <Elf_findSection+0x19b>
  20fef1:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
                if (null_byte == 0) return elf_section;
  20fef6:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  20fefb:	0f b7 44 24 4e       	movzx  eax,WORD PTR [rsp+0x4e]
  20ff00:	66 89 41 06          	mov    WORD PTR [rcx+0x6],ax
  20ff04:	8b 44 24 4a          	mov    eax,DWORD PTR [rsp+0x4a]
  20ff08:	89 41 02             	mov    DWORD PTR [rcx+0x2],eax
  20ff0b:	4c 89 71 08          	mov    QWORD PTR [rcx+0x8],r14
  20ff0f:	eb 82                	jmp    20fe93 <Elf_findSection+0x1a3>
  20ff11:	48 83 f9 4b          	cmp    rcx,0x4b
  20ff15:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  20ff1a:	74 b7                	je     20fed3 <Elf_findSection+0x1e3>
  20ff1c:	eb 04                	jmp    20ff22 <Elf_findSection+0x232>
  20ff1e:	66 b8 1e 00          	mov    ax,0x1e
            try elf.in_file.seekTo(name_offset);
  20ff22:	66 89 06             	mov    WORD PTR [rsi],ax
  20ff25:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  20ff2a:	48 8b 8c 24 80 00 00 	mov    rcx,QWORD PTR [rsp+0x80]
  20ff31:	00 
  20ff32:	48 89 4e 08          	mov    QWORD PTR [rsi+0x8],rcx
  20ff36:	48 89 46 02          	mov    QWORD PTR [rsi+0x2],rax
  20ff3a:	e9 54 ff ff ff       	jmp    20fe93 <Elf_findSection+0x1a3>
  20ff3f:	90                   	nop

000000000020ff40 <File_openRead>:
    pub fn openRead(allocator: *mem.Allocator, path: []const u8) OpenError!File {
  20ff40:	55                   	push   rbp
  20ff41:	41 57                	push   r15
  20ff43:	41 56                	push   r14
  20ff45:	41 54                	push   r12
  20ff47:	53                   	push   rbx
  20ff48:	48 83 ec 20          	sub    rsp,0x20
  20ff4c:	48 89 d3             	mov    rbx,rdx
  20ff4f:	49 89 f7             	mov    r15,rsi
  20ff52:	49 89 fe             	mov    r14,rdi
}

/// Returns a mutable slice with 1 more byte of length which is a null byte.
/// Caller owns the returned memory.
pub fn addNullByte(allocator: *mem.Allocator, slice: []const u8) ![]u8 {
    const result = try allocator.alloc(u8, slice.len + 1);
  20ff55:	4c 8b 63 08          	mov    r12,QWORD PTR [rbx+0x8]
  20ff59:	49 83 c4 01          	add    r12,0x1
  20ff5d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  20ff62:	b9 01 00 00 00       	mov    ecx,0x1
  20ff67:	4c 89 e2             	mov    rdx,r12
  20ff6a:	41 ff 17             	call   QWORD PTR [r15]
  20ff6d:	0f b7 6c 24 08       	movzx  ebp,WORD PTR [rsp+0x8]
  20ff72:	66 85 ed             	test   bp,bp
  20ff75:	0f 85 95 01 00 00    	jne    210110 <File_openRead+0x1d0>
        assert(byte_slice.len == byte_count);
  20ff7b:	4c 39 64 24 18       	cmp    QWORD PTR [rsp+0x18],r12
    if (!ok) {
  20ff80:	0f 85 b9 01 00 00    	jne    21013f <File_openRead+0x1ff>
    assert(dest.len >= source.len);
  20ff86:	48 8b 6b 08          	mov    rbp,QWORD PTR [rbx+0x8]
  20ff8a:	49 39 ec             	cmp    r12,rbp
  20ff8d:	0f 82 ac 01 00 00    	jb     21013f <File_openRead+0x1ff>
  20ff93:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
    for (source) |s, i|
  20ff98:	48 85 ed             	test   rbp,rbp
  20ff9b:	74 1f                	je     20ffbc <File_openRead+0x7c>
  20ff9d:	48 8d 4d ff          	lea    rcx,[rbp-0x1]
  20ffa1:	89 e8                	mov    eax,ebp
  20ffa3:	83 e0 07             	and    eax,0x7
  20ffa6:	48 83 f9 07          	cmp    rcx,0x7
  20ffaa:	73 17                	jae    20ffc3 <File_openRead+0x83>
  20ffac:	31 c9                	xor    ecx,ecx
  20ffae:	48 85 c0             	test   rax,rax
  20ffb1:	0f 85 85 00 00 00    	jne    21003c <File_openRead+0xfc>
  20ffb7:	e9 98 00 00 00       	jmp    210054 <File_openRead+0x114>
  20ffbc:	31 c0                	xor    eax,eax
  20ffbe:	e9 95 00 00 00       	jmp    210058 <File_openRead+0x118>
  20ffc3:	48 29 c5             	sub    rbp,rax
  20ffc6:	31 c9                	xor    ecx,ecx
  20ffc8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  20ffcf:	00 
  20ffd0:	48 8b 33             	mov    rsi,QWORD PTR [rbx]
  20ffd3:	0f b6 14 0e          	movzx  edx,BYTE PTR [rsi+rcx*1]
        dest[i] = s;
  20ffd7:	88 14 0f             	mov    BYTE PTR [rdi+rcx*1],dl
    for (source) |s, i|
  20ffda:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20ffdd:	0f b6 54 0a 01       	movzx  edx,BYTE PTR [rdx+rcx*1+0x1]
        dest[i] = s;
  20ffe2:	88 54 0f 01          	mov    BYTE PTR [rdi+rcx*1+0x1],dl
    for (source) |s, i|
  20ffe6:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20ffe9:	0f b6 54 0a 02       	movzx  edx,BYTE PTR [rdx+rcx*1+0x2]
        dest[i] = s;
  20ffee:	88 54 0f 02          	mov    BYTE PTR [rdi+rcx*1+0x2],dl
    for (source) |s, i|
  20fff2:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  20fff5:	0f b6 54 0a 03       	movzx  edx,BYTE PTR [rdx+rcx*1+0x3]
        dest[i] = s;
  20fffa:	88 54 0f 03          	mov    BYTE PTR [rdi+rcx*1+0x3],dl
    for (source) |s, i|
  20fffe:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  210001:	0f b6 54 0a 04       	movzx  edx,BYTE PTR [rdx+rcx*1+0x4]
        dest[i] = s;
  210006:	88 54 0f 04          	mov    BYTE PTR [rdi+rcx*1+0x4],dl
    for (source) |s, i|
  21000a:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  21000d:	0f b6 54 0a 05       	movzx  edx,BYTE PTR [rdx+rcx*1+0x5]
        dest[i] = s;
  210012:	88 54 0f 05          	mov    BYTE PTR [rdi+rcx*1+0x5],dl
    for (source) |s, i|
  210016:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  210019:	0f b6 54 0a 06       	movzx  edx,BYTE PTR [rdx+rcx*1+0x6]
        dest[i] = s;
  21001e:	88 54 0f 06          	mov    BYTE PTR [rdi+rcx*1+0x6],dl
    for (source) |s, i|
  210022:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  210025:	0f b6 54 0a 07       	movzx  edx,BYTE PTR [rdx+rcx*1+0x7]
        dest[i] = s;
  21002a:	88 54 0f 07          	mov    BYTE PTR [rdi+rcx*1+0x7],dl
    for (source) |s, i|
  21002e:	48 83 c1 08          	add    rcx,0x8
  210032:	48 39 cd             	cmp    rbp,rcx
  210035:	75 99                	jne    20ffd0 <File_openRead+0x90>
  210037:	48 85 c0             	test   rax,rax
  21003a:	74 18                	je     210054 <File_openRead+0x114>
  21003c:	48 f7 d8             	neg    rax
  21003f:	90                   	nop
  210040:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
  210043:	0f b6 14 0a          	movzx  edx,BYTE PTR [rdx+rcx*1]
        dest[i] = s;
  210047:	88 14 0f             	mov    BYTE PTR [rdi+rcx*1],dl
    for (source) |s, i|
  21004a:	48 83 c1 01          	add    rcx,0x1
  21004e:	48 83 c0 01          	add    rax,0x1
  210052:	75 ec                	jne    210040 <File_openRead+0x100>
    mem.copy(u8, result, slice);
    result[slice.len] = 0;
  210054:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]
  210058:	c6 04 07 00          	mov    BYTE PTR [rdi+rax*1],0x0
  21005c:	31 ed                	xor    ebp,ebp
  21005e:	66 90                	xchg   ax,ax
  210060:	b8 02 00 00 00       	mov    eax,0x2
  210065:	be 00 00 00 00       	mov    esi,0x0
  21006a:	31 d2                	xor    edx,edx
  21006c:	0f 05                	syscall 
  21006e:	48 89 c3             	mov    rbx,rax
  210071:	48 f7 d8             	neg    rax
  210074:	48 81 fb 00 f0 ff ff 	cmp    rbx,0xfffffffffffff000
  21007b:	48 0f 46 c5          	cmovbe rax,rbp
        if (err > 0) {
  21007f:	48 83 f8 04          	cmp    rax,0x4
  210083:	74 db                	je     210060 <File_openRead+0x120>
  210085:	48 83 f8 4b          	cmp    rax,0x4b
  210089:	77 62                	ja     2100ed <File_openRead+0x1ad>
  21008b:	48 8d 0d 8a 12 ff ff 	lea    rcx,[rip+0xffffffffffff128a]        # 20131c <__unnamed_9+0x63c>
  210092:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  210096:	48 01 c8             	add    rax,rcx
  210099:	ff e0                	jmp    rax
  21009b:	66 bd 10 00          	mov    bp,0x10
  21009f:	eb 50                	jmp    2100f1 <File_openRead+0x1b1>
  2100a1:	66 bd 0d 00          	mov    bp,0xd
  2100a5:	eb 4a                	jmp    2100f1 <File_openRead+0x1b1>
  2100a7:	66 bd 13 00          	mov    bp,0x13
  2100ab:	eb 44                	jmp    2100f1 <File_openRead+0x1b1>
  2100ad:	66 bd 1a 00          	mov    bp,0x1a
  2100b1:	eb 3e                	jmp    2100f1 <File_openRead+0x1b1>
  2100b3:	66 bd 18 00          	mov    bp,0x18
  2100b7:	eb 38                	jmp    2100f1 <File_openRead+0x1b1>
  2100b9:	66 bd 0f 00          	mov    bp,0xf
  2100bd:	eb 32                	jmp    2100f1 <File_openRead+0x1b1>
  2100bf:	66 bd 17 00          	mov    bp,0x17
  2100c3:	eb 2c                	jmp    2100f1 <File_openRead+0x1b1>
  2100c5:	31 ed                	xor    ebp,ebp
  2100c7:	eb 2a                	jmp    2100f3 <File_openRead+0x1b3>
  2100c9:	66 bd 1c 00          	mov    bp,0x1c
  2100cd:	eb 22                	jmp    2100f1 <File_openRead+0x1b1>
  2100cf:	66 bd 04 00          	mov    bp,0x4
  2100d3:	eb 1c                	jmp    2100f1 <File_openRead+0x1b1>
  2100d5:	66 bd 1b 00          	mov    bp,0x1b
  2100d9:	eb 16                	jmp    2100f1 <File_openRead+0x1b1>
  2100db:	66 bd 1d 00          	mov    bp,0x1d
  2100df:	eb 10                	jmp    2100f1 <File_openRead+0x1b1>
  2100e1:	66 bd 19 00          	mov    bp,0x19
  2100e5:	eb 0a                	jmp    2100f1 <File_openRead+0x1b1>
  2100e7:	66 bd 16 00          	mov    bp,0x16
  2100eb:	eb 04                	jmp    2100f1 <File_openRead+0x1b1>
  2100ed:	66 bd 02 00          	mov    bp,0x2
  2100f1:	31 db                	xor    ebx,ebx
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2100f3:	49 8b 47 10          	mov    rax,QWORD PTR [r15+0x10]
  2100f7:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  2100fc:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
  210101:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  210106:	4c 89 ff             	mov    rdi,r15
  210109:	ff d0                	call   rax
            const fd = try os.posixOpen(allocator, path, flags, 0);
  21010b:	66 85 ed             	test   bp,bp
  21010e:	74 23                	je     210133 <File_openRead+0x1f3>
  210110:	66 41 89 2e          	mov    WORD PTR [r14],bp
  210114:	0f b7 44 24 06       	movzx  eax,WORD PTR [rsp+0x6]
  210119:	66 41 89 46 06       	mov    WORD PTR [r14+0x6],ax
  21011e:	8b 44 24 02          	mov    eax,DWORD PTR [rsp+0x2]
  210122:	41 89 46 02          	mov    DWORD PTR [r14+0x2],eax
  210126:	48 83 c4 20          	add    rsp,0x20
  21012a:	5b                   	pop    rbx
  21012b:	41 5c                	pop    r12
  21012d:	41 5e                	pop    r14
  21012f:	41 5f                	pop    r15
  210131:	5d                   	pop    rbp
  210132:	c3                   	ret    
            return openHandle(fd);
  210133:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  210139:	41 89 5e 04          	mov    DWORD PTR [r14+0x4],ebx
  21013d:	eb e7                	jmp    210126 <File_openRead+0x1e6>
            @panic("assertion failure");
  21013f:	e8 6c 9b ff ff       	call   209cb0 <panic>
  210144:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21014b:	00 00 00 00 00 

0000000000210150 <FixedBufferAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  210150:	49 89 d0             	mov    r8,rdx
        const addr = @ptrToInt(self.buffer.ptr) + self.end_index;
  210153:	4c 8b 56 18          	mov    r10,QWORD PTR [rsi+0x18]
  210157:	4c 8b 4e 20          	mov    r9,QWORD PTR [rsi+0x20]
  21015b:	4b 8d 04 0a          	lea    rax,[r10+r9*1]
        const rem = @rem(addr, alignment);
  21015f:	81 e1 ff ff ff 1f    	and    ecx,0x1fffffff
  210165:	48 89 c2             	mov    rdx,rax
  210168:	48 c1 ea 20          	shr    rdx,0x20
  21016c:	74 07                	je     210175 <FixedBufferAllocator_alloc+0x25>
  21016e:	31 d2                	xor    edx,edx
  210170:	48 f7 f1             	div    rcx
  210173:	eb 04                	jmp    210179 <FixedBufferAllocator_alloc+0x29>
  210175:	31 d2                	xor    edx,edx
  210177:	f7 f1                	div    ecx
        const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  210179:	48 29 d1             	sub    rcx,rdx
  21017c:	48 85 d2             	test   rdx,rdx
  21017f:	48 0f 44 ca          	cmove  rcx,rdx
        const adjusted_index = self.end_index + march_forward_bytes;
  210183:	4c 01 d1             	add    rcx,r10
        const new_end_index = adjusted_index + n;
  210186:	4a 8d 04 01          	lea    rax,[rcx+r8*1]
        if (new_end_index > self.buffer.len) {
  21018a:	48 3b 46 28          	cmp    rax,QWORD PTR [rsi+0x28]
  21018e:	76 1b                	jbe    2101ab <FixedBufferAllocator_alloc+0x5b>
            return error.OutOfMemory;
  210190:	48 8b 05 b1 75 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff75b1]        # 207748 <__unnamed_61+0x10>
  210197:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  21019b:	c5 f8 10 05 95 75 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff7595]        # 207738 <__unnamed_61>
  2101a2:	ff 
  2101a3:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
  2101a7:	48 89 f8             	mov    rax,rdi
  2101aa:	c3                   	ret    
        }
        const result = self.buffer[adjusted_index..new_end_index];
        self.end_index = new_end_index;
  2101ab:	48 89 46 18          	mov    QWORD PTR [rsi+0x18],rax

        return result;
  2101af:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  2101b4:	0f b7 44 24 fe       	movzx  eax,WORD PTR [rsp-0x2]
  2101b9:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
        const result = self.buffer[adjusted_index..new_end_index];
  2101bd:	49 01 c9             	add    r9,rcx
        return result;
  2101c0:	8b 44 24 fa          	mov    eax,DWORD PTR [rsp-0x6]
  2101c4:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  2101c7:	4c 89 4f 08          	mov    QWORD PTR [rdi+0x8],r9
  2101cb:	4c 89 47 10          	mov    QWORD PTR [rdi+0x10],r8
  2101cf:	48 89 f8             	mov    rax,rdi
  2101d2:	c3                   	ret    
  2101d3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2101da:	84 00 00 00 00 00 

00000000002101e0 <FixedBufferAllocator_realloc>:
    }

    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  2101e0:	41 56                	push   r14
  2101e2:	53                   	push   rbx
  2101e3:	48 83 ec 28          	sub    rsp,0x28
  2101e7:	49 89 d1             	mov    r9,rdx
        const self = @fieldParentPtr(FixedBufferAllocator, "allocator", allocator);
        assert(old_mem.len <= self.end_index);
  2101ea:	49 8b 59 08          	mov    rbx,QWORD PTR [r9+0x8]
  2101ee:	4c 8b 5e 18          	mov    r11,QWORD PTR [rsi+0x18]
  2101f2:	4d 89 de             	mov    r14,r11
  2101f5:	49 29 de             	sub    r14,rbx
    if (!ok) {
  2101f8:	0f 82 de 01 00 00    	jb     2103dc <FixedBufferAllocator_realloc+0x1fc>
        if (new_size <= old_mem.len) {
  2101fe:	48 39 cb             	cmp    rbx,rcx
  210201:	73 2a                	jae    21022d <FixedBufferAllocator_realloc+0x4d>
            return old_mem[0..new_size];
        } else if (old_mem.ptr == self.buffer.ptr + self.end_index - old_mem.len) {
  210203:	4c 8b 56 20          	mov    r10,QWORD PTR [rsi+0x20]
  210207:	4b 8d 04 1a          	lea    rax,[r10+r11*1]
  21020b:	48 89 c2             	mov    rdx,rax
  21020e:	48 29 da             	sub    rdx,rbx
  210211:	49 39 11             	cmp    QWORD PTR [r9],rdx
  210214:	74 38                	je     21024e <FixedBufferAllocator_realloc+0x6e>
        const rem = @rem(addr, alignment);
  210216:	41 81 e0 ff ff ff 1f 	and    r8d,0x1fffffff
  21021d:	48 89 c2             	mov    rdx,rax
  210220:	48 c1 ea 20          	shr    rdx,0x20
  210224:	74 52                	je     210278 <FixedBufferAllocator_realloc+0x98>
  210226:	31 d2                	xor    edx,edx
  210228:	49 f7 f0             	div    r8
  21022b:	eb 50                	jmp    21027d <FixedBufferAllocator_realloc+0x9d>
            return old_mem[0..new_size];
  21022d:	49 8b 01             	mov    rax,QWORD PTR [r9]
  210230:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  210235:	0f b7 54 24 10       	movzx  edx,WORD PTR [rsp+0x10]
  21023a:	66 89 57 06          	mov    WORD PTR [rdi+0x6],dx
  21023e:	8b 54 24 0c          	mov    edx,DWORD PTR [rsp+0xc]
  210242:	89 57 02             	mov    DWORD PTR [rdi+0x2],edx
  210245:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  210249:	e9 7f 01 00 00       	jmp    2103cd <FixedBufferAllocator_realloc+0x1ed>
            const start_index = self.end_index - old_mem.len;
            const new_end_index = start_index + new_size;
  21024e:	49 8d 04 0e          	lea    rax,[r14+rcx*1]
            if (new_end_index > self.buffer.len) return error.OutOfMemory;
  210252:	48 3b 46 28          	cmp    rax,QWORD PTR [rsi+0x28]
  210256:	0f 86 94 00 00 00    	jbe    2102f0 <FixedBufferAllocator_realloc+0x110>
  21025c:	48 8b 05 e5 74 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff74e5]        # 207748 <__unnamed_61+0x10>
  210263:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  210267:	c5 f8 10 05 c9 74 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff74c9]        # 207738 <__unnamed_61>
  21026e:	ff 
  21026f:	c5 f8 11 07          	vmovups XMMWORD PTR [rdi],xmm0
  210273:	e9 59 01 00 00       	jmp    2103d1 <FixedBufferAllocator_realloc+0x1f1>
  210278:	31 d2                	xor    edx,edx
  21027a:	41 f7 f0             	div    r8d
        const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  21027d:	49 29 d0             	sub    r8,rdx
  210280:	48 85 d2             	test   rdx,rdx
  210283:	4c 0f 44 c2          	cmove  r8,rdx
        const adjusted_index = self.end_index + march_forward_bytes;
  210287:	4d 01 d8             	add    r8,r11
        const new_end_index = adjusted_index + n;
  21028a:	49 8d 04 08          	lea    rax,[r8+rcx*1]
        if (new_end_index > self.buffer.len) {
  21028e:	48 3b 46 28          	cmp    rax,QWORD PTR [rsi+0x28]
  210292:	76 1e                	jbe    2102b2 <FixedBufferAllocator_realloc+0xd2>
            const result = self.buffer[start_index..new_end_index];
            self.end_index = new_end_index;
            return result;
        } else {
            const result = try alloc(allocator, new_size, alignment);
  210294:	66 c7 07 05 00       	mov    WORD PTR [rdi],0x5
  210299:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  21029e:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  2102a2:	c5 f8 10 44 24 12    	vmovups xmm0,XMMWORD PTR [rsp+0x12]
  2102a8:	c5 f8 11 47 02       	vmovups XMMWORD PTR [rdi+0x2],xmm0
  2102ad:	e9 1f 01 00 00       	jmp    2103d1 <FixedBufferAllocator_realloc+0x1f1>
        self.end_index = new_end_index;
  2102b2:	48 89 46 18          	mov    QWORD PTR [rsi+0x18],rax
    assert(dest.len >= source.len);
  2102b6:	4d 8b 71 08          	mov    r14,QWORD PTR [r9+0x8]
  2102ba:	49 39 ce             	cmp    r14,rcx
  2102bd:	0f 87 19 01 00 00    	ja     2103dc <FixedBufferAllocator_realloc+0x1fc>
  2102c3:	4f 8d 1c 02          	lea    r11,[r10+r8*1]
    for (source) |s, i|
  2102c7:	4d 85 f6             	test   r14,r14
  2102ca:	0f 84 e5 00 00 00    	je     2103b5 <FixedBufferAllocator_realloc+0x1d5>
  2102d0:	49 8d 46 ff          	lea    rax,[r14-0x1]
  2102d4:	44 89 f2             	mov    edx,r14d
  2102d7:	83 e2 07             	and    edx,0x7
  2102da:	48 83 f8 07          	cmp    rax,0x7
  2102de:	73 35                	jae    210315 <FixedBufferAllocator_realloc+0x135>
  2102e0:	31 f6                	xor    esi,esi
  2102e2:	48 85 d2             	test   rdx,rdx
  2102e5:	0f 85 b1 00 00 00    	jne    21039c <FixedBufferAllocator_realloc+0x1bc>
  2102eb:	e9 c5 00 00 00       	jmp    2103b5 <FixedBufferAllocator_realloc+0x1d5>
            self.end_index = new_end_index;
  2102f0:	48 89 46 18          	mov    QWORD PTR [rsi+0x18],rax
            return result;
  2102f4:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  2102f9:	0f b7 44 24 0a       	movzx  eax,WORD PTR [rsp+0xa]
  2102fe:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
            const result = self.buffer[start_index..new_end_index];
  210302:	4d 01 f2             	add    r10,r14
            return result;
  210305:	8b 44 24 06          	mov    eax,DWORD PTR [rsp+0x6]
  210309:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  21030c:	4c 89 57 08          	mov    QWORD PTR [rdi+0x8],r10
  210310:	e9 b8 00 00 00       	jmp    2103cd <FixedBufferAllocator_realloc+0x1ed>
  210315:	49 29 d6             	sub    r14,rdx
  210318:	4b 8d 04 02          	lea    rax,[r10+r8*1]
  21031c:	48 83 c0 07          	add    rax,0x7
  210320:	31 f6                	xor    esi,esi
  210322:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210329:	1f 84 00 00 00 00 00 
  210330:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  210333:	0f b6 1c 33          	movzx  ebx,BYTE PTR [rbx+rsi*1]
        dest[i] = s;
  210337:	88 5c 30 f9          	mov    BYTE PTR [rax+rsi*1-0x7],bl
    for (source) |s, i|
  21033b:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  21033e:	0f b6 5c 33 01       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x1]
        dest[i] = s;
  210343:	88 5c 30 fa          	mov    BYTE PTR [rax+rsi*1-0x6],bl
    for (source) |s, i|
  210347:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  21034a:	0f b6 5c 33 02       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x2]
        dest[i] = s;
  21034f:	88 5c 30 fb          	mov    BYTE PTR [rax+rsi*1-0x5],bl
    for (source) |s, i|
  210353:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  210356:	0f b6 5c 33 03       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x3]
        dest[i] = s;
  21035b:	88 5c 30 fc          	mov    BYTE PTR [rax+rsi*1-0x4],bl
    for (source) |s, i|
  21035f:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  210362:	0f b6 5c 33 04       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x4]
        dest[i] = s;
  210367:	88 5c 30 fd          	mov    BYTE PTR [rax+rsi*1-0x3],bl
    for (source) |s, i|
  21036b:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  21036e:	0f b6 5c 33 05       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x5]
        dest[i] = s;
  210373:	88 5c 30 fe          	mov    BYTE PTR [rax+rsi*1-0x2],bl
    for (source) |s, i|
  210377:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  21037a:	0f b6 5c 33 06       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x6]
        dest[i] = s;
  21037f:	88 5c 30 ff          	mov    BYTE PTR [rax+rsi*1-0x1],bl
    for (source) |s, i|
  210383:	49 8b 19             	mov    rbx,QWORD PTR [r9]
  210386:	0f b6 5c 33 07       	movzx  ebx,BYTE PTR [rbx+rsi*1+0x7]
        dest[i] = s;
  21038b:	88 1c 30             	mov    BYTE PTR [rax+rsi*1],bl
    for (source) |s, i|
  21038e:	48 83 c6 08          	add    rsi,0x8
  210392:	49 39 f6             	cmp    r14,rsi
  210395:	75 99                	jne    210330 <FixedBufferAllocator_realloc+0x150>
  210397:	48 85 d2             	test   rdx,rdx
  21039a:	74 19                	je     2103b5 <FixedBufferAllocator_realloc+0x1d5>
  21039c:	48 f7 da             	neg    rdx
  21039f:	90                   	nop
  2103a0:	49 8b 01             	mov    rax,QWORD PTR [r9]
  2103a3:	0f b6 04 30          	movzx  eax,BYTE PTR [rax+rsi*1]
        dest[i] = s;
  2103a7:	41 88 04 33          	mov    BYTE PTR [r11+rsi*1],al
    for (source) |s, i|
  2103ab:	48 83 c6 01          	add    rsi,0x1
  2103af:	48 83 c2 01          	add    rdx,0x1
  2103b3:	75 eb                	jne    2103a0 <FixedBufferAllocator_realloc+0x1c0>
            mem.copy(u8, result, old_mem);
            return result;
  2103b5:	66 c7 07 00 00       	mov    WORD PTR [rdi],0x0
  2103ba:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  2103bf:	66 89 47 06          	mov    WORD PTR [rdi+0x6],ax
  2103c3:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  2103c6:	89 47 02             	mov    DWORD PTR [rdi+0x2],eax
  2103c9:	4c 89 5f 08          	mov    QWORD PTR [rdi+0x8],r11
  2103cd:	48 89 4f 10          	mov    QWORD PTR [rdi+0x10],rcx
  2103d1:	48 89 f8             	mov    rax,rdi
  2103d4:	48 83 c4 28          	add    rsp,0x28
  2103d8:	5b                   	pop    rbx
  2103d9:	41 5e                	pop    r14
  2103db:	c3                   	ret    
            @panic("assertion failure");
  2103dc:	e8 cf 98 ff ff       	call   209cb0 <panic>
  2103e1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2103e8:	0f 1f 84 00 00 00 00 
  2103ef:	00 

00000000002103f0 <InStream(ReadError)_readInt.33>:
        pub fn readInt(self: *Self, endian: builtin.Endian, comptime T: type) !T {
  2103f0:	55                   	push   rbp
  2103f1:	53                   	push   rbx
  2103f2:	48 83 ec 48          	sub    rsp,0x48
  2103f6:	89 d5                	mov    ebp,edx
  2103f8:	48 89 fb             	mov    rbx,rdi
  2103fb:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            try self.readNoEof(bytes[0..]);
  210400:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  210405:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  21040c:	00 00 
  21040e:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
  210413:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  210418:	ff 16                	call   QWORD PTR [rsi]
  21041a:	0f b7 44 24 28       	movzx  eax,WORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  21041f:	66 85 c0             	test   ax,ax
  210422:	75 10                	jne    210434 <InStream(ReadError)_readInt.33+0x44>
  210424:	48 8b 4c 24 30       	mov    rcx,QWORD PTR [rsp+0x30]
  210429:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  21042d:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  210432:	73 1c                	jae    210450 <InStream(ReadError)_readInt.33+0x60>
            try self.readNoEof(bytes[0..]);
  210434:	66 89 03             	mov    WORD PTR [rbx],ax
  210437:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  21043c:	48 8b 4c 24 40       	mov    rcx,QWORD PTR [rsp+0x40]
  210441:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  210445:	48 89 43 02          	mov    QWORD PTR [rbx+0x2],rax
  210449:	48 83 c4 48          	add    rsp,0x48
  21044d:	5b                   	pop    rbx
  21044e:	5d                   	pop    rbp
  21044f:	c3                   	ret    
  210450:	0f b6 44 24 08       	movzx  eax,BYTE PTR [rsp+0x8]
  210455:	0f b6 4c 24 09       	movzx  ecx,BYTE PTR [rsp+0x9]
    switch (endian) {
  21045a:	40 f6 c5 01          	test   bpl,0x1
  21045e:	74 51                	je     2104b1 <InStream(ReadError)_readInt.33+0xc1>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  210460:	48 c1 e1 08          	shl    rcx,0x8
  210464:	48 09 c1             	or     rcx,rax
  210467:	0f b6 44 24 0a       	movzx  eax,BYTE PTR [rsp+0xa]
  21046c:	48 c1 e0 10          	shl    rax,0x10
  210470:	48 09 c8             	or     rax,rcx
  210473:	0f b6 4c 24 0b       	movzx  ecx,BYTE PTR [rsp+0xb]
  210478:	48 c1 e1 18          	shl    rcx,0x18
  21047c:	48 09 c1             	or     rcx,rax
  21047f:	0f b6 44 24 0c       	movzx  eax,BYTE PTR [rsp+0xc]
  210484:	48 c1 e0 20          	shl    rax,0x20
  210488:	48 09 c8             	or     rax,rcx
  21048b:	0f b6 4c 24 0d       	movzx  ecx,BYTE PTR [rsp+0xd]
  210490:	48 c1 e1 28          	shl    rcx,0x28
  210494:	48 09 c1             	or     rcx,rax
  210497:	0f b6 54 24 0e       	movzx  edx,BYTE PTR [rsp+0xe]
  21049c:	48 c1 e2 30          	shl    rdx,0x30
  2104a0:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  2104a5:	48 c1 e0 38          	shl    rax,0x38
  2104a9:	48 09 d0             	or     rax,rdx
  2104ac:	48 09 c8             	or     rax,rcx
  2104af:	eb 4f                	jmp    210500 <InStream(ReadError)_readInt.33+0x110>
                result = (result << 8) | b;
  2104b1:	48 c1 e0 08          	shl    rax,0x8
  2104b5:	48 09 c8             	or     rax,rcx
  2104b8:	48 c1 e0 08          	shl    rax,0x8
  2104bc:	0f b6 4c 24 0a       	movzx  ecx,BYTE PTR [rsp+0xa]
  2104c1:	48 09 c1             	or     rcx,rax
  2104c4:	48 c1 e1 08          	shl    rcx,0x8
  2104c8:	0f b6 44 24 0b       	movzx  eax,BYTE PTR [rsp+0xb]
  2104cd:	48 09 c8             	or     rax,rcx
  2104d0:	48 c1 e0 08          	shl    rax,0x8
  2104d4:	0f b6 4c 24 0c       	movzx  ecx,BYTE PTR [rsp+0xc]
  2104d9:	48 09 c1             	or     rcx,rax
  2104dc:	48 c1 e1 08          	shl    rcx,0x8
  2104e0:	0f b6 44 24 0d       	movzx  eax,BYTE PTR [rsp+0xd]
  2104e5:	48 09 c8             	or     rax,rcx
  2104e8:	48 c1 e0 08          	shl    rax,0x8
  2104ec:	0f b6 4c 24 0e       	movzx  ecx,BYTE PTR [rsp+0xe]
  2104f1:	48 09 c1             	or     rcx,rax
  2104f4:	48 c1 e1 08          	shl    rcx,0x8
  2104f8:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
  2104fd:	48 09 c8             	or     rax,rcx
            return mem.readInt(bytes, T, endian);
  210500:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  210505:	0f b7 4c 24 16       	movzx  ecx,WORD PTR [rsp+0x16]
  21050a:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21050e:	8b 4c 24 12          	mov    ecx,DWORD PTR [rsp+0x12]
  210512:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  210515:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  210519:	48 83 c4 48          	add    rsp,0x48
  21051d:	5b                   	pop    rbx
  21051e:	5d                   	pop    rbp
  21051f:	c3                   	ret    

0000000000210520 <File_read>:
        IsDir,

        Unexpected,
    };

    pub fn read(self: *File, buffer: []u8) ReadError!usize {
  210520:	41 57                	push   r15
  210522:	41 56                	push   r14
  210524:	53                   	push   rbx
  210525:	49 89 d1             	mov    r9,rdx
  210528:	49 89 f2             	mov    r10,rsi
  21052b:	49 89 f8             	mov    r8,rdi
        if (is_posix) {
            var index: usize = 0;
            while (index < buffer.len) {
  21052e:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  210532:	48 85 d2             	test   rdx,rdx
  210535:	74 6c                	je     2105a3 <File_read+0x83>
  210537:	45 31 f6             	xor    r14d,r14d
  21053a:	4c 8d 3d 0b 0f ff ff 	lea    r15,[rip+0xffffffffffff0f0b]        # 20144c <__unnamed_9+0x76c>
  210541:	31 db                	xor    ebx,ebx
  210543:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21054a:	84 00 00 00 00 00 
  210550:	49 8b 31             	mov    rsi,QWORD PTR [r9]
                const amt_read = posix.read(self.handle, buffer.ptr + index, buffer.len - index);
  210553:	48 01 de             	add    rsi,rbx
  210556:	48 29 da             	sub    rdx,rbx
    return syscall3(SYS_read, @intCast(usize, fd), @ptrToInt(buf), count);
  210559:	49 63 3a             	movsxd rdi,DWORD PTR [r10]
  21055c:	31 c0                	xor    eax,eax
  21055e:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  210560:	48 89 c1             	mov    rcx,rax
  210563:	48 f7 d9             	neg    rcx
  210566:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  21056c:	49 0f 46 ce          	cmovbe rcx,r14
                const read_err = posix.getErrno(amt_read);
                if (read_err > 0) {
  210570:	48 83 f9 04          	cmp    rcx,0x4
  210574:	75 0b                	jne    210581 <File_read+0x61>
            while (index < buffer.len) {
  210576:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  21057a:	48 39 da             	cmp    rdx,rbx
  21057d:	77 d1                	ja     210550 <File_read+0x30>
  21057f:	eb 24                	jmp    2105a5 <File_read+0x85>
  210581:	48 83 f9 15          	cmp    rcx,0x15
  210585:	77 67                	ja     2105ee <File_read+0xce>
  210587:	49 63 0c 8f          	movsxd rcx,DWORD PTR [r15+rcx*4]
  21058b:	4c 01 f9             	add    rcx,r15
  21058e:	ff e1                	jmp    rcx
                        posix.EIO => return error.Io,
                        posix.EISDIR => return error.IsDir,
                        else => return os.unexpectedErrorPosix(read_err),
                    }
                }
                if (amt_read == 0) return index;
  210590:	48 85 c0             	test   rax,rax
  210593:	74 77                	je     21060c <File_read+0xec>
  210595:	48 01 c3             	add    rbx,rax
            while (index < buffer.len) {
  210598:	49 8b 51 08          	mov    rdx,QWORD PTR [r9+0x8]
  21059c:	48 39 da             	cmp    rdx,rbx
  21059f:	77 af                	ja     210550 <File_read+0x30>
  2105a1:	eb 02                	jmp    2105a5 <File_read+0x85>
  2105a3:	31 db                	xor    ebx,ebx
                index += amt_read;
            }
            return index;
  2105a5:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  2105ab:	0f b7 44 24 ea       	movzx  eax,WORD PTR [rsp-0x16]
  2105b0:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  2105b5:	8b 44 24 e6          	mov    eax,DWORD PTR [rsp-0x1a]
  2105b9:	41 89 40 02          	mov    DWORD PTR [r8+0x2],eax
  2105bd:	49 89 58 08          	mov    QWORD PTR [r8+0x8],rbx
  2105c1:	5b                   	pop    rbx
  2105c2:	41 5e                	pop    r14
  2105c4:	41 5f                	pop    r15
  2105c6:	c3                   	ret    
                        posix.EIO => return error.Io,
  2105c7:	c5 f8 10 05 f1 00 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff00f1]        # 2006c0 <__unnamed_62>
  2105ce:	ff 
  2105cf:	eb 12                	jmp    2105e3 <File_read+0xc3>
                        posix.EBADF => return error.BadFd,
  2105d1:	c5 f8 10 05 67 02 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff0267]        # 200840 <__unnamed_63>
  2105d8:	ff 
  2105d9:	eb 08                	jmp    2105e3 <File_read+0xc3>
                        posix.EISDIR => return error.IsDir,
  2105db:	c5 f8 10 05 dd ff fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffeffdd]        # 2005c0 <__unnamed_64>
  2105e2:	ff 
  2105e3:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
  2105e8:	5b                   	pop    rbx
  2105e9:	41 5e                	pop    r14
  2105eb:	41 5f                	pop    r15
  2105ed:	c3                   	ret    
                        else => return os.unexpectedErrorPosix(read_err),
  2105ee:	66 41 c7 00 02 00    	mov    WORD PTR [r8],0x2
  2105f4:	48 8b 44 24 f2       	mov    rax,QWORD PTR [rsp-0xe]
  2105f9:	48 8b 4c 24 f8       	mov    rcx,QWORD PTR [rsp-0x8]
  2105fe:	49 89 48 08          	mov    QWORD PTR [r8+0x8],rcx
  210602:	49 89 40 02          	mov    QWORD PTR [r8+0x2],rax
  210606:	5b                   	pop    rbx
  210607:	41 5e                	pop    r14
  210609:	41 5f                	pop    r15
  21060b:	c3                   	ret    
                if (amt_read == 0) return index;
  21060c:	66 41 c7 00 00 00    	mov    WORD PTR [r8],0x0
  210612:	0f b7 44 24 f0       	movzx  eax,WORD PTR [rsp-0x10]
  210617:	66 41 89 40 06       	mov    WORD PTR [r8+0x6],ax
  21061c:	8b 44 24 ec          	mov    eax,DWORD PTR [rsp-0x14]
  210620:	eb 97                	jmp    2105b9 <File_read+0x99>
  210622:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210629:	1f 84 00 00 00 00 00 

0000000000210630 <FileInStream_readFn>:
    fn readFn(in_stream: *Stream, buffer: []u8) Error!usize {
  210630:	53                   	push   rbx
  210631:	48 83 ec 10          	sub    rsp,0x10
  210635:	48 89 fb             	mov    rbx,rdi
        return self.file.read(buffer);
  210638:	48 8b 76 f8          	mov    rsi,QWORD PTR [rsi-0x8]
  21063c:	48 89 e7             	mov    rdi,rsp
  21063f:	e8 dc fe ff ff       	call   210520 <File_read>
  210644:	c5 f8 10 04 24       	vmovups xmm0,XMMWORD PTR [rsp]
  210649:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21064d:	48 89 d8             	mov    rax,rbx
  210650:	48 83 c4 10          	add    rsp,0x10
  210654:	5b                   	pop    rbx
  210655:	c3                   	ret    
  210656:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21065d:	00 00 00 

0000000000210660 <parseAbbrevTable>:
fn parseAbbrevTable(st: *ElfStackTrace) !AbbrevTable {
  210660:	55                   	push   rbp
  210661:	41 57                	push   r15
  210663:	41 56                	push   r14
  210665:	41 55                	push   r13
  210667:	41 54                	push   r12
  210669:	53                   	push   rbx
  21066a:	48 81 ec f8 01 00 00 	sub    rsp,0x1f8
  210671:	49 89 f4             	mov    r12,rsi
    var in_file_stream = io.FileInStream.init(in_file);
  210674:	4c 89 64 24 28       	mov    QWORD PTR [rsp+0x28],r12
  210679:	48 89 fb             	mov    rbx,rdi
  21067c:	48 8d 05 ad ff ff ff 	lea    rax,[rip+0xffffffffffffffad]        # 210630 <FileInStream_readFn>
  210683:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  210688:	4d 8b b4 24 a0 00 00 	mov    r14,QWORD PTR [r12+0xa0]
  21068f:	00 
            return Self{
  210690:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  210694:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21069b:	00 00 
  21069d:	48 c7 84 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],0x0
  2106a4:	00 00 00 00 00 
    var result = AbbrevTable.init(st.allocator());
  2106a9:	4c 89 b4 24 a8 00 00 	mov    QWORD PTR [rsp+0xa8],r14
  2106b0:	00 
  2106b1:	4c 8d 6c 24 0f       	lea    r13,[rsp+0xf]
            try self.readNoEof(result[0..]);
  2106b6:	4c 89 6c 24 60       	mov    QWORD PTR [rsp+0x60],r13
  2106bb:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  2106c2:	00 00 
        return self.file.read(buffer);
  2106c4:	48 8b 74 24 28       	mov    rsi,QWORD PTR [rsp+0x28]
  2106c9:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2106ce:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  2106d3:	e8 48 fe ff ff       	call   210520 <File_read>
  2106d8:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  2106de:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
            return self.readFn(self, buffer);
  2106e4:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
            const amt_read = try self.read(buf);
  2106e9:	66 85 c9             	test   cx,cx
  2106ec:	74 32                	je     210720 <parseAbbrevTable+0xc0>
        const abbrev_code = try readULeb128(in_stream);
  2106ee:	66 89 0b             	mov    WORD PTR [rbx],cx
  2106f1:	48 8b 84 24 f0 01 00 	mov    rax,QWORD PTR [rsp+0x1f0]
  2106f8:	00 
  2106f9:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
  2106fd:	c5 fc 10 84 24 d2 01 	vmovups ymm0,YMMWORD PTR [rsp+0x1d2]
  210704:	00 00 
  210706:	c5 fc 11 43 02       	vmovups YMMWORD PTR [rbx+0x2],ymm0
  21070b:	48 81 c4 f8 01 00 00 	add    rsp,0x1f8
  210712:	5b                   	pop    rbx
  210713:	41 5c                	pop    r12
  210715:	41 5d                	pop    r13
  210717:	41 5e                	pop    r14
  210719:	41 5f                	pop    r15
  21071b:	5d                   	pop    rbp
  21071c:	c5 f8 77             	vzeroupper 
  21071f:	c3                   	ret    
  210720:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
  210725:	31 c9                	xor    ecx,ecx
  210727:	48 89 4c 24 70       	mov    QWORD PTR [rsp+0x70],rcx
  21072c:	31 c9                	xor    ecx,ecx
  21072e:	48 89 4c 24 58       	mov    QWORD PTR [rsp+0x58],rcx
  210733:	45 31 ff             	xor    r15d,r15d
  210736:	31 ed                	xor    ebp,ebp
  210738:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21073f:	00 
            if (amt_read < buf.len) return error.EndOfStream;
  210740:	48 3b 44 24 68       	cmp    rax,QWORD PTR [rsp+0x68]
  210745:	0f 82 f8 04 00 00    	jb     210c43 <parseAbbrevTable+0x5e3>
            return result[0];
  21074b:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  210750:	89 c2                	mov    edx,eax
  210752:	83 e2 7f             	and    edx,0x7f
  210755:	89 ee                	mov    esi,ebp
  210757:	83 e6 3f             	and    esi,0x3f
  21075a:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21075f:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  210764:	48 39 d6             	cmp    rsi,rdx
  210767:	0f 85 df 04 00 00    	jne    210c4c <parseAbbrevTable+0x5ec>
        result |= operand;
  21076d:	49 09 cf             	or     r15,rcx
        if ((byte & 0b10000000) == 0) return result;
  210770:	84 c0                	test   al,al
  210772:	79 39                	jns    2107ad <parseAbbrevTable+0x14d>
        shift += 7;
  210774:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  210778:	4c 89 6c 24 60       	mov    QWORD PTR [rsp+0x60],r13
  21077d:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  210784:	00 00 
            return self.readFn(self, buffer);
  210786:	48 8d 7c 24 10       	lea    rdi,[rsp+0x10]
  21078b:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  210790:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  210795:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210799:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
  21079e:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
            const amt_read = try self.read(buf);
  2107a3:	66 85 c9             	test   cx,cx
  2107a6:	74 98                	je     210740 <parseAbbrevTable+0xe0>
  2107a8:	e9 41 ff ff ff       	jmp    2106ee <parseAbbrevTable+0x8e>
        if (abbrev_code == 0) return result;
  2107ad:	4d 85 ff             	test   r15,r15
  2107b0:	0f 84 01 05 00 00    	je     210cb7 <parseAbbrevTable+0x657>
  2107b6:	48 89 5c 24 38       	mov    QWORD PTR [rsp+0x38],rbx
  2107bb:	4c 89 a4 24 88 00 00 	mov    QWORD PTR [rsp+0x88],r12
  2107c2:	00 
            try self.readNoEof(result[0..]);
  2107c3:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  2107c8:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2107cf:	00 00 
  2107d1:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
            return self.readFn(self, buffer);
  2107d6:	48 89 df             	mov    rdi,rbx
  2107d9:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2107de:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2107e3:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  2107e7:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2107ec:	66 85 c0             	test   ax,ax
  2107ef:	0f 85 6a 04 00 00    	jne    210c5f <parseAbbrevTable+0x5ff>
  2107f5:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2107fa:	45 31 e4             	xor    r12d,r12d
  2107fd:	31 ed                	xor    ebp,ebp
  2107ff:	90                   	nop
            if (amt_read < buf.len) return error.EndOfStream;
  210800:	48 3b 4c 24 18       	cmp    rcx,QWORD PTR [rsp+0x18]
  210805:	0f 82 4a 04 00 00    	jb     210c55 <parseAbbrevTable+0x5f5>
            return result[0];
  21080b:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  210810:	89 c2                	mov    edx,eax
  210812:	83 e2 7f             	and    edx,0x7f
  210815:	89 ee                	mov    esi,ebp
  210817:	83 e6 3f             	and    esi,0x3f
  21081a:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21081f:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  210824:	48 39 d6             	cmp    rsi,rdx
  210827:	0f 85 2e 04 00 00    	jne    210c5b <parseAbbrevTable+0x5fb>
        result |= operand;
  21082d:	49 09 cc             	or     r12,rcx
        if ((byte & 0b10000000) == 0) return result;
  210830:	84 c0                	test   al,al
  210832:	79 3c                	jns    210870 <parseAbbrevTable+0x210>
        shift += 7;
  210834:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  210838:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  21083d:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  210842:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210849:	00 00 
            return self.readFn(self, buffer);
  21084b:	48 89 df             	mov    rdi,rbx
  21084e:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  210853:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  210858:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  21085c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210861:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  210866:	66 85 c0             	test   ax,ax
  210869:	74 95                	je     210800 <parseAbbrevTable+0x1a0>
  21086b:	e9 ef 03 00 00       	jmp    210c5f <parseAbbrevTable+0x5ff>
            try self.readNoEof(result[0..]);
  210870:	48 8d 44 24 0f       	lea    rax,[rsp+0xf]
  210875:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21087a:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210881:	00 00 
            return self.readFn(self, buffer);
  210883:	48 89 df             	mov    rdi,rbx
  210886:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  21088b:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  210890:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210894:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210899:	66 85 c0             	test   ax,ax
  21089c:	0f 85 7b 04 00 00    	jne    210d1d <parseAbbrevTable+0x6bd>
  2108a2:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
            if (amt_read < buf.len) return error.EndOfStream;
  2108a7:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  2108ac:	0f 82 67 04 00 00    	jb     210d19 <parseAbbrevTable+0x6b9>
  2108b2:	4c 89 b4 24 80 00 00 	mov    QWORD PTR [rsp+0x80],r14
  2108b9:	00 
  2108ba:	48 8b 84 24 88 00 00 	mov    rax,QWORD PTR [rsp+0x88]
  2108c1:	00 
  2108c2:	4c 8b a8 a0 00 00 00 	mov    r13,QWORD PTR [rax+0xa0]
  2108c9:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  2108cd:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  2108d4:	00 00 
            return result[0];
  2108d6:	8a 5c 24 0f          	mov    bl,BYTE PTR [rsp+0xf]
  2108da:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x0
  2108e1:	00 00 00 00 00 
            var better_capacity = self.items.len;
  2108e6:	48 8b 8c 24 98 00 00 	mov    rcx,QWORD PTR [rsp+0x98]
  2108ed:	00 
  2108ee:	4c 8b 74 24 58       	mov    r14,QWORD PTR [rsp+0x58]
            if (better_capacity >= new_capacity) return;
  2108f3:	4c 39 f1             	cmp    rcx,r14
  2108f6:	76 08                	jbe    210900 <parseAbbrevTable+0x2a0>
  2108f8:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  2108fd:	eb 55                	jmp    210954 <parseAbbrevTable+0x2f4>
  2108ff:	90                   	nop
                better_capacity += better_capacity / 2 + 8;
  210900:	48 89 c8             	mov    rax,rcx
  210903:	48 d1 e8             	shr    rax,1
  210906:	48 01 c1             	add    rcx,rax
  210909:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  21090d:	4c 39 f1             	cmp    rcx,r14
  210910:	76 ee                	jbe    210900 <parseAbbrevTable+0x2a0>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  210912:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  210917:	48 8b b4 24 80 00 00 	mov    rsi,QWORD PTR [rsp+0x80]
  21091e:	00 
  21091f:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  210926:	00 
  210927:	e8 74 04 00 00       	call   210da0 <Allocator_alignedRealloc>
  21092c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210931:	66 85 c0             	test   ax,ax
  210934:	0f 85 0a 04 00 00    	jne    210d44 <parseAbbrevTable+0x6e4>
  21093a:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21093f:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  210943:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21094a:	00 00 
            const result = &self.items[self.len];
  21094c:	48 8b 8c 24 90 00 00 	mov    rcx,QWORD PTR [rsp+0x90]
  210953:	00 
  210954:	49 6b ee 38          	imul   rbp,r14,0x38
  210958:	49 83 c6 01          	add    r14,0x1
            self.len = new_length;
  21095c:	4c 89 b4 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],r14
  210963:	00 
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  210964:	80 fb 01             	cmp    bl,0x1
            new_item_ptr.* = item;
  210967:	0f 94 04 29          	sete   BYTE PTR [rcx+rbp*1]
  21096b:	8a 44 24 7f          	mov    al,BYTE PTR [rsp+0x7f]
  21096f:	88 44 29 07          	mov    BYTE PTR [rcx+rbp*1+0x7],al
  210973:	0f b7 44 24 7d       	movzx  eax,WORD PTR [rsp+0x7d]
  210978:	66 89 44 29 05       	mov    WORD PTR [rcx+rbp*1+0x5],ax
  21097d:	8b 44 24 79          	mov    eax,DWORD PTR [rsp+0x79]
  210981:	89 44 29 01          	mov    DWORD PTR [rcx+rbp*1+0x1],eax
  210985:	4c 89 7c 29 08       	mov    QWORD PTR [rcx+rbp*1+0x8],r15
  21098a:	4c 89 64 29 10       	mov    QWORD PTR [rcx+rbp*1+0x10],r12
  21098f:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  210996:	00 
  210997:	48 89 44 29 28       	mov    QWORD PTR [rcx+rbp*1+0x28],rax
  21099c:	c5 f8 28 84 24 b0 00 	vmovaps xmm0,XMMWORD PTR [rsp+0xb0]
  2109a3:	00 00 
  2109a5:	c5 f8 11 44 29 18    	vmovups XMMWORD PTR [rcx+rbp*1+0x18],xmm0
  2109ab:	48 89 c8             	mov    rax,rcx
  2109ae:	48 89 44 24 70       	mov    QWORD PTR [rsp+0x70],rax
  2109b3:	4c 89 6c 29 30       	mov    QWORD PTR [rcx+rbp*1+0x30],r13
  2109b8:	4c 8d 6c 24 0f       	lea    r13,[rsp+0xf]
            try self.readNoEof(result[0..]);
  2109bd:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  2109c2:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  2109c9:	00 00 
  2109cb:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
            return self.readFn(self, buffer);
  2109d0:	48 89 df             	mov    rdi,rbx
  2109d3:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  2109d8:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2109dd:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  2109e1:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2109e6:	66 85 c0             	test   ax,ax
  2109e9:	0f 85 fd 02 00 00    	jne    210cec <parseAbbrevTable+0x68c>
  2109ef:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  2109f4:	48 01 e8             	add    rax,rbp
  2109f7:	48 83 c0 18          	add    rax,0x18
  2109fb:	48 89 44 24 58       	mov    QWORD PTR [rsp+0x58],rax
  210a00:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210a05:	45 31 ff             	xor    r15d,r15d
  210a08:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  210a0a:	48 3b 4c 24 18       	cmp    rcx,QWORD PTR [rsp+0x18]
  210a0f:	0f 82 d3 02 00 00    	jb     210ce8 <parseAbbrevTable+0x688>
            return result[0];
  210a15:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  210a1a:	89 c2                	mov    edx,eax
  210a1c:	83 e2 7f             	and    edx,0x7f
  210a1f:	89 ee                	mov    esi,ebp
  210a21:	83 e6 3f             	and    esi,0x3f
  210a24:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  210a29:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  210a2e:	48 39 d6             	cmp    rsi,rdx
  210a31:	48 8b 54 24 38       	mov    rdx,QWORD PTR [rsp+0x38]
  210a36:	0f 85 b7 02 00 00    	jne    210cf3 <parseAbbrevTable+0x693>
        result |= operand;
  210a3c:	49 09 cf             	or     r15,rcx
        if ((byte & 0b10000000) == 0) return result;
  210a3f:	84 c0                	test   al,al
  210a41:	0f 88 a2 00 00 00    	js     210ae9 <parseAbbrevTable+0x489>
            try self.readNoEof(result[0..]);
  210a47:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  210a4c:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210a53:	00 00 
            return self.readFn(self, buffer);
  210a55:	48 89 df             	mov    rdi,rbx
  210a58:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  210a5d:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  210a62:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210a66:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  210a6b:	66 85 c0             	test   ax,ax
  210a6e:	0f 85 1c 02 00 00    	jne    210c90 <parseAbbrevTable+0x630>
  210a74:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210a79:	45 31 e4             	xor    r12d,r12d
  210a7c:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  210a7e:	48 3b 4c 24 18       	cmp    rcx,QWORD PTR [rsp+0x18]
  210a83:	0f 82 fd 01 00 00    	jb     210c86 <parseAbbrevTable+0x626>
            return result[0];
  210a89:	0f b6 44 24 0f       	movzx  eax,BYTE PTR [rsp+0xf]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  210a8e:	89 c2                	mov    edx,eax
  210a90:	83 e2 7f             	and    edx,0x7f
  210a93:	89 ee                	mov    esi,ebp
  210a95:	83 e6 3f             	and    esi,0x3f
  210a98:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  210a9d:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  210aa2:	48 39 d6             	cmp    rsi,rdx
  210aa5:	0f 85 e1 01 00 00    	jne    210c8c <parseAbbrevTable+0x62c>
        result |= operand;
  210aab:	49 09 cc             	or     r12,rcx
        if ((byte & 0b10000000) == 0) return result;
  210aae:	84 c0                	test   al,al
  210ab0:	79 72                	jns    210b24 <parseAbbrevTable+0x4c4>
        shift += 7;
  210ab2:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  210ab6:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  210abb:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210ac2:	00 00 
            return self.readFn(self, buffer);
  210ac4:	48 89 df             	mov    rdi,rbx
  210ac7:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  210acc:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  210ad1:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210ad5:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210ada:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  210adf:	66 85 c0             	test   ax,ax
  210ae2:	74 9a                	je     210a7e <parseAbbrevTable+0x41e>
  210ae4:	e9 a7 01 00 00       	jmp    210c90 <parseAbbrevTable+0x630>
  210ae9:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  210aed:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  210af2:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210af9:	00 00 
            return self.readFn(self, buffer);
  210afb:	48 89 df             	mov    rdi,rbx
  210afe:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  210b03:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  210b08:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210b0c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210b11:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  210b16:	66 85 c0             	test   ax,ax
  210b19:	0f 84 eb fe ff ff    	je     210a0a <parseAbbrevTable+0x3aa>
  210b1f:	e9 c8 01 00 00       	jmp    210cec <parseAbbrevTable+0x68c>
            if (attr_id == 0 and form_id == 0) break;
  210b24:	4c 89 e0             	mov    rax,r12
  210b27:	4c 09 f8             	or     rax,r15
  210b2a:	0f 84 c0 00 00 00    	je     210bf0 <parseAbbrevTable+0x590>
  210b30:	48 8b 44 24 58       	mov    rax,QWORD PTR [rsp+0x58]
            const new_length = self.len + 1;
  210b35:	48 8b 68 10          	mov    rbp,QWORD PTR [rax+0x10]
            var better_capacity = self.items.len;
  210b39:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
            if (better_capacity >= new_capacity) return;
  210b3d:	48 39 e9             	cmp    rcx,rbp
  210b40:	76 0a                	jbe    210b4c <parseAbbrevTable+0x4ec>
            const result = &self.items[self.len];
  210b42:	48 89 e8             	mov    rax,rbp
  210b45:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  210b4a:	eb 47                	jmp    210b93 <parseAbbrevTable+0x533>
                better_capacity += better_capacity / 2 + 8;
  210b4c:	48 89 c8             	mov    rax,rcx
  210b4f:	48 d1 e8             	shr    rax,1
  210b52:	48 01 c1             	add    rcx,rax
  210b55:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  210b59:	48 39 e9             	cmp    rcx,rbp
  210b5c:	76 ee                	jbe    210b4c <parseAbbrevTable+0x4ec>
  210b5e:	48 8b 54 24 58       	mov    rdx,QWORD PTR [rsp+0x58]
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  210b63:	48 8b 72 18          	mov    rsi,QWORD PTR [rdx+0x18]
  210b67:	48 89 df             	mov    rdi,rbx
  210b6a:	e8 c1 04 00 00       	call   211030 <Allocator_alignedRealloc.41>
  210b6f:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210b74:	66 85 c0             	test   ax,ax
  210b77:	0f 85 ee 01 00 00    	jne    210d6b <parseAbbrevTable+0x70b>
  210b7d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  210b82:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  210b86:	48 8b 4c 24 58       	mov    rcx,QWORD PTR [rsp+0x58]
  210b8b:	c5 f8 11 01          	vmovups XMMWORD PTR [rcx],xmm0
            const result = &self.items[self.len];
  210b8f:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
  210b93:	48 83 c5 01          	add    rbp,0x1
  210b97:	48 89 ca             	mov    rdx,rcx
  210b9a:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
            self.len = new_length;
  210b9d:	48 89 6a 10          	mov    QWORD PTR [rdx+0x10],rbp
            new_item_ptr.* = item;
  210ba1:	48 c1 e0 04          	shl    rax,0x4
  210ba5:	4c 89 3c 01          	mov    QWORD PTR [rcx+rax*1],r15
  210ba9:	4c 89 64 01 08       	mov    QWORD PTR [rcx+rax*1+0x8],r12
            try self.readNoEof(result[0..]);
  210bae:	4c 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],r13
  210bb3:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  210bba:	00 00 
            return self.readFn(self, buffer);
  210bbc:	48 89 df             	mov    rdi,rbx
  210bbf:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  210bc4:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  210bc9:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210bcd:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  210bd2:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  210bd7:	41 bf 00 00 00 00    	mov    r15d,0x0
  210bdd:	bd 00 00 00 00       	mov    ebp,0x0
            const amt_read = try self.read(buf);
  210be2:	66 85 c0             	test   ax,ax
  210be5:	0f 84 1f fe ff ff    	je     210a0a <parseAbbrevTable+0x3aa>
  210beb:	e9 fc 00 00 00       	jmp    210cec <parseAbbrevTable+0x68c>
            try self.readNoEof(result[0..]);
  210bf0:	4c 89 74 24 58       	mov    QWORD PTR [rsp+0x58],r14
  210bf5:	4c 89 6c 24 60       	mov    QWORD PTR [rsp+0x60],r13
  210bfa:	48 c7 44 24 68 01 00 	mov    QWORD PTR [rsp+0x68],0x1
  210c01:	00 00 
            return self.readFn(self, buffer);
  210c03:	48 8d 7c 24 10       	lea    rdi,[rsp+0x10]
  210c08:	48 8d 74 24 30       	lea    rsi,[rsp+0x30]
  210c0d:	48 8d 54 24 60       	lea    rdx,[rsp+0x60]
  210c12:	ff 54 24 30          	call   QWORD PTR [rsp+0x30]
  210c16:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
  210c1b:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
            const amt_read = try self.read(buf);
  210c20:	66 85 c9             	test   cx,cx
  210c23:	4c 8b b4 24 80 00 00 	mov    r14,QWORD PTR [rsp+0x80]
  210c2a:	00 
  210c2b:	4c 8b a4 24 88 00 00 	mov    r12,QWORD PTR [rsp+0x88]
  210c32:	00 
  210c33:	48 8b 5c 24 38       	mov    rbx,QWORD PTR [rsp+0x38]
  210c38:	0f 84 f5 fa ff ff    	je     210733 <parseAbbrevTable+0xd3>
  210c3e:	e9 ab fa ff ff       	jmp    2106ee <parseAbbrevTable+0x8e>
  210c43:	66 b9 20 00          	mov    cx,0x20
  210c47:	e9 a2 fa ff ff       	jmp    2106ee <parseAbbrevTable+0x8e>
  210c4c:	66 b9 25 00          	mov    cx,0x25
  210c50:	e9 99 fa ff ff       	jmp    2106ee <parseAbbrevTable+0x8e>
  210c55:	66 b8 20 00          	mov    ax,0x20
  210c59:	eb 04                	jmp    210c5f <parseAbbrevTable+0x5ff>
  210c5b:	66 b8 25 00          	mov    ax,0x25
  210c5f:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
            .tag_id = try readULeb128(in_stream),
  210c64:	66 89 01             	mov    WORD PTR [rcx],ax
  210c67:	48 8b 84 24 ca 01 00 	mov    rax,QWORD PTR [rsp+0x1ca]
  210c6e:	00 
  210c6f:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210c73:	c5 fc 10 84 24 ac 01 	vmovups ymm0,YMMWORD PTR [rsp+0x1ac]
  210c7a:	00 00 
  210c7c:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210c81:	e9 85 fa ff ff       	jmp    21070b <parseAbbrevTable+0xab>
  210c86:	66 b8 20 00          	mov    ax,0x20
  210c8a:	eb 04                	jmp    210c90 <parseAbbrevTable+0x630>
  210c8c:	66 b8 25 00          	mov    ax,0x25
  210c90:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
            const form_id = try readULeb128(in_stream);
  210c95:	66 89 01             	mov    WORD PTR [rcx],ax
  210c98:	48 8b 84 24 32 01 00 	mov    rax,QWORD PTR [rsp+0x132]
  210c9f:	00 
  210ca0:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210ca4:	c5 fc 10 84 24 14 01 	vmovups ymm0,YMMWORD PTR [rsp+0x114]
  210cab:	00 00 
  210cad:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210cb2:	e9 54 fa ff ff       	jmp    21070b <parseAbbrevTable+0xab>
        if (abbrev_code == 0) return result;
  210cb7:	c5 fc 10 84 24 90 00 	vmovups ymm0,YMMWORD PTR [rsp+0x90]
  210cbe:	00 00 
  210cc0:	c5 fc 11 84 24 ce 00 	vmovups YMMWORD PTR [rsp+0xce],ymm0
  210cc7:	00 00 
  210cc9:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  210cce:	48 8b 84 24 e6 00 00 	mov    rax,QWORD PTR [rsp+0xe6]
  210cd5:	00 
  210cd6:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
  210cda:	c5 fc 10 84 24 c8 00 	vmovups ymm0,YMMWORD PTR [rsp+0xc8]
  210ce1:	00 00 
  210ce3:	e9 1e fa ff ff       	jmp    210706 <parseAbbrevTable+0xa6>
  210ce8:	66 b8 20 00          	mov    ax,0x20
  210cec:	48 8b 54 24 38       	mov    rdx,QWORD PTR [rsp+0x38]
  210cf1:	eb 04                	jmp    210cf7 <parseAbbrevTable+0x697>
  210cf3:	66 b8 25 00          	mov    ax,0x25
            const attr_id = try readULeb128(in_stream);
  210cf7:	66 89 02             	mov    WORD PTR [rdx],ax
  210cfa:	48 8b 84 24 58 01 00 	mov    rax,QWORD PTR [rsp+0x158]
  210d01:	00 
  210d02:	48 89 42 20          	mov    QWORD PTR [rdx+0x20],rax
  210d06:	c5 fc 10 84 24 3a 01 	vmovups ymm0,YMMWORD PTR [rsp+0x13a]
  210d0d:	00 00 
  210d0f:	c5 fc 11 42 02       	vmovups YMMWORD PTR [rdx+0x2],ymm0
  210d14:	e9 f2 f9 ff ff       	jmp    21070b <parseAbbrevTable+0xab>
  210d19:	66 b8 20 00          	mov    ax,0x20
  210d1d:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
            .has_children = (try in_stream.readByte()) == DW.CHILDREN_yes,
  210d22:	66 89 01             	mov    WORD PTR [rcx],ax
  210d25:	48 8b 84 24 a4 01 00 	mov    rax,QWORD PTR [rsp+0x1a4]
  210d2c:	00 
  210d2d:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210d31:	c5 fc 10 84 24 86 01 	vmovups ymm0,YMMWORD PTR [rsp+0x186]
  210d38:	00 00 
  210d3a:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210d3f:	e9 c7 f9 ff ff       	jmp    21070b <parseAbbrevTable+0xab>
  210d44:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
        try result.append(AbbrevTableEntry{
  210d49:	66 89 01             	mov    WORD PTR [rcx],ax
  210d4c:	48 8b 84 24 7e 01 00 	mov    rax,QWORD PTR [rsp+0x17e]
  210d53:	00 
  210d54:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210d58:	c5 fc 10 84 24 60 01 	vmovups ymm0,YMMWORD PTR [rsp+0x160]
  210d5f:	00 00 
  210d61:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210d66:	e9 a0 f9 ff ff       	jmp    21070b <parseAbbrevTable+0xab>
  210d6b:	48 8b 4c 24 38       	mov    rcx,QWORD PTR [rsp+0x38]
            try attrs.append(AbbrevAttr{
  210d70:	66 89 01             	mov    WORD PTR [rcx],ax
  210d73:	48 8b 84 24 0c 01 00 	mov    rax,QWORD PTR [rsp+0x10c]
  210d7a:	00 
  210d7b:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  210d7f:	c5 fc 10 84 24 ee 00 	vmovups ymm0,YMMWORD PTR [rsp+0xee]
  210d86:	00 00 
  210d88:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  210d8d:	e9 79 f9 ff ff       	jmp    21070b <parseAbbrevTable+0xab>
  210d92:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  210d99:	1f 84 00 00 00 00 00 

0000000000210da0 <Allocator_alignedRealloc>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  210da0:	41 56                	push   r14
  210da2:	53                   	push   rbx
  210da3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  210daa:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  210dad:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  210db1:	48 85 c0             	test   rax,rax
  210db4:	74 54                	je     210e0a <Allocator_alignedRealloc+0x6a>
        if (n == 0) {
  210db6:	48 85 c9             	test   rcx,rcx
  210db9:	0f 84 9b 00 00 00    	je     210e5a <Allocator_alignedRealloc+0xba>
        const old_byte_slice = @sliceToBytes(old_mem);
  210dbf:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  210dc2:	48 6b c0 38          	imul   rax,rax,0x38
  210dc6:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  210dcb:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  210dd0:	ba 38 00 00 00       	mov    edx,0x38
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  210dd5:	48 89 c8             	mov    rax,rcx
  210dd8:	48 f7 e2             	mul    rdx
  210ddb:	0f 81 c2 00 00 00    	jno    210ea3 <Allocator_alignedRealloc+0x103>
  210de1:	48 8d 0d e8 f9 fe ff 	lea    rcx,[rip+0xfffffffffffef9e8]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210de8:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210dec:	0f 84 cc 00 00 00    	je     210ebe <Allocator_alignedRealloc+0x11e>
  210df2:	48 8b 05 0f 55 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff550f]        # 206308 <__unnamed_65+0x10>
  210df9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  210dfd:	c5 f8 10 05 f3 54 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff54f3]        # 2062f8 <__unnamed_65>
  210e04:	ff 
  210e05:	e9 8a 00 00 00       	jmp    210e94 <Allocator_alignedRealloc+0xf4>
        if (n == 0) {
  210e0a:	48 85 c9             	test   rcx,rcx
  210e0d:	0f 84 f8 00 00 00    	je     210f0b <Allocator_alignedRealloc+0x16b>
  210e13:	ba 38 00 00 00       	mov    edx,0x38
  210e18:	48 89 c8             	mov    rax,rcx
  210e1b:	48 f7 e2             	mul    rdx
  210e1e:	0f 81 08 01 00 00    	jno    210f2c <Allocator_alignedRealloc+0x18c>
  210e24:	48 8d 0d a5 f9 fe ff 	lea    rcx,[rip+0xfffffffffffef9a5]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210e2b:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210e2f:	0f 84 12 01 00 00    	je     210f47 <Allocator_alignedRealloc+0x1a7>
  210e35:	0f b7 05 c2 54 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff54c2]        # 2062fe <__unnamed_65+0x6>
  210e3c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  210e41:	8b 05 b3 54 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff54b3]        # 2062fa <__unnamed_65+0x2>
  210e47:	89 04 24             	mov    DWORD PTR [rsp],eax
  210e4a:	48 89 e0             	mov    rax,rsp
  210e4d:	66 b9 05 00          	mov    cx,0x5
  210e51:	31 f6                	xor    esi,esi
  210e53:	31 d2                	xor    edx,edx
  210e55:	e9 a9 01 00 00       	jmp    211003 <Allocator_alignedRealloc+0x263>
        const bytes = @sliceToBytes(memory);
  210e5a:	48 6b c0 38          	imul   rax,rax,0x38
        if (bytes.len == 0) return;
  210e5e:	48 85 c0             	test   rax,rax
  210e61:	74 1e                	je     210e81 <Allocator_alignedRealloc+0xe1>
        const bytes = @sliceToBytes(memory);
  210e63:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  210e66:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  210e6a:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  210e6f:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  210e74:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  210e79:	48 89 f7             	mov    rdi,rsi
  210e7c:	48 89 c6             	mov    rsi,rax
  210e7f:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  210e81:	48 8b 05 68 54 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff5468]        # 2062f0 <__unnamed_66+0x10>
  210e88:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  210e8c:	c5 f8 10 05 4c 54 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff544c]        # 2062e0 <__unnamed_66>
  210e93:	ff 
  210e94:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  210e98:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210e9f:	5b                   	pop    rbx
  210ea0:	41 5e                	pop    r14
  210ea2:	c3                   	ret    
  210ea3:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  210ea8:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  210eaf:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210eb4:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210eb8:	0f 85 34 ff ff ff    	jne    210df2 <Allocator_alignedRealloc+0x52>
  210ebe:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  210ec2:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  210ec7:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  210ecc:	41 b8 01 00 00 00    	mov    r8d,0x1
  210ed2:	4c 89 f1             	mov    rcx,r14
  210ed5:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  210ed8:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  210edd:	66 85 c0             	test   ax,ax
  210ee0:	0f 84 97 00 00 00    	je     210f7d <Allocator_alignedRealloc+0x1dd>
  210ee6:	66 89 03             	mov    WORD PTR [rbx],ax
  210ee9:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  210ef0:	00 
  210ef1:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  210ef5:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  210efb:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  210f00:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210f07:	5b                   	pop    rbx
  210f08:	41 5e                	pop    r14
  210f0a:	c3                   	ret    
  210f0b:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  210f0e:	0f b7 0d d1 53 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff53d1]        # 2062e6 <__unnamed_66+0x6>
  210f15:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  210f1a:	8b 0d c2 53 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff53c2]        # 2062e2 <__unnamed_66+0x2>
  210f20:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  210f23:	31 c9                	xor    ecx,ecx
  210f25:	31 d2                	xor    edx,edx
  210f27:	e9 d7 00 00 00       	jmp    211003 <Allocator_alignedRealloc+0x263>
  210f2c:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  210f31:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  210f38:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  210f3d:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  210f41:	0f 85 ee fe ff ff    	jne    210e35 <Allocator_alignedRealloc+0x95>
  210f47:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  210f4b:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  210f50:	b9 01 00 00 00       	mov    ecx,0x1
  210f55:	4c 89 f2             	mov    rdx,r14
  210f58:	ff 16                	call   QWORD PTR [rsi]
  210f5a:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  210f5f:	66 85 c9             	test   cx,cx
  210f62:	74 67                	je     210fcb <Allocator_alignedRealloc+0x22b>
  210f64:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  210f69:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  210f6e:	48 89 e0             	mov    rax,rsp
  210f71:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  210f75:	89 14 24             	mov    DWORD PTR [rsp],edx
  210f78:	e9 86 00 00 00       	jmp    211003 <Allocator_alignedRealloc+0x263>
        assert(byte_slice.len == byte_count);
  210f7d:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  210f82:	0f 85 9e 00 00 00    	jne    211026 <Allocator_alignedRealloc+0x286>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  210f88:	49 c1 ee 03          	shr    r14,0x3
  210f8c:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  210f93:	49 92 24 
  210f96:	4c 89 f2             	mov    rdx,r14
  210f99:	c4 e2 f3 f6 c0       	mulx   rax,rcx,rax
  210f9e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  210fa3:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  210fa8:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  210fac:	48 8b 4c 24 60       	mov    rcx,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  210fb1:	8b 54 24 26          	mov    edx,DWORD PTR [rsp+0x26]
  210fb5:	89 53 02             	mov    DWORD PTR [rbx+0x2],edx
  210fb8:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
  210fbc:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  210fc0:	48 81 c4 88 00 00 00 	add    rsp,0x88
  210fc7:	5b                   	pop    rbx
  210fc8:	41 5e                	pop    r14
  210fca:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  210fcb:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  210fd0:	75 54                	jne    211026 <Allocator_alignedRealloc+0x286>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  210fd2:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  210fd7:	49 c1 ee 03          	shr    r14,0x3
  210fdb:	48 b8 93 24 49 92 24 	movabs rax,0x2492492492492493
  210fe2:	49 92 24 
  210fe5:	4c 89 f2             	mov    rdx,r14
  210fe8:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  210fed:	48 89 e0             	mov    rax,rsp
  210ff0:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  210ff4:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  210ff7:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  210ffc:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  211001:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  211003:	66 89 0b             	mov    WORD PTR [rbx],cx
  211006:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21100a:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21100e:	8b 00                	mov    eax,DWORD PTR [rax]
  211010:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  211013:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  211017:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  21101b:	48 81 c4 88 00 00 00 	add    rsp,0x88
  211022:	5b                   	pop    rbx
  211023:	41 5e                	pop    r14
  211025:	c3                   	ret    
            @panic("assertion failure");
  211026:	e8 85 8c ff ff       	call   209cb0 <panic>
  21102b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000211030 <Allocator_alignedRealloc.41>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  211030:	41 56                	push   r14
  211032:	53                   	push   rbx
  211033:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21103a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21103d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  211041:	48 85 c0             	test   rax,rax
  211044:	74 5e                	je     2110a4 <Allocator_alignedRealloc.41+0x74>
        if (n == 0) {
  211046:	48 85 c9             	test   rcx,rcx
  211049:	0f 84 a6 00 00 00    	je     2110f5 <Allocator_alignedRealloc.41+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  21104f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  211052:	48 c1 e0 04          	shl    rax,0x4
  211056:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21105b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  211060:	ba 10 00 00 00       	mov    edx,0x10
  211065:	48 89 c8             	mov    rax,rcx
  211068:	48 f7 e2             	mul    rdx
  21106b:	0f 81 ca 00 00 00    	jno    21113b <Allocator_alignedRealloc.41+0x10b>
  211071:	48 8d 0d 58 f7 fe ff 	lea    rcx,[rip+0xfffffffffffef758]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  211078:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21107c:	0f 84 d4 00 00 00    	je     211156 <Allocator_alignedRealloc.41+0x126>
  211082:	48 8b 05 af 52 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff52af]        # 206338 <__unnamed_67+0x10>
  211089:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21108d:	c5 f8 10 05 93 52 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff5293]        # 206328 <__unnamed_67>
  211094:	ff 
  211095:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  211099:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2110a0:	5b                   	pop    rbx
  2110a1:	41 5e                	pop    r14
  2110a3:	c3                   	ret    
        if (n == 0) {
  2110a4:	48 85 c9             	test   rcx,rcx
  2110a7:	0f 84 f6 00 00 00    	je     2111a3 <Allocator_alignedRealloc.41+0x173>
  2110ad:	ba 10 00 00 00       	mov    edx,0x10
  2110b2:	48 89 c8             	mov    rax,rcx
  2110b5:	48 f7 e2             	mul    rdx
  2110b8:	0f 81 07 01 00 00    	jno    2111c5 <Allocator_alignedRealloc.41+0x195>
  2110be:	48 8d 0d 0b f7 fe ff 	lea    rcx,[rip+0xfffffffffffef70b]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2110c5:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2110c9:	0f 84 11 01 00 00    	je     2111e0 <Allocator_alignedRealloc.41+0x1b0>
  2110cf:	0f b7 05 58 52 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff5258]        # 20632e <__unnamed_67+0x6>
  2110d6:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2110db:	8b 05 49 52 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff5249]        # 20632a <__unnamed_67+0x2>
  2110e1:	89 04 24             	mov    DWORD PTR [rsp],eax
  2110e4:	48 89 e0             	mov    rax,rsp
  2110e7:	66 b9 05 00          	mov    cx,0x5
  2110eb:	31 d2                	xor    edx,edx
  2110ed:	45 31 f6             	xor    r14d,r14d
  2110f0:	e9 6f 01 00 00       	jmp    211264 <Allocator_alignedRealloc.41+0x234>
        const bytes = @sliceToBytes(memory);
  2110f5:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  2110f9:	74 1e                	je     211119 <Allocator_alignedRealloc.41+0xe9>
        const bytes = @sliceToBytes(memory);
  2110fb:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2110fe:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  211102:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  211107:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21110c:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  211111:	48 89 f7             	mov    rdi,rsi
  211114:	48 89 c6             	mov    rsi,rax
  211117:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  211119:	48 8b 05 00 52 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff5200]        # 206320 <__unnamed_68+0x10>
  211120:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  211124:	c5 f8 10 05 e4 51 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff51e4]        # 206310 <__unnamed_68>
  21112b:	ff 
  21112c:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  211130:	48 81 c4 88 00 00 00 	add    rsp,0x88
  211137:	5b                   	pop    rbx
  211138:	41 5e                	pop    r14
  21113a:	c3                   	ret    
  21113b:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  211140:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  211147:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21114c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  211150:	0f 85 2c ff ff ff    	jne    211082 <Allocator_alignedRealloc.41+0x52>
  211156:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21115a:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  21115f:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  211164:	41 b8 08 00 00 00    	mov    r8d,0x8
  21116a:	4c 89 f1             	mov    rcx,r14
  21116d:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  211170:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  211175:	66 85 c0             	test   ax,ax
  211178:	0f 84 95 00 00 00    	je     211213 <Allocator_alignedRealloc.41+0x1e3>
  21117e:	66 89 03             	mov    WORD PTR [rbx],ax
  211181:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  211188:	00 
  211189:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21118d:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  211193:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  211198:	48 81 c4 88 00 00 00 	add    rsp,0x88
  21119f:	5b                   	pop    rbx
  2111a0:	41 5e                	pop    r14
  2111a2:	c3                   	ret    
  2111a3:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  2111a6:	0f b7 0d 69 51 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff5169]        # 206316 <__unnamed_68+0x6>
  2111ad:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2111b2:	8b 0d 5a 51 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff515a]        # 206312 <__unnamed_68+0x2>
  2111b8:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2111bb:	31 c9                	xor    ecx,ecx
  2111bd:	45 31 f6             	xor    r14d,r14d
  2111c0:	e9 9f 00 00 00       	jmp    211264 <Allocator_alignedRealloc.41+0x234>
  2111c5:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  2111ca:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  2111d1:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2111d6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2111da:	0f 85 ef fe ff ff    	jne    2110cf <Allocator_alignedRealloc.41+0x9f>
  2111e0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2111e4:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2111e9:	b9 08 00 00 00       	mov    ecx,0x8
  2111ee:	4c 89 f2             	mov    rdx,r14
  2111f1:	ff 16                	call   QWORD PTR [rsi]
  2111f3:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  2111f8:	66 85 c9             	test   cx,cx
  2111fb:	74 41                	je     21123e <Allocator_alignedRealloc.41+0x20e>
  2111fd:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  211202:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  211207:	48 89 e0             	mov    rax,rsp
  21120a:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  21120e:	89 14 24             	mov    DWORD PTR [rsp],edx
  211211:	eb 51                	jmp    211264 <Allocator_alignedRealloc.41+0x234>
        assert(byte_slice.len == byte_count);
  211213:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  211218:	75 6d                	jne    211287 <Allocator_alignedRealloc.41+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21121a:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21121f:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  211224:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  211229:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21122d:	49 c1 ee 04          	shr    r14,0x4
  211231:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  211235:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  211238:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21123c:	eb 3a                	jmp    211278 <Allocator_alignedRealloc.41+0x248>
        assert(byte_slice.len == byte_count);
  21123e:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  211243:	75 42                	jne    211287 <Allocator_alignedRealloc.41+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  211245:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21124a:	49 c1 ee 04          	shr    r14,0x4
  21124e:	48 89 e0             	mov    rax,rsp
  211251:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  211255:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  211258:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21125d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  211262:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  211264:	66 89 0b             	mov    WORD PTR [rbx],cx
  211267:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21126b:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21126f:	8b 00                	mov    eax,DWORD PTR [rax]
  211271:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  211274:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  211278:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  21127c:	48 81 c4 88 00 00 00 	add    rsp,0x88
  211283:	5b                   	pop    rbx
  211284:	41 5e                	pop    r14
  211286:	c3                   	ret    
            @panic("assertion failure");
  211287:	e8 24 8a ff ff       	call   209cb0 <panic>
  21128c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000211290 <Allocator_alignedRealloc.44>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  211290:	41 56                	push   r14
  211292:	53                   	push   rbx
  211293:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21129a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21129d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  2112a1:	48 85 c0             	test   rax,rax
  2112a4:	74 62                	je     211308 <Allocator_alignedRealloc.44+0x78>
        if (n == 0) {
  2112a6:	48 85 c9             	test   rcx,rcx
  2112a9:	0f 84 a9 00 00 00    	je     211358 <Allocator_alignedRealloc.44+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  2112af:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  2112b2:	48 c1 e0 03          	shl    rax,0x3
  2112b6:	48 8d 04 80          	lea    rax,[rax+rax*4]
  2112ba:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  2112bf:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  2112c4:	ba 28 00 00 00       	mov    edx,0x28
  2112c9:	48 89 c8             	mov    rax,rcx
  2112cc:	48 f7 e2             	mul    rdx
  2112cf:	0f 81 d0 00 00 00    	jno    2113a5 <Allocator_alignedRealloc.44+0x115>
  2112d5:	48 8d 0d f4 f4 fe ff 	lea    rcx,[rip+0xfffffffffffef4f4]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2112dc:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2112e0:	0f 84 da 00 00 00    	je     2113c0 <Allocator_alignedRealloc.44+0x130>
  2112e6:	48 8b 05 7b 50 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff507b]        # 206368 <__unnamed_69+0x10>
  2112ed:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2112f1:	c5 f8 10 05 5f 50 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff505f]        # 206358 <__unnamed_69>
  2112f8:	ff 
  2112f9:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2112fd:	48 81 c4 88 00 00 00 	add    rsp,0x88
  211304:	5b                   	pop    rbx
  211305:	41 5e                	pop    r14
  211307:	c3                   	ret    
        if (n == 0) {
  211308:	48 85 c9             	test   rcx,rcx
  21130b:	0f 84 fc 00 00 00    	je     21140d <Allocator_alignedRealloc.44+0x17d>
  211311:	ba 28 00 00 00       	mov    edx,0x28
  211316:	48 89 c8             	mov    rax,rcx
  211319:	48 f7 e2             	mul    rdx
  21131c:	0f 81 0c 01 00 00    	jno    21142e <Allocator_alignedRealloc.44+0x19e>
  211322:	48 8d 0d a7 f4 fe ff 	lea    rcx,[rip+0xfffffffffffef4a7]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  211329:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21132d:	0f 84 16 01 00 00    	je     211449 <Allocator_alignedRealloc.44+0x1b9>
  211333:	0f b7 05 24 50 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff5024]        # 20635e <__unnamed_69+0x6>
  21133a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21133f:	8b 05 15 50 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff5015]        # 20635a <__unnamed_69+0x2>
  211345:	89 04 24             	mov    DWORD PTR [rsp],eax
  211348:	48 89 e0             	mov    rax,rsp
  21134b:	66 b9 05 00          	mov    cx,0x5
  21134f:	31 f6                	xor    esi,esi
  211351:	31 d2                	xor    edx,edx
  211353:	e9 9d 01 00 00       	jmp    2114f5 <Allocator_alignedRealloc.44+0x265>
        const bytes = @sliceToBytes(memory);
  211358:	48 c1 e0 03          	shl    rax,0x3
  21135c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  211360:	48 85 c0             	test   rax,rax
  211363:	74 1e                	je     211383 <Allocator_alignedRealloc.44+0xf3>
        const bytes = @sliceToBytes(memory);
  211365:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  211368:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  21136c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  211371:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  211376:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  21137b:	48 89 f7             	mov    rdi,rsi
  21137e:	48 89 c6             	mov    rsi,rax
  211381:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  211383:	48 8b 05 c6 4f ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff4fc6]        # 206350 <__unnamed_70+0x10>
  21138a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21138e:	c5 f8 10 05 aa 4f ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff4faa]        # 206340 <__unnamed_70>
  211395:	ff 
  211396:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21139a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2113a1:	5b                   	pop    rbx
  2113a2:	41 5e                	pop    r14
  2113a4:	c3                   	ret    
  2113a5:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  2113aa:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  2113b1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2113b6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2113ba:	0f 85 26 ff ff ff    	jne    2112e6 <Allocator_alignedRealloc.44+0x56>
  2113c0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2113c4:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  2113c9:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2113ce:	41 b8 08 00 00 00    	mov    r8d,0x8
  2113d4:	4c 89 f1             	mov    rcx,r14
  2113d7:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  2113da:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  2113df:	66 85 c0             	test   ax,ax
  2113e2:	0f 84 94 00 00 00    	je     21147c <Allocator_alignedRealloc.44+0x1ec>
  2113e8:	66 89 03             	mov    WORD PTR [rbx],ax
  2113eb:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2113f2:	00 
  2113f3:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2113f7:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  2113fd:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  211402:	48 81 c4 88 00 00 00 	add    rsp,0x88
  211409:	5b                   	pop    rbx
  21140a:	41 5e                	pop    r14
  21140c:	c3                   	ret    
  21140d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  211410:	0f b7 0d 2f 4f ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff4f2f]        # 206346 <__unnamed_70+0x6>
  211417:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21141c:	8b 0d 20 4f ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff4f20]        # 206342 <__unnamed_70+0x2>
  211422:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  211425:	31 c9                	xor    ecx,ecx
  211427:	31 d2                	xor    edx,edx
  211429:	e9 c7 00 00 00       	jmp    2114f5 <Allocator_alignedRealloc.44+0x265>
  21142e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  211433:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  21143a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21143f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  211443:	0f 85 ea fe ff ff    	jne    211333 <Allocator_alignedRealloc.44+0xa3>
  211449:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21144d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  211452:	b9 08 00 00 00       	mov    ecx,0x8
  211457:	4c 89 f2             	mov    rdx,r14
  21145a:	ff 16                	call   QWORD PTR [rsi]
  21145c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  211461:	66 85 c9             	test   cx,cx
  211464:	74 57                	je     2114bd <Allocator_alignedRealloc.44+0x22d>
  211466:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  21146b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  211470:	48 89 e0             	mov    rax,rsp
  211473:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  211477:	89 14 24             	mov    DWORD PTR [rsp],edx
  21147a:	eb 79                	jmp    2114f5 <Allocator_alignedRealloc.44+0x265>
        assert(byte_slice.len == byte_count);
  21147c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  211481:	0f 85 91 00 00 00    	jne    211518 <Allocator_alignedRealloc.44+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  211487:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21148c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  211493:	cc cc cc 
  211496:	4c 89 f2             	mov    rdx,r14
  211499:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  21149e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  2114a3:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  2114a8:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2114ac:	48 c1 ea 05          	shr    rdx,0x5
  2114b0:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  2114b4:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  2114b7:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  2114bb:	eb 4c                	jmp    211509 <Allocator_alignedRealloc.44+0x279>
        assert(byte_slice.len == byte_count);
  2114bd:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  2114c2:	75 54                	jne    211518 <Allocator_alignedRealloc.44+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2114c4:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2114c9:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  2114d0:	cc cc cc 
  2114d3:	4c 89 f2             	mov    rdx,r14
  2114d6:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  2114db:	48 c1 ea 05          	shr    rdx,0x5
  2114df:	48 89 e0             	mov    rax,rsp
  2114e2:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  2114e6:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2114e9:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  2114ee:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2114f3:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  2114f5:	66 89 0b             	mov    WORD PTR [rbx],cx
  2114f8:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  2114fc:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  211500:	8b 00                	mov    eax,DWORD PTR [rax]
  211502:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  211505:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  211509:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  21150d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  211514:	5b                   	pop    rbx
  211515:	41 5e                	pop    r14
  211517:	c3                   	ret    
            @panic("assertion failure");
  211518:	e8 93 87 ff ff       	call   209cb0 <panic>
  21151d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000211520 <parseFormValue>:
fn parseFormValue(allocator: *mem.Allocator, in_stream: var, form_id: u64, is_64: bool) ParseFormValueError!FormValue {
  211520:	55                   	push   rbp
  211521:	41 57                	push   r15
  211523:	41 56                	push   r14
  211525:	41 55                	push   r13
  211527:	41 54                	push   r12
  211529:	53                   	push   rbx
  21152a:	48 81 ec 08 07 00 00 	sub    rsp,0x708
  211531:	44 89 c5             	mov    ebp,r8d
  211534:	48 89 cb             	mov    rbx,rcx
  211537:	49 89 d4             	mov    r12,rdx
  21153a:	49 89 f7             	mov    r15,rsi
  21153d:	49 89 fe             	mov    r14,rdi
  211540:	48 8d 05 91 4e ff ff 	lea    rax,[rip+0xffffffffffff4e91]        # 2063d8 <__unnamed_71>
    return switch (form_id) {
  211547:	48 8d 4b ff          	lea    rcx,[rbx-0x1]
  21154b:	48 83 f9 1f          	cmp    rcx,0x1f
  21154f:	0f 87 d1 19 00 00    	ja     212f26 <parseFormValue+0x1a06>
  211555:	48 8d 15 48 ff fe ff 	lea    rdx,[rip+0xfffffffffffeff48]        # 2014a4 <__unnamed_9+0x7c4>
  21155c:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  211560:	48 01 d1             	add    rcx,rdx
  211563:	ff e1                	jmp    rcx
  211565:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  21156c:	00 
  21156d:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  211572:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  211579:	00 
            try self.readNoEof(result[0..]);
  21157a:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  21157f:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  211586:	00 00 
  211588:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21158d:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211592:	4c 89 e6             	mov    rsi,r12
  211595:	41 ff 14 24          	call   QWORD PTR [r12]
  211599:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21159e:	66 85 c0             	test   ax,ax
  2115a1:	0f 84 f2 0b 00 00    	je     212199 <parseFormValue+0xc79>
  2115a7:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  2115ac:	66 89 01             	mov    WORD PTR [rcx],ax
  2115af:	48 8b 84 24 b4 06 00 	mov    rax,QWORD PTR [rsp+0x6b4]
  2115b6:	00 
  2115b7:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  2115bb:	c5 fc 10 84 24 96 06 	vmovups ymm0,YMMWORD PTR [rsp+0x696]
  2115c2:	00 00 
  2115c4:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  2115c9:	e9 69 19 00 00       	jmp    212f37 <parseFormValue+0x1a17>
  2115ce:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  2115d3:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2115d8:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  2115df:	00 00 
  2115e1:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2115e6:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2115eb:	4c 89 e6             	mov    rsi,r12
  2115ee:	41 ff 14 24          	call   QWORD PTR [r12]
  2115f2:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2115f7:	66 85 c0             	test   ax,ax
  2115fa:	75 14                	jne    211610 <parseFormValue+0xf0>
  2115fc:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211601:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211605:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21160a:	0f 83 ce 12 00 00    	jae    2128de <parseFormValue+0x13be>
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  211610:	66 41 89 06          	mov    WORD PTR [r14],ax
  211614:	48 8b 84 24 00 07 00 	mov    rax,QWORD PTR [rsp+0x700]
  21161b:	00 
  21161c:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  211620:	c5 fc 10 84 24 e2 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6e2]
  211627:	00 00 
  211629:	e9 0b 0d 00 00       	jmp    212339 <parseFormValue+0xe19>
  21162e:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  211633:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211638:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  21163f:	00 00 
  211641:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211646:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21164b:	4c 89 e6             	mov    rsi,r12
  21164e:	41 ff 14 24          	call   QWORD PTR [r12]
  211652:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211657:	66 85 c9             	test   cx,cx
  21165a:	75 14                	jne    211670 <parseFormValue+0x150>
            if (amt_read < buf.len) return error.EndOfStream;
  21165c:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  211661:	66 b9 20 00          	mov    cx,0x20
  211665:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  21166a:	0f 83 d8 12 00 00    	jae    212948 <parseFormValue+0x1428>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  211670:	66 89 8c 24 90 02 00 	mov    WORD PTR [rsp+0x290],cx
  211677:	00 
  211678:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21167c:	89 84 24 92 02 00 00 	mov    DWORD PTR [rsp+0x292],eax
  211683:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211688:	66 89 84 24 96 02 00 	mov    WORD PTR [rsp+0x296],ax
  21168f:	00 
  211690:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211694:	89 84 24 a9 02 00 00 	mov    DWORD PTR [rsp+0x2a9],eax
  21169b:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  2116a0:	66 89 84 24 ad 02 00 	mov    WORD PTR [rsp+0x2ad],ax
  2116a7:	00 
  2116a8:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  2116ac:	88 84 24 af 02 00 00 	mov    BYTE PTR [rsp+0x2af],al
  2116b3:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  2116b7:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  2116be:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  2116c3:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  2116ca:	00 
  2116cb:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  2116cf:	88 84 24 b7 02 00 00 	mov    BYTE PTR [rsp+0x2b7],al
  2116d6:	48 8d 84 24 90 02 00 	lea    rax,[rsp+0x290]
  2116dd:	00 
  2116de:	e9 43 18 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  2116e3:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  2116e8:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2116ed:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  2116f4:	00 00 
  2116f6:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2116fb:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211700:	4c 89 e6             	mov    rsi,r12
  211703:	41 ff 14 24          	call   QWORD PTR [r12]
  211707:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21170c:	66 85 c9             	test   cx,cx
  21170f:	75 14                	jne    211725 <parseFormValue+0x205>
            if (amt_read < buf.len) return error.EndOfStream;
  211711:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  211716:	66 b9 20 00          	mov    cx,0x20
  21171a:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  21171f:	0f 83 44 12 00 00    	jae    212969 <parseFormValue+0x1449>
  211725:	66 89 8c 24 68 02 00 	mov    WORD PTR [rsp+0x268],cx
  21172c:	00 
  21172d:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211731:	89 84 24 6a 02 00 00 	mov    DWORD PTR [rsp+0x26a],eax
  211738:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  21173d:	66 89 84 24 6e 02 00 	mov    WORD PTR [rsp+0x26e],ax
  211744:	00 
  211745:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211749:	89 84 24 81 02 00 00 	mov    DWORD PTR [rsp+0x281],eax
  211750:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211755:	66 89 84 24 85 02 00 	mov    WORD PTR [rsp+0x285],ax
  21175c:	00 
  21175d:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211761:	88 84 24 87 02 00 00 	mov    BYTE PTR [rsp+0x287],al
  211768:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21176c:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  211773:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  211778:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  21177f:	00 
  211780:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211784:	88 84 24 8f 02 00 00 	mov    BYTE PTR [rsp+0x28f],al
  21178b:	48 8d 84 24 68 02 00 	lea    rax,[rsp+0x268]
  211792:	00 
  211793:	e9 8e 17 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  211798:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  21179d:	b9 02 00 00 00       	mov    ecx,0x2
  2117a2:	4c 89 fe             	mov    rsi,r15
  2117a5:	4c 89 e2             	mov    rdx,r12
  2117a8:	e8 03 2b 00 00       	call   2142b0 <readAllocBytes>
  2117ad:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2117b2:	66 85 c0             	test   ax,ax
  2117b5:	0f 84 89 0b 00 00    	je     212344 <parseFormValue+0xe24>
  2117bb:	66 89 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],ax
  2117c2:	00 
  2117c3:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2117c7:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
  2117ce:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2117d3:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  2117da:	00 
  2117db:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  2117df:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  2117e6:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  2117eb:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  2117f2:	00 
  2117f3:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  2117f7:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  2117fe:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211802:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  211809:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21180e:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  211815:	00 
  211816:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  21181a:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  211821:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  211828:	00 
  211829:	e9 f8 16 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  21182e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211833:	b9 04 00 00 00       	mov    ecx,0x4
  211838:	4c 89 fe             	mov    rsi,r15
  21183b:	4c 89 e2             	mov    rdx,r12
  21183e:	e8 6d 2a 00 00       	call   2142b0 <readAllocBytes>
  211843:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  211848:	66 85 c0             	test   ax,ax
  21184b:	0f 84 9d 0b 00 00    	je     2123ee <parseFormValue+0xece>
  211851:	66 89 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],ax
  211858:	00 
  211859:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  21185d:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
  211864:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211869:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  211870:	00 
  211871:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211875:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  21187c:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211881:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  211888:	00 
  211889:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  21188d:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  211894:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211898:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  21189f:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  2118a4:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  2118ab:	00 
  2118ac:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  2118b0:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  2118b7:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  2118be:	00 
  2118bf:	e9 62 16 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  2118c4:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2118c9:	b9 08 00 00 00       	mov    ecx,0x8
  2118ce:	4c 89 fe             	mov    rsi,r15
  2118d1:	4c 89 e2             	mov    rdx,r12
  2118d4:	e8 d7 29 00 00       	call   2142b0 <readAllocBytes>
  2118d9:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2118de:	66 85 c0             	test   ax,ax
  2118e1:	0f 84 b1 0b 00 00    	je     212498 <parseFormValue+0xf78>
  2118e7:	66 89 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],ax
  2118ee:	00 
  2118ef:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  2118f3:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
  2118fa:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  2118ff:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  211906:	00 
  211907:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21190b:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  211912:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211917:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  21191e:	00 
  21191f:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211923:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  21192a:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  21192e:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  211935:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  21193a:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  211941:	00 
  211942:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211946:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  21194d:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  211954:	00 
  211955:	e9 cc 15 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  21195a:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
            return Self{
  21195f:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  211963:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  211969:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  211970:	00 00 
  211972:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  211979:	00 
    var buf = ArrayList(u8).init(allocator);
  21197a:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  21197f:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  211986:	00 
            try self.readNoEof(result[0..]);
  211987:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  21198e:	00 
  21198f:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  211996:	00 01 00 00 00 
  21199b:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  2119a0:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  2119a7:	00 
            return self.readFn(self, buffer);
  2119a8:	4c 89 e6             	mov    rsi,r12
  2119ab:	41 ff 14 24          	call   QWORD PTR [r12]
  2119af:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
            const amt_read = try self.read(buf);
  2119b4:	66 85 c0             	test   ax,ax
  2119b7:	0f 84 85 0b 00 00    	je     212542 <parseFormValue+0x1022>
  2119bd:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  2119c2:	66 89 01             	mov    WORD PTR [rcx],ax
  2119c5:	48 8b 84 24 84 05 00 	mov    rax,QWORD PTR [rsp+0x584]
  2119cc:	00 
  2119cd:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  2119d1:	c5 fc 10 84 24 66 05 	vmovups ymm0,YMMWORD PTR [rsp+0x566]
  2119d8:	00 00 
  2119da:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  2119df:	e9 53 15 00 00       	jmp    212f37 <parseFormValue+0x1a17>
  2119e4:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  2119eb:	00 
  2119ec:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  2119f1:	4c 8d ac 24 b0 00 00 	lea    r13,[rsp+0xb0]
  2119f8:	00 
            try self.readNoEof(result[0..]);
  2119f9:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  2119fe:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  211a05:	00 00 
  211a07:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211a0c:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211a11:	4c 89 e6             	mov    rsi,r12
  211a14:	41 ff 14 24          	call   QWORD PTR [r12]
  211a18:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211a1d:	66 85 c0             	test   ax,ax
  211a20:	0f 84 fa 0b 00 00    	je     212620 <parseFormValue+0x1100>
  211a26:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const block_len = try readULeb128(in_stream);
  211a2b:	66 89 01             	mov    WORD PTR [rcx],ax
  211a2e:	48 8b 84 24 da 06 00 	mov    rax,QWORD PTR [rsp+0x6da]
  211a35:	00 
  211a36:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  211a3a:	c5 fc 10 84 24 bc 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6bc]
  211a41:	00 00 
  211a43:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  211a48:	e9 ea 14 00 00       	jmp    212f37 <parseFormValue+0x1a17>
  211a4d:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            const input_slice = input_buf[0..size];
  211a52:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211a57:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  211a5e:	00 00 
  211a60:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211a65:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211a6a:	4c 89 e6             	mov    rsi,r12
  211a6d:	41 ff 14 24          	call   QWORD PTR [r12]
  211a71:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211a76:	66 85 c9             	test   cx,cx
  211a79:	75 14                	jne    211a8f <parseFormValue+0x56f>
            if (amt_read < buf.len) return error.EndOfStream;
  211a7b:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  211a80:	66 b9 20 00          	mov    cx,0x20
  211a84:	48 39 44 24 48       	cmp    QWORD PTR [rsp+0x48],rax
  211a89:	0f 83 fb 0e 00 00    	jae    21298a <parseFormValue+0x146a>
    const block_len = try in_stream.readVarInt(builtin.Endian.Little, usize, size);
  211a8f:	66 89 8c 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],cx
  211a96:	00 
  211a97:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211a9b:	89 84 24 ba 02 00 00 	mov    DWORD PTR [rsp+0x2ba],eax
  211aa2:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211aa7:	66 89 84 24 be 02 00 	mov    WORD PTR [rsp+0x2be],ax
  211aae:	00 
  211aaf:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211ab3:	89 84 24 d1 02 00 00 	mov    DWORD PTR [rsp+0x2d1],eax
  211aba:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211abf:	66 89 84 24 d5 02 00 	mov    WORD PTR [rsp+0x2d5],ax
  211ac6:	00 
  211ac7:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211acb:	88 84 24 d7 02 00 00 	mov    BYTE PTR [rsp+0x2d7],al
  211ad2:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211ad6:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  211add:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  211ae2:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  211ae9:	00 
  211aea:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211aee:	88 84 24 df 02 00 00 	mov    BYTE PTR [rsp+0x2df],al
  211af5:	48 8d 84 24 b8 02 00 	lea    rax,[rsp+0x2b8]
  211afc:	00 
  211afd:	e9 24 14 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  211b02:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  211b07:	b9 01 00 00 00       	mov    ecx,0x1
  211b0c:	4c 89 fe             	mov    rsi,r15
  211b0f:	4c 89 e2             	mov    rdx,r12
  211b12:	e8 99 27 00 00       	call   2142b0 <readAllocBytes>
  211b17:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  211b1c:	66 85 c0             	test   ax,ax
  211b1f:	0f 84 7c 0b 00 00    	je     2126a1 <parseFormValue+0x1181>
  211b25:	66 89 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],ax
  211b2c:	00 
  211b2d:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211b31:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
  211b38:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211b3d:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  211b44:	00 
  211b45:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211b49:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  211b50:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211b55:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  211b5c:	00 
  211b5d:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211b61:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  211b68:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211b6c:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  211b73:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  211b78:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  211b7f:	00 
  211b80:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211b84:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  211b8b:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  211b92:	00 
  211b93:	e9 8e 13 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  211b98:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  211b9f:	00 
            try self.readNoEof(result[0..]);
  211ba0:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211ba5:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  211bac:	00 00 
  211bae:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211bb3:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211bb8:	4c 89 e6             	mov    rsi,r12
  211bbb:	41 ff 14 24          	call   QWORD PTR [r12]
  211bbf:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211bc4:	66 85 c0             	test   ax,ax
  211bc7:	75 14                	jne    211bdd <parseFormValue+0x6bd>
  211bc9:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211bce:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211bd2:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211bd7:	0f 83 ce 0d 00 00    	jae    2129ab <parseFormValue+0x148b>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  211bdd:	66 41 89 06          	mov    WORD PTR [r14],ax
  211be1:	48 8b 84 24 42 06 00 	mov    rax,QWORD PTR [rsp+0x642]
  211be8:	00 
  211be9:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  211bed:	c5 fc 10 84 24 24 06 	vmovups ymm0,YMMWORD PTR [rsp+0x624]
  211bf4:	00 00 
  211bf6:	e9 3e 07 00 00       	jmp    212339 <parseFormValue+0xe19>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  211bfb:	40 f6 c5 01          	test   bpl,0x1
  211bff:	0f 84 1c 06 00 00    	je     212221 <parseFormValue+0xd01>
  211c05:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  211c0c:	00 
            try self.readNoEof(bytes[0..]);
  211c0d:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211c12:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  211c19:	00 00 
  211c1b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211c20:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211c25:	4c 89 e6             	mov    rsi,r12
  211c28:	41 ff 14 24          	call   QWORD PTR [r12]
  211c2c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211c31:	66 85 c0             	test   ax,ax
  211c34:	0f 85 29 06 00 00    	jne    212263 <parseFormValue+0xd43>
  211c3a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211c3f:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211c43:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211c48:	0f 82 15 06 00 00    	jb     212263 <parseFormValue+0xd43>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  211c4e:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  211c55:	00 
  211c56:	e9 4f 11 00 00       	jmp    212daa <parseFormValue+0x188a>
  211c5b:	40 f6 c5 01          	test   bpl,0x1
  211c5f:	0f 84 1c 06 00 00    	je     212281 <parseFormValue+0xd61>
  211c65:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  211c6c:	00 
            try self.readNoEof(bytes[0..]);
  211c6d:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211c72:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  211c79:	00 00 
  211c7b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211c80:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211c85:	4c 89 e6             	mov    rsi,r12
  211c88:	41 ff 14 24          	call   QWORD PTR [r12]
  211c8c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211c91:	66 85 c0             	test   ax,ax
  211c94:	0f 85 29 06 00 00    	jne    2122c3 <parseFormValue+0xda3>
  211c9a:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211c9f:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211ca3:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211ca8:	0f 82 15 06 00 00    	jb     2122c3 <parseFormValue+0xda3>
  211cae:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  211cb5:	00 
  211cb6:	e9 7d 11 00 00       	jmp    212e38 <parseFormValue+0x1918>
  211cbb:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  211cc2:	00 
            try self.readNoEof(bytes[0..]);
  211cc3:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211cc8:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  211ccf:	00 00 
  211cd1:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211cd6:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211cdb:	4c 89 e6             	mov    rsi,r12
  211cde:	41 ff 14 24          	call   QWORD PTR [r12]
  211ce2:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211ce7:	66 85 c0             	test   ax,ax
  211cea:	75 14                	jne    211d00 <parseFormValue+0x7e0>
  211cec:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211cf1:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211cf5:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211cfa:	0f 83 30 0d 00 00    	jae    212a30 <parseFormValue+0x1510>
    const block_len = try in_stream.readIntLe(T);
  211d00:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  211d07:	00 
  211d08:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211d0c:	89 84 24 42 02 00 00 	mov    DWORD PTR [rsp+0x242],eax
  211d13:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211d18:	66 89 84 24 46 02 00 	mov    WORD PTR [rsp+0x246],ax
  211d1f:	00 
  211d20:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211d24:	89 84 24 59 02 00 00 	mov    DWORD PTR [rsp+0x259],eax
  211d2b:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211d30:	66 89 84 24 5d 02 00 	mov    WORD PTR [rsp+0x25d],ax
  211d37:	00 
  211d38:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211d3c:	88 84 24 5f 02 00 00 	mov    BYTE PTR [rsp+0x25f],al
  211d43:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211d47:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  211d4e:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  211d53:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  211d5a:	00 
  211d5b:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211d5f:	88 84 24 67 02 00 00 	mov    BYTE PTR [rsp+0x267],al
  211d66:	48 8d 84 24 40 02 00 	lea    rax,[rsp+0x240]
  211d6d:	00 
  211d6e:	e9 b3 11 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  211d73:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  211d78:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211d7d:	48 c7 44 24 20 02 00 	mov    QWORD PTR [rsp+0x20],0x2
  211d84:	00 00 
  211d86:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211d8b:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211d90:	4c 89 e6             	mov    rsi,r12
  211d93:	41 ff 14 24          	call   QWORD PTR [r12]
  211d97:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211d9c:	66 85 c0             	test   ax,ax
  211d9f:	75 14                	jne    211db5 <parseFormValue+0x895>
  211da1:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211da6:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211daa:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211daf:	0f 83 dd 0c 00 00    	jae    212a92 <parseFormValue+0x1572>
  211db5:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  211dbc:	00 
  211dbd:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211dc1:	89 84 24 1a 02 00 00 	mov    DWORD PTR [rsp+0x21a],eax
  211dc8:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211dcd:	66 89 84 24 1e 02 00 	mov    WORD PTR [rsp+0x21e],ax
  211dd4:	00 
  211dd5:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211dd9:	89 84 24 31 02 00 00 	mov    DWORD PTR [rsp+0x231],eax
  211de0:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211de5:	66 89 84 24 35 02 00 	mov    WORD PTR [rsp+0x235],ax
  211dec:	00 
  211ded:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211df1:	88 84 24 37 02 00 00 	mov    BYTE PTR [rsp+0x237],al
  211df8:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211dfc:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  211e03:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  211e08:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  211e0f:	00 
  211e10:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211e14:	88 84 24 3f 02 00 00 	mov    BYTE PTR [rsp+0x23f],al
  211e1b:	48 8d 84 24 18 02 00 	lea    rax,[rsp+0x218]
  211e22:	00 
  211e23:	e9 fe 10 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  211e28:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  211e2d:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211e32:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  211e39:	00 00 
  211e3b:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211e40:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211e45:	4c 89 e6             	mov    rsi,r12
  211e48:	41 ff 14 24          	call   QWORD PTR [r12]
  211e4c:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211e51:	66 85 c0             	test   ax,ax
  211e54:	75 14                	jne    211e6a <parseFormValue+0x94a>
  211e56:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211e5b:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211e5f:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211e64:	0f 83 93 0c 00 00    	jae    212afd <parseFormValue+0x15dd>
  211e6a:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  211e71:	00 
  211e72:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211e76:	89 84 24 f2 01 00 00 	mov    DWORD PTR [rsp+0x1f2],eax
  211e7d:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211e82:	66 89 84 24 f6 01 00 	mov    WORD PTR [rsp+0x1f6],ax
  211e89:	00 
  211e8a:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211e8e:	89 84 24 09 02 00 00 	mov    DWORD PTR [rsp+0x209],eax
  211e95:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211e9a:	66 89 84 24 0d 02 00 	mov    WORD PTR [rsp+0x20d],ax
  211ea1:	00 
  211ea2:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211ea6:	88 84 24 0f 02 00 00 	mov    BYTE PTR [rsp+0x20f],al
  211ead:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211eb1:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  211eb8:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  211ebd:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  211ec4:	00 
  211ec5:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211ec9:	88 84 24 17 02 00 00 	mov    BYTE PTR [rsp+0x217],al
  211ed0:	48 8d 84 24 f0 01 00 	lea    rax,[rsp+0x1f0]
  211ed7:	00 
  211ed8:	e9 49 10 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  211edd:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  211ee2:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  211ee7:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  211eee:	00 00 
  211ef0:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211ef5:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211efa:	4c 89 e6             	mov    rsi,r12
  211efd:	41 ff 14 24          	call   QWORD PTR [r12]
  211f01:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211f06:	66 85 c0             	test   ax,ax
  211f09:	75 14                	jne    211f1f <parseFormValue+0x9ff>
  211f0b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  211f10:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  211f14:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  211f19:	0f 83 61 0c 00 00    	jae    212b80 <parseFormValue+0x1660>
  211f1f:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  211f26:	00 
  211f27:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  211f2b:	89 84 24 ca 01 00 00 	mov    DWORD PTR [rsp+0x1ca],eax
  211f32:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  211f37:	66 89 84 24 ce 01 00 	mov    WORD PTR [rsp+0x1ce],ax
  211f3e:	00 
  211f3f:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  211f43:	89 84 24 e1 01 00 00 	mov    DWORD PTR [rsp+0x1e1],eax
  211f4a:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  211f4f:	66 89 84 24 e5 01 00 	mov    WORD PTR [rsp+0x1e5],ax
  211f56:	00 
  211f57:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  211f5b:	88 84 24 e7 01 00 00 	mov    BYTE PTR [rsp+0x1e7],al
  211f62:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  211f66:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  211f6d:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  211f72:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  211f79:	00 
  211f7a:	8a 44 24 10          	mov    al,BYTE PTR [rsp+0x10]
  211f7e:	88 84 24 ef 01 00 00 	mov    BYTE PTR [rsp+0x1ef],al
  211f85:	48 8d 84 24 c8 01 00 	lea    rax,[rsp+0x1c8]
  211f8c:	00 
  211f8d:	e9 94 0f 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  211f92:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  211f99:	00 
  211f9a:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  211f9f:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  211fa6:	00 
            try self.readNoEof(result[0..]);
  211fa7:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  211fac:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  211fb3:	00 00 
  211fb5:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  211fba:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  211fbf:	4c 89 e6             	mov    rsi,r12
  211fc2:	41 ff 14 24          	call   QWORD PTR [r12]
  211fc6:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  211fcb:	66 85 c0             	test   ax,ax
  211fce:	0f 84 77 07 00 00    	je     21274b <parseFormValue+0x122b>
  211fd4:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const ref_len = try readULeb128(in_stream);
  211fd9:	66 89 01             	mov    WORD PTR [rcx],ax
  211fdc:	48 8b 84 24 f6 05 00 	mov    rax,QWORD PTR [rsp+0x5f6]
  211fe3:	00 
  211fe4:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  211fe8:	c5 fc 10 84 24 d8 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5d8]
  211fef:	00 00 
  211ff1:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  211ff6:	e9 3c 0f 00 00       	jmp    212f37 <parseFormValue+0x1a17>
  211ffb:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  212002:	00 
  212003:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  212008:	4c 8d bc 24 b0 00 00 	lea    r15,[rsp+0xb0]
  21200f:	00 
            try self.readNoEof(result[0..]);
  212010:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  212015:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21201c:	00 00 
  21201e:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  212023:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  212028:	4c 89 e6             	mov    rsi,r12
  21202b:	41 ff 14 24          	call   QWORD PTR [r12]
  21202f:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  212034:	66 85 c0             	test   ax,ax
  212037:	0f 84 8f 07 00 00    	je     2127cc <parseFormValue+0x12ac>
  21203d:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const child_form_id = try readULeb128(in_stream);
  212042:	66 89 01             	mov    WORD PTR [rcx],ax
  212045:	48 8b 84 24 38 05 00 	mov    rax,QWORD PTR [rsp+0x538]
  21204c:	00 
  21204d:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  212051:	c5 fc 10 84 24 1a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x51a]
  212058:	00 00 
  21205a:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  21205f:	e9 d3 0e 00 00       	jmp    212f37 <parseFormValue+0x1a17>
    return if (is_64) try in_stream.readIntLe(u64) else u64(try in_stream.readIntLe(u32));
  212064:	40 f6 c5 01          	test   bpl,0x1
  212068:	0f 84 70 02 00 00    	je     2122de <parseFormValue+0xdbe>
  21206e:	48 8d 84 24 90 00 00 	lea    rax,[rsp+0x90]
  212075:	00 
            try self.readNoEof(bytes[0..]);
  212076:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21207b:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  212082:	00 00 
  212084:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  212089:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21208e:	4c 89 e6             	mov    rsi,r12
  212091:	41 ff 14 24          	call   QWORD PTR [r12]
  212095:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21209a:	66 85 c0             	test   ax,ax
  21209d:	0f 85 7d 02 00 00    	jne    212320 <parseFormValue+0xe00>
  2120a3:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2120a8:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  2120ac:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2120b1:	0f 82 69 02 00 00    	jb     212320 <parseFormValue+0xe00>
  2120b7:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  2120be:	00 
  2120bf:	e9 02 0e 00 00       	jmp    212ec6 <parseFormValue+0x19a6>
  2120c4:	4c 89 bc 24 d0 00 00 	mov    QWORD PTR [rsp+0xd0],r15
  2120cb:	00 
  2120cc:	4c 89 74 24 68       	mov    QWORD PTR [rsp+0x68],r14
  2120d1:	4c 8d b4 24 b0 00 00 	lea    r14,[rsp+0xb0]
  2120d8:	00 
            try self.readNoEof(result[0..]);
  2120d9:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  2120de:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2120e5:	00 00 
  2120e7:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2120ec:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2120f1:	4c 89 e6             	mov    rsi,r12
  2120f4:	41 ff 14 24          	call   QWORD PTR [r12]
  2120f8:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2120fd:	66 85 c0             	test   ax,ax
  212100:	0f 84 45 07 00 00    	je     21284b <parseFormValue+0x132b>
  212106:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
            const size = try readULeb128(in_stream);
  21210b:	66 89 01             	mov    WORD PTR [rcx],ax
  21210e:	48 8b 84 24 8e 06 00 	mov    rax,QWORD PTR [rsp+0x68e]
  212115:	00 
  212116:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21211a:	c5 fc 10 84 24 70 06 	vmovups ymm0,YMMWORD PTR [rsp+0x670]
  212121:	00 00 
  212123:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  212128:	e9 0a 0e 00 00       	jmp    212f37 <parseFormValue+0x1a17>
  21212d:	48 8d 05 cc 42 ff ff 	lea    rax,[rip+0xffffffffffff42cc]        # 206400 <__unnamed_72>
  212134:	e9 ed 0d 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  212139:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  21213e:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  212143:	48 c7 44 24 20 08 00 	mov    QWORD PTR [rsp+0x20],0x8
  21214a:	00 00 
  21214c:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  212151:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  212156:	4c 89 e6             	mov    rsi,r12
  212159:	41 ff 14 24          	call   QWORD PTR [r12]
  21215d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  212162:	66 85 c0             	test   ax,ax
  212165:	75 14                	jne    21217b <parseFormValue+0xc5b>
  212167:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21216c:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  212170:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  212175:	0f 83 64 0a 00 00    	jae    212bdf <parseFormValue+0x16bf>
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  21217b:	66 41 89 06          	mov    WORD PTR [r14],ax
  21217f:	48 8b 84 24 aa 05 00 	mov    rax,QWORD PTR [rsp+0x5aa]
  212186:	00 
  212187:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  21218b:	c5 fc 10 84 24 8c 05 	vmovups ymm0,YMMWORD PTR [rsp+0x58c]
  212192:	00 00 
  212194:	e9 a0 01 00 00       	jmp    212339 <parseFormValue+0xe19>
  212199:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  21219e:	31 ed                	xor    ebp,ebp
  2121a0:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  2121a5:	45 31 ed             	xor    r13d,r13d
  2121a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2121af:	00 
  2121b0:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2121b5:	0f 82 11 07 00 00    	jb     2128cc <parseFormValue+0x13ac>
            return result[0];
  2121bb:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  2121c2:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2121c3:	89 c2                	mov    edx,eax
  2121c5:	83 e2 7f             	and    edx,0x7f
  2121c8:	44 89 ee             	mov    esi,r13d
  2121cb:	83 e6 3f             	and    esi,0x3f
  2121ce:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2121d3:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2121d8:	48 39 d6             	cmp    rsi,rdx
  2121db:	0f 85 f4 06 00 00    	jne    2128d5 <parseFormValue+0x13b5>
        result |= operand;
  2121e1:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  2121e4:	84 c0                	test   al,al
  2121e6:	0f 89 5d 0a 00 00    	jns    212c49 <parseFormValue+0x1729>
        shift += 7;
  2121ec:	49 83 c5 07          	add    r13,0x7
            try self.readNoEof(result[0..]);
  2121f0:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  2121f5:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2121fc:	00 00 
            return self.readFn(self, buffer);
  2121fe:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  212203:	4c 89 e6             	mov    rsi,r12
  212206:	4c 89 fa             	mov    rdx,r15
  212209:	41 ff 14 24          	call   QWORD PTR [r12]
  21220d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  212212:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  212217:	66 85 c0             	test   ax,ax
  21221a:	74 94                	je     2121b0 <parseFormValue+0xc90>
  21221c:	e9 86 f3 ff ff       	jmp    2115a7 <parseFormValue+0x87>
  212221:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  212226:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21222b:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  212232:	00 00 
  212234:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  212239:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21223e:	4c 89 e6             	mov    rsi,r12
  212241:	41 ff 14 24          	call   QWORD PTR [r12]
  212245:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  21224a:	66 85 c0             	test   ax,ax
  21224d:	75 14                	jne    212263 <parseFormValue+0xd43>
  21224f:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  212254:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  212258:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21225d:	0f 83 1e 0b 00 00    	jae    212d81 <parseFormValue+0x1861>
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  212263:	66 41 89 06          	mov    WORD PTR [r14],ax
  212267:	48 8b 84 24 5e 05 00 	mov    rax,QWORD PTR [rsp+0x55e]
  21226e:	00 
  21226f:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  212273:	c5 fc 10 84 24 40 05 	vmovups ymm0,YMMWORD PTR [rsp+0x540]
  21227a:	00 00 
  21227c:	e9 b8 00 00 00       	jmp    212339 <parseFormValue+0xe19>
  212281:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  212286:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  21228b:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  212292:	00 00 
  212294:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  212299:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  21229e:	4c 89 e6             	mov    rsi,r12
  2122a1:	41 ff 14 24          	call   QWORD PTR [r12]
  2122a5:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  2122aa:	66 85 c0             	test   ax,ax
  2122ad:	75 14                	jne    2122c3 <parseFormValue+0xda3>
  2122af:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2122b4:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  2122b8:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2122bd:	0f 83 4c 0b 00 00    	jae    212e0f <parseFormValue+0x18ef>
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  2122c3:	66 41 89 06          	mov    WORD PTR [r14],ax
  2122c7:	48 8b 84 24 d0 05 00 	mov    rax,QWORD PTR [rsp+0x5d0]
  2122ce:	00 
  2122cf:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  2122d3:	c5 fc 10 84 24 b2 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5b2]
  2122da:	00 00 
  2122dc:	eb 5b                	jmp    212339 <parseFormValue+0xe19>
  2122de:	48 8d 44 24 78       	lea    rax,[rsp+0x78]
            try self.readNoEof(bytes[0..]);
  2122e3:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  2122e8:	48 c7 44 24 20 04 00 	mov    QWORD PTR [rsp+0x20],0x4
  2122ef:	00 00 
  2122f1:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  2122f6:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  2122fb:	4c 89 e6             	mov    rsi,r12
  2122fe:	41 ff 14 24          	call   QWORD PTR [r12]
  212302:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
            const amt_read = try self.read(buf);
  212307:	66 85 c0             	test   ax,ax
  21230a:	75 14                	jne    212320 <parseFormValue+0xe00>
  21230c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  212311:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  212315:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  21231a:	0f 83 7d 0b 00 00    	jae    212e9d <parseFormValue+0x197d>
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  212320:	66 41 89 06          	mov    WORD PTR [r14],ax
  212324:	48 8b 84 24 1c 06 00 	mov    rax,QWORD PTR [rsp+0x61c]
  21232b:	00 
  21232c:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
  212330:	c5 fc 10 84 24 fe 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5fe]
  212337:	00 00 
  212339:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  21233f:	e9 f3 0b 00 00       	jmp    212f37 <parseFormValue+0x1a17>
    return FormValue{
  212344:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  21234b:	00 
  21234c:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  212351:	66 c7 84 24 78 01 00 	mov    WORD PTR [rsp+0x178],0x0
  212358:	00 00 00 
  21235b:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  21235f:	89 84 24 7a 01 00 00 	mov    DWORD PTR [rsp+0x17a],eax
        .Const = Constant{
  212366:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  21236c:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  212371:	66 89 84 24 7e 01 00 	mov    WORD PTR [rsp+0x17e],ax
  212378:	00 
  212379:	c5 f8 11 84 24 80 01 	vmovups XMMWORD PTR [rsp+0x180],xmm0
  212380:	00 00 
  212382:	c6 84 24 90 01 00 00 	mov    BYTE PTR [rsp+0x190],0x0
  212389:	00 
  21238a:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  212391:	89 84 24 91 01 00 00 	mov    DWORD PTR [rsp+0x191],eax
  212398:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  21239f:	00 
  2123a0:	66 89 84 24 95 01 00 	mov    WORD PTR [rsp+0x195],ax
  2123a7:	00 
  2123a8:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  2123af:	88 84 24 97 01 00 00 	mov    BYTE PTR [rsp+0x197],al
  2123b6:	c6 84 24 98 01 00 00 	mov    BYTE PTR [rsp+0x198],0x2
  2123bd:	02 
  2123be:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  2123c2:	88 84 24 9f 01 00 00 	mov    BYTE PTR [rsp+0x19f],al
  2123c9:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  2123ce:	66 89 84 24 9d 01 00 	mov    WORD PTR [rsp+0x19d],ax
  2123d5:	00 
  2123d6:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  2123da:	89 84 24 99 01 00 00 	mov    DWORD PTR [rsp+0x199],eax
  2123e1:	48 8d 84 24 78 01 00 	lea    rax,[rsp+0x178]
  2123e8:	00 
  2123e9:	e9 38 0b 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  2123ee:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  2123f5:	00 
  2123f6:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  2123fb:	66 c7 84 24 50 01 00 	mov    WORD PTR [rsp+0x150],0x0
  212402:	00 00 00 
  212405:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  212409:	89 84 24 52 01 00 00 	mov    DWORD PTR [rsp+0x152],eax
        .Const = Constant{
  212410:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  212416:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21241b:	66 89 84 24 56 01 00 	mov    WORD PTR [rsp+0x156],ax
  212422:	00 
  212423:	c5 f8 11 84 24 58 01 	vmovups XMMWORD PTR [rsp+0x158],xmm0
  21242a:	00 00 
  21242c:	c6 84 24 68 01 00 00 	mov    BYTE PTR [rsp+0x168],0x0
  212433:	00 
  212434:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  21243b:	89 84 24 69 01 00 00 	mov    DWORD PTR [rsp+0x169],eax
  212442:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  212449:	00 
  21244a:	66 89 84 24 6d 01 00 	mov    WORD PTR [rsp+0x16d],ax
  212451:	00 
  212452:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  212459:	88 84 24 6f 01 00 00 	mov    BYTE PTR [rsp+0x16f],al
  212460:	c6 84 24 70 01 00 00 	mov    BYTE PTR [rsp+0x170],0x2
  212467:	02 
  212468:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  21246c:	88 84 24 77 01 00 00 	mov    BYTE PTR [rsp+0x177],al
  212473:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  212478:	66 89 84 24 75 01 00 	mov    WORD PTR [rsp+0x175],ax
  21247f:	00 
  212480:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  212484:	89 84 24 71 01 00 00 	mov    DWORD PTR [rsp+0x171],eax
  21248b:	48 8d 84 24 50 01 00 	lea    rax,[rsp+0x150]
  212492:	00 
  212493:	e9 8e 0a 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  212498:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  21249f:	00 
  2124a0:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  2124a5:	66 c7 84 24 28 01 00 	mov    WORD PTR [rsp+0x128],0x0
  2124ac:	00 00 00 
  2124af:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  2124b3:	89 84 24 2a 01 00 00 	mov    DWORD PTR [rsp+0x12a],eax
        .Const = Constant{
  2124ba:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  2124c0:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  2124c5:	66 89 84 24 2e 01 00 	mov    WORD PTR [rsp+0x12e],ax
  2124cc:	00 
  2124cd:	c5 f8 11 84 24 30 01 	vmovups XMMWORD PTR [rsp+0x130],xmm0
  2124d4:	00 00 
  2124d6:	c6 84 24 40 01 00 00 	mov    BYTE PTR [rsp+0x140],0x0
  2124dd:	00 
  2124de:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  2124e5:	89 84 24 41 01 00 00 	mov    DWORD PTR [rsp+0x141],eax
  2124ec:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  2124f3:	00 
  2124f4:	66 89 84 24 45 01 00 	mov    WORD PTR [rsp+0x145],ax
  2124fb:	00 
  2124fc:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  212503:	88 84 24 47 01 00 00 	mov    BYTE PTR [rsp+0x147],al
  21250a:	c6 84 24 48 01 00 00 	mov    BYTE PTR [rsp+0x148],0x2
  212511:	02 
  212512:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  212516:	88 84 24 4f 01 00 00 	mov    BYTE PTR [rsp+0x14f],al
  21251d:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  212522:	66 89 84 24 4d 01 00 	mov    WORD PTR [rsp+0x14d],ax
  212529:	00 
  21252a:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  21252e:	89 84 24 49 01 00 00 	mov    DWORD PTR [rsp+0x149],eax
  212535:	48 8d 84 24 28 01 00 	lea    rax,[rsp+0x128]
  21253c:	00 
  21253d:	e9 e4 09 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  212542:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  212547:	45 31 ed             	xor    r13d,r13d
  21254a:	48 8d 5c 24 18       	lea    rbx,[rsp+0x18]
  21254f:	31 ed                	xor    ebp,ebp
  212551:	48 3b 8c 24 98 00 00 	cmp    rcx,QWORD PTR [rsp+0x98]
  212558:	00 
  212559:	0f 82 90 07 00 00    	jb     212cef <parseFormValue+0x17cf>
            return result[0];
  21255f:	44 8a bc 24 b0 00 00 	mov    r15b,BYTE PTR [rsp+0xb0]
  212566:	00 
        if (byte == 0) break;
  212567:	45 84 ff             	test   r15b,r15b
  21256a:	0f 84 88 07 00 00    	je     212cf8 <parseFormValue+0x17d8>
            var better_capacity = self.items.len;
  212570:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  212575:	48 39 e9             	cmp    rcx,rbp
  212578:	77 4f                	ja     2125c9 <parseFormValue+0x10a9>
  21257a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
                better_capacity += better_capacity / 2 + 8;
  212580:	48 89 c8             	mov    rax,rcx
  212583:	48 d1 e8             	shr    rax,1
  212586:	48 01 c1             	add    rcx,rax
  212589:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  21258d:	48 39 e9             	cmp    rcx,rbp
  212590:	76 ee                	jbe    212580 <parseFormValue+0x1060>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  212592:	48 89 df             	mov    rdi,rbx
  212595:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  21259c:	00 
  21259d:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  2125a2:	e8 f9 46 00 00       	call   216ca0 <Allocator_alignedRealloc.71>
  2125a7:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  2125ac:	66 85 c0             	test   ax,ax
  2125af:	0f 85 08 f4 ff ff    	jne    2119bd <parseFormValue+0x49d>
  2125b5:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  2125ba:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2125be:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  2125c4:	4c 8b 6c 24 40       	mov    r13,QWORD PTR [rsp+0x40]
  2125c9:	4c 8d 75 01          	lea    r14,[rbp+0x1]
            self.len = new_length;
  2125cd:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  2125d2:	45 88 7c 2d 00       	mov    BYTE PTR [r13+rbp*1+0x0],r15b
            try self.readNoEof(result[0..]);
  2125d7:	48 8d 84 24 b0 00 00 	lea    rax,[rsp+0xb0]
  2125de:	00 
  2125df:	48 89 84 24 90 00 00 	mov    QWORD PTR [rsp+0x90],rax
  2125e6:	00 
  2125e7:	48 c7 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],0x1
  2125ee:	00 01 00 00 00 
            return self.readFn(self, buffer);
  2125f3:	48 89 df             	mov    rdi,rbx
  2125f6:	4c 89 e6             	mov    rsi,r12
  2125f9:	48 8d 94 24 90 00 00 	lea    rdx,[rsp+0x90]
  212600:	00 
  212601:	41 ff 14 24          	call   QWORD PTR [r12]
  212605:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  21260a:	48 8b 4c 24 20       	mov    rcx,QWORD PTR [rsp+0x20]
  21260f:	4c 89 f5             	mov    rbp,r14
            const amt_read = try self.read(buf);
  212612:	66 85 c0             	test   ax,ax
  212615:	0f 84 36 ff ff ff    	je     212551 <parseFormValue+0x1031>
  21261b:	e9 9d f3 ff ff       	jmp    2119bd <parseFormValue+0x49d>
  212620:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  212625:	31 db                	xor    ebx,ebx
  212627:	4c 8d 7c 24 40       	lea    r15,[rsp+0x40]
  21262c:	4c 8d 74 24 18       	lea    r14,[rsp+0x18]
  212631:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  212633:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  212638:	0f 82 1f 07 00 00    	jb     212d5d <parseFormValue+0x183d>
            return result[0];
  21263e:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  212645:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  212646:	89 c2                	mov    edx,eax
  212648:	83 e2 7f             	and    edx,0x7f
  21264b:	89 ee                	mov    esi,ebp
  21264d:	83 e6 3f             	and    esi,0x3f
  212650:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  212655:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21265a:	48 39 d6             	cmp    rsi,rdx
  21265d:	0f 85 e9 08 00 00    	jne    212f4c <parseFormValue+0x1a2c>
        result |= operand;
  212663:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  212666:	84 c0                	test   al,al
  212668:	0f 89 02 09 00 00    	jns    212f70 <parseFormValue+0x1a50>
        shift += 7;
  21266e:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  212672:	4c 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],r13
  212677:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  21267e:	00 00 
            return self.readFn(self, buffer);
  212680:	4c 89 ff             	mov    rdi,r15
  212683:	4c 89 e6             	mov    rsi,r12
  212686:	4c 89 f2             	mov    rdx,r14
  212689:	41 ff 14 24          	call   QWORD PTR [r12]
  21268d:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  212692:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  212697:	66 85 c0             	test   ax,ax
  21269a:	74 97                	je     212633 <parseFormValue+0x1113>
  21269c:	e9 85 f3 ff ff       	jmp    211a26 <parseFormValue+0x506>
    return FormValue{
  2126a1:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x0
  2126a8:	00 
  2126a9:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  2126ae:	66 c7 84 24 a0 01 00 	mov    WORD PTR [rsp+0x1a0],0x0
  2126b5:	00 00 00 
  2126b8:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  2126bc:	89 84 24 a2 01 00 00 	mov    DWORD PTR [rsp+0x1a2],eax
        .Const = Constant{
  2126c3:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  2126c9:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  2126ce:	66 89 84 24 a6 01 00 	mov    WORD PTR [rsp+0x1a6],ax
  2126d5:	00 
  2126d6:	c5 f8 11 84 24 a8 01 	vmovups XMMWORD PTR [rsp+0x1a8],xmm0
  2126dd:	00 00 
  2126df:	c6 84 24 b8 01 00 00 	mov    BYTE PTR [rsp+0x1b8],0x0
  2126e6:	00 
  2126e7:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  2126ee:	89 84 24 b9 01 00 00 	mov    DWORD PTR [rsp+0x1b9],eax
  2126f5:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  2126fc:	00 
  2126fd:	66 89 84 24 bd 01 00 	mov    WORD PTR [rsp+0x1bd],ax
  212704:	00 
  212705:	8a 84 24 96 00 00 00 	mov    al,BYTE PTR [rsp+0x96]
  21270c:	88 84 24 bf 01 00 00 	mov    BYTE PTR [rsp+0x1bf],al
  212713:	c6 84 24 c0 01 00 00 	mov    BYTE PTR [rsp+0x1c0],0x2
  21271a:	02 
  21271b:	8a 44 24 1e          	mov    al,BYTE PTR [rsp+0x1e]
  21271f:	88 84 24 c7 01 00 00 	mov    BYTE PTR [rsp+0x1c7],al
  212726:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  21272b:	66 89 84 24 c5 01 00 	mov    WORD PTR [rsp+0x1c5],ax
  212732:	00 
  212733:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  212737:	89 84 24 c1 01 00 00 	mov    DWORD PTR [rsp+0x1c1],eax
  21273e:	48 8d 84 24 a0 01 00 	lea    rax,[rsp+0x1a0]
  212745:	00 
  212746:	e9 db 07 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  21274b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  212750:	31 db                	xor    ebx,ebx
  212752:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  212757:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  21275c:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  21275e:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  212763:	0f 82 fd 05 00 00    	jb     212d66 <parseFormValue+0x1846>
            return result[0];
  212769:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  212770:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  212771:	89 c2                	mov    edx,eax
  212773:	83 e2 7f             	and    edx,0x7f
  212776:	89 ee                	mov    esi,ebp
  212778:	83 e6 3f             	and    esi,0x3f
  21277b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  212780:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  212785:	48 39 d6             	cmp    rsi,rdx
  212788:	0f 85 c7 07 00 00    	jne    212f55 <parseFormValue+0x1a35>
        result |= operand;
  21278e:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  212791:	84 c0                	test   al,al
  212793:	0f 89 7d 08 00 00    	jns    213016 <parseFormValue+0x1af6>
        shift += 7;
  212799:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  21279d:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  2127a2:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2127a9:	00 00 
            return self.readFn(self, buffer);
  2127ab:	4c 89 ef             	mov    rdi,r13
  2127ae:	4c 89 e6             	mov    rsi,r12
  2127b1:	4c 89 fa             	mov    rdx,r15
  2127b4:	41 ff 14 24          	call   QWORD PTR [r12]
  2127b8:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2127bd:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  2127c2:	66 85 c0             	test   ax,ax
  2127c5:	74 97                	je     21275e <parseFormValue+0x123e>
  2127c7:	e9 08 f8 ff ff       	jmp    211fd4 <parseFormValue+0xab4>
  2127cc:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  2127d1:	45 31 f6             	xor    r14d,r14d
  2127d4:	4c 8d 6c 24 18       	lea    r13,[rsp+0x18]
  2127d9:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  2127db:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  2127e0:	0f 82 89 05 00 00    	jb     212d6f <parseFormValue+0x184f>
            return result[0];
  2127e6:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  2127ed:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2127ee:	89 c2                	mov    edx,eax
  2127f0:	83 e2 7f             	and    edx,0x7f
  2127f3:	89 de                	mov    esi,ebx
  2127f5:	83 e6 3f             	and    esi,0x3f
  2127f8:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2127fd:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  212802:	48 39 d6             	cmp    rsi,rdx
  212805:	0f 85 53 07 00 00    	jne    212f5e <parseFormValue+0x1a3e>
        result |= operand;
  21280b:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  21280e:	84 c0                	test   al,al
  212810:	0f 89 a6 08 00 00    	jns    2130bc <parseFormValue+0x1b9c>
        shift += 7;
  212816:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  21281a:	4c 89 7c 24 18       	mov    QWORD PTR [rsp+0x18],r15
  21281f:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  212826:	00 00 
            return self.readFn(self, buffer);
  212828:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
  21282d:	4c 89 e6             	mov    rsi,r12
  212830:	4c 89 ea             	mov    rdx,r13
  212833:	41 ff 14 24          	call   QWORD PTR [r12]
  212837:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  21283c:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  212841:	66 85 c0             	test   ax,ax
  212844:	74 95                	je     2127db <parseFormValue+0x12bb>
  212846:	e9 f2 f7 ff ff       	jmp    21203d <parseFormValue+0xb1d>
  21284b:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
  212850:	31 db                	xor    ebx,ebx
  212852:	4c 8d 6c 24 40       	lea    r13,[rsp+0x40]
  212857:	4c 8d 7c 24 18       	lea    r15,[rsp+0x18]
  21285c:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  21285e:	48 3b 4c 24 20       	cmp    rcx,QWORD PTR [rsp+0x20]
  212863:	0f 82 0f 05 00 00    	jb     212d78 <parseFormValue+0x1858>
            return result[0];
  212869:	0f b6 84 24 b0 00 00 	movzx  eax,BYTE PTR [rsp+0xb0]
  212870:	00 
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  212871:	89 c2                	mov    edx,eax
  212873:	83 e2 7f             	and    edx,0x7f
  212876:	89 ee                	mov    esi,ebp
  212878:	83 e6 3f             	and    esi,0x3f
  21287b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  212880:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  212885:	48 39 d6             	cmp    rsi,rdx
  212888:	0f 85 d9 06 00 00    	jne    212f67 <parseFormValue+0x1a47>
        result |= operand;
  21288e:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  212891:	84 c0                	test   al,al
  212893:	0f 89 65 08 00 00    	jns    2130fe <parseFormValue+0x1bde>
        shift += 7;
  212899:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  21289d:	4c 89 74 24 18       	mov    QWORD PTR [rsp+0x18],r14
  2128a2:	48 c7 44 24 20 01 00 	mov    QWORD PTR [rsp+0x20],0x1
  2128a9:	00 00 
            return self.readFn(self, buffer);
  2128ab:	4c 89 ef             	mov    rdi,r13
  2128ae:	4c 89 e6             	mov    rsi,r12
  2128b1:	4c 89 fa             	mov    rdx,r15
  2128b4:	41 ff 14 24          	call   QWORD PTR [r12]
  2128b8:	0f b7 44 24 40       	movzx  eax,WORD PTR [rsp+0x40]
  2128bd:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            const amt_read = try self.read(buf);
  2128c2:	66 85 c0             	test   ax,ax
  2128c5:	74 97                	je     21285e <parseFormValue+0x133e>
  2128c7:	e9 3a f8 ff ff       	jmp    212106 <parseFormValue+0xbe6>
  2128cc:	66 b8 20 00          	mov    ax,0x20
  2128d0:	e9 d2 ec ff ff       	jmp    2115a7 <parseFormValue+0x87>
  2128d5:	66 b8 25 00          	mov    ax,0x25
  2128d9:	e9 c9 ec ff ff       	jmp    2115a7 <parseFormValue+0x87>
  2128de:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_addr => FormValue{ .Address = try parseFormValueTargetAddrSize(in_stream) },
  2128e3:	66 c7 84 24 08 04 00 	mov    WORD PTR [rsp+0x408],0x0
  2128ea:	00 00 00 
  2128ed:	48 89 84 24 10 04 00 	mov    QWORD PTR [rsp+0x410],rax
  2128f4:	00 
  2128f5:	c5 f8 10 84 24 08 05 	vmovups xmm0,XMMWORD PTR [rsp+0x508]
  2128fc:	00 00 
  2128fe:	c5 f8 11 84 24 18 04 	vmovups XMMWORD PTR [rsp+0x418],xmm0
  212905:	00 00 
  212907:	c6 84 24 28 04 00 00 	mov    BYTE PTR [rsp+0x428],0x0
  21290e:	00 
  21290f:	8b 84 24 11 03 00 00 	mov    eax,DWORD PTR [rsp+0x311]
  212916:	89 84 24 29 04 00 00 	mov    DWORD PTR [rsp+0x429],eax
  21291d:	0f b7 84 24 15 03 00 	movzx  eax,WORD PTR [rsp+0x315]
  212924:	00 
  212925:	66 89 84 24 2d 04 00 	mov    WORD PTR [rsp+0x42d],ax
  21292c:	00 
  21292d:	8a 84 24 17 03 00 00 	mov    al,BYTE PTR [rsp+0x317]
  212934:	88 84 24 2f 04 00 00 	mov    BYTE PTR [rsp+0x42f],al
  21293b:	48 8d 84 24 08 04 00 	lea    rax,[rsp+0x408]
  212942:	00 
  212943:	e9 de 05 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  212948:	48 85 c0             	test   rax,rax
            for (bytes) |b, index| {
  21294b:	0f 84 00 08 00 00    	je     213151 <parseFormValue+0x1c31>
  212951:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  212956:	48 83 f8 10          	cmp    rax,0x10
  21295a:	0f 83 cc 0b 00 00    	jae    21352c <parseFormValue+0x200c>
  212960:	31 db                	xor    ebx,ebx
  212962:	31 c9                	xor    ecx,ecx
  212964:	e9 b7 11 00 00       	jmp    213b20 <parseFormValue+0x2600>
  212969:	48 85 c0             	test   rax,rax
  21296c:	0f 84 e6 07 00 00    	je     213158 <parseFormValue+0x1c38>
  212972:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  212977:	48 83 f8 10          	cmp    rax,0x10
  21297b:	0f 83 c9 0c 00 00    	jae    21364a <parseFormValue+0x212a>
  212981:	31 db                	xor    ebx,ebx
  212983:	31 c9                	xor    ecx,ecx
  212985:	e9 77 13 00 00       	jmp    213d01 <parseFormValue+0x27e1>
  21298a:	48 85 c0             	test   rax,rax
  21298d:	0f 84 cc 07 00 00    	je     21315f <parseFormValue+0x1c3f>
  212993:	48 8b 54 24 18       	mov    rdx,QWORD PTR [rsp+0x18]
  212998:	48 83 f8 10          	cmp    rax,0x10
  21299c:	0f 83 c6 0d 00 00    	jae    213768 <parseFormValue+0x2248>
  2129a2:	31 db                	xor    ebx,ebx
  2129a4:	31 c9                	xor    ecx,ecx
  2129a6:	e9 37 15 00 00       	jmp    213ee2 <parseFormValue+0x29c2>
        DW.FORM_flag => FormValue{ .Flag = (try in_stream.readByte()) != 0 },
  2129ab:	80 bc 24 b0 00 00 00 	cmp    BYTE PTR [rsp+0xb0],0x0
  2129b2:	00 
  2129b3:	0f 95 84 24 08 01 00 	setne  BYTE PTR [rsp+0x108]
  2129ba:	00 
  2129bb:	66 c7 84 24 18 03 00 	mov    WORD PTR [rsp+0x318],0x0
  2129c2:	00 00 00 
  2129c5:	0f 95 84 24 20 03 00 	setne  BYTE PTR [rsp+0x320]
  2129cc:	00 
  2129cd:	c5 f8 10 84 24 69 04 	vmovups xmm0,XMMWORD PTR [rsp+0x469]
  2129d4:	00 00 
  2129d6:	c5 f8 11 84 24 21 03 	vmovups XMMWORD PTR [rsp+0x321],xmm0
  2129dd:	00 00 
  2129df:	48 8b 84 24 78 04 00 	mov    rax,QWORD PTR [rsp+0x478]
  2129e6:	00 
  2129e7:	48 89 84 24 30 03 00 	mov    QWORD PTR [rsp+0x330],rax
  2129ee:	00 
  2129ef:	c6 84 24 38 03 00 00 	mov    BYTE PTR [rsp+0x338],0x4
  2129f6:	04 
  2129f7:	8b 84 24 03 03 00 00 	mov    eax,DWORD PTR [rsp+0x303]
  2129fe:	89 84 24 39 03 00 00 	mov    DWORD PTR [rsp+0x339],eax
  212a05:	0f b7 84 24 07 03 00 	movzx  eax,WORD PTR [rsp+0x307]
  212a0c:	00 
  212a0d:	66 89 84 24 3d 03 00 	mov    WORD PTR [rsp+0x33d],ax
  212a14:	00 
  212a15:	8a 84 24 09 03 00 00 	mov    al,BYTE PTR [rsp+0x309]
  212a1c:	88 84 24 3f 03 00 00 	mov    BYTE PTR [rsp+0x33f],al
  212a23:	48 8d 84 24 18 03 00 	lea    rax,[rsp+0x318]
  212a2a:	00 
  212a2b:	e9 f6 04 00 00       	jmp    212f26 <parseFormValue+0x1a06>
            return mem.readInt(bytes, T, endian);
  212a30:	0f b6 8c 24 b0 00 00 	movzx  ecx,BYTE PTR [rsp+0xb0]
  212a37:	00 
  212a38:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  212a3d:	4c 89 fe             	mov    rsi,r15
  212a40:	4c 89 e2             	mov    rdx,r12
  212a43:	e8 68 18 00 00       	call   2142b0 <readAllocBytes>
  212a48:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  212a4d:	66 85 c0             	test   ax,ax
  212a50:	0f 84 10 07 00 00    	je     213166 <parseFormValue+0x1c46>
  212a56:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  212a5c:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  212a62:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  212a69:	00 00 
  212a6b:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  212a72:	00 00 
  212a74:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  212a78:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  212a7b:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  212a80:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  212a85:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  212a89:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  212a8d:	e9 39 07 00 00       	jmp    2131cb <parseFormValue+0x1cab>
  212a92:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  212a97:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  212a9c:	48 c1 e1 08          	shl    rcx,0x8
  212aa0:	48 09 c1             	or     rcx,rax
  212aa3:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  212aa8:	4c 89 fe             	mov    rsi,r15
  212aab:	4c 89 e2             	mov    rdx,r12
  212aae:	e8 fd 17 00 00       	call   2142b0 <readAllocBytes>
  212ab3:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  212ab8:	66 85 c0             	test   ax,ax
  212abb:	0f 84 5d 07 00 00    	je     21321e <parseFormValue+0x1cfe>
  212ac1:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  212ac7:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  212acd:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  212ad4:	00 00 
  212ad6:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  212add:	00 00 
  212adf:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  212ae3:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  212ae6:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  212aeb:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  212af0:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  212af4:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  212af8:	e9 86 07 00 00       	jmp    213283 <parseFormValue+0x1d63>
  212afd:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  212b02:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  212b07:	48 c1 e1 08          	shl    rcx,0x8
  212b0b:	48 09 c1             	or     rcx,rax
  212b0e:	0f b6 44 24 7a       	movzx  eax,BYTE PTR [rsp+0x7a]
  212b13:	48 c1 e0 10          	shl    rax,0x10
  212b17:	48 09 c8             	or     rax,rcx
  212b1a:	0f b6 4c 24 7b       	movzx  ecx,BYTE PTR [rsp+0x7b]
  212b1f:	48 c1 e1 18          	shl    rcx,0x18
  212b23:	48 09 c1             	or     rcx,rax
  212b26:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  212b2b:	4c 89 fe             	mov    rsi,r15
  212b2e:	4c 89 e2             	mov    rdx,r12
  212b31:	e8 7a 17 00 00       	call   2142b0 <readAllocBytes>
  212b36:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  212b3b:	66 85 c0             	test   ax,ax
  212b3e:	0f 84 92 07 00 00    	je     2132d6 <parseFormValue+0x1db6>
  212b44:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  212b4a:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  212b50:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  212b57:	00 00 
  212b59:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  212b60:	00 00 
  212b62:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  212b66:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  212b69:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  212b6e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  212b73:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  212b77:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  212b7b:	e9 bb 07 00 00       	jmp    21333b <parseFormValue+0x1e1b>
  212b80:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
  212b85:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
  212b8a:	4c 89 fe             	mov    rsi,r15
  212b8d:	4c 89 e2             	mov    rdx,r12
  212b90:	e8 1b 17 00 00       	call   2142b0 <readAllocBytes>
  212b95:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  212b9a:	66 85 c0             	test   ax,ax
  212b9d:	0f 84 eb 07 00 00    	je     21338e <parseFormValue+0x1e6e>
  212ba3:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  212ba9:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  212baf:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  212bb6:	00 00 
  212bb8:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  212bbf:	00 00 
  212bc1:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  212bc5:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  212bc8:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  212bcd:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  212bd2:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  212bd6:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  212bda:	e9 14 08 00 00       	jmp    2133f3 <parseFormValue+0x1ed3>
  212bdf:	48 8b 44 24 78       	mov    rax,QWORD PTR [rsp+0x78]
        DW.FORM_ref_sig8 => FormValue{ .RefSig8 = try in_stream.readIntLe(u64) },
  212be4:	66 c7 84 24 90 03 00 	mov    WORD PTR [rsp+0x390],0x0
  212beb:	00 00 00 
  212bee:	48 89 84 24 98 03 00 	mov    QWORD PTR [rsp+0x398],rax
  212bf5:	00 
  212bf6:	c5 f8 10 84 24 d8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4d8]
  212bfd:	00 00 
  212bff:	c5 f8 11 84 24 a0 03 	vmovups XMMWORD PTR [rsp+0x3a0],xmm0
  212c06:	00 00 
  212c08:	c6 84 24 b0 03 00 00 	mov    BYTE PTR [rsp+0x3b0],0x8
  212c0f:	08 
  212c10:	8b 84 24 ee 02 00 00 	mov    eax,DWORD PTR [rsp+0x2ee]
  212c17:	89 84 24 b1 03 00 00 	mov    DWORD PTR [rsp+0x3b1],eax
  212c1e:	0f b7 84 24 f2 02 00 	movzx  eax,WORD PTR [rsp+0x2f2]
  212c25:	00 
  212c26:	66 89 84 24 b5 03 00 	mov    WORD PTR [rsp+0x3b5],ax
  212c2d:	00 
  212c2e:	8a 84 24 f4 02 00 00 	mov    al,BYTE PTR [rsp+0x2f4]
  212c35:	88 84 24 b7 03 00 00 	mov    BYTE PTR [rsp+0x3b7],al
  212c3c:	48 8d 84 24 90 03 00 	lea    rax,[rsp+0x390]
  212c43:	00 
  212c44:	e9 dd 02 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  212c49:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
            .payload = try readAllocBytes(allocator, in_stream, size),
  212c4e:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  212c55:	00 
  212c56:	4c 89 e2             	mov    rdx,r12
  212c59:	48 89 e9             	mov    rcx,rbp
  212c5c:	e8 4f 16 00 00       	call   2142b0 <readAllocBytes>
  212c61:	0f b7 54 24 40       	movzx  edx,WORD PTR [rsp+0x40]
  212c66:	66 85 d2             	test   dx,dx
  212c69:	48 8b 6c 24 68       	mov    rbp,QWORD PTR [rsp+0x68]
  212c6e:	0f 84 d2 07 00 00    	je     213446 <parseFormValue+0x1f26>
  212c74:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  212c79:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  212c80:	00 
  212c81:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  212c85:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
  212c8c:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  212c90:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  212c97:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  212c9c:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  212ca3:	00 
  212ca4:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  212ca8:	88 84 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],al
  212caf:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  212cb6:	00 
  212cb7:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  212cbb:	89 84 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],eax
  212cc2:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  212cc9:	00 
  212cca:	0f b7 4c 24 0e       	movzx  ecx,WORD PTR [rsp+0xe]
  212ccf:	66 89 8c 24 ec 00 00 	mov    WORD PTR [rsp+0xec],cx
  212cd6:	00 
  212cd7:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  212cde:	00 
  212cdf:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  212ce3:	88 9c 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],bl
  212cea:	e9 f5 07 00 00       	jmp    2134e4 <parseFormValue+0x1fc4>
  212cef:	66 b8 20 00          	mov    ax,0x20
  212cf3:	e9 c5 ec ff ff       	jmp    2119bd <parseFormValue+0x49d>
            return self.items[0..self.len];
  212cf8:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
        DW.FORM_string => FormValue{ .String = try readStringRaw(allocator, in_stream) },
  212cfd:	66 c7 84 24 68 03 00 	mov    WORD PTR [rsp+0x368],0x0
  212d04:	00 00 00 
  212d07:	48 89 84 24 70 03 00 	mov    QWORD PTR [rsp+0x370],rax
  212d0e:	00 
  212d0f:	48 89 ac 24 78 03 00 	mov    QWORD PTR [rsp+0x378],rbp
  212d16:	00 
  212d17:	c6 84 24 88 03 00 00 	mov    BYTE PTR [rsp+0x388],0x9
  212d1e:	09 
  212d1f:	8b 84 24 e7 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e7]
  212d26:	89 84 24 89 03 00 00 	mov    DWORD PTR [rsp+0x389],eax
  212d2d:	0f b7 84 24 eb 02 00 	movzx  eax,WORD PTR [rsp+0x2eb]
  212d34:	00 
  212d35:	66 89 84 24 8d 03 00 	mov    WORD PTR [rsp+0x38d],ax
  212d3c:	00 
  212d3d:	8a 84 24 ed 02 00 00 	mov    al,BYTE PTR [rsp+0x2ed]
  212d44:	88 84 24 8f 03 00 00 	mov    BYTE PTR [rsp+0x38f],al
  212d4b:	48 8d 84 24 68 03 00 	lea    rax,[rsp+0x368]
  212d52:	00 
  212d53:	4c 8b 74 24 68       	mov    r14,QWORD PTR [rsp+0x68]
  212d58:	e9 c9 01 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  212d5d:	66 b8 20 00          	mov    ax,0x20
  212d61:	e9 c0 ec ff ff       	jmp    211a26 <parseFormValue+0x506>
  212d66:	66 b8 20 00          	mov    ax,0x20
  212d6a:	e9 65 f2 ff ff       	jmp    211fd4 <parseFormValue+0xab4>
  212d6f:	66 b8 20 00          	mov    ax,0x20
  212d73:	e9 c5 f2 ff ff       	jmp    21203d <parseFormValue+0xb1d>
  212d78:	66 b8 20 00          	mov    ax,0x20
  212d7c:	e9 85 f3 ff ff       	jmp    212106 <parseFormValue+0xbe6>
  212d81:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  212d86:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  212d8b:	48 c1 e1 08          	shl    rcx,0x8
  212d8f:	48 09 c1             	or     rcx,rax
  212d92:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  212d97:	48 c1 e2 10          	shl    rdx,0x10
  212d9b:	48 09 ca             	or     rdx,rcx
  212d9e:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  212da3:	48 c1 e0 18          	shl    rax,0x18
  212da7:	48 09 d0             	or     rax,rdx
        DW.FORM_strp => FormValue{ .StrPtr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  212daa:	66 c7 84 24 40 03 00 	mov    WORD PTR [rsp+0x340],0x0
  212db1:	00 00 00 
  212db4:	48 89 84 24 48 03 00 	mov    QWORD PTR [rsp+0x348],rax
  212dbb:	00 
  212dbc:	c5 f8 10 84 24 c8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4c8]
  212dc3:	00 00 
  212dc5:	c5 f8 11 84 24 50 03 	vmovups XMMWORD PTR [rsp+0x350],xmm0
  212dcc:	00 00 
  212dce:	c6 84 24 60 03 00 00 	mov    BYTE PTR [rsp+0x360],0xa
  212dd5:	0a 
  212dd6:	8b 84 24 e0 02 00 00 	mov    eax,DWORD PTR [rsp+0x2e0]
  212ddd:	89 84 24 61 03 00 00 	mov    DWORD PTR [rsp+0x361],eax
  212de4:	0f b7 84 24 e4 02 00 	movzx  eax,WORD PTR [rsp+0x2e4]
  212deb:	00 
  212dec:	66 89 84 24 65 03 00 	mov    WORD PTR [rsp+0x365],ax
  212df3:	00 
  212df4:	8a 84 24 e6 02 00 00 	mov    al,BYTE PTR [rsp+0x2e6]
  212dfb:	88 84 24 67 03 00 00 	mov    BYTE PTR [rsp+0x367],al
  212e02:	48 8d 84 24 40 03 00 	lea    rax,[rsp+0x340]
  212e09:	00 
  212e0a:	e9 17 01 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  212e0f:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  212e14:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  212e19:	48 c1 e1 08          	shl    rcx,0x8
  212e1d:	48 09 c1             	or     rcx,rax
  212e20:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  212e25:	48 c1 e2 10          	shl    rdx,0x10
  212e29:	48 09 ca             	or     rdx,rcx
  212e2c:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  212e31:	48 c1 e0 18          	shl    rax,0x18
  212e35:	48 09 d0             	or     rax,rdx
        DW.FORM_ref_addr => FormValue{ .RefAddr = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  212e38:	66 c7 84 24 b8 03 00 	mov    WORD PTR [rsp+0x3b8],0x0
  212e3f:	00 00 00 
  212e42:	48 89 84 24 c0 03 00 	mov    QWORD PTR [rsp+0x3c0],rax
  212e49:	00 
  212e4a:	c5 f8 10 84 24 e8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4e8]
  212e51:	00 00 
  212e53:	c5 f8 11 84 24 c8 03 	vmovups XMMWORD PTR [rsp+0x3c8],xmm0
  212e5a:	00 00 
  212e5c:	c6 84 24 d8 03 00 00 	mov    BYTE PTR [rsp+0x3d8],0x7
  212e63:	07 
  212e64:	8b 84 24 f5 02 00 00 	mov    eax,DWORD PTR [rsp+0x2f5]
  212e6b:	89 84 24 d9 03 00 00 	mov    DWORD PTR [rsp+0x3d9],eax
  212e72:	0f b7 84 24 f9 02 00 	movzx  eax,WORD PTR [rsp+0x2f9]
  212e79:	00 
  212e7a:	66 89 84 24 dd 03 00 	mov    WORD PTR [rsp+0x3dd],ax
  212e81:	00 
  212e82:	8a 84 24 fb 02 00 00 	mov    al,BYTE PTR [rsp+0x2fb]
  212e89:	88 84 24 df 03 00 00 	mov    BYTE PTR [rsp+0x3df],al
  212e90:	48 8d 84 24 b8 03 00 	lea    rax,[rsp+0x3b8]
  212e97:	00 
  212e98:	e9 89 00 00 00       	jmp    212f26 <parseFormValue+0x1a06>
  212e9d:	0f b6 44 24 78       	movzx  eax,BYTE PTR [rsp+0x78]
  212ea2:	0f b6 4c 24 79       	movzx  ecx,BYTE PTR [rsp+0x79]
  212ea7:	48 c1 e1 08          	shl    rcx,0x8
  212eab:	48 09 c1             	or     rcx,rax
  212eae:	0f b6 54 24 7a       	movzx  edx,BYTE PTR [rsp+0x7a]
  212eb3:	48 c1 e2 10          	shl    rdx,0x10
  212eb7:	48 09 ca             	or     rdx,rcx
  212eba:	0f b6 44 24 7b       	movzx  eax,BYTE PTR [rsp+0x7b]
  212ebf:	48 c1 e0 18          	shl    rax,0x18
  212ec3:	48 09 d0             	or     rax,rdx
        DW.FORM_sec_offset => FormValue{ .SecOffset = try parseFormValueDwarfOffsetSize(in_stream, is_64) },
  212ec6:	66 c7 84 24 e0 03 00 	mov    WORD PTR [rsp+0x3e0],0x0
  212ecd:	00 00 00 
  212ed0:	48 89 84 24 e8 03 00 	mov    QWORD PTR [rsp+0x3e8],rax
  212ed7:	00 
  212ed8:	c5 f8 10 84 24 f8 04 	vmovups xmm0,XMMWORD PTR [rsp+0x4f8]
  212edf:	00 00 
  212ee1:	c5 f8 11 84 24 f0 03 	vmovups XMMWORD PTR [rsp+0x3f0],xmm0
  212ee8:	00 00 
  212eea:	c6 84 24 00 04 00 00 	mov    BYTE PTR [rsp+0x400],0x5
  212ef1:	05 
  212ef2:	8b 84 24 fc 02 00 00 	mov    eax,DWORD PTR [rsp+0x2fc]
  212ef9:	89 84 24 01 04 00 00 	mov    DWORD PTR [rsp+0x401],eax
  212f00:	0f b7 84 24 00 03 00 	movzx  eax,WORD PTR [rsp+0x300]
  212f07:	00 
  212f08:	66 89 84 24 05 04 00 	mov    WORD PTR [rsp+0x405],ax
  212f0f:	00 
  212f10:	8a 84 24 02 03 00 00 	mov    al,BYTE PTR [rsp+0x302]
  212f17:	88 84 24 07 04 00 00 	mov    BYTE PTR [rsp+0x407],al
  212f1e:	48 8d 84 24 e0 03 00 	lea    rax,[rsp+0x3e0]
  212f25:	00 
    return switch (form_id) {
  212f26:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
  212f2a:	49 89 4e 20          	mov    QWORD PTR [r14+0x20],rcx
  212f2e:	c5 fc 10 00          	vmovups ymm0,YMMWORD PTR [rax]
  212f32:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  212f37:	48 81 c4 08 07 00 00 	add    rsp,0x708
  212f3e:	5b                   	pop    rbx
  212f3f:	41 5c                	pop    r12
  212f41:	41 5d                	pop    r13
  212f43:	41 5e                	pop    r14
  212f45:	41 5f                	pop    r15
  212f47:	5d                   	pop    rbp
  212f48:	c5 f8 77             	vzeroupper 
  212f4b:	c3                   	ret    
  212f4c:	66 b8 25 00          	mov    ax,0x25
  212f50:	e9 d1 ea ff ff       	jmp    211a26 <parseFormValue+0x506>
  212f55:	66 b8 25 00          	mov    ax,0x25
  212f59:	e9 76 f0 ff ff       	jmp    211fd4 <parseFormValue+0xab4>
  212f5e:	66 b8 25 00          	mov    ax,0x25
  212f62:	e9 d6 f0 ff ff       	jmp    21203d <parseFormValue+0xb1d>
  212f67:	66 b8 25 00          	mov    ax,0x25
  212f6b:	e9 96 f1 ff ff       	jmp    212106 <parseFormValue+0xbe6>
  212f70:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  212f75:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  212f7c:	00 
  212f7d:	4c 89 e2             	mov    rdx,r12
  212f80:	48 89 d9             	mov    rcx,rbx
  212f83:	e8 28 13 00 00       	call   2142b0 <readAllocBytes>
  212f88:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  212f8d:	66 85 c9             	test   cx,cx
  212f90:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  212f95:	0f 84 eb 08 00 00    	je     213886 <parseFormValue+0x2366>
  212f9b:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  212fa0:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  212fa7:	00 
  212fa8:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  212fac:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  212fb3:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  212fb7:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  212fbe:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  212fc3:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  212fca:	00 
  212fcb:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  212fcf:	88 84 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],al
  212fd6:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  212fdd:	00 
  212fde:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  212fe2:	89 84 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],eax
  212fe9:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  212ff0:	00 
  212ff1:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  212ff6:	66 89 94 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],dx
  212ffd:	00 
  212ffe:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  213005:	00 
  213006:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  21300a:	88 9c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],bl
  213011:	e9 a1 00 00 00       	jmp    2130b7 <parseFormValue+0x1b97>
  213016:	48 8d 7c 24 40       	lea    rdi,[rsp+0x40]
    const buf = try readAllocBytes(allocator, in_stream, size);
  21301b:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  213022:	00 
  213023:	4c 89 e2             	mov    rdx,r12
  213026:	48 89 d9             	mov    rcx,rbx
  213029:	e8 82 12 00 00       	call   2142b0 <readAllocBytes>
  21302e:	0f b7 4c 24 40       	movzx  ecx,WORD PTR [rsp+0x40]
  213033:	66 85 c9             	test   cx,cx
  213036:	48 8b 7c 24 68       	mov    rdi,QWORD PTR [rsp+0x68]
  21303b:	0f 84 d9 08 00 00    	je     21391a <parseFormValue+0x23fa>
  213041:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  213046:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  21304d:	00 
  21304e:	8b 44 24 3a          	mov    eax,DWORD PTR [rsp+0x3a]
  213052:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  213059:	8b 44 24 11          	mov    eax,DWORD PTR [rsp+0x11]
  21305d:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  213064:	0f b7 44 24 15       	movzx  eax,WORD PTR [rsp+0x15]
  213069:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  213070:	00 
  213071:	8a 44 24 17          	mov    al,BYTE PTR [rsp+0x17]
  213075:	88 84 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],al
  21307c:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  213083:	00 
  213084:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  213088:	89 84 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],eax
  21308f:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  213096:	00 
  213097:	0f b7 54 24 0e       	movzx  edx,WORD PTR [rsp+0xe]
  21309c:	66 89 94 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],dx
  2130a3:	00 
  2130a4:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  2130ab:	00 
  2130ac:	8a 5c 24 10          	mov    bl,BYTE PTR [rsp+0x10]
  2130b0:	88 9c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],bl
  2130b7:	e9 ef 08 00 00       	jmp    2139ab <parseFormValue+0x248b>
            return parseFormValue(allocator, in_stream, child_form_id, is_64);
  2130bc:	44 0f b6 c5          	movzx  r8d,bpl
  2130c0:	48 8d bc 24 a0 04 00 	lea    rdi,[rsp+0x4a0]
  2130c7:	00 
  2130c8:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  2130cf:	00 
  2130d0:	4c 89 e2             	mov    rdx,r12
  2130d3:	4c 89 f1             	mov    rcx,r14
  2130d6:	e8 45 e4 ff ff       	call   211520 <parseFormValue>
  2130db:	48 8b 84 24 c0 04 00 	mov    rax,QWORD PTR [rsp+0x4c0]
  2130e2:	00 
  2130e3:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  2130e8:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  2130ec:	c5 fc 10 84 24 a0 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4a0]
  2130f3:	00 00 
  2130f5:	c5 fc 11 01          	vmovups YMMWORD PTR [rcx],ymm0
  2130f9:	e9 39 fe ff ff       	jmp    212f37 <parseFormValue+0x1a17>
  2130fe:	48 8d bc 24 50 04 00 	lea    rdi,[rsp+0x450]
  213105:	00 
            const buf = try readAllocBytes(allocator, in_stream, size);
  213106:	48 8b b4 24 d0 00 00 	mov    rsi,QWORD PTR [rsp+0xd0]
  21310d:	00 
  21310e:	4c 89 e2             	mov    rdx,r12
  213111:	48 89 d9             	mov    rcx,rbx
  213114:	e8 97 11 00 00       	call   2142b0 <readAllocBytes>
  213119:	0f b7 84 24 50 04 00 	movzx  eax,WORD PTR [rsp+0x450]
  213120:	00 
  213121:	66 85 c0             	test   ax,ax
  213124:	0f 84 c4 08 00 00    	je     2139ee <parseFormValue+0x24ce>
  21312a:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  21312f:	66 89 01             	mov    WORD PTR [rcx],ax
  213132:	48 8b 84 24 68 06 00 	mov    rax,QWORD PTR [rsp+0x668]
  213139:	00 
  21313a:	48 89 41 20          	mov    QWORD PTR [rcx+0x20],rax
  21313e:	c5 fc 10 84 24 4a 06 	vmovups ymm0,YMMWORD PTR [rsp+0x64a]
  213145:	00 00 
  213147:	c5 fc 11 41 02       	vmovups YMMWORD PTR [rcx+0x2],ymm0
  21314c:	e9 e6 fd ff ff       	jmp    212f37 <parseFormValue+0x1a17>
  213151:	31 c9                	xor    ecx,ecx
  213153:	e9 f1 09 00 00       	jmp    213b49 <parseFormValue+0x2629>
  213158:	31 c9                	xor    ecx,ecx
  21315a:	e9 cb 0b 00 00       	jmp    213d2a <parseFormValue+0x280a>
  21315f:	31 c9                	xor    ecx,ecx
  213161:	e9 a5 0d 00 00       	jmp    213f0b <parseFormValue+0x29eb>
    const buf = try readAllocBytes(allocator, in_stream, size);
  213166:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  21316d:	00 00 
  21316f:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  213176:	00 00 
    return FormValue{ .Ref = buf };
  213178:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  21317e:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  213185:	00 
  213186:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  21318b:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  213190:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  213194:	89 04 24             	mov    DWORD PTR [rsp],eax
  213197:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  21319c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2131a1:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  2131a5:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  2131a9:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  2131af:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2131b6:	00 00 
  2131b8:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  2131be:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  2131c5:	00 00 
  2131c7:	b1 06                	mov    cl,0x6
  2131c9:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  2131cb:	66 89 84 24 40 02 00 	mov    WORD PTR [rsp+0x240],ax
  2131d2:	00 
  2131d3:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  2131da:	00 00 
  2131dc:	c5 f8 11 84 24 42 02 	vmovups XMMWORD PTR [rsp+0x242],xmm0
  2131e3:	00 00 
  2131e5:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  2131ec:	00 00 
  2131ee:	c5 f8 11 84 24 50 02 	vmovups XMMWORD PTR [rsp+0x250],xmm0
  2131f5:	00 00 
  2131f7:	88 8c 24 60 02 00 00 	mov    BYTE PTR [rsp+0x260],cl
  2131fe:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  213201:	89 84 24 61 02 00 00 	mov    DWORD PTR [rsp+0x261],eax
  213208:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  21320d:	66 89 84 24 65 02 00 	mov    WORD PTR [rsp+0x265],ax
  213214:	00 
  213215:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  213219:	e9 41 eb ff ff       	jmp    211d5f <parseFormValue+0x83f>
    const buf = try readAllocBytes(allocator, in_stream, size);
  21321e:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  213225:	00 00 
  213227:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  21322e:	00 00 
    return FormValue{ .Ref = buf };
  213230:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  213236:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  21323d:	00 
  21323e:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  213243:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  213248:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  21324c:	89 04 24             	mov    DWORD PTR [rsp],eax
  21324f:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  213254:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  213259:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  21325d:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  213261:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  213267:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  21326e:	00 00 
  213270:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  213276:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  21327d:	00 00 
  21327f:	b1 06                	mov    cl,0x6
  213281:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  213283:	66 89 84 24 18 02 00 	mov    WORD PTR [rsp+0x218],ax
  21328a:	00 
  21328b:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  213292:	00 00 
  213294:	c5 f8 11 84 24 1a 02 	vmovups XMMWORD PTR [rsp+0x21a],xmm0
  21329b:	00 00 
  21329d:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  2132a4:	00 00 
  2132a6:	c5 f8 11 84 24 28 02 	vmovups XMMWORD PTR [rsp+0x228],xmm0
  2132ad:	00 00 
  2132af:	88 8c 24 38 02 00 00 	mov    BYTE PTR [rsp+0x238],cl
  2132b6:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  2132b9:	89 84 24 39 02 00 00 	mov    DWORD PTR [rsp+0x239],eax
  2132c0:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  2132c5:	66 89 84 24 3d 02 00 	mov    WORD PTR [rsp+0x23d],ax
  2132cc:	00 
  2132cd:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  2132d1:	e9 3e eb ff ff       	jmp    211e14 <parseFormValue+0x8f4>
    const buf = try readAllocBytes(allocator, in_stream, size);
  2132d6:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  2132dd:	00 00 
  2132df:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  2132e6:	00 00 
    return FormValue{ .Ref = buf };
  2132e8:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  2132ee:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  2132f5:	00 
  2132f6:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  2132fb:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  213300:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  213304:	89 04 24             	mov    DWORD PTR [rsp],eax
  213307:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  21330c:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  213311:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  213315:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  213319:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  21331f:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213326:	00 00 
  213328:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  21332e:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  213335:	00 00 
  213337:	b1 06                	mov    cl,0x6
  213339:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  21333b:	66 89 84 24 f0 01 00 	mov    WORD PTR [rsp+0x1f0],ax
  213342:	00 
  213343:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  21334a:	00 00 
  21334c:	c5 f8 11 84 24 f2 01 	vmovups XMMWORD PTR [rsp+0x1f2],xmm0
  213353:	00 00 
  213355:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  21335c:	00 00 
  21335e:	c5 f8 11 84 24 00 02 	vmovups XMMWORD PTR [rsp+0x200],xmm0
  213365:	00 00 
  213367:	88 8c 24 10 02 00 00 	mov    BYTE PTR [rsp+0x210],cl
  21336e:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  213371:	89 84 24 11 02 00 00 	mov    DWORD PTR [rsp+0x211],eax
  213378:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  21337d:	66 89 84 24 15 02 00 	mov    WORD PTR [rsp+0x215],ax
  213384:	00 
  213385:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  213389:	e9 3b eb ff ff       	jmp    211ec9 <parseFormValue+0x9a9>
    const buf = try readAllocBytes(allocator, in_stream, size);
  21338e:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  213395:	00 00 
  213397:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  21339e:	00 00 
    return FormValue{ .Ref = buf };
  2133a0:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  2133a6:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  2133ad:	00 
  2133ae:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  2133b3:	c6 44 24 08 06       	mov    BYTE PTR [rsp+0x8],0x6
  2133b8:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  2133bc:	89 04 24             	mov    DWORD PTR [rsp],eax
  2133bf:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  2133c4:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2133c9:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  2133cd:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  2133d1:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  2133d7:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  2133de:	00 00 
  2133e0:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  2133e6:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  2133ed:	00 00 
  2133ef:	b1 06                	mov    cl,0x6
  2133f1:	31 c0                	xor    eax,eax
    return parseFormValueRefLen(allocator, in_stream, block_len);
  2133f3:	66 89 84 24 c8 01 00 	mov    WORD PTR [rsp+0x1c8],ax
  2133fa:	00 
  2133fb:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  213402:	00 00 
  213404:	c5 f8 11 84 24 ca 01 	vmovups XMMWORD PTR [rsp+0x1ca],xmm0
  21340b:	00 00 
  21340d:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  213414:	00 00 
  213416:	c5 f8 11 84 24 d8 01 	vmovups XMMWORD PTR [rsp+0x1d8],xmm0
  21341d:	00 00 
  21341f:	88 8c 24 e8 01 00 00 	mov    BYTE PTR [rsp+0x1e8],cl
  213426:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  213429:	89 84 24 e9 01 00 00 	mov    DWORD PTR [rsp+0x1e9],eax
  213430:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  213435:	66 89 84 24 ed 01 00 	mov    WORD PTR [rsp+0x1ed],ax
  21343c:	00 
  21343d:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  213441:	e9 38 eb ff ff       	jmp    211f7e <parseFormValue+0xa5e>
            const signed = form_id == DW.FORM_sdata;
  213446:	48 83 fb 0d          	cmp    rbx,0xd
    return FormValue{
  21344a:	0f 94 84 24 b0 00 00 	sete   BYTE PTR [rsp+0xb0]
  213451:	00 
  213452:	c6 44 24 60 02       	mov    BYTE PTR [rsp+0x60],0x2
  213457:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  21345b:	89 84 24 18 01 00 00 	mov    DWORD PTR [rsp+0x118],eax
            const signed = form_id == DW.FORM_sdata;
  213462:	40 0f 94 c7          	sete   dil
    return FormValue{
  213466:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21346b:	66 89 84 24 1c 01 00 	mov    WORD PTR [rsp+0x11c],ax
  213472:	00 
        .Const = Constant{
  213473:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{
  213479:	8b 84 24 90 00 00 00 	mov    eax,DWORD PTR [rsp+0x90]
  213480:	89 84 24 f0 00 00 00 	mov    DWORD PTR [rsp+0xf0],eax
  213487:	48 8d b4 24 18 01 00 	lea    rsi,[rsp+0x118]
  21348e:	00 
  21348f:	0f b7 84 24 94 00 00 	movzx  eax,WORD PTR [rsp+0x94]
  213496:	00 
  213497:	66 89 84 24 f4 00 00 	mov    WORD PTR [rsp+0xf4],ax
  21349e:	00 
  21349f:	48 8d 84 24 f0 00 00 	lea    rax,[rsp+0xf0]
  2134a6:	00 
  2134a7:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  2134ae:	88 8c 24 f6 00 00 00 	mov    BYTE PTR [rsp+0xf6],cl
  2134b5:	b3 02                	mov    bl,0x2
  2134b7:	8b 4c 24 18          	mov    ecx,DWORD PTR [rsp+0x18]
  2134bb:	89 8c 24 e8 00 00 00 	mov    DWORD PTR [rsp+0xe8],ecx
  2134c2:	48 8d 8c 24 e8 00 00 	lea    rcx,[rsp+0xe8]
  2134c9:	00 
  2134ca:	0f b7 54 24 1c       	movzx  edx,WORD PTR [rsp+0x1c]
  2134cf:	66 89 94 24 ec 00 00 	mov    WORD PTR [rsp+0xec],dx
  2134d6:	00 
  2134d7:	8a 54 24 1e          	mov    dl,BYTE PTR [rsp+0x1e]
  2134db:	88 94 24 ee 00 00 00 	mov    BYTE PTR [rsp+0xee],dl
  2134e2:	31 d2                	xor    edx,edx
            return parseFormValueConstant(allocator, in_stream, signed, block_len);
  2134e4:	66 89 55 00          	mov    WORD PTR [rbp+0x0],dx
  2134e8:	0f b7 56 04          	movzx  edx,WORD PTR [rsi+0x4]
  2134ec:	66 89 55 06          	mov    WORD PTR [rbp+0x6],dx
  2134f0:	8b 16                	mov    edx,DWORD PTR [rsi]
  2134f2:	89 55 02             	mov    DWORD PTR [rbp+0x2],edx
  2134f5:	c5 f8 11 45 08       	vmovups XMMWORD PTR [rbp+0x8],xmm0
  2134fa:	40 88 7d 18          	mov    BYTE PTR [rbp+0x18],dil
  2134fe:	8a 50 06             	mov    dl,BYTE PTR [rax+0x6]
  213501:	88 55 1f             	mov    BYTE PTR [rbp+0x1f],dl
  213504:	0f b7 50 04          	movzx  edx,WORD PTR [rax+0x4]
  213508:	66 89 55 1d          	mov    WORD PTR [rbp+0x1d],dx
  21350c:	8b 00                	mov    eax,DWORD PTR [rax]
  21350e:	89 45 19             	mov    DWORD PTR [rbp+0x19],eax
  213511:	88 5d 20             	mov    BYTE PTR [rbp+0x20],bl
  213514:	0f b7 41 04          	movzx  eax,WORD PTR [rcx+0x4]
  213518:	66 89 45 25          	mov    WORD PTR [rbp+0x25],ax
  21351c:	8b 01                	mov    eax,DWORD PTR [rcx]
  21351e:	89 45 21             	mov    DWORD PTR [rbp+0x21],eax
  213521:	8a 41 06             	mov    al,BYTE PTR [rcx+0x6]
  213524:	88 45 27             	mov    BYTE PTR [rbp+0x27],al
  213527:	e9 0b fa ff ff       	jmp    212f37 <parseFormValue+0x1a17>
            for (bytes) |b, index| {
  21352c:	48 89 c3             	mov    rbx,rax
  21352f:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  213533:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  213537:	48 89 e9             	mov    rcx,rbp
  21353a:	48 c1 e9 04          	shr    rcx,0x4
  21353e:	8d 79 01             	lea    edi,[rcx+0x1]
  213541:	83 e7 01             	and    edi,0x1
  213544:	48 85 ed             	test   rbp,rbp
  213547:	0f 84 29 05 00 00    	je     213a76 <parseFormValue+0x2556>
  21354d:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  213551:	48 29 cd             	sub    rbp,rcx
  213554:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  213558:	c5 fd 6f 0d 40 d7 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffed740]        # 200ca0 <app_mask+0x68>
  21355f:	ff 
  213560:	31 c9                	xor    ecx,ecx
  213562:	c4 e2 7d 59 2d bd d6 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffed6bd]        # 200c28 <__unnamed_441+0x88>
  213569:	fe ff 
  21356b:	c4 e2 7d 59 35 0c d7 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffed70c]        # 200c80 <app_mask+0x48>
  213572:	fe ff 
  213574:	c4 e2 7d 59 3d fb d6 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffed6fb]        # 200c78 <app_mask+0x40>
  21357b:	fe ff 
  21357d:	c4 62 7d 59 05 32 d6 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffed632]        # 200bb8 <__unnamed_441+0x18>
  213584:	fe ff 
  213586:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  21358a:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  21358e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  213592:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  213598:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  21359f:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  2135a6:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  2135ad:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  2135b2:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  2135b6:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  2135ba:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  2135be:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  2135c3:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  2135c7:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  2135cc:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  2135d0:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  2135d5:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  2135d9:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  2135de:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  2135e5:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  2135ec:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  2135f3:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  2135fa:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  2135fe:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  213602:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  213607:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  21360b:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  21360f:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  213614:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  213618:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  21361d:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  213621:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  213626:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  21362a:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  21362f:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  213633:	48 83 c1 20          	add    rcx,0x20
  213637:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  21363b:	48 83 c5 02          	add    rbp,0x2
  21363f:	0f 85 4d ff ff ff    	jne    213592 <parseFormValue+0x2072>
  213645:	e9 46 04 00 00       	jmp    213a90 <parseFormValue+0x2570>
  21364a:	48 89 c3             	mov    rbx,rax
  21364d:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  213651:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  213655:	48 89 e9             	mov    rcx,rbp
  213658:	48 c1 e9 04          	shr    rcx,0x4
  21365c:	8d 79 01             	lea    edi,[rcx+0x1]
  21365f:	83 e7 01             	and    edi,0x1
  213662:	48 85 ed             	test   rbp,rbp
  213665:	0f 84 ec 05 00 00    	je     213c57 <parseFormValue+0x2737>
  21366b:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  21366f:	48 29 cd             	sub    rbp,rcx
  213672:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  213676:	c5 fd 6f 0d 22 d6 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffed622]        # 200ca0 <app_mask+0x68>
  21367d:	ff 
  21367e:	31 c9                	xor    ecx,ecx
  213680:	c4 e2 7d 59 2d 9f d5 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffed59f]        # 200c28 <__unnamed_441+0x88>
  213687:	fe ff 
  213689:	c4 e2 7d 59 35 ee d5 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffed5ee]        # 200c80 <app_mask+0x48>
  213690:	fe ff 
  213692:	c4 e2 7d 59 3d dd d5 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffed5dd]        # 200c78 <app_mask+0x40>
  213699:	fe ff 
  21369b:	c4 62 7d 59 05 14 d5 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffed514]        # 200bb8 <__unnamed_441+0x18>
  2136a2:	fe ff 
  2136a4:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2136a8:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  2136ac:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2136b0:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  2136b6:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  2136bd:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  2136c4:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  2136cb:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  2136d0:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  2136d4:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  2136d8:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  2136dc:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  2136e1:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  2136e5:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  2136ea:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  2136ee:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  2136f3:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  2136f7:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  2136fc:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  213703:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  21370a:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  213711:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  213718:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  21371c:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  213720:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  213725:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  213729:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  21372d:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  213732:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  213736:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  21373b:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  21373f:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  213744:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  213748:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  21374d:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  213751:	48 83 c1 20          	add    rcx,0x20
  213755:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  213759:	48 83 c5 02          	add    rbp,0x2
  21375d:	0f 85 4d ff ff ff    	jne    2136b0 <parseFormValue+0x2190>
  213763:	e9 09 05 00 00       	jmp    213c71 <parseFormValue+0x2751>
  213768:	48 89 c3             	mov    rbx,rax
  21376b:	48 83 e3 f0          	and    rbx,0xfffffffffffffff0
  21376f:	48 8d 6b f0          	lea    rbp,[rbx-0x10]
  213773:	48 89 e9             	mov    rcx,rbp
  213776:	48 c1 e9 04          	shr    rcx,0x4
  21377a:	8d 79 01             	lea    edi,[rcx+0x1]
  21377d:	83 e7 01             	and    edi,0x1
  213780:	48 85 ed             	test   rbp,rbp
  213783:	0f 84 af 06 00 00    	je     213e38 <parseFormValue+0x2918>
  213789:	48 8d 6f ff          	lea    rbp,[rdi-0x1]
  21378d:	48 29 cd             	sub    rbp,rcx
  213790:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  213794:	c5 fd 6f 0d 04 d5 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffed504]        # 200ca0 <app_mask+0x68>
  21379b:	ff 
  21379c:	31 c9                	xor    ecx,ecx
  21379e:	c4 e2 7d 59 2d 81 d4 	vpbroadcastq ymm5,QWORD PTR [rip+0xfffffffffffed481]        # 200c28 <__unnamed_441+0x88>
  2137a5:	fe ff 
  2137a7:	c4 e2 7d 59 35 d0 d4 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffed4d0]        # 200c80 <app_mask+0x48>
  2137ae:	fe ff 
  2137b0:	c4 e2 7d 59 3d bf d4 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffed4bf]        # 200c78 <app_mask+0x40>
  2137b7:	fe ff 
  2137b9:	c4 62 7d 59 05 f6 d3 	vpbroadcastq ymm8,QWORD PTR [rip+0xfffffffffffed3f6]        # 200bb8 <__unnamed_441+0x18>
  2137c0:	fe ff 
  2137c2:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  2137c6:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  2137ca:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  2137ce:	c4 62 7d 32 0c 0a    	vpmovzxbq ymm9,DWORD PTR [rdx+rcx*1]
  2137d4:	c4 62 7d 32 54 0a 04 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x4]
  2137db:	c4 62 7d 32 5c 0a 08 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x8]
  2137e2:	c4 62 7d 32 64 0a 0c 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0xc]
  2137e9:	c5 95 73 f1 03       	vpsllq ymm13,ymm1,0x3
  2137ee:	c5 15 d4 f5          	vpaddq ymm14,ymm13,ymm5
  2137f2:	c5 15 db fe          	vpand  ymm15,ymm13,ymm6
  2137f6:	c5 0d db f6          	vpand  ymm14,ymm14,ymm6
  2137fa:	c4 42 b5 47 cf       	vpsllvq ymm9,ymm9,ymm15
  2137ff:	c5 b5 eb c0          	vpor   ymm0,ymm9,ymm0
  213803:	c4 42 ad 47 ce       	vpsllvq ymm9,ymm10,ymm14
  213808:	c5 b5 eb db          	vpor   ymm3,ymm9,ymm3
  21380c:	c4 42 a5 47 cf       	vpsllvq ymm9,ymm11,ymm15
  213811:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  213815:	c4 42 9d 47 ce       	vpsllvq ymm9,ymm12,ymm14
  21381a:	c4 62 7d 32 54 0a 10 	vpmovzxbq ymm10,DWORD PTR [rdx+rcx*1+0x10]
  213821:	c4 62 7d 32 5c 0a 14 	vpmovzxbq ymm11,DWORD PTR [rdx+rcx*1+0x14]
  213828:	c4 62 7d 32 64 0a 18 	vpmovzxbq ymm12,DWORD PTR [rdx+rcx*1+0x18]
  21382f:	c4 62 7d 32 74 0a 1c 	vpmovzxbq ymm14,DWORD PTR [rdx+rcx*1+0x1c]
  213836:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
  21383a:	c5 15 d4 cf          	vpaddq ymm9,ymm13,ymm7
  21383e:	c4 41 15 d4 e8       	vpaddq ymm13,ymm13,ymm8
  213843:	c5 35 db ce          	vpand  ymm9,ymm9,ymm6
  213847:	c5 15 db ee          	vpand  ymm13,ymm13,ymm6
  21384b:	c4 42 ad 47 d1       	vpsllvq ymm10,ymm10,ymm9
  213850:	c5 ad eb c0          	vpor   ymm0,ymm10,ymm0
  213854:	c4 42 a5 47 d5       	vpsllvq ymm10,ymm11,ymm13
  213859:	c5 ad eb db          	vpor   ymm3,ymm10,ymm3
  21385d:	c4 42 9d 47 c9       	vpsllvq ymm9,ymm12,ymm9
  213862:	c5 b5 eb e4          	vpor   ymm4,ymm9,ymm4
  213866:	c4 42 8d 47 cd       	vpsllvq ymm9,ymm14,ymm13
  21386b:	c5 b5 eb d2          	vpor   ymm2,ymm9,ymm2
            for (bytes) |b, index| {
  21386f:	48 83 c1 20          	add    rcx,0x20
  213873:	c5 f5 d4 cd          	vpaddq ymm1,ymm1,ymm5
  213877:	48 83 c5 02          	add    rbp,0x2
  21387b:	0f 85 4d ff ff ff    	jne    2137ce <parseFormValue+0x22ae>
  213881:	e9 cc 05 00 00       	jmp    213e52 <parseFormValue+0x2932>
    return FormValue{ .Block = buf };
  213886:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x1
  21388d:	01 
  21388e:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  213892:	89 84 24 20 01 00 00 	mov    DWORD PTR [rsp+0x120],eax
  213899:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  21389e:	66 89 84 24 24 01 00 	mov    WORD PTR [rsp+0x124],ax
  2138a5:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  2138a6:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Block = buf };
  2138ac:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  2138b0:	89 84 24 00 01 00 00 	mov    DWORD PTR [rsp+0x100],eax
  2138b7:	48 8d b4 24 20 01 00 	lea    rsi,[rsp+0x120]
  2138be:	00 
  2138bf:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  2138c4:	66 89 84 24 04 01 00 	mov    WORD PTR [rsp+0x104],ax
  2138cb:	00 
  2138cc:	48 8d 84 24 00 01 00 	lea    rax,[rsp+0x100]
  2138d3:	00 
  2138d4:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  2138d8:	88 8c 24 06 01 00 00 	mov    BYTE PTR [rsp+0x106],cl
  2138df:	b3 01                	mov    bl,0x1
  2138e1:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  2138e8:	89 8c 24 f8 00 00 00 	mov    DWORD PTR [rsp+0xf8],ecx
  2138ef:	48 8d 94 24 f8 00 00 	lea    rdx,[rsp+0xf8]
  2138f6:	00 
  2138f7:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  2138fe:	00 
  2138ff:	66 89 8c 24 fc 00 00 	mov    WORD PTR [rsp+0xfc],cx
  213906:	00 
  213907:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  21390e:	88 8c 24 fe 00 00 00 	mov    BYTE PTR [rsp+0xfe],cl
  213915:	e9 8f 00 00 00       	jmp    2139a9 <parseFormValue+0x2489>
    return FormValue{ .Ref = buf };
  21391a:	c6 84 24 b0 00 00 00 	mov    BYTE PTR [rsp+0xb0],0x6
  213921:	06 
  213922:	8b 44 24 78          	mov    eax,DWORD PTR [rsp+0x78]
  213926:	89 84 24 10 01 00 00 	mov    DWORD PTR [rsp+0x110],eax
  21392d:	0f b7 44 24 7c       	movzx  eax,WORD PTR [rsp+0x7c]
  213932:	66 89 84 24 14 01 00 	mov    WORD PTR [rsp+0x114],ax
  213939:	00 
    const buf = try readAllocBytes(allocator, in_stream, size);
  21393a:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
    return FormValue{ .Ref = buf };
  213940:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
  213944:	89 84 24 e0 00 00 00 	mov    DWORD PTR [rsp+0xe0],eax
  21394b:	48 8d b4 24 10 01 00 	lea    rsi,[rsp+0x110]
  213952:	00 
  213953:	0f b7 44 24 1c       	movzx  eax,WORD PTR [rsp+0x1c]
  213958:	66 89 84 24 e4 00 00 	mov    WORD PTR [rsp+0xe4],ax
  21395f:	00 
  213960:	48 8d 84 24 e0 00 00 	lea    rax,[rsp+0xe0]
  213967:	00 
  213968:	8a 4c 24 1e          	mov    cl,BYTE PTR [rsp+0x1e]
  21396c:	88 8c 24 e6 00 00 00 	mov    BYTE PTR [rsp+0xe6],cl
  213973:	b3 06                	mov    bl,0x6
  213975:	8b 8c 24 90 00 00 00 	mov    ecx,DWORD PTR [rsp+0x90]
  21397c:	89 8c 24 d8 00 00 00 	mov    DWORD PTR [rsp+0xd8],ecx
  213983:	48 8d 94 24 d8 00 00 	lea    rdx,[rsp+0xd8]
  21398a:	00 
  21398b:	0f b7 8c 24 94 00 00 	movzx  ecx,WORD PTR [rsp+0x94]
  213992:	00 
  213993:	66 89 8c 24 dc 00 00 	mov    WORD PTR [rsp+0xdc],cx
  21399a:	00 
  21399b:	8a 8c 24 96 00 00 00 	mov    cl,BYTE PTR [rsp+0x96]
  2139a2:	88 8c 24 de 00 00 00 	mov    BYTE PTR [rsp+0xde],cl
  2139a9:	31 c9                	xor    ecx,ecx
  2139ab:	66 89 0f             	mov    WORD PTR [rdi],cx
  2139ae:	0f b7 4e 04          	movzx  ecx,WORD PTR [rsi+0x4]
  2139b2:	66 89 4f 06          	mov    WORD PTR [rdi+0x6],cx
  2139b6:	8b 0e                	mov    ecx,DWORD PTR [rsi]
  2139b8:	89 4f 02             	mov    DWORD PTR [rdi+0x2],ecx
  2139bb:	c5 f8 11 47 08       	vmovups XMMWORD PTR [rdi+0x8],xmm0
  2139c0:	8a 48 06             	mov    cl,BYTE PTR [rax+0x6]
  2139c3:	88 4f 1f             	mov    BYTE PTR [rdi+0x1f],cl
  2139c6:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  2139ca:	66 89 4f 1d          	mov    WORD PTR [rdi+0x1d],cx
  2139ce:	8b 00                	mov    eax,DWORD PTR [rax]
  2139d0:	89 47 19             	mov    DWORD PTR [rdi+0x19],eax
  2139d3:	88 5f 20             	mov    BYTE PTR [rdi+0x20],bl
  2139d6:	0f b7 42 04          	movzx  eax,WORD PTR [rdx+0x4]
  2139da:	66 89 47 25          	mov    WORD PTR [rdi+0x25],ax
  2139de:	8b 02                	mov    eax,DWORD PTR [rdx]
  2139e0:	89 47 21             	mov    DWORD PTR [rdi+0x21],eax
  2139e3:	8a 42 06             	mov    al,BYTE PTR [rdx+0x6]
  2139e6:	88 47 27             	mov    BYTE PTR [rdi+0x27],al
  2139e9:	e9 49 f5 ff ff       	jmp    212f37 <parseFormValue+0x1a17>
            const buf = try readAllocBytes(allocator, in_stream, size);
  2139ee:	c5 f8 10 84 24 58 04 	vmovups xmm0,XMMWORD PTR [rsp+0x458]
  2139f5:	00 00 
  2139f7:	c5 f8 29 84 24 80 04 	vmovaps XMMWORD PTR [rsp+0x480],xmm0
  2139fe:	00 00 
            return FormValue{ .ExprLoc = buf };
  213a00:	c5 f8 11 84 24 38 04 	vmovups XMMWORD PTR [rsp+0x438],xmm0
  213a07:	00 00 
  213a09:	48 8b 84 24 90 04 00 	mov    rax,QWORD PTR [rsp+0x490]
  213a10:	00 
  213a11:	48 89 84 24 48 04 00 	mov    QWORD PTR [rsp+0x448],rax
  213a18:	00 
  213a19:	c6 84 24 ae 00 00 00 	mov    BYTE PTR [rsp+0xae],0x3
  213a20:	03 
  213a21:	48 8b 4c 24 68       	mov    rcx,QWORD PTR [rsp+0x68]
  213a26:	66 c7 01 00 00       	mov    WORD PTR [rcx],0x0
  213a2b:	c5 f8 10 84 24 32 04 	vmovups xmm0,XMMWORD PTR [rsp+0x432]
  213a32:	00 00 
  213a34:	c5 fa 6f 8c 24 40 04 	vmovdqu xmm1,XMMWORD PTR [rsp+0x440]
  213a3b:	00 00 
  213a3d:	c5 fa 7f 49 10       	vmovdqu XMMWORD PTR [rcx+0x10],xmm1
  213a42:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  213a47:	8a 84 24 ae 00 00 00 	mov    al,BYTE PTR [rsp+0xae]
  213a4e:	88 41 20             	mov    BYTE PTR [rcx+0x20],al
  213a51:	8a 84 24 10 03 00 00 	mov    al,BYTE PTR [rsp+0x310]
  213a58:	88 41 27             	mov    BYTE PTR [rcx+0x27],al
  213a5b:	0f b7 84 24 0e 03 00 	movzx  eax,WORD PTR [rsp+0x30e]
  213a62:	00 
  213a63:	66 89 41 25          	mov    WORD PTR [rcx+0x25],ax
  213a67:	8b 84 24 0a 03 00 00 	mov    eax,DWORD PTR [rsp+0x30a]
  213a6e:	89 41 21             	mov    DWORD PTR [rcx+0x21],eax
  213a71:	e9 c1 f4 ff ff       	jmp    212f37 <parseFormValue+0x1a17>
  213a76:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  213a7a:	c5 fd 6f 0d 1e d2 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffed21e]        # 200ca0 <app_mask+0x68>
  213a81:	ff 
  213a82:	31 c9                	xor    ecx,ecx
  213a84:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  213a88:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  213a8c:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  213a90:	48 85 ff             	test   rdi,rdi
  213a93:	74 62                	je     213af7 <parseFormValue+0x25d7>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  213a95:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  213a9c:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  213aa1:	c4 e2 7d 59 35 7e d1 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffed17e]        # 200c28 <__unnamed_441+0x88>
  213aa8:	fe ff 
  213aaa:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  213aae:	c4 e2 7d 59 3d c9 d1 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffed1c9]        # 200c80 <app_mask+0x48>
  213ab5:	fe ff 
  213ab7:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  213abb:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  213ac0:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  213ac7:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  213acb:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  213acf:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  213ad4:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  213ad8:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  213adf:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  213ae4:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  213ae8:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  213aee:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  213af3:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  213af7:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  213afb:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  213aff:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213b03:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  213b09:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213b0d:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  213b12:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213b16:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  213b1b:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  213b1e:	74 29                	je     213b49 <parseFormValue+0x2629>
  213b20:	48 29 d8             	sub    rax,rbx
  213b23:	48 01 da             	add    rdx,rbx
  213b26:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  213b2a:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  213b2d:	89 de                	mov    esi,ebx
  213b2f:	40 80 e6 38          	and    sil,0x38
  213b33:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  213b38:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  213b3b:	48 83 c3 08          	add    rbx,0x8
  213b3f:	48 83 c2 01          	add    rdx,0x1
  213b43:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  213b47:	75 e1                	jne    213b2a <parseFormValue+0x260a>
  213b49:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  213b4e:	4c 89 fe             	mov    rsi,r15
  213b51:	4c 89 e2             	mov    rdx,r12
  213b54:	c5 f8 77             	vzeroupper 
  213b57:	e8 54 07 00 00       	call   2142b0 <readAllocBytes>
  213b5c:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  213b61:	66 85 c0             	test   ax,ax
  213b64:	74 39                	je     213b9f <parseFormValue+0x267f>
  213b66:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  213b6c:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  213b72:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  213b79:	00 00 
  213b7b:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213b82:	00 00 
  213b84:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  213b88:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  213b8b:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  213b90:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  213b95:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  213b99:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  213b9d:	eb 65                	jmp    213c04 <parseFormValue+0x26e4>
  213b9f:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  213ba6:	00 00 
  213ba8:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  213baf:	00 00 
    return FormValue{ .Block = buf };
  213bb1:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  213bb7:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  213bbe:	00 
  213bbf:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  213bc4:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  213bc9:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  213bcd:	89 04 24             	mov    DWORD PTR [rsp],eax
  213bd0:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  213bd5:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  213bda:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  213bde:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  213be2:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  213be8:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213bef:	00 00 
  213bf1:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  213bf7:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  213bfe:	00 00 
  213c00:	b1 01                	mov    cl,0x1
  213c02:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  213c04:	66 89 84 24 90 02 00 	mov    WORD PTR [rsp+0x290],ax
  213c0b:	00 
  213c0c:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  213c13:	00 00 
  213c15:	c5 f8 11 84 24 92 02 	vmovups XMMWORD PTR [rsp+0x292],xmm0
  213c1c:	00 00 
  213c1e:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  213c25:	00 00 
  213c27:	c5 f8 11 84 24 a0 02 	vmovups XMMWORD PTR [rsp+0x2a0],xmm0
  213c2e:	00 00 
  213c30:	88 8c 24 b0 02 00 00 	mov    BYTE PTR [rsp+0x2b0],cl
  213c37:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  213c3a:	89 84 24 b1 02 00 00 	mov    DWORD PTR [rsp+0x2b1],eax
  213c41:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  213c46:	66 89 84 24 b5 02 00 	mov    WORD PTR [rsp+0x2b5],ax
  213c4d:	00 
  213c4e:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  213c52:	e9 78 da ff ff       	jmp    2116cf <parseFormValue+0x1af>
  213c57:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  213c5b:	c5 fd 6f 0d 3d d0 fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffed03d]        # 200ca0 <app_mask+0x68>
  213c62:	ff 
  213c63:	31 c9                	xor    ecx,ecx
  213c65:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  213c69:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  213c6d:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  213c71:	48 85 ff             	test   rdi,rdi
  213c74:	74 62                	je     213cd8 <parseFormValue+0x27b8>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  213c76:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  213c7d:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  213c82:	c4 e2 7d 59 35 9d cf 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffecf9d]        # 200c28 <__unnamed_441+0x88>
  213c89:	fe ff 
  213c8b:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  213c8f:	c4 e2 7d 59 3d e8 cf 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffecfe8]        # 200c80 <app_mask+0x48>
  213c96:	fe ff 
  213c98:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  213c9c:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  213ca1:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  213ca8:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  213cac:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  213cb0:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  213cb5:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  213cb9:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  213cc0:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  213cc5:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  213cc9:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  213ccf:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  213cd4:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  213cd8:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  213cdc:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  213ce0:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213ce4:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  213cea:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213cee:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  213cf3:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213cf7:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  213cfc:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  213cff:	74 29                	je     213d2a <parseFormValue+0x280a>
  213d01:	48 29 d8             	sub    rax,rbx
  213d04:	48 01 da             	add    rdx,rbx
  213d07:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  213d0b:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  213d0e:	89 de                	mov    esi,ebx
  213d10:	40 80 e6 38          	and    sil,0x38
  213d14:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  213d19:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  213d1c:	48 83 c3 08          	add    rbx,0x8
  213d20:	48 83 c2 01          	add    rdx,0x1
  213d24:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  213d28:	75 e1                	jne    213d0b <parseFormValue+0x27eb>
  213d2a:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  213d2f:	4c 89 fe             	mov    rsi,r15
  213d32:	4c 89 e2             	mov    rdx,r12
  213d35:	c5 f8 77             	vzeroupper 
  213d38:	e8 73 05 00 00       	call   2142b0 <readAllocBytes>
  213d3d:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  213d42:	66 85 c0             	test   ax,ax
  213d45:	74 39                	je     213d80 <parseFormValue+0x2860>
  213d47:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  213d4d:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  213d53:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  213d5a:	00 00 
  213d5c:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213d63:	00 00 
  213d65:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  213d69:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  213d6c:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  213d71:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  213d76:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  213d7a:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  213d7e:	eb 65                	jmp    213de5 <parseFormValue+0x28c5>
  213d80:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  213d87:	00 00 
  213d89:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  213d90:	00 00 
    return FormValue{ .Block = buf };
  213d92:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  213d98:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  213d9f:	00 
  213da0:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  213da5:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  213daa:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  213dae:	89 04 24             	mov    DWORD PTR [rsp],eax
  213db1:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  213db6:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  213dbb:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  213dbf:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  213dc3:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  213dc9:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213dd0:	00 00 
  213dd2:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  213dd8:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  213ddf:	00 00 
  213de1:	b1 01                	mov    cl,0x1
  213de3:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  213de5:	66 89 84 24 68 02 00 	mov    WORD PTR [rsp+0x268],ax
  213dec:	00 
  213ded:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  213df4:	00 00 
  213df6:	c5 f8 11 84 24 6a 02 	vmovups XMMWORD PTR [rsp+0x26a],xmm0
  213dfd:	00 00 
  213dff:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  213e06:	00 00 
  213e08:	c5 f8 11 84 24 78 02 	vmovups XMMWORD PTR [rsp+0x278],xmm0
  213e0f:	00 00 
  213e11:	88 8c 24 88 02 00 00 	mov    BYTE PTR [rsp+0x288],cl
  213e18:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  213e1b:	89 84 24 89 02 00 00 	mov    DWORD PTR [rsp+0x289],eax
  213e22:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  213e27:	66 89 84 24 8d 02 00 	mov    WORD PTR [rsp+0x28d],ax
  213e2e:	00 
  213e2f:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  213e33:	e9 4c d9 ff ff       	jmp    211784 <parseFormValue+0x264>
  213e38:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  213e3c:	c5 fd 6f 0d 5c ce fe 	vmovdqa ymm1,YMMWORD PTR [rip+0xfffffffffffece5c]        # 200ca0 <app_mask+0x68>
  213e43:	ff 
  213e44:	31 c9                	xor    ecx,ecx
  213e46:	c5 e1 ef db          	vpxor  xmm3,xmm3,xmm3
  213e4a:	c5 d9 ef e4          	vpxor  xmm4,xmm4,xmm4
  213e4e:	c5 e9 ef d2          	vpxor  xmm2,xmm2,xmm2
  213e52:	48 85 ff             	test   rdi,rdi
  213e55:	74 62                	je     213eb9 <parseFormValue+0x2999>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  213e57:	c4 e2 7d 32 6c 0a 0c 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0xc]
  213e5e:	c5 f5 73 f1 03       	vpsllq ymm1,ymm1,0x3
  213e63:	c4 e2 7d 59 35 bc cd 	vpbroadcastq ymm6,QWORD PTR [rip+0xfffffffffffecdbc]        # 200c28 <__unnamed_441+0x88>
  213e6a:	fe ff 
  213e6c:	c5 f5 d4 f6          	vpaddq ymm6,ymm1,ymm6
  213e70:	c4 e2 7d 59 3d 07 ce 	vpbroadcastq ymm7,QWORD PTR [rip+0xfffffffffffece07]        # 200c80 <app_mask+0x48>
  213e77:	fe ff 
  213e79:	c5 cd db f7          	vpand  ymm6,ymm6,ymm7
  213e7d:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  213e82:	c4 62 7d 32 44 0a 08 	vpmovzxbq ymm8,DWORD PTR [rdx+rcx*1+0x8]
  213e89:	c5 d5 eb d2          	vpor   ymm2,ymm5,ymm2
  213e8d:	c5 f5 db cf          	vpand  ymm1,ymm1,ymm7
  213e91:	c4 e2 bd 47 e9       	vpsllvq ymm5,ymm8,ymm1
  213e96:	c5 d5 eb e4          	vpor   ymm4,ymm5,ymm4
  213e9a:	c4 e2 7d 32 6c 0a 04 	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1+0x4]
  213ea1:	c4 e2 d5 47 ee       	vpsllvq ymm5,ymm5,ymm6
  213ea6:	c5 d5 eb db          	vpor   ymm3,ymm5,ymm3
  213eaa:	c4 e2 7d 32 2c 0a    	vpmovzxbq ymm5,DWORD PTR [rdx+rcx*1]
  213eb0:	c4 e2 d5 47 c9       	vpsllvq ymm1,ymm5,ymm1
  213eb5:	c5 f5 eb c0          	vpor   ymm0,ymm1,ymm0
  213eb9:	c5 e5 eb ca          	vpor   ymm1,ymm3,ymm2
  213ebd:	c5 fd eb c4          	vpor   ymm0,ymm0,ymm4
  213ec1:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213ec5:	c4 e3 7d 39 c1 01    	vextracti128 xmm1,ymm0,0x1
  213ecb:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213ecf:	c5 f9 70 c8 4e       	vpshufd xmm1,xmm0,0x4e
  213ed4:	c5 fd eb c1          	vpor   ymm0,ymm0,ymm1
  213ed8:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
  213edd:	48 39 d8             	cmp    rax,rbx
            for (bytes) |b, index| {
  213ee0:	74 29                	je     213f0b <parseFormValue+0x29eb>
  213ee2:	48 29 d8             	sub    rax,rbx
  213ee5:	48 01 da             	add    rdx,rbx
  213ee8:	48 c1 e3 03          	shl    rbx,0x3
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  213eec:	0f b6 3a             	movzx  edi,BYTE PTR [rdx]
  213eef:	89 de                	mov    esi,ebx
  213ef1:	40 80 e6 38          	and    sil,0x38
  213ef5:	c4 e2 c9 f7 f7       	shlx   rsi,rdi,rsi
  213efa:	48 09 f1             	or     rcx,rsi
            for (bytes) |b, index| {
  213efd:	48 83 c3 08          	add    rbx,0x8
  213f01:	48 83 c2 01          	add    rdx,0x1
  213f05:	48 83 c0 ff          	add    rax,0xffffffffffffffff
  213f09:	75 e1                	jne    213eec <parseFormValue+0x29cc>
  213f0b:	48 8d 7c 24 78       	lea    rdi,[rsp+0x78]
    const buf = try readAllocBytes(allocator, in_stream, size);
  213f10:	4c 89 fe             	mov    rsi,r15
  213f13:	4c 89 e2             	mov    rdx,r12
  213f16:	c5 f8 77             	vzeroupper 
  213f19:	e8 92 03 00 00       	call   2142b0 <readAllocBytes>
  213f1e:	0f b7 44 24 78       	movzx  eax,WORD PTR [rsp+0x78]
  213f23:	66 85 c0             	test   ax,ax
  213f26:	74 39                	je     213f61 <parseFormValue+0x2a41>
  213f28:	c5 f8 10 44 24 40    	vmovups xmm0,XMMWORD PTR [rsp+0x40]
  213f2e:	c5 fa 6f 4c 24 4e    	vmovdqu xmm1,XMMWORD PTR [rsp+0x4e]
  213f34:	c5 fa 7f 8c 24 9e 00 	vmovdqu XMMWORD PTR [rsp+0x9e],xmm1
  213f3b:	00 00 
  213f3d:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213f44:	00 00 
  213f46:	8b 4c 24 60          	mov    ecx,DWORD PTR [rsp+0x60]
  213f4a:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  213f4d:	0f b7 4c 24 64       	movzx  ecx,WORD PTR [rsp+0x64]
  213f52:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  213f57:	8a 4c 24 66          	mov    cl,BYTE PTR [rsp+0x66]
  213f5b:	88 4c 24 06          	mov    BYTE PTR [rsp+0x6],cl
  213f5f:	eb 65                	jmp    213fc6 <parseFormValue+0x2aa6>
  213f61:	c5 f8 10 84 24 80 00 	vmovups xmm0,XMMWORD PTR [rsp+0x80]
  213f68:	00 00 
  213f6a:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  213f71:	00 00 
    return FormValue{ .Block = buf };
  213f73:	c5 f8 11 44 24 1e    	vmovups XMMWORD PTR [rsp+0x1e],xmm0
  213f79:	48 8b 84 24 c0 00 00 	mov    rax,QWORD PTR [rsp+0xc0]
  213f80:	00 
  213f81:	48 89 44 24 2e       	mov    QWORD PTR [rsp+0x2e],rax
  213f86:	c6 44 24 08 01       	mov    BYTE PTR [rsp+0x8],0x1
  213f8b:	8b 44 24 71          	mov    eax,DWORD PTR [rsp+0x71]
  213f8f:	89 04 24             	mov    DWORD PTR [rsp],eax
  213f92:	0f b7 44 24 75       	movzx  eax,WORD PTR [rsp+0x75]
  213f97:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  213f9c:	8a 44 24 77          	mov    al,BYTE PTR [rsp+0x77]
  213fa0:	88 44 24 06          	mov    BYTE PTR [rsp+0x6],al
  213fa4:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  213faa:	c5 f8 29 84 24 90 00 	vmovaps XMMWORD PTR [rsp+0x90],xmm0
  213fb1:	00 00 
  213fb3:	c5 f8 10 44 24 26    	vmovups xmm0,XMMWORD PTR [rsp+0x26]
  213fb9:	c5 f8 11 84 24 9e 00 	vmovups XMMWORD PTR [rsp+0x9e],xmm0
  213fc0:	00 00 
  213fc2:	b1 01                	mov    cl,0x1
  213fc4:	31 c0                	xor    eax,eax
    return parseFormValueBlockLen(allocator, in_stream, block_len);
  213fc6:	66 89 84 24 b8 02 00 	mov    WORD PTR [rsp+0x2b8],ax
  213fcd:	00 
  213fce:	c5 f8 28 84 24 90 00 	vmovaps xmm0,XMMWORD PTR [rsp+0x90]
  213fd5:	00 00 
  213fd7:	c5 f8 11 84 24 ba 02 	vmovups XMMWORD PTR [rsp+0x2ba],xmm0
  213fde:	00 00 
  213fe0:	c5 f8 10 84 24 9e 00 	vmovups xmm0,XMMWORD PTR [rsp+0x9e]
  213fe7:	00 00 
  213fe9:	c5 f8 11 84 24 c8 02 	vmovups XMMWORD PTR [rsp+0x2c8],xmm0
  213ff0:	00 00 
  213ff2:	88 8c 24 d8 02 00 00 	mov    BYTE PTR [rsp+0x2d8],cl
  213ff9:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  213ffc:	89 84 24 d9 02 00 00 	mov    DWORD PTR [rsp+0x2d9],eax
  214003:	0f b7 44 24 04       	movzx  eax,WORD PTR [rsp+0x4]
  214008:	66 89 84 24 dd 02 00 	mov    WORD PTR [rsp+0x2dd],ax
  21400f:	00 
  214010:	8a 44 24 06          	mov    al,BYTE PTR [rsp+0x6]
  214014:	e9 d5 da ff ff       	jmp    211aee <parseFormValue+0x5ce>
  214019:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000214020 <Allocator_alignedRealloc.47>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  214020:	41 56                	push   r14
  214022:	53                   	push   rbx
  214023:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21402a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21402d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  214031:	48 85 c0             	test   rax,rax
  214034:	74 62                	je     214098 <Allocator_alignedRealloc.47+0x78>
        if (n == 0) {
  214036:	48 85 c9             	test   rcx,rcx
  214039:	0f 84 a9 00 00 00    	je     2140e8 <Allocator_alignedRealloc.47+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  21403f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  214042:	48 c1 e0 03          	shl    rax,0x3
  214046:	48 8d 04 80          	lea    rax,[rax+rax*4]
  21404a:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21404f:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  214054:	ba 28 00 00 00       	mov    edx,0x28
  214059:	48 89 c8             	mov    rax,rcx
  21405c:	48 f7 e2             	mul    rdx
  21405f:	0f 81 d0 00 00 00    	jno    214135 <Allocator_alignedRealloc.47+0x115>
  214065:	48 8d 0d 64 c7 fe ff 	lea    rcx,[rip+0xfffffffffffec764]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21406c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  214070:	0f 84 da 00 00 00    	je     214150 <Allocator_alignedRealloc.47+0x130>
  214076:	48 8b 05 53 23 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff2353]        # 2063d0 <__unnamed_73+0x10>
  21407d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  214081:	c5 f8 10 05 37 23 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff2337]        # 2063c0 <__unnamed_73>
  214088:	ff 
  214089:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21408d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  214094:	5b                   	pop    rbx
  214095:	41 5e                	pop    r14
  214097:	c3                   	ret    
        if (n == 0) {
  214098:	48 85 c9             	test   rcx,rcx
  21409b:	0f 84 fc 00 00 00    	je     21419d <Allocator_alignedRealloc.47+0x17d>
  2140a1:	ba 28 00 00 00       	mov    edx,0x28
  2140a6:	48 89 c8             	mov    rax,rcx
  2140a9:	48 f7 e2             	mul    rdx
  2140ac:	0f 81 0c 01 00 00    	jno    2141be <Allocator_alignedRealloc.47+0x19e>
  2140b2:	48 8d 0d 17 c7 fe ff 	lea    rcx,[rip+0xfffffffffffec717]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2140b9:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2140bd:	0f 84 16 01 00 00    	je     2141d9 <Allocator_alignedRealloc.47+0x1b9>
  2140c3:	0f b7 05 fc 22 ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff22fc]        # 2063c6 <__unnamed_73+0x6>
  2140ca:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2140cf:	8b 05 ed 22 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff22ed]        # 2063c2 <__unnamed_73+0x2>
  2140d5:	89 04 24             	mov    DWORD PTR [rsp],eax
  2140d8:	48 89 e0             	mov    rax,rsp
  2140db:	66 b9 05 00          	mov    cx,0x5
  2140df:	31 f6                	xor    esi,esi
  2140e1:	31 d2                	xor    edx,edx
  2140e3:	e9 9d 01 00 00       	jmp    214285 <Allocator_alignedRealloc.47+0x265>
        const bytes = @sliceToBytes(memory);
  2140e8:	48 c1 e0 03          	shl    rax,0x3
  2140ec:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  2140f0:	48 85 c0             	test   rax,rax
  2140f3:	74 1e                	je     214113 <Allocator_alignedRealloc.47+0xf3>
        const bytes = @sliceToBytes(memory);
  2140f5:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  2140f8:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  2140fc:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  214101:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  214106:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  21410b:	48 89 f7             	mov    rdi,rsi
  21410e:	48 89 c6             	mov    rsi,rax
  214111:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  214113:	48 8b 05 9e 22 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff229e]        # 2063b8 <__unnamed_74+0x10>
  21411a:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  21411e:	c5 f8 10 05 82 22 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff2282]        # 2063a8 <__unnamed_74>
  214125:	ff 
  214126:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21412a:	48 81 c4 88 00 00 00 	add    rsp,0x88
  214131:	5b                   	pop    rbx
  214132:	41 5e                	pop    r14
  214134:	c3                   	ret    
  214135:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  21413a:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  214141:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  214146:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21414a:	0f 85 26 ff ff ff    	jne    214076 <Allocator_alignedRealloc.47+0x56>
  214150:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  214154:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  214159:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21415e:	41 b8 08 00 00 00    	mov    r8d,0x8
  214164:	4c 89 f1             	mov    rcx,r14
  214167:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21416a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21416f:	66 85 c0             	test   ax,ax
  214172:	0f 84 94 00 00 00    	je     21420c <Allocator_alignedRealloc.47+0x1ec>
  214178:	66 89 03             	mov    WORD PTR [rbx],ax
  21417b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  214182:	00 
  214183:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  214187:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  21418d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  214192:	48 81 c4 88 00 00 00 	add    rsp,0x88
  214199:	5b                   	pop    rbx
  21419a:	41 5e                	pop    r14
  21419c:	c3                   	ret    
  21419d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  2141a0:	0f b7 0d 07 22 ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff2207]        # 2063ae <__unnamed_74+0x6>
  2141a7:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2141ac:	8b 0d f8 21 ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff21f8]        # 2063aa <__unnamed_74+0x2>
  2141b2:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2141b5:	31 c9                	xor    ecx,ecx
  2141b7:	31 d2                	xor    edx,edx
  2141b9:	e9 c7 00 00 00       	jmp    214285 <Allocator_alignedRealloc.47+0x265>
  2141be:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  2141c3:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  2141ca:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2141cf:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2141d3:	0f 85 ea fe ff ff    	jne    2140c3 <Allocator_alignedRealloc.47+0xa3>
  2141d9:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2141dd:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2141e2:	b9 08 00 00 00       	mov    ecx,0x8
  2141e7:	4c 89 f2             	mov    rdx,r14
  2141ea:	ff 16                	call   QWORD PTR [rsi]
  2141ec:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  2141f1:	66 85 c9             	test   cx,cx
  2141f4:	74 57                	je     21424d <Allocator_alignedRealloc.47+0x22d>
  2141f6:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  2141fb:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  214200:	48 89 e0             	mov    rax,rsp
  214203:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  214207:	89 14 24             	mov    DWORD PTR [rsp],edx
  21420a:	eb 79                	jmp    214285 <Allocator_alignedRealloc.47+0x265>
        assert(byte_slice.len == byte_count);
  21420c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  214211:	0f 85 91 00 00 00    	jne    2142a8 <Allocator_alignedRealloc.47+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  214217:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21421c:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  214223:	cc cc cc 
  214226:	4c 89 f2             	mov    rdx,r14
  214229:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  21422e:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  214233:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  214238:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21423c:	48 c1 ea 05          	shr    rdx,0x5
  214240:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  214244:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  214247:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21424b:	eb 4c                	jmp    214299 <Allocator_alignedRealloc.47+0x279>
        assert(byte_slice.len == byte_count);
  21424d:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  214252:	75 54                	jne    2142a8 <Allocator_alignedRealloc.47+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  214254:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  214259:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  214260:	cc cc cc 
  214263:	4c 89 f2             	mov    rdx,r14
  214266:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  21426b:	48 c1 ea 05          	shr    rdx,0x5
  21426f:	48 89 e0             	mov    rax,rsp
  214272:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  214276:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  214279:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21427e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  214283:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  214285:	66 89 0b             	mov    WORD PTR [rbx],cx
  214288:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21428c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  214290:	8b 00                	mov    eax,DWORD PTR [rax]
  214292:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  214295:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  214299:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  21429d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2142a4:	5b                   	pop    rbx
  2142a5:	41 5e                	pop    r14
  2142a7:	c3                   	ret    
            @panic("assertion failure");
  2142a8:	e8 03 5a ff ff       	call   209cb0 <panic>
  2142ad:	0f 1f 00             	nop    DWORD PTR [rax]

00000000002142b0 <readAllocBytes>:
fn readAllocBytes(allocator: *mem.Allocator, in_stream: var, size: usize) ![]u8 {
  2142b0:	55                   	push   rbp
  2142b1:	41 57                	push   r15
  2142b3:	41 56                	push   r14
  2142b5:	41 54                	push   r12
  2142b7:	53                   	push   rbx
  2142b8:	48 83 ec 70          	sub    rsp,0x70
  2142bc:	48 89 cb             	mov    rbx,rcx
  2142bf:	49 89 d4             	mov    r12,rdx
  2142c2:	49 89 f6             	mov    r14,rsi
  2142c5:	49 89 ff             	mov    r15,rdi
        if (n == 0) {
  2142c8:	48 85 db             	test   rbx,rbx
  2142cb:	74 32                	je     2142ff <readAllocBytes+0x4f>
  2142cd:	48 89 e7             	mov    rdi,rsp
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2142d0:	b9 01 00 00 00       	mov    ecx,0x1
  2142d5:	4c 89 f6             	mov    rsi,r14
  2142d8:	48 89 da             	mov    rdx,rbx
  2142db:	41 ff 16             	call   QWORD PTR [r14]
  2142de:	0f b7 04 24          	movzx  eax,WORD PTR [rsp]
  2142e2:	66 85 c0             	test   ax,ax
  2142e5:	74 1c                	je     214303 <readAllocBytes+0x53>
    const buf = try allocator.alloc(u8, size);
  2142e7:	66 41 89 07          	mov    WORD PTR [r15],ax
  2142eb:	48 8b 44 24 68       	mov    rax,QWORD PTR [rsp+0x68]
  2142f0:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  2142f4:	c5 f8 10 44 24 5a    	vmovups xmm0,XMMWORD PTR [rsp+0x5a]
  2142fa:	e9 d8 00 00 00       	jmp    2143d7 <readAllocBytes+0x127>
  2142ff:	31 c0                	xor    eax,eax
  214301:	eb 13                	jmp    214316 <readAllocBytes+0x66>
        assert(byte_slice.len == byte_count);
  214303:	48 39 5c 24 10       	cmp    QWORD PTR [rsp+0x10],rbx
    if (!ok) {
  214308:	0f 85 dc 00 00 00    	jne    2143ea <readAllocBytes+0x13a>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  21430e:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
  214313:	48 89 d8             	mov    rax,rbx
    const buf = try allocator.alloc(u8, size);
  214316:	48 89 4c 24 18       	mov    QWORD PTR [rsp+0x18],rcx
  21431b:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
  214320:	48 89 e7             	mov    rdi,rsp
  214323:	48 8d 54 24 18       	lea    rdx,[rsp+0x18]
            return self.readFn(self, buffer);
  214328:	4c 89 e6             	mov    rsi,r12
  21432b:	41 ff 14 24          	call   QWORD PTR [r12]
  21432f:	0f b7 2c 24          	movzx  ebp,WORD PTR [rsp]
    if ((try in_stream.read(buf)) < size) return error.EndOfFile;
  214333:	66 85 ed             	test   bp,bp
  214336:	74 39                	je     214371 <readAllocBytes+0xc1>
        const bytes = @sliceToBytes(memory);
  214338:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  21433d:	48 85 c0             	test   rax,rax
  214340:	74 1a                	je     21435c <readAllocBytes+0xac>
        const bytes = @sliceToBytes(memory);
  214342:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  214347:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  21434b:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  21434f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214354:	48 89 e6             	mov    rsi,rsp
  214357:	4c 89 f7             	mov    rdi,r14
  21435a:	ff d2                	call   rdx
  21435c:	66 41 89 2f          	mov    WORD PTR [r15],bp
  214360:	48 8b 44 24 52       	mov    rax,QWORD PTR [rsp+0x52]
  214365:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  214369:	c5 f8 10 44 24 44    	vmovups xmm0,XMMWORD PTR [rsp+0x44]
  21436f:	eb 66                	jmp    2143d7 <readAllocBytes+0x127>
  214371:	48 39 5c 24 08       	cmp    QWORD PTR [rsp+0x8],rbx
  214376:	73 3e                	jae    2143b6 <readAllocBytes+0x106>
        const bytes = @sliceToBytes(memory);
  214378:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
        if (bytes.len == 0) return;
  21437d:	48 85 c0             	test   rax,rax
  214380:	74 1a                	je     21439c <readAllocBytes+0xec>
        const bytes = @sliceToBytes(memory);
  214382:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  214387:	49 8b 56 10          	mov    rdx,QWORD PTR [r14+0x10]
  21438b:	48 89 0c 24          	mov    QWORD PTR [rsp],rcx
  21438f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214394:	48 89 e6             	mov    rsi,rsp
  214397:	4c 89 f7             	mov    rdi,r14
  21439a:	ff d2                	call   rdx
  21439c:	48 8b 05 8d 33 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff338d]        # 207730 <__unnamed_75+0x10>
  2143a3:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  2143a7:	c5 f8 10 05 71 33 ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff3371]        # 207720 <__unnamed_75>
  2143ae:	ff 
  2143af:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  2143b4:	eb 27                	jmp    2143dd <readAllocBytes+0x12d>
    return buf;
  2143b6:	c5 f8 10 44 24 18    	vmovups xmm0,XMMWORD PTR [rsp+0x18]
  2143bc:	c5 f8 11 44 24 34    	vmovups XMMWORD PTR [rsp+0x34],xmm0
  2143c2:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  2143c8:	48 8b 44 24 3c       	mov    rax,QWORD PTR [rsp+0x3c]
  2143cd:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  2143d1:	c5 f8 10 44 24 2e    	vmovups xmm0,XMMWORD PTR [rsp+0x2e]
  2143d7:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  2143dd:	48 83 c4 70          	add    rsp,0x70
  2143e1:	5b                   	pop    rbx
  2143e2:	41 5c                	pop    r12
  2143e4:	41 5e                	pop    r14
  2143e6:	41 5f                	pop    r15
  2143e8:	5d                   	pop    rbp
  2143e9:	c3                   	ret    
            @panic("assertion failure");
  2143ea:	e8 c1 58 ff ff       	call   209cb0 <panic>
  2143ef:	90                   	nop

00000000002143f0 <readStringRaw>:
            return Self{
  2143f0:	55                   	push   rbp
  2143f1:	41 57                	push   r15
  2143f3:	41 56                	push   r14
  2143f5:	41 55                	push   r13
  2143f7:	41 54                	push   r12
  2143f9:	53                   	push   rbx
  2143fa:	48 81 ec 98 00 00 00 	sub    rsp,0x98
  214401:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  214405:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
  21440b:	48 89 d3             	mov    rbx,rdx
  21440e:	49 89 f7             	mov    r15,rsi
  214411:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
  214416:	48 c7 44 24 50 00 00 	mov    QWORD PTR [rsp+0x50],0x0
  21441d:	00 00 
    var buf = ArrayList(u8).init(allocator);
  21441f:	4c 89 7c 24 58       	mov    QWORD PTR [rsp+0x58],r15
  214424:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
            try self.readNoEof(result[0..]);
  214429:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21442e:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  214435:	00 00 
  214437:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21443c:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
            return self.readFn(self, buffer);
  214441:	48 89 de             	mov    rsi,rbx
  214444:	ff 13                	call   QWORD PTR [rbx]
  214446:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21444b:	66 85 c9             	test   cx,cx
  21444e:	74 34                	je     214484 <readStringRaw+0x94>
  214450:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
        const byte = try in_stream.readByte();
  214455:	66 89 0a             	mov    WORD PTR [rdx],cx
  214458:	48 8b 84 24 90 00 00 	mov    rax,QWORD PTR [rsp+0x90]
  21445f:	00 
  214460:	48 89 42 10          	mov    QWORD PTR [rdx+0x10],rax
  214464:	c5 f8 10 84 24 82 00 	vmovups xmm0,XMMWORD PTR [rsp+0x82]
  21446b:	00 00 
  21446d:	c5 f8 11 42 02       	vmovups XMMWORD PTR [rdx+0x2],xmm0
  214472:	48 81 c4 98 00 00 00 	add    rsp,0x98
  214479:	5b                   	pop    rbx
  21447a:	41 5c                	pop    r12
  21447c:	41 5d                	pop    r13
  21447e:	41 5e                	pop    r14
  214480:	41 5f                	pop    r15
  214482:	5d                   	pop    rbp
  214483:	c3                   	ret    
  214484:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  214489:	31 ed                	xor    ebp,ebp
  21448b:	45 31 ed             	xor    r13d,r13d
  21448e:	66 90                	xchg   ax,ax
            if (amt_read < buf.len) return error.EndOfStream;
  214490:	48 3b 44 24 18       	cmp    rax,QWORD PTR [rsp+0x18]
  214495:	0f 82 b6 00 00 00    	jb     214551 <readStringRaw+0x161>
            return result[0];
  21449b:	44 8a 64 24 07       	mov    r12b,BYTE PTR [rsp+0x7]
        if (byte == 0) break;
  2144a0:	45 84 e4             	test   r12b,r12b
  2144a3:	0f 84 b1 00 00 00    	je     21455a <readStringRaw+0x16a>
            var better_capacity = self.items.len;
  2144a9:	48 8b 4c 24 48       	mov    rcx,QWORD PTR [rsp+0x48]
            if (better_capacity >= new_capacity) return;
  2144ae:	4c 39 e9             	cmp    rcx,r13
  2144b1:	77 53                	ja     214506 <readStringRaw+0x116>
  2144b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2144ba:	84 00 00 00 00 00 
                better_capacity += better_capacity / 2 + 8;
  2144c0:	48 89 c8             	mov    rax,rcx
  2144c3:	48 d1 e8             	shr    rax,1
  2144c6:	48 01 c1             	add    rcx,rax
  2144c9:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2144cd:	4c 39 e9             	cmp    rcx,r13
  2144d0:	76 ee                	jbe    2144c0 <readStringRaw+0xd0>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2144d2:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2144d7:	4c 89 fe             	mov    rsi,r15
  2144da:	48 8d 54 24 40       	lea    rdx,[rsp+0x40]
  2144df:	e8 bc 27 00 00       	call   216ca0 <Allocator_alignedRealloc.71>
  2144e4:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2144e9:	66 85 c0             	test   ax,ax
  2144ec:	0f 85 94 00 00 00    	jne    214586 <readStringRaw+0x196>
  2144f2:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  2144f7:	c5 f8 10 00          	vmovups xmm0,XMMWORD PTR [rax]
  2144fb:	c5 f8 29 44 24 40    	vmovaps XMMWORD PTR [rsp+0x40],xmm0
            const result = &self.items[self.len];
  214501:	48 8b 6c 24 40       	mov    rbp,QWORD PTR [rsp+0x40]
  214506:	4d 8d 75 01          	lea    r14,[r13+0x1]
            self.len = new_length;
  21450a:	4c 89 74 24 50       	mov    QWORD PTR [rsp+0x50],r14
            new_item_ptr.* = item;
  21450f:	46 88 64 2d 00       	mov    BYTE PTR [rbp+r13*1+0x0],r12b
            try self.readNoEof(result[0..]);
  214514:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  214519:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21451e:	48 c7 44 24 18 01 00 	mov    QWORD PTR [rsp+0x18],0x1
  214525:	00 00 
            return self.readFn(self, buffer);
  214527:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21452c:	48 89 de             	mov    rsi,rbx
  21452f:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  214534:	ff 13                	call   QWORD PTR [rbx]
  214536:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  21453b:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  214540:	4d 89 f5             	mov    r13,r14
            const amt_read = try self.read(buf);
  214543:	66 85 c9             	test   cx,cx
  214546:	0f 84 44 ff ff ff    	je     214490 <readStringRaw+0xa0>
  21454c:	e9 ff fe ff ff       	jmp    214450 <readStringRaw+0x60>
  214551:	66 b9 20 00          	mov    cx,0x20
  214555:	e9 f6 fe ff ff       	jmp    214450 <readStringRaw+0x60>
  21455a:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
    return buf.toSlice();
  21455f:	66 c7 02 00 00       	mov    WORD PTR [rdx],0x0
  214564:	0f b7 44 24 3e       	movzx  eax,WORD PTR [rsp+0x3e]
  214569:	66 89 42 06          	mov    WORD PTR [rdx+0x6],ax
            return self.items[0..self.len];
  21456d:	48 8b 44 24 40       	mov    rax,QWORD PTR [rsp+0x40]
  214572:	8b 4c 24 3a          	mov    ecx,DWORD PTR [rsp+0x3a]
  214576:	89 4a 02             	mov    DWORD PTR [rdx+0x2],ecx
  214579:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
  21457d:	4c 89 6a 10          	mov    QWORD PTR [rdx+0x10],r13
  214581:	e9 ec fe ff ff       	jmp    214472 <readStringRaw+0x82>
  214586:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
        try buf.append(byte);
  21458b:	66 89 01             	mov    WORD PTR [rcx],ax
  21458e:	48 8b 44 24 7a       	mov    rax,QWORD PTR [rsp+0x7a]
  214593:	48 89 41 10          	mov    QWORD PTR [rcx+0x10],rax
  214597:	c5 f8 10 44 24 6c    	vmovups xmm0,XMMWORD PTR [rsp+0x6c]
  21459d:	c5 f8 11 41 02       	vmovups XMMWORD PTR [rcx+0x2],xmm0
  2145a2:	e9 cb fe ff ff       	jmp    214472 <readStringRaw+0x82>
  2145a7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  2145ae:	00 00 

00000000002145b0 <Allocator_alignedRealloc.54>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  2145b0:	41 56                	push   r14
  2145b2:	53                   	push   rbx
  2145b3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  2145ba:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  2145bd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  2145c1:	48 85 c0             	test   rax,rax
  2145c4:	74 62                	je     214628 <Allocator_alignedRealloc.54+0x78>
        if (n == 0) {
  2145c6:	48 85 c9             	test   rcx,rcx
  2145c9:	0f 84 a9 00 00 00    	je     214678 <Allocator_alignedRealloc.54+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  2145cf:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  2145d2:	48 c1 e0 04          	shl    rax,0x4
  2145d6:	48 8d 04 40          	lea    rax,[rax+rax*2]
  2145da:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  2145df:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  2145e4:	ba 30 00 00 00       	mov    edx,0x30
  2145e9:	48 89 c8             	mov    rax,rcx
  2145ec:	48 f7 e2             	mul    rdx
  2145ef:	0f 81 d0 00 00 00    	jno    2146c5 <Allocator_alignedRealloc.54+0x115>
  2145f5:	48 8d 0d d4 c1 fe ff 	lea    rcx,[rip+0xfffffffffffec1d4]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2145fc:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  214600:	0f 84 da 00 00 00    	je     2146e0 <Allocator_alignedRealloc.54+0x130>
  214606:	48 8b 05 3b 1e ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff1e3b]        # 206448 <__unnamed_76+0x10>
  21460d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  214611:	c5 f8 10 05 1f 1e ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff1e1f]        # 206438 <__unnamed_76>
  214618:	ff 
  214619:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21461d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  214624:	5b                   	pop    rbx
  214625:	41 5e                	pop    r14
  214627:	c3                   	ret    
        if (n == 0) {
  214628:	48 85 c9             	test   rcx,rcx
  21462b:	0f 84 fc 00 00 00    	je     21472d <Allocator_alignedRealloc.54+0x17d>
  214631:	ba 30 00 00 00       	mov    edx,0x30
  214636:	48 89 c8             	mov    rax,rcx
  214639:	48 f7 e2             	mul    rdx
  21463c:	0f 81 0c 01 00 00    	jno    21474e <Allocator_alignedRealloc.54+0x19e>
  214642:	48 8d 0d 87 c1 fe ff 	lea    rcx,[rip+0xfffffffffffec187]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  214649:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21464d:	0f 84 16 01 00 00    	je     214769 <Allocator_alignedRealloc.54+0x1b9>
  214653:	0f b7 05 e4 1d ff ff 	movzx  eax,WORD PTR [rip+0xffffffffffff1de4]        # 20643e <__unnamed_76+0x6>
  21465a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21465f:	8b 05 d5 1d ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffff1dd5]        # 20643a <__unnamed_76+0x2>
  214665:	89 04 24             	mov    DWORD PTR [rsp],eax
  214668:	48 89 e0             	mov    rax,rsp
  21466b:	66 b9 05 00          	mov    cx,0x5
  21466f:	31 f6                	xor    esi,esi
  214671:	31 d2                	xor    edx,edx
  214673:	e9 9d 01 00 00       	jmp    214815 <Allocator_alignedRealloc.54+0x265>
        const bytes = @sliceToBytes(memory);
  214678:	48 c1 e0 04          	shl    rax,0x4
  21467c:	48 8d 04 40          	lea    rax,[rax+rax*2]
        if (bytes.len == 0) return;
  214680:	48 85 c0             	test   rax,rax
  214683:	74 1e                	je     2146a3 <Allocator_alignedRealloc.54+0xf3>
        const bytes = @sliceToBytes(memory);
  214685:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  214688:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  21468c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  214691:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  214696:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  21469b:	48 89 f7             	mov    rdi,rsi
  21469e:	48 89 c6             	mov    rsi,rax
  2146a1:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  2146a3:	48 8b 05 86 1d ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff1d86]        # 206430 <__unnamed_77+0x10>
  2146aa:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2146ae:	c5 f8 10 05 6a 1d ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff1d6a]        # 206420 <__unnamed_77>
  2146b5:	ff 
  2146b6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2146ba:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2146c1:	5b                   	pop    rbx
  2146c2:	41 5e                	pop    r14
  2146c4:	c3                   	ret    
  2146c5:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  2146ca:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  2146d1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2146d6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2146da:	0f 85 26 ff ff ff    	jne    214606 <Allocator_alignedRealloc.54+0x56>
  2146e0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2146e4:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  2146e9:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2146ee:	41 b8 02 00 00 00    	mov    r8d,0x2
  2146f4:	4c 89 f1             	mov    rcx,r14
  2146f7:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  2146fa:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  2146ff:	66 85 c0             	test   ax,ax
  214702:	0f 84 94 00 00 00    	je     21479c <Allocator_alignedRealloc.54+0x1ec>
  214708:	66 89 03             	mov    WORD PTR [rbx],ax
  21470b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  214712:	00 
  214713:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  214717:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  21471d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  214722:	48 81 c4 88 00 00 00 	add    rsp,0x88
  214729:	5b                   	pop    rbx
  21472a:	41 5e                	pop    r14
  21472c:	c3                   	ret    
  21472d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  214730:	0f b7 0d ef 1c ff ff 	movzx  ecx,WORD PTR [rip+0xffffffffffff1cef]        # 206426 <__unnamed_77+0x6>
  214737:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21473c:	8b 0d e0 1c ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffff1ce0]        # 206422 <__unnamed_77+0x2>
  214742:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  214745:	31 c9                	xor    ecx,ecx
  214747:	31 d2                	xor    edx,edx
  214749:	e9 c7 00 00 00       	jmp    214815 <Allocator_alignedRealloc.54+0x265>
  21474e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  214753:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  21475a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21475f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  214763:	0f 85 ea fe ff ff    	jne    214653 <Allocator_alignedRealloc.54+0xa3>
  214769:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21476d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  214772:	b9 02 00 00 00       	mov    ecx,0x2
  214777:	4c 89 f2             	mov    rdx,r14
  21477a:	ff 16                	call   QWORD PTR [rsi]
  21477c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  214781:	66 85 c9             	test   cx,cx
  214784:	74 57                	je     2147dd <Allocator_alignedRealloc.54+0x22d>
  214786:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  21478b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  214790:	48 89 e0             	mov    rax,rsp
  214793:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  214797:	89 14 24             	mov    DWORD PTR [rsp],edx
  21479a:	eb 79                	jmp    214815 <Allocator_alignedRealloc.54+0x265>
        assert(byte_slice.len == byte_count);
  21479c:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  2147a1:	0f 85 91 00 00 00    	jne    214838 <Allocator_alignedRealloc.54+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2147a7:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2147ac:	48 b9 ab aa aa aa aa 	movabs rcx,0xaaaaaaaaaaaaaaab
  2147b3:	aa aa aa 
  2147b6:	4c 89 f2             	mov    rdx,r14
  2147b9:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  2147be:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  2147c3:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  2147c8:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2147cc:	48 c1 ea 05          	shr    rdx,0x5
  2147d0:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  2147d4:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  2147d7:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  2147db:	eb 4c                	jmp    214829 <Allocator_alignedRealloc.54+0x279>
        assert(byte_slice.len == byte_count);
  2147dd:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  2147e2:	75 54                	jne    214838 <Allocator_alignedRealloc.54+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2147e4:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2147e9:	48 b8 ab aa aa aa aa 	movabs rax,0xaaaaaaaaaaaaaaab
  2147f0:	aa aa aa 
  2147f3:	4c 89 f2             	mov    rdx,r14
  2147f6:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  2147fb:	48 c1 ea 05          	shr    rdx,0x5
  2147ff:	48 89 e0             	mov    rax,rsp
  214802:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  214806:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  214809:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21480e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  214813:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  214815:	66 89 0b             	mov    WORD PTR [rbx],cx
  214818:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21481c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  214820:	8b 00                	mov    eax,DWORD PTR [rax]
  214822:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  214825:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  214829:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  21482d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  214834:	5b                   	pop    rbx
  214835:	41 5e                	pop    r14
  214837:	c3                   	ret    
            @panic("assertion failure");
  214838:	e8 73 54 ff ff       	call   209cb0 <panic>
  21483d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000214840 <getLineNumberInfo>:
fn getLineNumberInfo(st: *ElfStackTrace, compile_unit: *const CompileUnit, target_address: usize) !LineInfo {
  214840:	55                   	push   rbp
  214841:	41 57                	push   r15
  214843:	41 56                	push   r14
  214845:	41 55                	push   r13
  214847:	41 54                	push   r12
  214849:	53                   	push   rbx
  21484a:	48 81 ec 18 0b 00 00 	sub    rsp,0xb18
  214851:	49 89 cc             	mov    r12,rcx
  214854:	49 89 d6             	mov    r14,rdx
  214857:	49 89 f7             	mov    r15,rsi
  21485a:	48 89 fd             	mov    rbp,rdi
    const compile_unit_cwd = try compile_unit.die.getAttrString(st, DW.AT_comp_dir);
  21485d:	49 8b 46 08          	mov    rax,QWORD PTR [r14+0x8]
            return self.items[0..self.len];
  214861:	48 8b 48 20          	mov    rcx,QWORD PTR [rax+0x20]
        for (self.attrs.toSliceConst()) |*attr| {
  214865:	48 85 c9             	test   rcx,rcx
  214868:	74 19                	je     214883 <getLineNumberInfo+0x43>
  21486a:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  21486e:	31 d2                	xor    edx,edx
            if (attr.id == id) return &attr.value;
  214870:	48 83 38 1b          	cmp    QWORD PTR [rax],0x1b
  214874:	74 36                	je     2148ac <getLineNumberInfo+0x6c>
        for (self.attrs.toSliceConst()) |*attr| {
  214876:	48 83 c2 01          	add    rdx,0x1
  21487a:	48 83 c0 28          	add    rax,0x28
  21487e:	48 39 ca             	cmp    rdx,rcx
  214881:	72 ed                	jb     214870 <getLineNumberInfo+0x30>
        const form_value = self.getAttr(id) orelse return error.MissingDebugInfo;
  214883:	48 8b 05 76 1c ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffff1c76]        # 206500 <__unnamed_43+0x10>
  21488a:	48 89 84 24 7e 01 00 	mov    QWORD PTR [rsp+0x17e],rax
  214891:	00 
  214892:	c5 f8 10 05 58 1c ff 	vmovups xmm0,XMMWORD PTR [rip+0xffffffffffff1c58]        # 2064f2 <__unnamed_43+0x2>
  214899:	ff 
  21489a:	c5 f8 29 84 24 70 01 	vmovaps XMMWORD PTR [rsp+0x170],xmm0
  2148a1:	00 00 
  2148a3:	66 b8 24 00          	mov    ax,0x24
  2148a7:	e9 c5 00 00 00       	jmp    214971 <getLineNumberInfo+0x131>
  2148ac:	8a 48 20             	mov    cl,BYTE PTR [rax+0x20]
  2148af:	80 f9 0a             	cmp    cl,0xa
        return switch (form_value.*) {
  2148b2:	74 1e                	je     2148d2 <getLineNumberInfo+0x92>
  2148b4:	80 f9 09             	cmp    cl,0x9
  2148b7:	75 69                	jne    214922 <getLineNumberInfo+0xe2>
            FormValue.String => |value| value,
  2148b9:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  2148c0:	c5 f8 10 40 08       	vmovups xmm0,XMMWORD PTR [rax+0x8]
  2148c5:	c5 f8 11 44 24 10    	vmovups XMMWORD PTR [rsp+0x10],xmm0
  2148cb:	48 8d 5c 24 08       	lea    rbx,[rsp+0x8]
  2148d0:	eb 7d                	jmp    21494f <getLineNumberInfo+0x10f>
            FormValue.StrPtr => |offset| getString(st, offset),
  2148d2:	48 8b 70 08          	mov    rsi,QWORD PTR [rax+0x8]
    const pos = st.debug_str.offset + offset;
  2148d6:	49 8b 47 70          	mov    rax,QWORD PTR [r15+0x70]
    if (@maxValue(@typeOf(x)) > @maxValue(T) and x > @maxValue(T)) {
  2148da:	48 03 70 18          	add    rsi,QWORD PTR [rax+0x18]
  2148de:	78 4b                	js     21492b <getLineNumberInfo+0xeb>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  2148e0:	49 63 3f             	movsxd rdi,DWORD PTR [r15]
  2148e3:	31 db                	xor    ebx,ebx
  2148e5:	b8 08 00 00 00       	mov    eax,0x8
  2148ea:	31 d2                	xor    edx,edx
  2148ec:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2148ee:	48 89 c1             	mov    rcx,rax
  2148f1:	48 f7 d9             	neg    rcx
  2148f4:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2148fa:	48 0f 46 cb          	cmovbe rcx,rbx
  2148fe:	66 b8 02 00          	mov    ax,0x2
                if (err > 0) {
  214902:	48 83 f9 1d          	cmp    rcx,0x1d
  214906:	0f 87 44 02 00 00    	ja     214b50 <getLineNumberInfo+0x310>
  21490c:	48 8d 15 11 cc fe ff 	lea    rdx,[rip+0xfffffffffffecc11]        # 201524 <__unnamed_9+0x844>
  214913:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  214917:	48 01 d1             	add    rcx,rdx
  21491a:	ff e1                	jmp    rcx
  21491c:	66 b8 22 00          	mov    ax,0x22
  214920:	eb 0d                	jmp    21492f <getLineNumberInfo+0xef>
  214922:	48 8d 1d df 1b ff ff 	lea    rbx,[rip+0xffffffffffff1bdf]        # 206508 <__unnamed_26>
  214929:	eb 24                	jmp    21494f <getLineNumberInfo+0x10f>
  21492b:	66 b8 23 00          	mov    ax,0x23
    try st.self_exe_file.seekTo(pos);
  21492f:	66 89 44 24 20       	mov    WORD PTR [rsp+0x20],ax
  214934:	c5 f8 10 44 24 48    	vmovups xmm0,XMMWORD PTR [rsp+0x48]
  21493a:	c5 f8 11 44 24 22    	vmovups XMMWORD PTR [rsp+0x22],xmm0
  214940:	48 8b 44 24 56       	mov    rax,QWORD PTR [rsp+0x56]
  214945:	48 89 44 24 30       	mov    QWORD PTR [rsp+0x30],rax
  21494a:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
        return switch (form_value.*) {
  21494f:	0f b7 03             	movzx  eax,WORD PTR [rbx]
  214952:	48 8b 4b 10          	mov    rcx,QWORD PTR [rbx+0x10]
  214956:	48 89 8c 24 7e 01 00 	mov    QWORD PTR [rsp+0x17e],rcx
  21495d:	00 
  21495e:	c5 f8 10 43 02       	vmovups xmm0,XMMWORD PTR [rbx+0x2]
  214963:	c5 f8 29 84 24 70 01 	vmovaps XMMWORD PTR [rsp+0x170],xmm0
  21496a:	00 00 
    const compile_unit_cwd = try compile_unit.die.getAttrString(st, DW.AT_comp_dir);
  21496c:	66 85 c0             	test   ax,ax
  21496f:	74 35                	je     2149a6 <getLineNumberInfo+0x166>
  214971:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  214975:	c5 fe 6f 84 24 ca 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xaca]
  21497c:	00 00 
  21497e:	c5 fc 10 8c 24 d8 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xad8]
  214985:	00 00 
  214987:	c5 fc 11 4d 10       	vmovups YMMWORD PTR [rbp+0x10],ymm1
  21498c:	c5 fe 7f 45 02       	vmovdqu YMMWORD PTR [rbp+0x2],ymm0
  214991:	48 81 c4 18 0b 00 00 	add    rsp,0xb18
  214998:	5b                   	pop    rbx
  214999:	41 5c                	pop    r12
  21499b:	41 5d                	pop    r13
  21499d:	41 5e                	pop    r14
  21499f:	41 5f                	pop    r15
  2149a1:	5d                   	pop    rbp
  2149a2:	c5 f8 77             	vzeroupper 
  2149a5:	c3                   	ret    
  2149a6:	4c 89 a4 24 a0 00 00 	mov    QWORD PTR [rsp+0xa0],r12
  2149ad:	00 
  2149ae:	48 89 2c 24          	mov    QWORD PTR [rsp],rbp
  2149b2:	c5 fa 6f 84 24 76 01 	vmovdqu xmm0,XMMWORD PTR [rsp+0x176]
  2149b9:	00 00 
  2149bb:	c5 f9 7f 84 24 e0 01 	vmovdqa XMMWORD PTR [rsp+0x1e0],xmm0
  2149c2:	00 00 
    const debug_line_end = st.debug_line.offset + st.debug_line.size;
  2149c4:	49 8b 47 78          	mov    rax,QWORD PTR [r15+0x78]
  2149c8:	48 8b 58 18          	mov    rbx,QWORD PTR [rax+0x18]
  2149cc:	4c 8b 60 20          	mov    r12,QWORD PTR [rax+0x20]
    var in_file_stream = io.FileInStream.init(in_file);
  2149d0:	4c 89 7c 24 38       	mov    QWORD PTR [rsp+0x38],r15
  2149d5:	48 8d 05 54 bc ff ff 	lea    rax,[rip+0xffffffffffffbc54]        # 210630 <FileInStream_readFn>
  2149dc:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
    while (this_offset < debug_line_end) : (this_index += 1) {
  2149e1:	4d 85 e4             	test   r12,r12
  2149e4:	0f 84 44 01 00 00    	je     214b2e <getLineNumberInfo+0x2ee>
  2149ea:	49 01 dc             	add    r12,rbx
  2149ed:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  2149f4:	4c 89 7c 24 60       	mov    QWORD PTR [rsp+0x60],r15
  2149f9:	48 85 db             	test   rbx,rbx
  2149fc:	0f 88 66 01 00 00    	js     214b68 <getLineNumberInfo+0x328>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  214a02:	49 63 3f             	movsxd rdi,DWORD PTR [r15]
  214a05:	b8 08 00 00 00       	mov    eax,0x8
  214a0a:	31 d2                	xor    edx,edx
  214a0c:	48 89 de             	mov    rsi,rbx
  214a0f:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  214a11:	48 89 c1             	mov    rcx,rax
  214a14:	48 f7 d9             	neg    rcx
  214a17:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  214a1d:	b8 00 00 00 00       	mov    eax,0x0
  214a22:	48 0f 46 c8          	cmovbe rcx,rax
  214a26:	48 85 c9             	test   rcx,rcx
  214a29:	0f 85 46 01 00 00    	jne    214b75 <getLineNumberInfo+0x335>
            try self.readNoEof(bytes[0..]);
  214a2f:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214a34:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214a39:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  214a40:	00 00 
            return self.readFn(self, buffer);
  214a42:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214a47:	48 8d 6c 24 40       	lea    rbp,[rsp+0x40]
  214a4c:	48 89 ee             	mov    rsi,rbp
  214a4f:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  214a54:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214a58:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214a5d:	66 85 c0             	test   ax,ax
  214a60:	0f 85 e6 01 00 00    	jne    214c4c <getLineNumberInfo+0x40c>
  214a66:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  214a6b:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  214a70:	0f 82 e9 00 00 00    	jb     214b5f <getLineNumberInfo+0x31f>
  214a76:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  214a7b:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  214a80:	48 c1 e1 08          	shl    rcx,0x8
  214a84:	48 09 c1             	or     rcx,rax
  214a87:	0f b6 54 24 4a       	movzx  edx,BYTE PTR [rsp+0x4a]
  214a8c:	48 c1 e2 10          	shl    rdx,0x10
  214a90:	48 09 ca             	or     rdx,rcx
  214a93:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  214a98:	48 c1 e0 18          	shl    rax,0x18
  214a9c:	48 09 d0             	or     rax,rdx
    is_64.* = (first_32_bits == 0xffffffff);
  214a9f:	83 f8 ff             	cmp    eax,0xffffffff
    if (is_64.*) {
  214aa2:	74 3f                	je     214ae3 <getLineNumberInfo+0x2a3>
        if (first_32_bits >= 0xfffffff0) return error.InvalidDebugInfo;
  214aa4:	83 f8 ef             	cmp    eax,0xffffffef
  214aa7:	0f 87 9b 01 00 00    	ja     214c48 <getLineNumberInfo+0x408>
  214aad:	45 31 ff             	xor    r15d,r15d
        if (unit_length == 0) return error.MissingDebugInfo;
  214ab0:	48 85 c0             	test   rax,rax
  214ab3:	74 79                	je     214b2e <getLineNumberInfo+0x2ee>
        if (compile_unit.index != this_index) {
  214ab5:	49 83 c5 01          	add    r13,0x1
  214ab9:	4d 3b 6e 10          	cmp    r13,QWORD PTR [r14+0x10]
  214abd:	0f 84 22 01 00 00    	je     214be5 <getLineNumberInfo+0x3a5>
        const next_offset = unit_length + (if (is_64) usize(12) else usize(4));
  214ac3:	41 0f b6 cf          	movzx  ecx,r15b
  214ac7:	48 8d 0c cb          	lea    rcx,[rbx+rcx*8]
            this_offset += next_offset;
  214acb:	48 8d 1c 08          	lea    rbx,[rax+rcx*1]
  214acf:	48 83 c3 04          	add    rbx,0x4
    while (this_offset < debug_line_end) : (this_index += 1) {
  214ad3:	4c 39 e3             	cmp    rbx,r12
  214ad6:	4c 8b 7c 24 60       	mov    r15,QWORD PTR [rsp+0x60]
  214adb:	0f 82 18 ff ff ff    	jb     2149f9 <getLineNumberInfo+0x1b9>
  214ae1:	eb 4b                	jmp    214b2e <getLineNumberInfo+0x2ee>
            try self.readNoEof(bytes[0..]);
  214ae3:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214ae8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214aed:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  214af4:	00 00 
            return self.readFn(self, buffer);
  214af6:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214afb:	48 89 ee             	mov    rsi,rbp
  214afe:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  214b03:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214b07:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214b0c:	66 85 c0             	test   ax,ax
  214b0f:	0f 85 37 01 00 00    	jne    214c4c <getLineNumberInfo+0x40c>
  214b15:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  214b1a:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  214b1f:	72 3e                	jb     214b5f <getLineNumberInfo+0x31f>
  214b21:	48 8b 44 24 48       	mov    rax,QWORD PTR [rsp+0x48]
  214b26:	41 b7 01             	mov    r15b,0x1
        if (unit_length == 0) return error.MissingDebugInfo;
  214b29:	48 85 c0             	test   rax,rax
  214b2c:	75 87                	jne    214ab5 <getLineNumberInfo+0x275>
  214b2e:	c5 fc 10 05 42 1a ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff1a42]        # 206578 <__unnamed_78+0x10>
  214b35:	ff 
  214b36:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  214b3a:	c5 fc 11 40 10       	vmovups YMMWORD PTR [rax+0x10],ymm0
  214b3f:	c5 fe 6f 05 21 1a ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff1a21]        # 206568 <__unnamed_78>
  214b46:	ff 
  214b47:	c5 fe 7f 00          	vmovdqu YMMWORD PTR [rax],ymm0
  214b4b:	e9 41 fe ff ff       	jmp    214991 <getLineNumberInfo+0x151>
  214b50:	48 83 f9 4b          	cmp    rcx,0x4b
  214b54:	0f 85 d5 fd ff ff    	jne    21492f <getLineNumberInfo+0xef>
  214b5a:	e9 bd fd ff ff       	jmp    21491c <getLineNumberInfo+0xdc>
  214b5f:	66 b8 20 00          	mov    ax,0x20
  214b63:	e9 e4 00 00 00       	jmp    214c4c <getLineNumberInfo+0x40c>
  214b68:	66 b8 23 00          	mov    ax,0x23
  214b6c:	48 8b 34 24          	mov    rsi,QWORD PTR [rsp]
  214b70:	e9 0e 01 00 00       	jmp    214c83 <getLineNumberInfo+0x443>
  214b75:	66 b8 02 00          	mov    ax,0x2
  214b79:	48 8d 51 fa          	lea    rdx,[rcx-0x6]
  214b7d:	48 83 fa 17          	cmp    rdx,0x17
  214b81:	48 8b 34 24          	mov    rsi,QWORD PTR [rsp]
  214b85:	0f 87 e9 00 00 00    	ja     214c74 <getLineNumberInfo+0x434>
  214b8b:	48 8d 0d 0a ca fe ff 	lea    rcx,[rip+0xfffffffffffeca0a]        # 20159c <__unnamed_9+0x8bc>
  214b92:	48 63 14 91          	movsxd rdx,DWORD PTR [rcx+rdx*4]
  214b96:	48 01 ca             	add    rdx,rcx
  214b99:	ff e2                	jmp    rdx
  214b9b:	66 b8 22 00          	mov    ax,0x22
  214b9f:	e9 df 00 00 00       	jmp    214c83 <getLineNumberInfo+0x443>
  214ba4:	66 b8 1e 00          	mov    ax,0x1e
  214ba8:	e9 82 fd ff ff       	jmp    21492f <getLineNumberInfo+0xef>
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  214bad:	4c 89 bc 24 a0 01 00 	mov    QWORD PTR [rsp+0x1a0],r15
  214bb4:	00 
  214bb5:	48 8d 94 24 a8 01 00 	lea    rdx,[rsp+0x1a8]
  214bbc:	00 
  214bbd:	48 8d 05 6c ba ff ff 	lea    rax,[rip+0xffffffffffffba6c]        # 210630 <FileInStream_readFn>
  214bc4:	48 89 84 24 a8 01 00 	mov    QWORD PTR [rsp+0x1a8],rax
  214bcb:	00 
  214bcc:	49 8b b7 a0 00 00 00 	mov    rsi,QWORD PTR [r15+0xa0]
  214bd3:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  214bd8:	48 89 df             	mov    rdi,rbx
  214bdb:	e8 10 f8 ff ff       	call   2143f0 <readStringRaw>
  214be0:	e9 6a fd ff ff       	jmp    21494f <getLineNumberInfo+0x10f>
        const version = try in_stream.readInt(st.elf.endian, u16);
  214be5:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  214bea:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  214bed:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214bf2:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214bf7:	48 c7 44 24 10 02 00 	mov    QWORD PTR [rsp+0x10],0x2
  214bfe:	00 00 
  214c00:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214c05:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214c0a:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214c0f:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214c13:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214c18:	66 85 c0             	test   ax,ax
  214c1b:	75 10                	jne    214c2d <getLineNumberInfo+0x3ed>
  214c1d:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214c22:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214c26:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214c2b:	73 7a                	jae    214ca7 <getLineNumberInfo+0x467>
  214c2d:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  214c31:	66 89 01             	mov    WORD PTR [rcx],ax
  214c34:	c5 fe 6f 84 24 40 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa40]
  214c3b:	00 00 
  214c3d:	c5 fc 10 8c 24 4e 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa4e]
  214c44:	00 00 
  214c46:	eb 1d                	jmp    214c65 <getLineNumberInfo+0x425>
  214c48:	66 b8 25 00          	mov    ax,0x25
  214c4c:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const unit_length = try readInitialLength(@typeOf(in_stream.readFn).ReturnType.ErrorSet, in_stream, &is_64);
  214c50:	66 89 01             	mov    WORD PTR [rcx],ax
  214c53:	c5 fe 6f 84 24 6e 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa6e]
  214c5a:	00 00 
  214c5c:	c5 fc 10 8c 24 7c 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa7c]
  214c63:	00 00 
  214c65:	c5 fc 11 49 10       	vmovups YMMWORD PTR [rcx+0x10],ymm1
  214c6a:	c5 fe 7f 41 02       	vmovdqu YMMWORD PTR [rcx+0x2],ymm0
  214c6f:	e9 1d fd ff ff       	jmp    214991 <getLineNumberInfo+0x151>
  214c74:	48 83 f9 4b          	cmp    rcx,0x4b
  214c78:	75 09                	jne    214c83 <getLineNumberInfo+0x443>
  214c7a:	e9 1c ff ff ff       	jmp    214b9b <getLineNumberInfo+0x35b>
  214c7f:	66 b8 1e 00          	mov    ax,0x1e
        try in_file.seekTo(this_offset);
  214c83:	66 89 06             	mov    WORD PTR [rsi],ax
  214c86:	c5 fe 6f 84 24 9c 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa9c]
  214c8d:	00 00 
  214c8f:	c5 fc 10 8c 24 aa 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xaaa]
  214c96:	00 00 
  214c98:	c5 fc 11 4e 10       	vmovups YMMWORD PTR [rsi+0x10],ymm1
  214c9d:	c5 fe 7f 46 02       	vmovdqu YMMWORD PTR [rsi+0x2],ymm0
  214ca2:	e9 ea fc ff ff       	jmp    214991 <getLineNumberInfo+0x151>
  214ca7:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  214cac:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  214cb1:	89 ca                	mov    edx,ecx
  214cb3:	c1 e2 08             	shl    edx,0x8
  214cb6:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  214cb8:	c1 e0 08             	shl    eax,0x8
  214cbb:	09 c8                	or     eax,ecx
    switch (endian) {
  214cbd:	f6 c3 01             	test   bl,0x1
  214cc0:	66 0f 45 c2          	cmovne ax,dx
        if (version != 2 and version != 4) return error.InvalidDebugInfo;
  214cc4:	44 0f b7 e0          	movzx  r12d,ax
  214cc8:	41 83 fc 02          	cmp    r12d,0x2
  214ccc:	48 8b 2c 24          	mov    rbp,QWORD PTR [rsp]
  214cd0:	74 0a                	je     214cdc <getLineNumberInfo+0x49c>
  214cd2:	41 83 fc 04          	cmp    r12d,0x4
  214cd6:	0f 85 ac 00 00 00    	jne    214d88 <getLineNumberInfo+0x548>
  214cdc:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  214ce1:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
        const prologue_length = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  214ce4:	45 84 ff             	test   r15b,r15b
  214ce7:	74 44                	je     214d2d <getLineNumberInfo+0x4ed>
  214ce9:	0f b6 d3             	movzx  edx,bl
  214cec:	48 8d bc 24 90 01 00 	lea    rdi,[rsp+0x190]
  214cf3:	00 
  214cf4:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
  214cf9:	48 89 de             	mov    rsi,rbx
  214cfc:	e8 ef b6 ff ff       	call   2103f0 <InStream(ReadError)_readInt.33>
  214d01:	0f b7 84 24 90 01 00 	movzx  eax,WORD PTR [rsp+0x190]
  214d08:	00 
  214d09:	66 85 c0             	test   ax,ax
  214d0c:	0f 84 95 00 00 00    	je     214da7 <getLineNumberInfo+0x567>
  214d12:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  214d16:	c5 fe 6f 84 24 12 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xa12]
  214d1d:	00 00 
  214d1f:	c5 fc 10 8c 24 20 0a 	vmovups ymm1,YMMWORD PTR [rsp+0xa20]
  214d26:	00 00 
  214d28:	e9 5a fc ff ff       	jmp    214987 <getLineNumberInfo+0x147>
            try self.readNoEof(bytes[0..]);
  214d2d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214d32:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214d37:	48 c7 44 24 10 04 00 	mov    QWORD PTR [rsp+0x10],0x4
  214d3e:	00 00 
  214d40:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214d45:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214d4a:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214d4f:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214d53:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214d58:	66 85 c0             	test   ax,ax
  214d5b:	75 10                	jne    214d6d <getLineNumberInfo+0x52d>
  214d5d:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214d62:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214d66:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214d6b:	73 44                	jae    214db1 <getLineNumberInfo+0x571>
  214d6d:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  214d71:	c5 fe 6f 84 24 e4 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x9e4]
  214d78:	00 00 
  214d7a:	c5 fc 10 8c 24 f2 09 	vmovups ymm1,YMMWORD PTR [rsp+0x9f2]
  214d81:	00 00 
  214d83:	e9 ff fb ff ff       	jmp    214987 <getLineNumberInfo+0x147>
        if (version != 2 and version != 4) return error.InvalidDebugInfo;
  214d88:	c5 fc 10 05 b8 17 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff17b8]        # 206548 <__unnamed_79+0x10>
  214d8f:	ff 
  214d90:	c5 fc 11 45 10       	vmovups YMMWORD PTR [rbp+0x10],ymm0
  214d95:	c5 fe 6f 05 9b 17 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff179b]        # 206538 <__unnamed_79>
  214d9c:	ff 
  214d9d:	c5 fe 7f 45 00       	vmovdqu YMMWORD PTR [rbp+0x0],ymm0
  214da2:	e9 ea fb ff ff       	jmp    214991 <getLineNumberInfo+0x151>
        const prologue_length = if (is_64) try in_stream.readInt(st.elf.endian, u64) else try in_stream.readInt(st.elf.endian, u32);
  214da7:	4c 8b b4 24 98 01 00 	mov    r14,QWORD PTR [rsp+0x198]
  214dae:	00 
  214daf:	eb 4f                	jmp    214e00 <getLineNumberInfo+0x5c0>
  214db1:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  214db6:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  214dbb:	f6 c3 01             	test   bl,0x1
  214dbe:	74 1b                	je     214ddb <getLineNumberInfo+0x59b>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  214dc0:	c1 e1 08             	shl    ecx,0x8
  214dc3:	09 c1                	or     ecx,eax
  214dc5:	0f b6 54 24 4a       	movzx  edx,BYTE PTR [rsp+0x4a]
  214dca:	c1 e2 10             	shl    edx,0x10
  214dcd:	09 ca                	or     edx,ecx
  214dcf:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  214dd4:	c1 e0 18             	shl    eax,0x18
  214dd7:	09 d0                	or     eax,edx
  214dd9:	eb 19                	jmp    214df4 <getLineNumberInfo+0x5b4>
                result = (result << 8) | b;
  214ddb:	c1 e0 08             	shl    eax,0x8
  214dde:	09 c8                	or     eax,ecx
  214de0:	c1 e0 08             	shl    eax,0x8
  214de3:	0f b6 4c 24 4a       	movzx  ecx,BYTE PTR [rsp+0x4a]
  214de8:	09 c1                	or     ecx,eax
  214dea:	c1 e1 08             	shl    ecx,0x8
  214ded:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  214df2:	09 c8                	or     eax,ecx
  214df4:	41 89 c6             	mov    r14d,eax
  214df7:	48 8b 2c 24          	mov    rbp,QWORD PTR [rsp]
  214dfb:	48 8d 5c 24 40       	lea    rbx,[rsp+0x40]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  214e00:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  214e05:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  214e08:	45 31 c0             	xor    r8d,r8d
  214e0b:	b8 08 00 00 00       	mov    eax,0x8
  214e10:	be 00 00 00 00       	mov    esi,0x0
  214e15:	ba 01 00 00 00       	mov    edx,0x1
  214e1a:	0f 05                	syscall 
  214e1c:	49 89 c5             	mov    r13,rax
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  214e1f:	4c 89 e9             	mov    rcx,r13
  214e22:	48 f7 d9             	neg    rcx
  214e25:	49 81 fd 00 f0 ff ff 	cmp    r13,0xfffffffffffff000
  214e2c:	49 0f 46 c8          	cmovbe rcx,r8
                if (err > 0) {
  214e30:	48 83 f9 1d          	cmp    rcx,0x1d
  214e34:	77 1a                	ja     214e50 <getLineNumberInfo+0x610>
  214e36:	66 b8 1e 00          	mov    ax,0x1e
  214e3a:	48 8d 15 bb c7 fe ff 	lea    rdx,[rip+0xfffffffffffec7bb]        # 2015fc <__unnamed_9+0x91c>
  214e41:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  214e45:	48 01 d1             	add    rcx,rdx
  214e48:	ff e1                	jmp    rcx
  214e4a:	66 b8 22 00          	mov    ax,0x22
  214e4e:	eb 0a                	jmp    214e5a <getLineNumberInfo+0x61a>
  214e50:	48 83 f9 4b          	cmp    rcx,0x4b
  214e54:	74 f4                	je     214e4a <getLineNumberInfo+0x60a>
  214e56:	66 b8 02 00          	mov    ax,0x2
        const prog_start_offset = (try in_file.getPos()) + prologue_length;
  214e5a:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  214e5e:	c5 fe 6f 84 24 b6 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x9b6]
  214e65:	00 00 
  214e67:	c5 fc 10 8c 24 c4 09 	vmovups ymm1,YMMWORD PTR [rsp+0x9c4]
  214e6e:	00 00 
  214e70:	e9 12 fb ff ff       	jmp    214987 <getLineNumberInfo+0x147>
            try self.readNoEof(result[0..]);
  214e75:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214e7a:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214e7f:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214e86:	00 00 
  214e88:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214e8d:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214e92:	48 89 de             	mov    rsi,rbx
  214e95:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214e99:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214e9e:	66 85 c0             	test   ax,ax
  214ea1:	75 10                	jne    214eb3 <getLineNumberInfo+0x673>
  214ea3:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214ea8:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214eac:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214eb1:	73 1e                	jae    214ed1 <getLineNumberInfo+0x691>
  214eb3:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const minimum_instruction_length = try in_stream.readByte();
  214eb7:	66 89 01             	mov    WORD PTR [rcx],ax
  214eba:	c5 fe 6f 84 24 88 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x988]
  214ec1:	00 00 
  214ec3:	c5 fc 10 8c 24 96 09 	vmovups ymm1,YMMWORD PTR [rsp+0x996]
  214eca:	00 00 
  214ecc:	e9 94 fd ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
            return result[0];
  214ed1:	44 0f b6 7c 24 48    	movzx  r15d,BYTE PTR [rsp+0x48]
  214ed7:	4d 85 ff             	test   r15,r15
        if (minimum_instruction_length == 0) return error.InvalidDebugInfo;
  214eda:	0f 84 62 15 00 00    	je     216442 <getLineNumberInfo+0x1c02>
        if (version >= 4) {
  214ee0:	41 83 fc 04          	cmp    r12d,0x4
  214ee4:	72 5e                	jb     214f44 <getLineNumberInfo+0x704>
            try self.readNoEof(result[0..]);
  214ee6:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214eeb:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214ef0:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214ef7:	00 00 
  214ef9:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214efe:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214f03:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214f08:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214f0c:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214f11:	66 85 c0             	test   ax,ax
  214f14:	75 10                	jne    214f26 <getLineNumberInfo+0x6e6>
  214f16:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214f1b:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214f1f:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214f24:	73 1e                	jae    214f44 <getLineNumberInfo+0x704>
  214f26:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            _ = try in_stream.readByte();
  214f2a:	66 89 01             	mov    WORD PTR [rcx],ax
  214f2d:	c5 fe 6f 84 24 5a 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x95a]
  214f34:	00 00 
  214f36:	c5 fc 10 8c 24 68 09 	vmovups ymm1,YMMWORD PTR [rsp+0x968]
  214f3d:	00 00 
  214f3f:	e9 21 fd ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
            try self.readNoEof(result[0..]);
  214f44:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214f49:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214f4e:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214f55:	00 00 
  214f57:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214f5c:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214f61:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214f66:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214f6a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214f6f:	66 85 c0             	test   ax,ax
  214f72:	75 10                	jne    214f84 <getLineNumberInfo+0x744>
  214f74:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214f79:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214f7d:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214f82:	73 1e                	jae    214fa2 <getLineNumberInfo+0x762>
  214f84:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const default_is_stmt = (try in_stream.readByte()) != 0;
  214f88:	66 89 01             	mov    WORD PTR [rcx],ax
  214f8b:	c5 fe 6f 84 24 2c 09 	vmovdqu ymm0,YMMWORD PTR [rsp+0x92c]
  214f92:	00 00 
  214f94:	c5 fc 10 8c 24 3a 09 	vmovups ymm1,YMMWORD PTR [rsp+0x93a]
  214f9b:	00 00 
  214f9d:	e9 c3 fc ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
            return result[0];
  214fa2:	40 8a 6c 24 48       	mov    bpl,BYTE PTR [rsp+0x48]
            try self.readNoEof(result[0..]);
  214fa7:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  214fac:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  214fb1:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  214fb8:	00 00 
  214fba:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  214fbf:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  214fc4:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  214fc9:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  214fcd:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  214fd2:	66 85 c0             	test   ax,ax
  214fd5:	75 10                	jne    214fe7 <getLineNumberInfo+0x7a7>
  214fd7:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  214fdc:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  214fe0:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  214fe5:	73 1e                	jae    215005 <getLineNumberInfo+0x7c5>
  214fe7:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const line_base = try in_stream.readByteSigned();
  214feb:	66 89 01             	mov    WORD PTR [rcx],ax
  214fee:	c5 fe 6f 84 24 fe 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8fe]
  214ff5:	00 00 
  214ff7:	c5 fc 10 8c 24 0c 09 	vmovups ymm1,YMMWORD PTR [rsp+0x90c]
  214ffe:	00 00 
  215000:	e9 60 fc ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
            return result[0];
  215005:	48 0f be 44 24 48    	movsx  rax,BYTE PTR [rsp+0x48]
            try self.readNoEof(result[0..]);
  21500b:	48 89 84 24 68 01 00 	mov    QWORD PTR [rsp+0x168],rax
  215012:	00 
  215013:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215018:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21501d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215024:	00 00 
  215026:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21502b:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  215030:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215035:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215039:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21503e:	66 85 c0             	test   ax,ax
  215041:	75 10                	jne    215053 <getLineNumberInfo+0x813>
  215043:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215048:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  21504c:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  215051:	73 1e                	jae    215071 <getLineNumberInfo+0x831>
  215053:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const line_range = try in_stream.readByte();
  215057:	66 89 01             	mov    WORD PTR [rcx],ax
  21505a:	c5 fe 6f 84 24 d0 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8d0]
  215061:	00 00 
  215063:	c5 fc 10 8c 24 de 08 	vmovups ymm1,YMMWORD PTR [rsp+0x8de]
  21506a:	00 00 
  21506c:	e9 f4 fb ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
            return result[0];
  215071:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
  215075:	88 44 24 5f          	mov    BYTE PTR [rsp+0x5f],al
        if (line_range == 0) return error.InvalidDebugInfo;
  215079:	84 c0                	test   al,al
  21507b:	0f 84 c1 13 00 00    	je     216442 <getLineNumberInfo+0x1c02>
            try self.readNoEof(result[0..]);
  215081:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215086:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21508b:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215092:	00 00 
  215094:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  215099:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  21509e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2150a3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2150a7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2150ac:	66 85 c0             	test   ax,ax
  2150af:	75 10                	jne    2150c1 <getLineNumberInfo+0x881>
  2150b1:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2150b6:	66 b8 20 00          	mov    ax,0x20
            if (amt_read < buf.len) return error.EndOfStream;
  2150ba:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  2150bf:	73 1e                	jae    2150df <getLineNumberInfo+0x89f>
  2150c1:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        const opcode_base = try in_stream.readByte();
  2150c5:	66 89 01             	mov    WORD PTR [rcx],ax
  2150c8:	c5 fe 6f 84 24 a2 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x8a2]
  2150cf:	00 00 
  2150d1:	c5 fc 10 8c 24 b0 08 	vmovups ymm1,YMMWORD PTR [rsp+0x8b0]
  2150d8:	00 00 
  2150da:	e9 86 fb ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
            return result[0];
  2150df:	8a 4c 24 48          	mov    cl,BYTE PTR [rsp+0x48]
  2150e3:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  2150e8:	48 8b 80 a0 00 00 00 	mov    rax,QWORD PTR [rax+0xa0]
  2150ef:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  2150f4:	88 4c 24 5e          	mov    BYTE PTR [rsp+0x5e],cl
        const standard_opcode_lengths = try st.allocator().alloc(u8, opcode_base - 1);
  2150f8:	89 c8                	mov    eax,ecx
  2150fa:	04 ff                	add    al,0xff
        if (n == 0) {
  2150fc:	74 48                	je     215146 <getLineNumberInfo+0x906>
  2150fe:	0f b6 d0             	movzx  edx,al
  215101:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  215106:	b9 01 00 00 00       	mov    ecx,0x1
  21510b:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  215110:	48 89 94 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rdx
  215117:	00 
  215118:	ff 16                	call   QWORD PTR [rsi]
  21511a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21511f:	66 85 c0             	test   ax,ax
  215122:	0f 84 91 00 00 00    	je     2151b9 <getLineNumberInfo+0x979>
  215128:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  21512c:	66 89 01             	mov    WORD PTR [rcx],ax
  21512f:	c5 fe 6f 84 24 74 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x874]
  215136:	00 00 
  215138:	c5 fc 10 8c 24 82 08 	vmovups ymm1,YMMWORD PTR [rsp+0x882]
  21513f:	00 00 
  215141:	e9 1f fb ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  215146:	31 c0                	xor    eax,eax
  215148:	48 89 84 24 98 00 00 	mov    QWORD PTR [rsp+0x98],rax
  21514f:	00 
            return Self{
  215150:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  215154:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  21515b:	00 00 
  21515d:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x0
  215164:	00 00 00 00 00 
  215169:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
        var include_directories = ArrayList([]u8).init(st.allocator());
  21516e:	48 89 b4 24 c8 00 00 	mov    QWORD PTR [rsp+0xc8],rsi
  215175:	00 
  215176:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21517b:	48 8d 94 24 b0 00 00 	lea    rdx,[rsp+0xb0]
  215182:	00 
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  215183:	b9 08 00 00 00       	mov    ecx,0x8
  215188:	e8 d3 23 00 00       	call   217560 <Allocator_alignedRealloc.76>
  21518d:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215192:	66 85 c0             	test   ax,ax
  215195:	0f 84 bd 00 00 00    	je     215258 <getLineNumberInfo+0xa18>
  21519b:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try include_directories.append(compile_unit_cwd);
  21519f:	66 89 01             	mov    WORD PTR [rcx],ax
  2151a2:	c5 fe 6f 84 24 18 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x818]
  2151a9:	00 00 
  2151ab:	c5 fc 10 8c 24 26 08 	vmovups ymm1,YMMWORD PTR [rsp+0x826]
  2151b2:	00 00 
  2151b4:	e9 ac fa ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
        assert(byte_slice.len == byte_count);
  2151b9:	48 8b 84 24 98 00 00 	mov    rax,QWORD PTR [rsp+0x98]
  2151c0:	00 
  2151c1:	48 39 44 24 30       	cmp    QWORD PTR [rsp+0x30],rax
    if (!ok) {
  2151c6:	0f 85 7d 16 00 00    	jne    216849 <getLineNumberInfo+0x2009>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2151cc:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  2151d1:	48 89 84 24 d8 00 00 	mov    QWORD PTR [rsp+0xd8],rax
  2151d8:	00 
  2151d9:	45 31 e4             	xor    r12d,r12d
  2151dc:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
            try self.readNoEof(result[0..]);
  2151e1:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2151e6:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2151eb:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2151f2:	00 00 
            return self.readFn(self, buffer);
  2151f4:	48 89 df             	mov    rdi,rbx
  2151f7:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2151fc:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  215201:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215205:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21520a:	66 85 c0             	test   ax,ax
  21520d:	0f 85 cf 00 00 00    	jne    2152e2 <getLineNumberInfo+0xaa2>
  215213:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  215218:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  21521d:	0f 82 bb 00 00 00    	jb     2152de <getLineNumberInfo+0xa9e>
            return result[0];
  215223:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                standard_opcode_lengths[i] = try in_stream.readByte();
  215228:	48 8b 8c 24 d8 00 00 	mov    rcx,QWORD PTR [rsp+0xd8]
  21522f:	00 
  215230:	42 88 04 21          	mov    BYTE PTR [rcx+r12*1],al
            while (i < opcode_base - 1) : (i += 1) {
  215234:	49 83 c4 01          	add    r12,0x1
  215238:	4c 3b a4 24 98 00 00 	cmp    r12,QWORD PTR [rsp+0x98]
  21523f:	00 
  215240:	72 9f                	jb     2151e1 <getLineNumberInfo+0x9a1>
  215242:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  215247:	48 8b 80 a0 00 00 00 	mov    rax,QWORD PTR [rax+0xa0]
  21524e:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  215253:	e9 f8 fe ff ff       	jmp    215150 <getLineNumberInfo+0x910>
  215258:	c5 f8 10 44 24 28    	vmovups xmm0,XMMWORD PTR [rsp+0x28]
  21525e:	c5 f8 29 84 24 b0 00 	vmovaps XMMWORD PTR [rsp+0xb0],xmm0
  215265:	00 00 
            const result = &self.items[self.len];
  215267:	4c 8b a4 24 b0 00 00 	mov    r12,QWORD PTR [rsp+0xb0]
  21526e:	00 
            self.len = new_length;
  21526f:	48 c7 84 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],0x1
  215276:	00 01 00 00 00 
            new_item_ptr.* = item;
  21527b:	c5 f9 6f 84 24 e0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1e0]
  215282:	00 00 
  215284:	c4 c1 7a 7f 04 24    	vmovdqu XMMWORD PTR [r12],xmm0
  21528a:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  21528f:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215294:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  215299:	48 8d 0d 90 b3 ff ff 	lea    rcx,[rip+0xffffffffffffb390]        # 210630 <FileInStream_readFn>
  2152a0:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  2152a5:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
  2152ac:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  2152b1:	e8 3a f1 ff ff       	call   2143f0 <readStringRaw>
  2152b6:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const dir = try st.readString();
  2152bb:	66 85 c0             	test   ax,ax
  2152be:	74 40                	je     215300 <getLineNumberInfo+0xac0>
  2152c0:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  2152c4:	66 89 01             	mov    WORD PTR [rcx],ax
  2152c7:	c5 fe 6f 84 24 ea 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x7ea]
  2152ce:	00 00 
  2152d0:	c5 fc 10 8c 24 f8 07 	vmovups ymm1,YMMWORD PTR [rsp+0x7f8]
  2152d7:	00 00 
  2152d9:	e9 87 f9 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  2152de:	66 b8 20 00          	mov    ax,0x20
  2152e2:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                standard_opcode_lengths[i] = try in_stream.readByte();
  2152e6:	66 89 01             	mov    WORD PTR [rcx],ax
  2152e9:	c5 fe 6f 84 24 46 08 	vmovdqu ymm0,YMMWORD PTR [rsp+0x846]
  2152f0:	00 00 
  2152f2:	c5 fc 10 8c 24 54 08 	vmovups ymm1,YMMWORD PTR [rsp+0x854]
  2152f9:	00 00 
  2152fb:	e9 65 f9 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  215300:	4d 01 f5             	add    r13,r14
  215303:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  215309:	c5 f9 7f 84 24 50 01 	vmovdqa XMMWORD PTR [rsp+0x150],xmm0
  215310:	00 00 
  215312:	41 be 01 00 00 00    	mov    r14d,0x1
            if (dir.len == 0) break;
  215318:	c5 f9 6f 84 24 50 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x150]
  21531f:	00 00 
  215321:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  215327:	48 85 c0             	test   rax,rax
  21532a:	0f 84 ce 00 00 00    	je     2153fe <getLineNumberInfo+0xbbe>
            var better_capacity = self.items.len;
  215330:	48 8b 8c 24 b8 00 00 	mov    rcx,QWORD PTR [rsp+0xb8]
  215337:	00 
            if (better_capacity >= new_capacity) return;
  215338:	4c 39 f1             	cmp    rcx,r14
  21533b:	77 51                	ja     21538e <getLineNumberInfo+0xb4e>
                better_capacity += better_capacity / 2 + 8;
  21533d:	48 89 c8             	mov    rax,rcx
  215340:	48 d1 e8             	shr    rax,1
  215343:	48 01 c1             	add    rcx,rax
  215346:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  21534a:	4c 39 f1             	cmp    rcx,r14
  21534d:	76 ee                	jbe    21533d <getLineNumberInfo+0xafd>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  21534f:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  215354:	48 8b 74 24 68       	mov    rsi,QWORD PTR [rsp+0x68]
  215359:	48 8d 94 24 b0 00 00 	lea    rdx,[rsp+0xb0]
  215360:	00 
  215361:	e8 fa 21 00 00       	call   217560 <Allocator_alignedRealloc.76>
  215366:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21536b:	66 85 c0             	test   ax,ax
  21536e:	0f 85 94 01 00 00    	jne    215508 <getLineNumberInfo+0xcc8>
  215374:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  215379:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  21537d:	c5 f9 7f 84 24 b0 00 	vmovdqa XMMWORD PTR [rsp+0xb0],xmm0
  215384:	00 00 
            const result = &self.items[self.len];
  215386:	4c 8b a4 24 b0 00 00 	mov    r12,QWORD PTR [rsp+0xb0]
  21538d:	00 
  21538e:	49 8d 5e 01          	lea    rbx,[r14+0x1]
  215392:	49 c1 e6 04          	shl    r14,0x4
            self.len = new_length;
  215396:	48 89 9c 24 c0 00 00 	mov    QWORD PTR [rsp+0xc0],rbx
  21539d:	00 
            new_item_ptr.* = item;
  21539e:	c5 f8 28 84 24 50 01 	vmovaps xmm0,XMMWORD PTR [rsp+0x150]
  2153a5:	00 00 
  2153a7:	c4 81 78 11 04 34    	vmovups XMMWORD PTR [r12+r14*1],xmm0
  2153ad:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  2153b2:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2153b7:	48 8d 0d 72 b2 ff ff 	lea    rcx,[rip+0xffffffffffffb272]        # 210630 <FileInStream_readFn>
  2153be:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  2153c3:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  2153ca:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2153cf:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2153d4:	e8 17 f0 ff ff       	call   2143f0 <readStringRaw>
  2153d9:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2153de:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  2153e4:	c5 f9 7f 84 24 50 01 	vmovdqa XMMWORD PTR [rsp+0x150],xmm0
  2153eb:	00 00 
  2153ed:	49 89 de             	mov    r14,rbx
            const dir = try st.readString();
  2153f0:	66 85 c0             	test   ax,ax
  2153f3:	0f 84 1f ff ff ff    	je     215318 <getLineNumberInfo+0xad8>
  2153f9:	e9 c2 fe ff ff       	jmp    2152c0 <getLineNumberInfo+0xa80>
  2153fe:	48 8b 54 24 60       	mov    rdx,QWORD PTR [rsp+0x60]
  215403:	48 8b b2 a0 00 00 00 	mov    rsi,QWORD PTR [rdx+0xa0]
            return Self{
  21540a:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  21540e:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
  215414:	48 c7 84 24 80 00 00 	mov    QWORD PTR [rsp+0x80],0x0
  21541b:	00 00 00 00 00 
        var file_entries = ArrayList(FileEntry).init(st.allocator());
  215420:	48 89 b4 24 88 00 00 	mov    QWORD PTR [rsp+0x88],rsi
  215427:	00 
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  215428:	c5 fc 28 05 90 b8 fe 	vmovaps ymm0,YMMWORD PTR [rip+0xfffffffffffeb890]        # 200cc0 <app_mask+0x88>
  21542f:	ff 
  215430:	c5 fc 11 84 24 e0 00 	vmovups YMMWORD PTR [rsp+0xe0],ymm0
  215437:	00 00 
        const default_is_stmt = (try in_stream.readByte()) != 0;
  215439:	40 84 ed             	test   bpl,bpl
        var prog = LineNumberProgram.init(default_is_stmt, include_directories.toSliceConst(), &file_entries, target_address);
  21543c:	0f 95 84 24 00 01 00 	setne  BYTE PTR [rsp+0x100]
  215443:	00 
  215444:	66 c7 84 24 01 01 00 	mov    WORD PTR [rsp+0x101],0x0
  21544b:	00 00 00 
  21544e:	8b 84 24 d3 00 00 00 	mov    eax,DWORD PTR [rsp+0xd3]
  215455:	89 84 24 03 01 00 00 	mov    DWORD PTR [rsp+0x103],eax
            return self.items[0..self.len];
  21545c:	48 8b 84 24 b0 00 00 	mov    rax,QWORD PTR [rsp+0xb0]
  215463:	00 
  215464:	8a 8c 24 d7 00 00 00 	mov    cl,BYTE PTR [rsp+0xd7]
  21546b:	88 8c 24 07 01 00 00 	mov    BYTE PTR [rsp+0x107],cl
  215472:	48 8b 8c 24 a0 00 00 	mov    rcx,QWORD PTR [rsp+0xa0]
  215479:	00 
  21547a:	48 89 8c 24 08 01 00 	mov    QWORD PTR [rsp+0x108],rcx
  215481:	00 
  215482:	48 89 84 24 10 01 00 	mov    QWORD PTR [rsp+0x110],rax
  215489:	00 
  21548a:	4c 89 b4 24 18 01 00 	mov    QWORD PTR [rsp+0x118],r14
  215491:	00 
  215492:	48 8d 44 24 70       	lea    rax,[rsp+0x70]
  215497:	48 89 84 24 20 01 00 	mov    QWORD PTR [rsp+0x120],rax
  21549e:	00 
  21549f:	48 c7 84 24 28 01 00 	mov    QWORD PTR [rsp+0x128],0x0
  2154a6:	00 00 00 00 00 
  2154ab:	c5 fe 6f 84 24 f8 0a 	vmovdqu ymm0,YMMWORD PTR [rsp+0xaf8]
  2154b2:	00 00 
  2154b4:	c5 fe 7f 84 24 30 01 	vmovdqu YMMWORD PTR [rsp+0x130],ymm0
  2154bb:	00 00 
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  2154bd:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
  2154c2:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  2154c7:	48 8d 05 62 b1 ff ff 	lea    rax,[rip+0xffffffffffffb162]        # 210630 <FileInStream_readFn>
  2154ce:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2154d3:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
            return readStringRaw(self.allocator(), in_stream);
  2154d8:	c5 f8 77             	vzeroupper 
  2154db:	e8 10 ef ff ff       	call   2143f0 <readStringRaw>
  2154e0:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const file_name = try st.readString();
  2154e5:	66 85 c0             	test   ax,ax
  2154e8:	74 3c                	je     215526 <getLineNumberInfo+0xce6>
  2154ea:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  2154ee:	66 89 01             	mov    WORD PTR [rcx],ax
  2154f1:	c5 fe 6f 84 24 8e 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x78e]
  2154f8:	00 00 
  2154fa:	c5 fc 10 8c 24 9c 07 	vmovups ymm1,YMMWORD PTR [rsp+0x79c]
  215501:	00 00 
  215503:	e9 5d f7 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  215508:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            try include_directories.append(dir);
  21550c:	66 89 01             	mov    WORD PTR [rcx],ax
  21550f:	c5 fc 10 84 24 bc 07 	vmovups ymm0,YMMWORD PTR [rsp+0x7bc]
  215516:	00 00 
  215518:	c5 fc 10 8c 24 ca 07 	vmovups ymm1,YMMWORD PTR [rsp+0x7ca]
  21551f:	00 00 
  215521:	e9 3f f7 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  215526:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
  21552c:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  215533:	00 00 
            if (file_name.len == 0) break;
  215535:	c5 f9 6f 84 24 a0 00 	vmovdqa xmm0,XMMWORD PTR [rsp+0xa0]
  21553c:	00 00 
  21553e:	c4 e3 f9 16 c0 01    	vpextrq rax,xmm0,0x1
  215544:	48 85 c0             	test   rax,rax
  215547:	0f 84 44 03 00 00    	je     215891 <getLineNumberInfo+0x1051>
            try self.readNoEof(result[0..]);
  21554d:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215552:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215557:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21555e:	00 00 
            return self.readFn(self, buffer);
  215560:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  215565:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21556a:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  21556f:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215573:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215578:	66 85 c0             	test   ax,ax
  21557b:	0f 85 ca 02 00 00    	jne    21584b <getLineNumberInfo+0x100b>
  215581:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215586:	45 31 e4             	xor    r12d,r12d
  215589:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  21558b:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  215590:	0f 82 ab 02 00 00    	jb     215841 <getLineNumberInfo+0x1001>
            return result[0];
  215596:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21559b:	89 c2                	mov    edx,eax
  21559d:	83 e2 7f             	and    edx,0x7f
  2155a0:	89 ee                	mov    esi,ebp
  2155a2:	83 e6 3f             	and    esi,0x3f
  2155a5:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  2155aa:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  2155af:	48 39 d6             	cmp    rsi,rdx
  2155b2:	0f 85 8f 02 00 00    	jne    215847 <getLineNumberInfo+0x1007>
        result |= operand;
  2155b8:	49 09 cc             	or     r12,rcx
        if ((byte & 0b10000000) == 0) return result;
  2155bb:	84 c0                	test   al,al
  2155bd:	79 3e                	jns    2155fd <getLineNumberInfo+0xdbd>
        shift += 7;
  2155bf:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  2155c3:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2155c8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2155cd:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2155d4:	00 00 
            return self.readFn(self, buffer);
  2155d6:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2155db:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2155e0:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2155e5:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2155e9:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2155ee:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2155f3:	66 85 c0             	test   ax,ax
  2155f6:	74 93                	je     21558b <getLineNumberInfo+0xd4b>
  2155f8:	e9 4e 02 00 00       	jmp    21584b <getLineNumberInfo+0x100b>
            try self.readNoEof(result[0..]);
  2155fd:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215602:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215607:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21560e:	00 00 
            return self.readFn(self, buffer);
  215610:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  215615:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21561a:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  21561f:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215623:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215628:	66 85 c0             	test   ax,ax
  21562b:	0f 85 42 02 00 00    	jne    215873 <getLineNumberInfo+0x1033>
  215631:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215636:	45 31 f6             	xor    r14d,r14d
  215639:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  21563b:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  215640:	0f 82 23 02 00 00    	jb     215869 <getLineNumberInfo+0x1029>
            return result[0];
  215646:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21564b:	89 c2                	mov    edx,eax
  21564d:	83 e2 7f             	and    edx,0x7f
  215650:	89 ee                	mov    esi,ebp
  215652:	83 e6 3f             	and    esi,0x3f
  215655:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21565a:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21565f:	48 39 d6             	cmp    rsi,rdx
  215662:	0f 85 07 02 00 00    	jne    21586f <getLineNumberInfo+0x102f>
        result |= operand;
  215668:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  21566b:	84 c0                	test   al,al
  21566d:	79 3e                	jns    2156ad <getLineNumberInfo+0xe6d>
        shift += 7;
  21566f:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  215673:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215678:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21567d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215684:	00 00 
            return self.readFn(self, buffer);
  215686:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21568b:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215690:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  215695:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215699:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21569e:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2156a3:	66 85 c0             	test   ax,ax
  2156a6:	74 93                	je     21563b <getLineNumberInfo+0xdfb>
  2156a8:	e9 c6 01 00 00       	jmp    215873 <getLineNumberInfo+0x1033>
            try self.readNoEof(result[0..]);
  2156ad:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2156b2:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2156b7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2156be:	00 00 
            return self.readFn(self, buffer);
  2156c0:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  2156c5:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2156ca:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  2156cf:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2156d3:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  2156d8:	66 85 c0             	test   ax,ax
  2156db:	0f 85 05 02 00 00    	jne    2158e6 <getLineNumberInfo+0x10a6>
  2156e1:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2156e6:	31 db                	xor    ebx,ebx
  2156e8:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  2156ea:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  2156ef:	0f 82 e7 01 00 00    	jb     2158dc <getLineNumberInfo+0x109c>
            return result[0];
  2156f5:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  2156fa:	89 c2                	mov    edx,eax
  2156fc:	83 e2 7f             	and    edx,0x7f
  2156ff:	89 ee                	mov    esi,ebp
  215701:	83 e6 3f             	and    esi,0x3f
  215704:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  215709:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  21570e:	48 39 d6             	cmp    rsi,rdx
  215711:	0f 85 cb 01 00 00    	jne    2158e2 <getLineNumberInfo+0x10a2>
        result |= operand;
  215717:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  21571a:	84 c0                	test   al,al
  21571c:	79 3e                	jns    21575c <getLineNumberInfo+0xf1c>
        shift += 7;
  21571e:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  215722:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215727:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21572c:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215733:	00 00 
            return self.readFn(self, buffer);
  215735:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  21573a:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  21573f:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
  215744:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215748:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21574d:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215752:	66 85 c0             	test   ax,ax
  215755:	74 93                	je     2156ea <getLineNumberInfo+0xeaa>
  215757:	e9 8a 01 00 00       	jmp    2158e6 <getLineNumberInfo+0x10a6>
            const new_length = self.len + 1;
  21575c:	48 8b ac 24 80 00 00 	mov    rbp,QWORD PTR [rsp+0x80]
  215763:	00 
            var better_capacity = self.items.len;
  215764:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
            if (better_capacity >= new_capacity) return;
  215769:	48 39 e9             	cmp    rcx,rbp
  21576c:	76 05                	jbe    215773 <getLineNumberInfo+0xf33>
            const result = &self.items[self.len];
  21576e:	48 89 e8             	mov    rax,rbp
  215771:	eb 4e                	jmp    2157c1 <getLineNumberInfo+0xf81>
                better_capacity += better_capacity / 2 + 8;
  215773:	48 89 c8             	mov    rax,rcx
  215776:	48 d1 e8             	shr    rax,1
  215779:	48 01 c1             	add    rcx,rax
  21577c:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  215780:	48 39 e9             	cmp    rcx,rbp
  215783:	76 ee                	jbe    215773 <getLineNumberInfo+0xf33>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  215785:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  21578c:	00 
  21578d:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  215792:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  215797:	e8 24 20 00 00       	call   2177c0 <Allocator_alignedRealloc.79>
  21579c:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2157a1:	66 85 c0             	test   ax,ax
  2157a4:	0f 85 bc 0c 00 00    	jne    216466 <getLineNumberInfo+0x1c26>
  2157aa:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  2157af:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2157b3:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
            const result = &self.items[self.len];
  2157b9:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2157c0:	00 
  2157c1:	48 83 c5 01          	add    rbp,0x1
  2157c5:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  2157ca:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  2157ce:	48 89 ac 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rbp
  2157d5:	00 
            new_item_ptr.* = item;
  2157d6:	c5 f8 28 84 24 a0 00 	vmovaps xmm0,XMMWORD PTR [rsp+0xa0]
  2157dd:	00 00 
  2157df:	c5 f8 11 04 c1       	vmovups XMMWORD PTR [rcx+rax*8],xmm0
  2157e4:	4c 89 64 c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],r12
  2157e9:	4c 89 74 c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],r14
  2157ee:	48 89 5c c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rbx
  2157f3:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  2157f8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2157fd:	48 8d 0d 2c ae ff ff 	lea    rcx,[rip+0xffffffffffffae2c]        # 210630 <FileInStream_readFn>
  215804:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  215809:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  215810:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  215815:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  21581a:	e8 d1 eb ff ff       	call   2143f0 <readStringRaw>
  21581f:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215824:	c5 fa 6f 44 24 28    	vmovdqu xmm0,XMMWORD PTR [rsp+0x28]
            const file_name = try st.readString();
  21582a:	c5 f9 7f 84 24 a0 00 	vmovdqa XMMWORD PTR [rsp+0xa0],xmm0
  215831:	00 00 
  215833:	66 85 c0             	test   ax,ax
  215836:	0f 84 f9 fc ff ff    	je     215535 <getLineNumberInfo+0xcf5>
  21583c:	e9 a9 fc ff ff       	jmp    2154ea <getLineNumberInfo+0xcaa>
  215841:	66 b8 20 00          	mov    ax,0x20
  215845:	eb 04                	jmp    21584b <getLineNumberInfo+0x100b>
  215847:	66 b8 25 00          	mov    ax,0x25
  21584b:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const dir_index = try readULeb128(in_stream);
  21584f:	66 89 01             	mov    WORD PTR [rcx],ax
  215852:	c5 fe 6f 84 24 60 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x760]
  215859:	00 00 
  21585b:	c5 fc 10 8c 24 6e 07 	vmovups ymm1,YMMWORD PTR [rsp+0x76e]
  215862:	00 00 
  215864:	e9 fc f3 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  215869:	66 b8 20 00          	mov    ax,0x20
  21586d:	eb 04                	jmp    215873 <getLineNumberInfo+0x1033>
  21586f:	66 b8 25 00          	mov    ax,0x25
  215873:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const mtime = try readULeb128(in_stream);
  215877:	66 89 01             	mov    WORD PTR [rcx],ax
  21587a:	c5 fe 6f 84 24 32 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x732]
  215881:	00 00 
  215883:	c5 fc 10 8c 24 40 07 	vmovups ymm1,YMMWORD PTR [rsp+0x740]
  21588a:	00 00 
  21588c:	e9 d4 f3 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  215891:	4d 85 ed             	test   r13,r13
  215894:	78 6e                	js     215904 <getLineNumberInfo+0x10c4>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  215896:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  21589b:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  21589e:	31 ed                	xor    ebp,ebp
  2158a0:	b8 08 00 00 00       	mov    eax,0x8
  2158a5:	31 d2                	xor    edx,edx
  2158a7:	4c 89 ee             	mov    rsi,r13
  2158aa:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  2158ac:	48 89 c1             	mov    rcx,rax
  2158af:	48 f7 d9             	neg    rcx
  2158b2:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  2158b8:	48 0f 46 cd          	cmovbe rcx,rbp
  2158bc:	66 b8 02 00          	mov    ax,0x2
                if (err > 0) {
  2158c0:	48 83 f9 1d          	cmp    rcx,0x1d
  2158c4:	77 60                	ja     215926 <getLineNumberInfo+0x10e6>
  2158c6:	48 8d 15 a7 bd fe ff 	lea    rdx,[rip+0xfffffffffffebda7]        # 201674 <__unnamed_9+0x994>
  2158cd:	48 63 0c 8a          	movsxd rcx,DWORD PTR [rdx+rcx*4]
  2158d1:	48 01 d1             	add    rcx,rdx
  2158d4:	ff e1                	jmp    rcx
  2158d6:	66 b8 22 00          	mov    ax,0x22
  2158da:	eb 2c                	jmp    215908 <getLineNumberInfo+0x10c8>
  2158dc:	66 b8 20 00          	mov    ax,0x20
  2158e0:	eb 04                	jmp    2158e6 <getLineNumberInfo+0x10a6>
  2158e2:	66 b8 25 00          	mov    ax,0x25
  2158e6:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            const len_bytes = try readULeb128(in_stream);
  2158ea:	66 89 01             	mov    WORD PTR [rcx],ax
  2158ed:	c5 fe 6f 84 24 04 07 	vmovdqu ymm0,YMMWORD PTR [rsp+0x704]
  2158f4:	00 00 
  2158f6:	c5 fc 10 8c 24 12 07 	vmovups ymm1,YMMWORD PTR [rsp+0x712]
  2158fd:	00 00 
  2158ff:	e9 61 f3 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  215904:	66 b8 23 00          	mov    ax,0x23
  215908:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
        try in_file.seekTo(prog_start_offset);
  21590c:	66 89 01             	mov    WORD PTR [rcx],ax
  21590f:	c5 fe 6f 84 24 a8 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x6a8]
  215916:	00 00 
  215918:	c5 fc 10 8c 24 b6 06 	vmovups ymm1,YMMWORD PTR [rsp+0x6b6]
  21591f:	00 00 
  215921:	e9 3f f3 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  215926:	48 83 f9 4b          	cmp    rcx,0x4b
  21592a:	75 dc                	jne    215908 <getLineNumberInfo+0x10c8>
  21592c:	eb a8                	jmp    2158d6 <getLineNumberInfo+0x1096>
            try self.readNoEof(result[0..]);
  21592e:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215933:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215938:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21593f:	00 00 
  215941:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  215946:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
            return self.readFn(self, buffer);
  21594b:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215950:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215954:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215959:	66 85 c9             	test   cx,cx
  21595c:	74 31                	je     21598f <getLineNumberInfo+0x114f>
  21595e:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
            const opcode = try in_stream.readByte();
  215962:	66 89 08             	mov    WORD PTR [rax],cx
  215965:	c5 fe 6f 84 24 7a 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x67a]
  21596c:	00 00 
  21596e:	c5 fc 10 8c 24 88 06 	vmovups ymm1,YMMWORD PTR [rsp+0x688]
  215975:	00 00 
  215977:	c5 fc 11 48 10       	vmovups YMMWORD PTR [rax+0x10],ymm1
  21597c:	c5 fe 7f 40 02       	vmovdqu YMMWORD PTR [rax+0x2],ymm0
  215981:	e9 0b f0 ff ff       	jmp    214991 <getLineNumberInfo+0x151>
  215986:	66 b8 1e 00          	mov    ax,0x1e
  21598a:	e9 79 ff ff ff       	jmp    215908 <getLineNumberInfo+0x10c8>
  21598f:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
  215994:	8a 4c 24 5e          	mov    cl,BYTE PTR [rsp+0x5e]
  215998:	f6 d1                	not    cl
  21599a:	88 8c 24 a0 00 00 00 	mov    BYTE PTR [rsp+0xa0],cl
  2159a1:	4c 8d 64 24 20       	lea    r12,[rsp+0x20]
  2159a6:	4c 8d 6c 24 08       	lea    r13,[rsp+0x8]
            if (amt_read < buf.len) return error.EndOfStream;
  2159ab:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  2159b0:	0f 82 f0 0a 00 00    	jb     2164a6 <getLineNumberInfo+0x1c66>
            return result[0];
  2159b6:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
            if (opcode == DW.LNS_extended_op) {
  2159ba:	84 c0                	test   al,al
  2159bc:	74 62                	je     215a20 <getLineNumberInfo+0x11e0>
            } else if (opcode >= opcode_base) {
  2159be:	89 c1                	mov    ecx,eax
  2159c0:	2a 4c 24 5e          	sub    cl,BYTE PTR [rsp+0x5e]
  2159c4:	0f 83 01 01 00 00    	jae    215acb <getLineNumberInfo+0x128b>
                switch (opcode) {
  2159ca:	04 ff                	add    al,0xff
  2159cc:	0f b6 c0             	movzx  eax,al
  2159cf:	3c 09                	cmp    al,0x9
  2159d1:	0f 87 3b 02 00 00    	ja     215c12 <getLineNumberInfo+0x13d2>
  2159d7:	48 8d 0d 0e bd fe ff 	lea    rcx,[rip+0xfffffffffffebd0e]        # 2016ec <__unnamed_9+0xa0c>
  2159de:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  2159e2:	48 01 c8             	add    rax,rcx
  2159e5:	ff e0                	jmp    rax
                        if (try prog.checkLineMatch()) |info| return info;
  2159e7:	48 8d bc 24 08 02 00 	lea    rdi,[rsp+0x208]
  2159ee:	00 
  2159ef:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  2159f6:	00 
  2159f7:	e8 34 14 00 00       	call   216e30 <LineNumberProgram_checkLineMatch>
  2159fc:	0f b7 84 24 08 02 00 	movzx  eax,WORD PTR [rsp+0x208]
  215a03:	00 
  215a04:	66 85 c0             	test   ax,ax
  215a07:	0f 85 ac 0c 00 00    	jne    2166b9 <getLineNumberInfo+0x1e79>
  215a0d:	80 bc 24 38 02 00 00 	cmp    BYTE PTR [rsp+0x238],0x1
  215a14:	01 
  215a15:	0f 85 0c 01 00 00    	jne    215b27 <getLineNumberInfo+0x12e7>
  215a1b:	e9 b7 0c 00 00       	jmp    2166d7 <getLineNumberInfo+0x1e97>
            try self.readNoEof(result[0..]);
  215a20:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215a25:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215a2a:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215a31:	00 00 
            return self.readFn(self, buffer);
  215a33:	4c 89 e7             	mov    rdi,r12
  215a36:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215a3b:	4c 89 ea             	mov    rdx,r13
  215a3e:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215a42:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215a47:	66 85 c0             	test   ax,ax
  215a4a:	0f 85 38 0a 00 00    	jne    216488 <getLineNumberInfo+0x1c48>
  215a50:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215a55:	31 ed                	xor    ebp,ebp
  215a57:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  215a59:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  215a5e:	0f 82 fc 09 00 00    	jb     216460 <getLineNumberInfo+0x1c20>
            return result[0];
  215a64:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  215a69:	89 c2                	mov    edx,eax
  215a6b:	83 e2 7f             	and    edx,0x7f
  215a6e:	89 de                	mov    esi,ebx
  215a70:	83 e6 3f             	and    esi,0x3f
  215a73:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  215a78:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  215a7d:	48 39 d6             	cmp    rsi,rdx
  215a80:	0f 85 fe 09 00 00    	jne    216484 <getLineNumberInfo+0x1c44>
        result |= operand;
  215a86:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  215a89:	84 c0                	test   al,al
  215a8b:	0f 89 d8 00 00 00    	jns    215b69 <getLineNumberInfo+0x1329>
        shift += 7;
  215a91:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  215a95:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215a9a:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215a9f:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215aa6:	00 00 
            return self.readFn(self, buffer);
  215aa8:	4c 89 e7             	mov    rdi,r12
  215aab:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215ab0:	4c 89 ea             	mov    rdx,r13
  215ab3:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215ab7:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215abc:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215ac1:	66 85 c0             	test   ax,ax
  215ac4:	74 93                	je     215a59 <getLineNumberInfo+0x1219>
  215ac6:	e9 bd 09 00 00       	jmp    216488 <getLineNumberInfo+0x1c48>
                const inc_line = i32(line_base) + i32(adjusted_opcode % line_range);
  215acb:	0f b6 c1             	movzx  eax,cl
  215ace:	f6 74 24 5f          	div    BYTE PTR [rsp+0x5f]
  215ad2:	0f b6 cc             	movzx  ecx,ah
  215ad5:	48 03 8c 24 68 01 00 	add    rcx,QWORD PTR [rsp+0x168]
  215adc:	00 
                prog.line += inc_line;
  215add:	48 01 8c 24 f0 00 00 	add    QWORD PTR [rsp+0xf0],rcx
  215ae4:	00 
                const inc_addr = minimum_instruction_length * (adjusted_opcode / line_range);
  215ae5:	41 f6 e7             	mul    r15b
                prog.address += inc_addr;
  215ae8:	0f b6 c0             	movzx  eax,al
  215aeb:	48 01 84 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rax
  215af2:	00 
                if (try prog.checkLineMatch()) |info| return info;
  215af3:	48 8d bc 24 40 02 00 	lea    rdi,[rsp+0x240]
  215afa:	00 
  215afb:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  215b02:	00 
  215b03:	e8 28 13 00 00       	call   216e30 <LineNumberProgram_checkLineMatch>
  215b08:	0f b7 84 24 40 02 00 	movzx  eax,WORD PTR [rsp+0x240]
  215b0f:	00 
  215b10:	66 85 c0             	test   ax,ax
  215b13:	0f 85 96 09 00 00    	jne    2164af <getLineNumberInfo+0x1c6f>
  215b19:	80 bc 24 70 02 00 00 	cmp    BYTE PTR [rsp+0x270],0x1
  215b20:	01 
  215b21:	0f 84 a6 09 00 00    	je     2164cd <getLineNumberInfo+0x1c8d>
  215b27:	c6 84 24 01 01 00 00 	mov    BYTE PTR [rsp+0x101],0x0
  215b2e:	00 
            try self.readNoEof(result[0..]);
  215b2f:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215b34:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215b39:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215b40:	00 00 
            return self.readFn(self, buffer);
  215b42:	4c 89 e7             	mov    rdi,r12
  215b45:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215b4a:	4c 89 ea             	mov    rdx,r13
  215b4d:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215b51:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  215b56:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215b5b:	66 85 c9             	test   cx,cx
  215b5e:	0f 84 47 fe ff ff    	je     2159ab <getLineNumberInfo+0x116b>
  215b64:	e9 f5 fd ff ff       	jmp    21595e <getLineNumberInfo+0x111e>
                if (op_size < 1) return error.InvalidDebugInfo;
  215b69:	48 85 ed             	test   rbp,rbp
  215b6c:	0f 84 d0 08 00 00    	je     216442 <getLineNumberInfo+0x1c02>
            try self.readNoEof(result[0..]);
  215b72:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215b77:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215b7c:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215b83:	00 00 
            return self.readFn(self, buffer);
  215b85:	4c 89 e7             	mov    rdi,r12
  215b88:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215b8d:	4c 89 ea             	mov    rdx,r13
  215b90:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215b94:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215b99:	66 85 c0             	test   ax,ax
  215b9c:	0f 85 39 0a 00 00    	jne    2165db <getLineNumberInfo+0x1d9b>
  215ba2:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  215ba7:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  215bac:	0f 82 25 0a 00 00    	jb     2165d7 <getLineNumberInfo+0x1d97>
            return result[0];
  215bb2:	8a 44 24 48          	mov    al,BYTE PTR [rsp+0x48]
                switch (sub_op) {
  215bb6:	3c 02                	cmp    al,0x2
  215bb8:	0f 84 03 04 00 00    	je     215fc1 <getLineNumberInfo+0x1781>
  215bbe:	3c 03                	cmp    al,0x3
  215bc0:	0f 84 b2 04 00 00    	je     216078 <getLineNumberInfo+0x1838>
  215bc6:	3c 01                	cmp    al,0x1
  215bc8:	0f 84 2b 0a 00 00    	je     2165f9 <getLineNumberInfo+0x1db9>
  215bce:	48 83 c5 ff          	add    rbp,0xffffffffffffffff
  215bd2:	0f 88 6a 08 00 00    	js     216442 <getLineNumberInfo+0x1c02>
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  215bd8:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  215bdd:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  215be0:	b8 08 00 00 00       	mov    eax,0x8
  215be5:	ba 01 00 00 00       	mov    edx,0x1
  215bea:	48 89 ee             	mov    rsi,rbp
  215bed:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  215bef:	48 89 c1             	mov    rcx,rax
  215bf2:	48 f7 d9             	neg    rcx
  215bf5:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  215bfb:	b8 00 00 00 00       	mov    eax,0x0
  215c00:	48 0f 46 c8          	cmovbe rcx,rax
                if (err > 0) {
  215c04:	48 85 c9             	test   rcx,rcx
  215c07:	0f 84 22 ff ff ff    	je     215b2f <getLineNumberInfo+0x12ef>
  215c0d:	e9 6e 0b 00 00       	jmp    216780 <getLineNumberInfo+0x1f40>
                        if (opcode - 1 >= standard_opcode_lengths.len) return error.InvalidDebugInfo;
  215c12:	48 39 84 24 98 00 00 	cmp    QWORD PTR [rsp+0x98],rax
  215c19:	00 
  215c1a:	0f 86 22 08 00 00    	jbe    216442 <getLineNumberInfo+0x1c02>
                        try in_file.seekForward(len_bytes);
  215c20:	48 8b 8c 24 d8 00 00 	mov    rcx,QWORD PTR [rsp+0xd8]
  215c27:	00 
  215c28:	0f b6 34 01          	movzx  esi,BYTE PTR [rcx+rax*1]
    return syscall3(SYS_lseek, @intCast(usize, fd), @bitCast(usize, offset), ref_pos);
  215c2c:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  215c31:	48 63 38             	movsxd rdi,DWORD PTR [rax]
  215c34:	b8 08 00 00 00       	mov    eax,0x8
  215c39:	ba 01 00 00 00       	mov    edx,0x1
  215c3e:	0f 05                	syscall 
    return if (signed_r > -4096 and signed_r < 0) @intCast(usize, -signed_r) else 0;
  215c40:	48 89 c1             	mov    rcx,rax
  215c43:	48 f7 d9             	neg    rcx
  215c46:	48 3d 00 f0 ff ff    	cmp    rax,0xfffffffffffff000
  215c4c:	b8 00 00 00 00       	mov    eax,0x0
  215c51:	48 0f 46 c8          	cmovbe rcx,rax
  215c55:	48 85 c9             	test   rcx,rcx
  215c58:	0f 84 d1 fe ff ff    	je     215b2f <getLineNumberInfo+0x12ef>
  215c5e:	e9 b6 0a 00 00       	jmp    216719 <getLineNumberInfo+0x1ed9>
            try self.readNoEof(result[0..]);
  215c63:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215c68:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215c6d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215c74:	00 00 
            return self.readFn(self, buffer);
  215c76:	4c 89 e7             	mov    rdi,r12
  215c79:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215c7e:	4c 89 ea             	mov    rdx,r13
  215c81:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215c85:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215c8a:	66 85 c0             	test   ax,ax
  215c8d:	0f 85 98 08 00 00    	jne    21652b <getLineNumberInfo+0x1ceb>
  215c93:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215c98:	31 db                	xor    ebx,ebx
  215c9a:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  215c9c:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  215ca1:	0f 82 68 08 00 00    	jb     21650f <getLineNumberInfo+0x1ccf>
            return result[0];
  215ca7:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  215cac:	89 c2                	mov    edx,eax
  215cae:	83 e2 7f             	and    edx,0x7f
  215cb1:	89 ee                	mov    esi,ebp
  215cb3:	83 e6 3f             	and    esi,0x3f
  215cb6:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  215cbb:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  215cc0:	48 39 d6             	cmp    rsi,rdx
  215cc3:	0f 85 5e 08 00 00    	jne    216527 <getLineNumberInfo+0x1ce7>
        result |= operand;
  215cc9:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  215ccc:	84 c0                	test   al,al
  215cce:	0f 89 16 05 00 00    	jns    2161ea <getLineNumberInfo+0x19aa>
        shift += 7;
  215cd4:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  215cd8:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215cdd:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215ce2:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215ce9:	00 00 
            return self.readFn(self, buffer);
  215ceb:	4c 89 e7             	mov    rdi,r12
  215cee:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215cf3:	4c 89 ea             	mov    rdx,r13
  215cf6:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215cfa:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215cff:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215d04:	66 85 c0             	test   ax,ax
  215d07:	74 93                	je     215c9c <getLineNumberInfo+0x145c>
  215d09:	e9 1d 08 00 00       	jmp    21652b <getLineNumberInfo+0x1ceb>
            try self.readNoEof(result[0..]);
  215d0e:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215d13:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215d18:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215d1f:	00 00 
            return self.readFn(self, buffer);
  215d21:	4c 89 e7             	mov    rdi,r12
  215d24:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215d29:	4c 89 ea             	mov    rdx,r13
  215d2c:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215d30:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215d35:	66 85 c0             	test   ax,ax
  215d38:	0f 85 0f 08 00 00    	jne    21654d <getLineNumberInfo+0x1d0d>
  215d3e:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215d43:	bb 07 00 00 00       	mov    ebx,0x7
  215d48:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  215d4a:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  215d4f:	0f 82 c0 07 00 00    	jb     216515 <getLineNumberInfo+0x1cd5>
  215d55:	48 8d 53 f9          	lea    rdx,[rbx-0x7]
            return result[0];
  215d59:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(i64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  215d5e:	89 c6                	mov    esi,eax
  215d60:	83 e6 7f             	and    esi,0x7f
  215d63:	83 e2 3f             	and    edx,0x3f
  215d66:	c4 e2 e9 f7 ce       	shlx   rcx,rsi,rdx
  215d6b:	c4 e2 ea f7 d1       	sarx   rdx,rcx,rdx
  215d70:	48 39 f2             	cmp    rdx,rsi
  215d73:	0f 85 d0 07 00 00    	jne    216549 <getLineNumberInfo+0x1d09>
        result |= operand;
  215d79:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) {
  215d7c:	84 c0                	test   al,al
  215d7e:	0f 89 77 04 00 00    	jns    2161fb <getLineNumberInfo+0x19bb>
            try self.readNoEof(result[0..]);
  215d84:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215d89:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215d8e:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215d95:	00 00 
            return self.readFn(self, buffer);
  215d97:	4c 89 e7             	mov    rdi,r12
  215d9a:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215d9f:	4c 89 ea             	mov    rdx,r13
  215da2:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215da6:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215dab:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215db0:	48 83 c3 07          	add    rbx,0x7
  215db4:	66 85 c0             	test   ax,ax
  215db7:	74 91                	je     215d4a <getLineNumberInfo+0x150a>
  215db9:	e9 8f 07 00 00       	jmp    21654d <getLineNumberInfo+0x1d0d>
            try self.readNoEof(result[0..]);
  215dbe:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215dc3:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215dc8:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215dcf:	00 00 
            return self.readFn(self, buffer);
  215dd1:	4c 89 e7             	mov    rdi,r12
  215dd4:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215dd9:	4c 89 ea             	mov    rdx,r13
  215ddc:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215de0:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215de5:	66 85 c0             	test   ax,ax
  215de8:	0f 85 81 07 00 00    	jne    21656f <getLineNumberInfo+0x1d2f>
  215dee:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215df3:	31 db                	xor    ebx,ebx
  215df5:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  215df7:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  215dfc:	0f 82 19 07 00 00    	jb     21651b <getLineNumberInfo+0x1cdb>
            return result[0];
  215e02:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  215e07:	89 c2                	mov    edx,eax
  215e09:	83 e2 7f             	and    edx,0x7f
  215e0c:	89 ee                	mov    esi,ebp
  215e0e:	83 e6 3f             	and    esi,0x3f
  215e11:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  215e16:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  215e1b:	48 39 d6             	cmp    rsi,rdx
  215e1e:	0f 85 47 07 00 00    	jne    21656b <getLineNumberInfo+0x1d2b>
        result |= operand;
  215e24:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  215e27:	84 c0                	test   al,al
  215e29:	0f 89 f2 03 00 00    	jns    216221 <getLineNumberInfo+0x19e1>
        shift += 7;
  215e2f:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  215e33:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215e38:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215e3d:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215e44:	00 00 
            return self.readFn(self, buffer);
  215e46:	4c 89 e7             	mov    rdi,r12
  215e49:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215e4e:	4c 89 ea             	mov    rdx,r13
  215e51:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215e55:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215e5a:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215e5f:	66 85 c0             	test   ax,ax
  215e62:	74 93                	je     215df7 <getLineNumberInfo+0x15b7>
  215e64:	e9 06 07 00 00       	jmp    21656f <getLineNumberInfo+0x1d2f>
            try self.readNoEof(result[0..]);
  215e69:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215e6e:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215e73:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215e7a:	00 00 
            return self.readFn(self, buffer);
  215e7c:	4c 89 e7             	mov    rdi,r12
  215e7f:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215e84:	4c 89 ea             	mov    rdx,r13
  215e87:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215e8b:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215e90:	66 85 c0             	test   ax,ax
  215e93:	0f 85 f8 06 00 00    	jne    216591 <getLineNumberInfo+0x1d51>
  215e99:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  215e9e:	31 db                	xor    ebx,ebx
  215ea0:	31 ed                	xor    ebp,ebp
            if (amt_read < buf.len) return error.EndOfStream;
  215ea2:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  215ea7:	0f 82 74 06 00 00    	jb     216521 <getLineNumberInfo+0x1ce1>
            return result[0];
  215ead:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  215eb2:	89 c2                	mov    edx,eax
  215eb4:	83 e2 7f             	and    edx,0x7f
  215eb7:	89 ee                	mov    esi,ebp
  215eb9:	83 e6 3f             	and    esi,0x3f
  215ebc:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  215ec1:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  215ec6:	48 39 d6             	cmp    rsi,rdx
  215ec9:	0f 85 be 06 00 00    	jne    21658d <getLineNumberInfo+0x1d4d>
        result |= operand;
  215ecf:	48 09 cb             	or     rbx,rcx
        if ((byte & 0b10000000) == 0) return result;
  215ed2:	84 c0                	test   al,al
  215ed4:	0f 89 54 03 00 00    	jns    21622e <getLineNumberInfo+0x19ee>
        shift += 7;
  215eda:	48 83 c5 07          	add    rbp,0x7
            try self.readNoEof(result[0..]);
  215ede:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215ee3:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215ee8:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  215eef:	00 00 
            return self.readFn(self, buffer);
  215ef1:	4c 89 e7             	mov    rdi,r12
  215ef4:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215ef9:	4c 89 ea             	mov    rdx,r13
  215efc:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215f00:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  215f05:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  215f0a:	66 85 c0             	test   ax,ax
  215f0d:	74 93                	je     215ea2 <getLineNumberInfo+0x1662>
  215f0f:	e9 7d 06 00 00       	jmp    216591 <getLineNumberInfo+0x1d51>
                        prog.is_stmt = !prog.is_stmt;
  215f14:	8a 84 24 00 01 00 00 	mov    al,BYTE PTR [rsp+0x100]
  215f1b:	f6 d0                	not    al
  215f1d:	24 01                	and    al,0x1
  215f1f:	88 84 24 00 01 00 00 	mov    BYTE PTR [rsp+0x100],al
  215f26:	e9 04 fc ff ff       	jmp    215b2f <getLineNumberInfo+0x12ef>
                        prog.basic_block = true;
  215f2b:	c6 84 24 01 01 00 00 	mov    BYTE PTR [rsp+0x101],0x1
  215f32:	01 
  215f33:	e9 f7 fb ff ff       	jmp    215b2f <getLineNumberInfo+0x12ef>
                        const inc_addr = minimum_instruction_length * ((255 - opcode_base) / line_range);
  215f38:	0f b6 84 24 a0 00 00 	movzx  eax,BYTE PTR [rsp+0xa0]
  215f3f:	00 
  215f40:	f6 74 24 5f          	div    BYTE PTR [rsp+0x5f]
  215f44:	41 f6 e7             	mul    r15b
                        prog.address += inc_addr;
  215f47:	0f b6 c0             	movzx  eax,al
  215f4a:	eb 68                	jmp    215fb4 <getLineNumberInfo+0x1774>
                        const arg = try in_stream.readInt(st.elf.endian, u16);
  215f4c:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  215f51:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  215f54:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215f59:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215f5e:	48 c7 44 24 10 02 00 	mov    QWORD PTR [rsp+0x10],0x2
  215f65:	00 00 
            return self.readFn(self, buffer);
  215f67:	4c 89 e7             	mov    rdi,r12
  215f6a:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215f6f:	4c 89 ea             	mov    rdx,r13
  215f72:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215f76:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215f7b:	66 85 c0             	test   ax,ax
  215f7e:	0f 85 c0 07 00 00    	jne    216744 <getLineNumberInfo+0x1f04>
  215f84:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  215f89:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  215f8e:	0f 82 ac 07 00 00    	jb     216740 <getLineNumberInfo+0x1f00>
  215f94:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  215f99:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  215f9e:	89 ca                	mov    edx,ecx
  215fa0:	c1 e2 08             	shl    edx,0x8
  215fa3:	09 c2                	or     edx,eax
                result = (result << 8) | b;
  215fa5:	c1 e0 08             	shl    eax,0x8
  215fa8:	09 c8                	or     eax,ecx
    switch (endian) {
  215faa:	f6 c3 01             	test   bl,0x1
  215fad:	66 0f 45 c2          	cmovne ax,dx
                        prog.address += arg;
  215fb1:	0f b7 c0             	movzx  eax,ax
  215fb4:	48 01 84 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rax
  215fbb:	00 
  215fbc:	e9 6e fb ff ff       	jmp    215b2f <getLineNumberInfo+0x12ef>
                        const addr = try in_stream.readInt(st.elf.endian, usize);
  215fc1:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
  215fc6:	8a 58 12             	mov    bl,BYTE PTR [rax+0x12]
            try self.readNoEof(bytes[0..]);
  215fc9:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  215fce:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  215fd3:	48 c7 44 24 10 08 00 	mov    QWORD PTR [rsp+0x10],0x8
  215fda:	00 00 
            return self.readFn(self, buffer);
  215fdc:	4c 89 e7             	mov    rdi,r12
  215fdf:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  215fe4:	4c 89 ea             	mov    rdx,r13
  215fe7:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  215feb:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  215ff0:	66 85 c0             	test   ax,ax
  215ff3:	0f 85 ae 07 00 00    	jne    2167a7 <getLineNumberInfo+0x1f67>
  215ff9:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            if (amt_read < buf.len) return error.EndOfStream;
  215ffe:	48 3b 44 24 10       	cmp    rax,QWORD PTR [rsp+0x10]
  216003:	0f 82 9a 07 00 00    	jb     2167a3 <getLineNumberInfo+0x1f63>
  216009:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
  21600e:	0f b6 4c 24 49       	movzx  ecx,BYTE PTR [rsp+0x49]
  216013:	f6 c3 01             	test   bl,0x1
  216016:	0f 84 72 01 00 00    	je     21618e <getLineNumberInfo+0x194e>
                result = result | (T(b) << @intCast(ShiftType, index * 8));
  21601c:	48 c1 e1 08          	shl    rcx,0x8
  216020:	48 09 c1             	or     rcx,rax
  216023:	0f b6 44 24 4a       	movzx  eax,BYTE PTR [rsp+0x4a]
  216028:	48 c1 e0 10          	shl    rax,0x10
  21602c:	48 09 c8             	or     rax,rcx
  21602f:	0f b6 4c 24 4b       	movzx  ecx,BYTE PTR [rsp+0x4b]
  216034:	48 c1 e1 18          	shl    rcx,0x18
  216038:	48 09 c1             	or     rcx,rax
  21603b:	0f b6 44 24 4c       	movzx  eax,BYTE PTR [rsp+0x4c]
  216040:	48 c1 e0 20          	shl    rax,0x20
  216044:	48 09 c8             	or     rax,rcx
  216047:	0f b6 4c 24 4d       	movzx  ecx,BYTE PTR [rsp+0x4d]
  21604c:	48 c1 e1 28          	shl    rcx,0x28
  216050:	48 09 c1             	or     rcx,rax
  216053:	0f b6 54 24 4e       	movzx  edx,BYTE PTR [rsp+0x4e]
  216058:	48 c1 e2 30          	shl    rdx,0x30
  21605c:	0f b6 44 24 4f       	movzx  eax,BYTE PTR [rsp+0x4f]
  216061:	48 c1 e0 38          	shl    rax,0x38
  216065:	48 09 d0             	or     rax,rdx
  216068:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  21606b:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  216072:	00 
  216073:	e9 b7 fa ff ff       	jmp    215b2f <getLineNumberInfo+0x12ef>
  216078:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
            var in_file_stream = io.FileInStream.init(&self.self_exe_file);
  21607d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  216082:	48 8d 0d a7 a5 ff ff 	lea    rcx,[rip+0xffffffffffffa5a7]        # 210630 <FileInStream_readFn>
  216089:	48 89 4c 24 10       	mov    QWORD PTR [rsp+0x10],rcx
  21608e:	48 8b b0 a0 00 00 00 	mov    rsi,QWORD PTR [rax+0xa0]
            return readStringRaw(self.allocator(), in_stream);
  216095:	4c 89 e7             	mov    rdi,r12
  216098:	48 8d 54 24 10       	lea    rdx,[rsp+0x10]
  21609d:	e8 4e e3 ff ff       	call   2143f0 <readStringRaw>
  2160a2:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2160a7:	48 8d 4c 24 22       	lea    rcx,[rsp+0x22]
  2160ac:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  2160b0:	c5 f8 29 84 24 b0 01 	vmovaps XMMWORD PTR [rsp+0x1b0],xmm0
  2160b7:	00 00 
  2160b9:	48 8b 49 0e          	mov    rcx,QWORD PTR [rcx+0xe]
  2160bd:	48 89 8c 24 be 01 00 	mov    QWORD PTR [rsp+0x1be],rcx
  2160c4:	00 
                        const file_name = try st.readString();
  2160c5:	66 85 c0             	test   ax,ax
  2160c8:	0f 85 94 06 00 00    	jne    216762 <getLineNumberInfo+0x1f22>
  2160ce:	48 8d 84 24 b6 01 00 	lea    rax,[rsp+0x1b6]
  2160d5:	00 
  2160d6:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2160da:	c5 f9 7f 84 24 d0 01 	vmovdqa XMMWORD PTR [rsp+0x1d0],xmm0
  2160e1:	00 00 
            try self.readNoEof(result[0..]);
  2160e3:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2160e8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2160ed:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2160f4:	00 00 
            return self.readFn(self, buffer);
  2160f6:	4c 89 e7             	mov    rdi,r12
  2160f9:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2160fe:	4c 89 ea             	mov    rdx,r13
  216101:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  216105:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21610a:	66 85 c0             	test   ax,ax
  21610d:	0f 85 a6 04 00 00    	jne    2165b9 <getLineNumberInfo+0x1d79>
  216113:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  216118:	31 ed                	xor    ebp,ebp
  21611a:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  21611c:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  216121:	0f 82 88 04 00 00    	jb     2165af <getLineNumberInfo+0x1d6f>
            return result[0];
  216127:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  21612c:	89 c2                	mov    edx,eax
  21612e:	83 e2 7f             	and    edx,0x7f
  216131:	89 de                	mov    esi,ebx
  216133:	83 e6 3f             	and    esi,0x3f
  216136:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  21613b:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  216140:	48 39 d6             	cmp    rsi,rdx
  216143:	0f 85 6c 04 00 00    	jne    2165b5 <getLineNumberInfo+0x1d75>
        result |= operand;
  216149:	48 09 cd             	or     rbp,rcx
        if ((byte & 0b10000000) == 0) return result;
  21614c:	84 c0                	test   al,al
  21614e:	0f 89 e7 00 00 00    	jns    21623b <getLineNumberInfo+0x19fb>
        shift += 7;
  216154:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  216158:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  21615d:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  216162:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  216169:	00 00 
            return self.readFn(self, buffer);
  21616b:	4c 89 e7             	mov    rdi,r12
  21616e:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  216173:	4c 89 ea             	mov    rdx,r13
  216176:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21617a:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21617f:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  216184:	66 85 c0             	test   ax,ax
  216187:	74 93                	je     21611c <getLineNumberInfo+0x18dc>
  216189:	e9 2b 04 00 00       	jmp    2165b9 <getLineNumberInfo+0x1d79>
                result = (result << 8) | b;
  21618e:	48 c1 e0 08          	shl    rax,0x8
  216192:	48 09 c8             	or     rax,rcx
  216195:	48 c1 e0 08          	shl    rax,0x8
  216199:	0f b6 4c 24 4a       	movzx  ecx,BYTE PTR [rsp+0x4a]
  21619e:	48 09 c1             	or     rcx,rax
  2161a1:	48 c1 e1 08          	shl    rcx,0x8
  2161a5:	0f b6 44 24 4b       	movzx  eax,BYTE PTR [rsp+0x4b]
  2161aa:	48 09 c8             	or     rax,rcx
  2161ad:	48 c1 e0 08          	shl    rax,0x8
  2161b1:	0f b6 4c 24 4c       	movzx  ecx,BYTE PTR [rsp+0x4c]
  2161b6:	48 09 c1             	or     rcx,rax
  2161b9:	48 c1 e1 08          	shl    rcx,0x8
  2161bd:	0f b6 44 24 4d       	movzx  eax,BYTE PTR [rsp+0x4d]
  2161c2:	48 09 c8             	or     rax,rcx
  2161c5:	48 c1 e0 08          	shl    rax,0x8
  2161c9:	0f b6 4c 24 4e       	movzx  ecx,BYTE PTR [rsp+0x4e]
  2161ce:	48 09 c1             	or     rcx,rax
  2161d1:	48 c1 e1 08          	shl    rcx,0x8
  2161d5:	0f b6 44 24 4f       	movzx  eax,BYTE PTR [rsp+0x4f]
  2161da:	48 09 c8             	or     rax,rcx
                        prog.address = addr;
  2161dd:	48 89 84 24 e0 00 00 	mov    QWORD PTR [rsp+0xe0],rax
  2161e4:	00 
  2161e5:	e9 45 f9 ff ff       	jmp    215b2f <getLineNumberInfo+0x12ef>
                        prog.address += arg * minimum_instruction_length;
  2161ea:	49 0f af df          	imul   rbx,r15
  2161ee:	48 01 9c 24 e0 00 00 	add    QWORD PTR [rsp+0xe0],rbx
  2161f5:	00 
  2161f6:	e9 34 f9 ff ff       	jmp    215b2f <getLineNumberInfo+0x12ef>
            if (shift < @sizeOf(i64) * 8 and (byte & 0b01000000) != 0) result |= -(i64(1) << @intCast(u6, shift));
  2161fb:	48 83 fb 3f          	cmp    rbx,0x3f
  2161ff:	77 13                	ja     216214 <getLineNumberInfo+0x19d4>
  216201:	24 40                	and    al,0x40
  216203:	74 0f                	je     216214 <getLineNumberInfo+0x19d4>
  216205:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  21620c:	c4 e2 e1 f7 c0       	shlx   rax,rax,rbx
  216211:	48 09 c5             	or     rbp,rax
                        prog.line += arg;
  216214:	48 01 ac 24 f0 00 00 	add    QWORD PTR [rsp+0xf0],rbp
  21621b:	00 
  21621c:	e9 0e f9 ff ff       	jmp    215b2f <getLineNumberInfo+0x12ef>
                        prog.file = arg;
  216221:	48 89 9c 24 e8 00 00 	mov    QWORD PTR [rsp+0xe8],rbx
  216228:	00 
  216229:	e9 01 f9 ff ff       	jmp    215b2f <getLineNumberInfo+0x12ef>
                        prog.column = arg;
  21622e:	48 89 9c 24 f8 00 00 	mov    QWORD PTR [rsp+0xf8],rbx
  216235:	00 
  216236:	e9 f4 f8 ff ff       	jmp    215b2f <getLineNumberInfo+0x12ef>
            try self.readNoEof(result[0..]);
  21623b:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  216240:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  216245:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21624c:	00 00 
            return self.readFn(self, buffer);
  21624e:	4c 89 e7             	mov    rdi,r12
  216251:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  216256:	4c 89 ea             	mov    rdx,r13
  216259:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21625d:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  216262:	66 85 c0             	test   ax,ax
  216265:	0f 85 e0 03 00 00    	jne    21664b <getLineNumberInfo+0x1e0b>
  21626b:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  216270:	45 31 f6             	xor    r14d,r14d
  216273:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  216275:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  21627a:	0f 82 c1 03 00 00    	jb     216641 <getLineNumberInfo+0x1e01>
            return result[0];
  216280:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  216285:	89 c2                	mov    edx,eax
  216287:	83 e2 7f             	and    edx,0x7f
  21628a:	89 de                	mov    esi,ebx
  21628c:	83 e6 3f             	and    esi,0x3f
  21628f:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  216294:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  216299:	48 39 d6             	cmp    rsi,rdx
  21629c:	0f 85 a5 03 00 00    	jne    216647 <getLineNumberInfo+0x1e07>
        result |= operand;
  2162a2:	49 09 ce             	or     r14,rcx
        if ((byte & 0b10000000) == 0) return result;
  2162a5:	84 c0                	test   al,al
  2162a7:	79 3a                	jns    2162e3 <getLineNumberInfo+0x1aa3>
        shift += 7;
  2162a9:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  2162ad:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2162b2:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2162b7:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2162be:	00 00 
            return self.readFn(self, buffer);
  2162c0:	4c 89 e7             	mov    rdi,r12
  2162c3:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2162c8:	4c 89 ea             	mov    rdx,r13
  2162cb:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  2162cf:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2162d4:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  2162d9:	66 85 c0             	test   ax,ax
  2162dc:	74 97                	je     216275 <getLineNumberInfo+0x1a35>
  2162de:	e9 68 03 00 00       	jmp    21664b <getLineNumberInfo+0x1e0b>
            try self.readNoEof(result[0..]);
  2162e3:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  2162e8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  2162ed:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  2162f4:	00 00 
            return self.readFn(self, buffer);
  2162f6:	4c 89 e7             	mov    rdi,r12
  2162f9:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  2162fe:	4c 89 ea             	mov    rdx,r13
  216301:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  216305:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
            const amt_read = try self.read(buf);
  21630a:	66 85 c0             	test   ax,ax
  21630d:	0f 85 bc 04 00 00    	jne    2167cf <getLineNumberInfo+0x1f8f>
  216313:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  216318:	31 c0                	xor    eax,eax
  21631a:	48 89 44 24 68       	mov    QWORD PTR [rsp+0x68],rax
  21631f:	31 db                	xor    ebx,ebx
            if (amt_read < buf.len) return error.EndOfStream;
  216321:	48 3b 4c 24 10       	cmp    rcx,QWORD PTR [rsp+0x10]
  216326:	0f 82 99 04 00 00    	jb     2167c5 <getLineNumberInfo+0x1f85>
            return result[0];
  21632c:	0f b6 44 24 48       	movzx  eax,BYTE PTR [rsp+0x48]
        if (@shlWithOverflow(u64, byte & 0b01111111, @intCast(u6, shift), &operand)) return error.InvalidDebugInfo;
  216331:	89 c2                	mov    edx,eax
  216333:	83 e2 7f             	and    edx,0x7f
  216336:	89 de                	mov    esi,ebx
  216338:	83 e6 3f             	and    esi,0x3f
  21633b:	c4 e2 c9 f7 ca       	shlx   rcx,rdx,rsi
  216340:	c4 e2 cb f7 f1       	shrx   rsi,rcx,rsi
  216345:	48 39 d6             	cmp    rsi,rdx
  216348:	0f 85 7d 04 00 00    	jne    2167cb <getLineNumberInfo+0x1f8b>
        result |= operand;
  21634e:	48 09 4c 24 68       	or     QWORD PTR [rsp+0x68],rcx
        if ((byte & 0b10000000) == 0) return result;
  216353:	84 c0                	test   al,al
  216355:	79 3a                	jns    216391 <getLineNumberInfo+0x1b51>
        shift += 7;
  216357:	48 83 c3 07          	add    rbx,0x7
            try self.readNoEof(result[0..]);
  21635b:	48 8d 44 24 48       	lea    rax,[rsp+0x48]
  216360:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  216365:	48 c7 44 24 10 01 00 	mov    QWORD PTR [rsp+0x10],0x1
  21636c:	00 00 
            return self.readFn(self, buffer);
  21636e:	4c 89 e7             	mov    rdi,r12
  216371:	48 8d 74 24 40       	lea    rsi,[rsp+0x40]
  216376:	4c 89 ea             	mov    rdx,r13
  216379:	ff 54 24 40          	call   QWORD PTR [rsp+0x40]
  21637d:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  216382:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
            const amt_read = try self.read(buf);
  216387:	66 85 c0             	test   ax,ax
  21638a:	74 95                	je     216321 <getLineNumberInfo+0x1ae1>
  21638c:	e9 3e 04 00 00       	jmp    2167cf <getLineNumberInfo+0x1f8f>
                        try file_entries.append(FileEntry{
  216391:	c5 f9 6f 84 24 d0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1d0]
  216398:	00 00 
  21639a:	c5 f9 7f 84 24 f0 01 	vmovdqa XMMWORD PTR [rsp+0x1f0],xmm0
  2163a1:	00 00 
            const new_length = self.len + 1;
  2163a3:	48 8b 9c 24 80 00 00 	mov    rbx,QWORD PTR [rsp+0x80]
  2163aa:	00 
            var better_capacity = self.items.len;
  2163ab:	48 8b 4c 24 78       	mov    rcx,QWORD PTR [rsp+0x78]
            if (better_capacity >= new_capacity) return;
  2163b0:	48 39 d9             	cmp    rcx,rbx
  2163b3:	76 05                	jbe    2163ba <getLineNumberInfo+0x1b7a>
            const result = &self.items[self.len];
  2163b5:	48 89 d8             	mov    rax,rbx
  2163b8:	eb 4c                	jmp    216406 <getLineNumberInfo+0x1bc6>
                better_capacity += better_capacity / 2 + 8;
  2163ba:	48 89 c8             	mov    rax,rcx
  2163bd:	48 d1 e8             	shr    rax,1
  2163c0:	48 01 c1             	add    rcx,rax
  2163c3:	48 83 c1 08          	add    rcx,0x8
                if (better_capacity >= new_capacity) break;
  2163c7:	48 39 d9             	cmp    rcx,rbx
  2163ca:	76 ee                	jbe    2163ba <getLineNumberInfo+0x1b7a>
            self.items = try self.allocator.alignedRealloc(T, A, self.items, better_capacity);
  2163cc:	48 8b b4 24 88 00 00 	mov    rsi,QWORD PTR [rsp+0x88]
  2163d3:	00 
  2163d4:	4c 89 e7             	mov    rdi,r12
  2163d7:	48 8d 54 24 70       	lea    rdx,[rsp+0x70]
  2163dc:	e8 df 13 00 00       	call   2177c0 <Allocator_alignedRealloc.79>
  2163e1:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  2163e6:	66 85 c0             	test   ax,ax
  2163e9:	0f 85 5f 04 00 00    	jne    21684e <getLineNumberInfo+0x200e>
  2163ef:	48 8d 44 24 28       	lea    rax,[rsp+0x28]
  2163f4:	c5 fa 6f 00          	vmovdqu xmm0,XMMWORD PTR [rax]
  2163f8:	c5 f9 7f 44 24 70    	vmovdqa XMMWORD PTR [rsp+0x70],xmm0
            const result = &self.items[self.len];
  2163fe:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  216405:	00 
  216406:	48 83 c3 01          	add    rbx,0x1
  21640a:	48 8b 4c 24 70       	mov    rcx,QWORD PTR [rsp+0x70]
  21640f:	48 8d 04 80          	lea    rax,[rax+rax*4]
            self.len = new_length;
  216413:	48 89 9c 24 80 00 00 	mov    QWORD PTR [rsp+0x80],rbx
  21641a:	00 
            new_item_ptr.* = item;
  21641b:	c5 f9 6f 84 24 f0 01 	vmovdqa xmm0,XMMWORD PTR [rsp+0x1f0]
  216422:	00 00 
  216424:	c5 fa 7f 04 c1       	vmovdqu XMMWORD PTR [rcx+rax*8],xmm0
  216429:	48 89 6c c1 10       	mov    QWORD PTR [rcx+rax*8+0x10],rbp
  21642e:	4c 89 74 c1 18       	mov    QWORD PTR [rcx+rax*8+0x18],r14
  216433:	48 8b 54 24 68       	mov    rdx,QWORD PTR [rsp+0x68]
  216438:	48 89 54 c1 20       	mov    QWORD PTR [rcx+rax*8+0x20],rdx
  21643d:	e9 ed f6 ff ff       	jmp    215b2f <getLineNumberInfo+0x12ef>
  216442:	c5 fc 10 05 fe 00 ff 	vmovups ymm0,YMMWORD PTR [rip+0xffffffffffff00fe]        # 206548 <__unnamed_79+0x10>
  216449:	ff 
  21644a:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  21644e:	c5 fc 11 40 10       	vmovups YMMWORD PTR [rax+0x10],ymm0
  216453:	c5 fe 6f 05 dd 00 ff 	vmovdqu ymm0,YMMWORD PTR [rip+0xffffffffffff00dd]        # 206538 <__unnamed_79>
  21645a:	ff 
  21645b:	e9 e7 e6 ff ff       	jmp    214b47 <getLineNumberInfo+0x307>
  216460:	66 b8 20 00          	mov    ax,0x20
  216464:	eb 22                	jmp    216488 <getLineNumberInfo+0x1c48>
  216466:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
            try file_entries.append(FileEntry{
  21646a:	66 89 01             	mov    WORD PTR [rcx],ax
  21646d:	c5 fc 10 84 24 d6 06 	vmovups ymm0,YMMWORD PTR [rsp+0x6d6]
  216474:	00 00 
  216476:	c5 fc 10 8c 24 e4 06 	vmovups ymm1,YMMWORD PTR [rsp+0x6e4]
  21647d:	00 00 
  21647f:	e9 e1 e7 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  216484:	66 b8 25 00          	mov    ax,0x25
  216488:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                const op_size = try readULeb128(in_stream);
  21648c:	66 89 01             	mov    WORD PTR [rcx],ax
  21648f:	c5 fe 6f 84 24 4c 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x64c]
  216496:	00 00 
  216498:	c5 fc 10 8c 24 5a 06 	vmovups ymm1,YMMWORD PTR [rsp+0x65a]
  21649f:	00 00 
  2164a1:	e9 bf e7 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  2164a6:	66 b9 20 00          	mov    cx,0x20
  2164aa:	e9 af f4 ff ff       	jmp    21595e <getLineNumberInfo+0x111e>
  2164af:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                if (try prog.checkLineMatch()) |info| return info;
  2164b3:	66 89 01             	mov    WORD PTR [rcx],ax
  2164b6:	c5 fc 10 84 24 80 04 	vmovups ymm0,YMMWORD PTR [rsp+0x480]
  2164bd:	00 00 
  2164bf:	c5 fc 10 8c 24 8e 04 	vmovups ymm1,YMMWORD PTR [rsp+0x48e]
  2164c6:	00 00 
  2164c8:	e9 98 e7 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  2164cd:	48 8b 84 24 68 02 00 	mov    rax,QWORD PTR [rsp+0x268]
  2164d4:	00 
  2164d5:	48 89 84 24 08 03 00 	mov    QWORD PTR [rsp+0x308],rax
  2164dc:	00 
  2164dd:	c5 fc 10 84 24 48 02 	vmovups ymm0,YMMWORD PTR [rsp+0x248]
  2164e4:	00 00 
  2164e6:	c5 fc 11 84 24 e8 02 	vmovups YMMWORD PTR [rsp+0x2e8],ymm0
  2164ed:	00 00 
  2164ef:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  2164f3:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  2164f8:	c5 fc 10 84 24 e2 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2e2]
  2164ff:	00 00 
  216501:	c5 fc 10 8c 24 f0 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2f0]
  216508:	00 00 
  21650a:	e9 68 f4 ff ff       	jmp    215977 <getLineNumberInfo+0x1137>
  21650f:	66 b8 20 00          	mov    ax,0x20
  216513:	eb 16                	jmp    21652b <getLineNumberInfo+0x1ceb>
  216515:	66 b8 20 00          	mov    ax,0x20
  216519:	eb 32                	jmp    21654d <getLineNumberInfo+0x1d0d>
  21651b:	66 b8 20 00          	mov    ax,0x20
  21651f:	eb 4e                	jmp    21656f <getLineNumberInfo+0x1d2f>
  216521:	66 b8 20 00          	mov    ax,0x20
  216525:	eb 6a                	jmp    216591 <getLineNumberInfo+0x1d51>
  216527:	66 b8 25 00          	mov    ax,0x25
  21652b:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  21652f:	66 89 01             	mov    WORD PTR [rcx],ax
  216532:	c5 fc 10 84 24 f6 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3f6]
  216539:	00 00 
  21653b:	c5 fc 10 8c 24 04 04 	vmovups ymm1,YMMWORD PTR [rsp+0x404]
  216542:	00 00 
  216544:	e9 1c e7 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  216549:	66 b8 25 00          	mov    ax,0x25
  21654d:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readILeb128(in_stream);
  216551:	66 89 01             	mov    WORD PTR [rcx],ax
  216554:	c5 fc 10 84 24 c8 03 	vmovups ymm0,YMMWORD PTR [rsp+0x3c8]
  21655b:	00 00 
  21655d:	c5 fc 10 8c 24 d6 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3d6]
  216564:	00 00 
  216566:	e9 fa e6 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  21656b:	66 b8 25 00          	mov    ax,0x25
  21656f:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  216573:	66 89 01             	mov    WORD PTR [rcx],ax
  216576:	c5 fc 10 84 24 9a 03 	vmovups ymm0,YMMWORD PTR [rsp+0x39a]
  21657d:	00 00 
  21657f:	c5 fc 10 8c 24 a8 03 	vmovups ymm1,YMMWORD PTR [rsp+0x3a8]
  216586:	00 00 
  216588:	e9 d8 e6 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  21658d:	66 b8 25 00          	mov    ax,0x25
  216591:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try readULeb128(in_stream);
  216595:	66 89 01             	mov    WORD PTR [rcx],ax
  216598:	c5 fc 10 84 24 6c 03 	vmovups ymm0,YMMWORD PTR [rsp+0x36c]
  21659f:	00 00 
  2165a1:	c5 fc 10 8c 24 7a 03 	vmovups ymm1,YMMWORD PTR [rsp+0x37a]
  2165a8:	00 00 
  2165aa:	e9 b6 e6 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  2165af:	66 b8 20 00          	mov    ax,0x20
  2165b3:	eb 04                	jmp    2165b9 <getLineNumberInfo+0x1d79>
  2165b5:	66 b8 25 00          	mov    ax,0x25
  2165b9:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const dir_index = try readULeb128(in_stream);
  2165bd:	66 89 01             	mov    WORD PTR [rcx],ax
  2165c0:	c5 fc 10 84 24 38 05 	vmovups ymm0,YMMWORD PTR [rsp+0x538]
  2165c7:	00 00 
  2165c9:	c5 fc 10 8c 24 46 05 	vmovups ymm1,YMMWORD PTR [rsp+0x546]
  2165d0:	00 00 
  2165d2:	e9 8e e6 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  2165d7:	66 b8 20 00          	mov    ax,0x20
  2165db:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                sub_op = try in_stream.readByte();
  2165df:	66 89 01             	mov    WORD PTR [rcx],ax
  2165e2:	c5 fe 6f 84 24 1e 06 	vmovdqu ymm0,YMMWORD PTR [rsp+0x61e]
  2165e9:	00 00 
  2165eb:	c5 fc 10 8c 24 2c 06 	vmovups ymm1,YMMWORD PTR [rsp+0x62c]
  2165f2:	00 00 
  2165f4:	e9 6c e6 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
                        prog.end_sequence = true;
  2165f9:	c6 84 24 02 01 00 00 	mov    BYTE PTR [rsp+0x102],0x1
  216600:	01 
  216601:	48 8d bc 24 78 02 00 	lea    rdi,[rsp+0x278]
  216608:	00 
  216609:	48 8d b4 24 e0 00 00 	lea    rsi,[rsp+0xe0]
  216610:	00 
                        if (try prog.checkLineMatch()) |info| return info;
  216611:	e8 1a 08 00 00       	call   216e30 <LineNumberProgram_checkLineMatch>
  216616:	0f b7 84 24 78 02 00 	movzx  eax,WORD PTR [rsp+0x278]
  21661d:	00 
  21661e:	66 85 c0             	test   ax,ax
  216621:	74 46                	je     216669 <getLineNumberInfo+0x1e29>
  216623:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
  216627:	66 89 01             	mov    WORD PTR [rcx],ax
  21662a:	c5 fc 10 84 24 c2 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5c2]
  216631:	00 00 
  216633:	c5 fc 10 8c 24 d0 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5d0]
  21663a:	00 00 
  21663c:	e9 24 e6 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  216641:	66 b8 20 00          	mov    ax,0x20
  216645:	eb 04                	jmp    21664b <getLineNumberInfo+0x1e0b>
  216647:	66 b8 25 00          	mov    ax,0x25
  21664b:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const mtime = try readULeb128(in_stream);
  21664f:	66 89 01             	mov    WORD PTR [rcx],ax
  216652:	c5 fc 10 84 24 0a 05 	vmovups ymm0,YMMWORD PTR [rsp+0x50a]
  216659:	00 00 
  21665b:	c5 fc 10 8c 24 18 05 	vmovups ymm1,YMMWORD PTR [rsp+0x518]
  216662:	00 00 
  216664:	e9 fc e5 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
                        if (try prog.checkLineMatch()) |info| return info;
  216669:	80 bc 24 a8 02 00 00 	cmp    BYTE PTR [rsp+0x2a8],0x1
  216670:	01 
  216671:	0f 85 b7 e4 ff ff    	jne    214b2e <getLineNumberInfo+0x2ee>
  216677:	48 8b 84 24 a0 02 00 	mov    rax,QWORD PTR [rsp+0x2a0]
  21667e:	00 
  21667f:	48 89 84 24 36 03 00 	mov    QWORD PTR [rsp+0x336],rax
  216686:	00 
  216687:	c5 fc 10 84 24 80 02 	vmovups ymm0,YMMWORD PTR [rsp+0x280]
  21668e:	00 00 
  216690:	c5 fc 11 84 24 16 03 	vmovups YMMWORD PTR [rsp+0x316],ymm0
  216697:	00 00 
  216699:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  21669d:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  2166a2:	c5 fc 10 84 24 10 03 	vmovups ymm0,YMMWORD PTR [rsp+0x310]
  2166a9:	00 00 
  2166ab:	c5 fc 10 8c 24 1e 03 	vmovups ymm1,YMMWORD PTR [rsp+0x31e]
  2166b2:	00 00 
  2166b4:	e9 be f2 ff ff       	jmp    215977 <getLineNumberInfo+0x1137>
  2166b9:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        if (try prog.checkLineMatch()) |info| return info;
  2166bd:	66 89 01             	mov    WORD PTR [rcx],ax
  2166c0:	c5 fc 10 84 24 24 04 	vmovups ymm0,YMMWORD PTR [rsp+0x424]
  2166c7:	00 00 
  2166c9:	c5 fc 10 8c 24 32 04 	vmovups ymm1,YMMWORD PTR [rsp+0x432]
  2166d0:	00 00 
  2166d2:	e9 8e e5 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  2166d7:	48 8b 84 24 30 02 00 	mov    rax,QWORD PTR [rsp+0x230]
  2166de:	00 
  2166df:	48 89 84 24 da 02 00 	mov    QWORD PTR [rsp+0x2da],rax
  2166e6:	00 
  2166e7:	c5 fc 10 84 24 10 02 	vmovups ymm0,YMMWORD PTR [rsp+0x210]
  2166ee:	00 00 
  2166f0:	c5 fc 11 84 24 ba 02 	vmovups YMMWORD PTR [rsp+0x2ba],ymm0
  2166f7:	00 00 
  2166f9:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  2166fd:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  216702:	c5 fc 10 84 24 b4 02 	vmovups ymm0,YMMWORD PTR [rsp+0x2b4]
  216709:	00 00 
  21670b:	c5 fc 10 8c 24 c2 02 	vmovups ymm1,YMMWORD PTR [rsp+0x2c2]
  216712:	00 00 
  216714:	e9 5e f2 ff ff       	jmp    215977 <getLineNumberInfo+0x1137>
  216719:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  21671d:	48 83 f8 17          	cmp    rax,0x17
  216721:	0f 87 c6 00 00 00    	ja     2167ed <getLineNumberInfo+0x1fad>
  216727:	48 8d 0d e6 af fe ff 	lea    rcx,[rip+0xfffffffffffeafe6]        # 201714 <__unnamed_9+0xa34>
  21672e:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  216732:	48 01 c8             	add    rax,rcx
  216735:	ff e0                	jmp    rax
  216737:	66 b8 1e 00          	mov    ax,0x1e
  21673b:	e9 c9 00 00 00       	jmp    216809 <getLineNumberInfo+0x1fc9>
  216740:	66 b8 20 00          	mov    ax,0x20
  216744:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const arg = try in_stream.readInt(st.elf.endian, u16);
  216748:	66 89 01             	mov    WORD PTR [rcx],ax
  21674b:	c5 fc 10 84 24 3e 03 	vmovups ymm0,YMMWORD PTR [rsp+0x33e]
  216752:	00 00 
  216754:	c5 fc 10 8c 24 4c 03 	vmovups ymm1,YMMWORD PTR [rsp+0x34c]
  21675b:	00 00 
  21675d:	e9 03 e5 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  216762:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const file_name = try st.readString();
  216766:	66 89 01             	mov    WORD PTR [rcx],ax
  216769:	c5 fc 10 84 24 66 05 	vmovups ymm0,YMMWORD PTR [rsp+0x566]
  216770:	00 00 
  216772:	c5 fc 10 8c 24 74 05 	vmovups ymm1,YMMWORD PTR [rsp+0x574]
  216779:	00 00 
  21677b:	e9 e5 e4 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  216780:	48 8d 41 fa          	lea    rax,[rcx-0x6]
  216784:	48 83 f8 17          	cmp    rax,0x17
  216788:	77 6f                	ja     2167f9 <getLineNumberInfo+0x1fb9>
  21678a:	48 8d 0d e3 af fe ff 	lea    rcx,[rip+0xfffffffffffeafe3]        # 201774 <__unnamed_9+0xa94>
  216791:	48 63 04 81          	movsxd rax,DWORD PTR [rcx+rax*4]
  216795:	48 01 c8             	add    rax,rcx
  216798:	ff e0                	jmp    rax
  21679a:	66 b8 22 00          	mov    ax,0x22
  21679e:	e9 88 00 00 00       	jmp    21682b <getLineNumberInfo+0x1feb>
  2167a3:	66 b8 20 00          	mov    ax,0x20
  2167a7:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const addr = try in_stream.readInt(st.elf.endian, usize);
  2167ab:	66 89 01             	mov    WORD PTR [rcx],ax
  2167ae:	c5 fe 6f 84 24 94 05 	vmovdqu ymm0,YMMWORD PTR [rsp+0x594]
  2167b5:	00 00 
  2167b7:	c5 fc 10 8c 24 a2 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5a2]
  2167be:	00 00 
  2167c0:	e9 a0 e4 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  2167c5:	66 b8 20 00          	mov    ax,0x20
  2167c9:	eb 04                	jmp    2167cf <getLineNumberInfo+0x1f8f>
  2167cb:	66 b8 25 00          	mov    ax,0x25
  2167cf:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        const len_bytes = try readULeb128(in_stream);
  2167d3:	66 89 01             	mov    WORD PTR [rcx],ax
  2167d6:	c5 fc 10 84 24 dc 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4dc]
  2167dd:	00 00 
  2167df:	c5 fc 10 8c 24 ea 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4ea]
  2167e6:	00 00 
  2167e8:	e9 78 e4 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  2167ed:	48 83 f9 4b          	cmp    rcx,0x4b
  2167f1:	75 12                	jne    216805 <getLineNumberInfo+0x1fc5>
  2167f3:	66 b8 22 00          	mov    ax,0x22
  2167f7:	eb 10                	jmp    216809 <getLineNumberInfo+0x1fc9>
  2167f9:	48 83 f9 4b          	cmp    rcx,0x4b
  2167fd:	74 9b                	je     21679a <getLineNumberInfo+0x1f5a>
  2167ff:	66 b8 02 00          	mov    ax,0x2
  216803:	eb 26                	jmp    21682b <getLineNumberInfo+0x1feb>
  216805:	66 b8 02 00          	mov    ax,0x2
  216809:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try in_file.seekForward(len_bytes);
  21680d:	66 89 01             	mov    WORD PTR [rcx],ax
  216810:	c5 fc 10 84 24 52 04 	vmovups ymm0,YMMWORD PTR [rsp+0x452]
  216817:	00 00 
  216819:	c5 fc 10 8c 24 60 04 	vmovups ymm1,YMMWORD PTR [rsp+0x460]
  216820:	00 00 
  216822:	e9 3e e4 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  216827:	66 b8 1e 00          	mov    ax,0x1e
  21682b:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try in_file.seekForward(fwd_amt);
  21682f:	66 89 01             	mov    WORD PTR [rcx],ax
  216832:	c5 fc 10 84 24 f0 05 	vmovups ymm0,YMMWORD PTR [rsp+0x5f0]
  216839:	00 00 
  21683b:	c5 fc 10 8c 24 fe 05 	vmovups ymm1,YMMWORD PTR [rsp+0x5fe]
  216842:	00 00 
  216844:	e9 1c e4 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
            @panic("assertion failure");
  216849:	e8 62 34 ff ff       	call   209cb0 <panic>
  21684e:	48 8b 0c 24          	mov    rcx,QWORD PTR [rsp]
                        try file_entries.append(FileEntry{
  216852:	66 89 01             	mov    WORD PTR [rcx],ax
  216855:	c5 fc 10 84 24 ae 04 	vmovups ymm0,YMMWORD PTR [rsp+0x4ae]
  21685c:	00 00 
  21685e:	c5 fc 10 8c 24 bc 04 	vmovups ymm1,YMMWORD PTR [rsp+0x4bc]
  216865:	00 00 
  216867:	e9 f9 e3 ff ff       	jmp    214c65 <getLineNumberInfo+0x425>
  21686c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000216870 <printLineFromFile>:
fn printLineFromFile(allocator: *mem.Allocator, out_stream: var, line_info: *const LineInfo) !void {
  216870:	55                   	push   rbp
  216871:	41 57                	push   r15
  216873:	41 56                	push   r14
  216875:	41 55                	push   r13
  216877:	41 54                	push   r12
  216879:	53                   	push   rbx
  21687a:	48 81 ec 58 10 00 00 	sub    rsp,0x1058
  216881:	48 89 d3             	mov    rbx,rdx
  216884:	49 89 f6             	mov    r14,rsi
  216887:	48 89 f8             	mov    rax,rdi
    var f = try os.File.openRead(allocator, line_info.file_name);
  21688a:	48 8d 53 10          	lea    rdx,[rbx+0x10]
  21688e:	48 8d 7c 24 38       	lea    rdi,[rsp+0x38]
  216893:	48 89 c6             	mov    rsi,rax
  216896:	e8 a5 96 ff ff       	call   20ff40 <File_openRead>
  21689b:	0f b7 6c 24 38       	movzx  ebp,WORD PTR [rsp+0x38]
  2168a0:	66 85 ed             	test   bp,bp
  2168a3:	74 07                	je     2168ac <printLineFromFile+0x3c>
  2168a5:	89 e8                	mov    eax,ebp
  2168a7:	e9 8e 02 00 00       	jmp    216b3a <printLineFromFile+0x2ca>
  2168ac:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
  2168b1:	48 63 5c 24 3c       	movsxd rbx,DWORD PTR [rsp+0x3c]
  2168b6:	89 5c 24 08          	mov    DWORD PTR [rsp+0x8],ebx
    var buf: [os.page_size]u8 = undefined;
  2168ba:	48 8d 35 0e fe fe ff 	lea    rsi,[rip+0xfffffffffffefe0e]        # 2066cf <__unnamed_80>
  2168c1:	48 8d 6c 24 58       	lea    rbp,[rsp+0x58]
  2168c6:	ba 00 10 00 00       	mov    edx,0x1000
  2168cb:	48 89 ef             	mov    rdi,rbp
  2168ce:	e8 6d 28 00 00       	call   219140 <memcpy>
        const amt_read = try f.read(buf[0..]);
  2168d3:	48 89 6c 24 28       	mov    QWORD PTR [rsp+0x28],rbp
  2168d8:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  2168df:	00 00 
  2168e1:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  2168e6:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  2168eb:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  2168f0:	e8 2b 9c ff ff       	call   210520 <File_read>
  2168f5:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  2168fb:	74 40                	je     21693d <printLineFromFile+0xcd>
  2168fd:	0f 1f 00             	nop    DWORD PTR [rax]
    return asm volatile ("syscall"
  216900:	b8 03 00 00 00       	mov    eax,0x3
  216905:	48 89 df             	mov    rdi,rbx
  216908:	0f 05                	syscall 
            switch (err) {
  21690a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  21690e:	74 f0                	je     216900 <printLineFromFile+0x90>
            const first = list.first orelse return null;
  216910:	48 8b 05 39 a7 00 00 	mov    rax,QWORD PTR [rip+0xa739]        # 221050 <emfile_promise_queue>
  216917:	48 85 c0             	test   rax,rax
  21691a:	0f 84 15 02 00 00    	je     216b35 <printLineFromFile+0x2c5>
            if (node.prev) |prev_node| {
  216920:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  216923:	48 85 c9             	test   rcx,rcx
  216926:	0f 84 a5 01 00 00    	je     216ad1 <printLineFromFile+0x261>
                prev_node.next = node.next;
  21692c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  216930:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  216934:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216938:	e9 9f 01 00 00       	jmp    216adc <printLineFromFile+0x26c>
  21693d:	41 bc 01 00 00 00    	mov    r12d,0x1
  216943:	4c 89 74 24 40       	mov    QWORD PTR [rsp+0x40],r14
  216948:	4c 8b 6c 24 20       	mov    r13,QWORD PTR [rsp+0x20]
        for (slice) |byte| {
  21694d:	4d 85 ed             	test   r13,r13
  216950:	0f 84 3a 01 00 00    	je     216a90 <printLineFromFile+0x220>
  216956:	45 31 ff             	xor    r15d,r15d
  216959:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  21695e:	66 90                	xchg   ax,ax
  216960:	46 0f b6 74 3c 58    	movzx  r14d,BYTE PTR [rsp+r15*1+0x58]
            if (line == line_info.line) {
  216966:	4c 3b 21             	cmp    r12,QWORD PTR [rcx]
  216969:	75 45                	jne    2169b0 <printLineFromFile+0x140>
  21696b:	44 88 74 24 07       	mov    BYTE PTR [rsp+0x7],r14b
            const slice = (*[1]u8)(&byte)[0..];
  216970:	48 8d 44 24 07       	lea    rax,[rsp+0x7]
  216975:	48 89 44 24 48       	mov    QWORD PTR [rsp+0x48],rax
  21697a:	48 c7 44 24 50 01 00 	mov    QWORD PTR [rsp+0x50],0x1
  216981:	00 00 
  216983:	48 8b 7c 24 40       	mov    rdi,QWORD PTR [rsp+0x40]
            return self.writeFn(self, slice);
  216988:	48 8d 74 24 48       	lea    rsi,[rsp+0x48]
  21698d:	ff 17                	call   QWORD PTR [rdi]
  21698f:	89 c5                	mov    ebp,eax
                try out_stream.writeByte(byte);
  216991:	66 85 ed             	test   bp,bp
  216994:	75 7a                	jne    216a10 <printLineFromFile+0x1a0>
                if (byte == '\n') {
  216996:	41 80 fe 0a          	cmp    r14b,0xa
  21699a:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
  21699f:	0f 84 ab 00 00 00    	je     216a50 <printLineFromFile+0x1e0>
        for (slice) |byte| {
  2169a5:	49 83 c7 01          	add    r15,0x1
  2169a9:	4d 39 ef             	cmp    r15,r13
  2169ac:	72 b2                	jb     216960 <printLineFromFile+0xf0>
  2169ae:	eb 15                	jmp    2169c5 <printLineFromFile+0x155>
            if (byte == '\n') {
  2169b0:	31 c0                	xor    eax,eax
  2169b2:	41 80 fe 0a          	cmp    r14b,0xa
  2169b6:	0f 94 c0             	sete   al
  2169b9:	49 01 c4             	add    r12,rax
        for (slice) |byte| {
  2169bc:	49 83 c7 01          	add    r15,0x1
  2169c0:	4d 39 ef             	cmp    r15,r13
  2169c3:	72 9b                	jb     216960 <printLineFromFile+0xf0>
        if (amt_read < buf.len) return error.EndOfFile;
  2169c5:	49 81 fd ff 0f 00 00 	cmp    r13,0xfff
  2169cc:	48 8d 44 24 58       	lea    rax,[rsp+0x58]
  2169d1:	0f 86 b9 00 00 00    	jbe    216a90 <printLineFromFile+0x220>
        const amt_read = try f.read(buf[0..]);
  2169d7:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  2169dc:	48 c7 44 24 30 00 10 	mov    QWORD PTR [rsp+0x30],0x1000
  2169e3:	00 00 
  2169e5:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
  2169ea:	48 8d 74 24 08       	lea    rsi,[rsp+0x8]
  2169ef:	48 8d 54 24 28       	lea    rdx,[rsp+0x28]
  2169f4:	e8 27 9b ff ff       	call   210520 <File_read>
  2169f9:	66 83 7c 24 18 00    	cmp    WORD PTR [rsp+0x18],0x0
  2169ff:	0f 84 43 ff ff ff    	je     216948 <printLineFromFile+0xd8>
  216a05:	e9 f6 fe ff ff       	jmp    216900 <printLineFromFile+0x90>
  216a0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  216a10:	b8 03 00 00 00       	mov    eax,0x3
  216a15:	48 89 df             	mov    rdi,rbx
  216a18:	0f 05                	syscall 
  216a1a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  216a1e:	74 f0                	je     216a10 <printLineFromFile+0x1a0>
            const first = list.first orelse return null;
  216a20:	48 8b 05 29 a6 00 00 	mov    rax,QWORD PTR [rip+0xa629]        # 221050 <emfile_promise_queue>
  216a27:	48 85 c0             	test   rax,rax
  216a2a:	0f 84 75 fe ff ff    	je     2168a5 <printLineFromFile+0x35>
            if (node.prev) |prev_node| {
  216a30:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  216a33:	48 85 c9             	test   rcx,rcx
  216a36:	0f 84 10 01 00 00    	je     216b4c <printLineFromFile+0x2dc>
                prev_node.next = node.next;
  216a3c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  216a40:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  216a44:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216a48:	e9 0a 01 00 00       	jmp    216b57 <printLineFromFile+0x2e7>
  216a4d:	0f 1f 00             	nop    DWORD PTR [rax]
  216a50:	b8 03 00 00 00       	mov    eax,0x3
  216a55:	48 89 df             	mov    rdi,rbx
  216a58:	0f 05                	syscall 
  216a5a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  216a5e:	74 f0                	je     216a50 <printLineFromFile+0x1e0>
            const first = list.first orelse return null;
  216a60:	48 8b 05 e9 a5 00 00 	mov    rax,QWORD PTR [rip+0xa5e9]        # 221050 <emfile_promise_queue>
  216a67:	48 85 c0             	test   rax,rax
  216a6a:	0f 84 b5 01 00 00    	je     216c25 <printLineFromFile+0x3b5>
            if (node.prev) |prev_node| {
  216a70:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  216a73:	48 85 c9             	test   rcx,rcx
  216a76:	0f 84 42 01 00 00    	je     216bbe <printLineFromFile+0x34e>
                prev_node.next = node.next;
  216a7c:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  216a80:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  216a84:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216a88:	e9 3c 01 00 00       	jmp    216bc9 <printLineFromFile+0x359>
  216a8d:	0f 1f 00             	nop    DWORD PTR [rax]
  216a90:	b8 03 00 00 00       	mov    eax,0x3
  216a95:	48 89 df             	mov    rdi,rbx
  216a98:	0f 05                	syscall 
  216a9a:	48 83 f8 fc          	cmp    rax,0xfffffffffffffffc
  216a9e:	74 f0                	je     216a90 <printLineFromFile+0x220>
            const first = list.first orelse return null;
  216aa0:	48 8b 05 a9 a5 00 00 	mov    rax,QWORD PTR [rip+0xa5a9]        # 221050 <emfile_promise_queue>
  216aa7:	66 bd 26 00          	mov    bp,0x26
  216aab:	48 85 c0             	test   rax,rax
  216aae:	0f 84 f1 fd ff ff    	je     2168a5 <printLineFromFile+0x35>
            if (node.prev) |prev_node| {
  216ab4:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  216ab7:	48 85 c9             	test   rcx,rcx
  216aba:	0f 84 6c 01 00 00    	je     216c2c <printLineFromFile+0x3bc>
                prev_node.next = node.next;
  216ac0:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
  216ac4:	48 89 51 08          	mov    QWORD PTR [rcx+0x8],rdx
            if (node.next) |next_node| {
  216ac8:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216acc:	e9 66 01 00 00       	jmp    216c37 <printLineFromFile+0x3c7>
                list.first = node.next;
  216ad1:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216ad5:	48 89 0d 74 a5 00 00 	mov    QWORD PTR [rip+0xa574],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  216adc:	48 85 c9             	test   rcx,rcx
  216adf:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  216ae2:	48 8d 35 6f a5 00 00 	lea    rsi,[rip+0xa56f]        # 221058 <emfile_promise_queue+0x8>
  216ae9:	48 0f 45 f1          	cmovne rsi,rcx
  216aed:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  216af0:	48 83 05 68 a5 00 00 	add    QWORD PTR [rip+0xa568],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  216af7:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  216af8:	74 1e                	je     216b18 <printLineFromFile+0x2a8>
  216afa:	48 83 3d 4e a5 00 00 	cmp    QWORD PTR [rip+0xa54e],0x0        # 221050 <emfile_promise_queue>
  216b01:	00 
  216b02:	0f 84 8c 01 00 00    	je     216c94 <printLineFromFile+0x424>
  216b08:	48 8b 0d 49 a5 00 00 	mov    rcx,QWORD PTR [rip+0xa549]        # 221058 <emfile_promise_queue+0x8>
  216b0f:	48 85 c9             	test   rcx,rcx
  216b12:	0f 84 7c 01 00 00    	je     216c94 <printLineFromFile+0x424>
                    if (emfile_promise_queue.popFirst()) |p| resume p.data;
  216b18:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  216b1c:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  216b20:	48 89 c1             	mov    rcx,rax
  216b23:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  216b27:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  216b2d:	75 f1                	jne    216b20 <printLineFromFile+0x2b0>
  216b2f:	a8 01                	test   al,0x1
  216b31:	75 02                	jne    216b35 <printLineFromFile+0x2c5>
  216b33:	ff 17                	call   QWORD PTR [rdi]
  216b35:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  216b3a:	48 81 c4 58 10 00 00 	add    rsp,0x1058
  216b41:	5b                   	pop    rbx
  216b42:	41 5c                	pop    r12
  216b44:	41 5d                	pop    r13
  216b46:	41 5e                	pop    r14
  216b48:	41 5f                	pop    r15
  216b4a:	5d                   	pop    rbp
  216b4b:	c3                   	ret    
                list.first = node.next;
  216b4c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216b50:	48 89 0d f9 a4 00 00 	mov    QWORD PTR [rip+0xa4f9],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  216b57:	48 85 c9             	test   rcx,rcx
  216b5a:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  216b5d:	48 8d 35 f4 a4 00 00 	lea    rsi,[rip+0xa4f4]        # 221058 <emfile_promise_queue+0x8>
  216b64:	48 0f 45 f1          	cmovne rsi,rcx
  216b68:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  216b6b:	48 83 05 ed a4 00 00 	add    QWORD PTR [rip+0xa4ed],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  216b72:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  216b73:	74 1e                	je     216b93 <printLineFromFile+0x323>
  216b75:	48 83 3d d3 a4 00 00 	cmp    QWORD PTR [rip+0xa4d3],0x0        # 221050 <emfile_promise_queue>
  216b7c:	00 
  216b7d:	0f 84 11 01 00 00    	je     216c94 <printLineFromFile+0x424>
  216b83:	48 8b 0d ce a4 00 00 	mov    rcx,QWORD PTR [rip+0xa4ce]        # 221058 <emfile_promise_queue+0x8>
  216b8a:	48 85 c9             	test   rcx,rcx
  216b8d:	0f 84 01 01 00 00    	je     216c94 <printLineFromFile+0x424>
  216b93:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  216b97:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  216b9b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  216ba0:	48 89 c1             	mov    rcx,rax
  216ba3:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  216ba7:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  216bad:	75 f1                	jne    216ba0 <printLineFromFile+0x330>
  216baf:	a8 01                	test   al,0x1
  216bb1:	0f 85 ee fc ff ff    	jne    2168a5 <printLineFromFile+0x35>
  216bb7:	ff 17                	call   QWORD PTR [rdi]
  216bb9:	e9 e7 fc ff ff       	jmp    2168a5 <printLineFromFile+0x35>
                list.first = node.next;
  216bbe:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216bc2:	48 89 0d 87 a4 00 00 	mov    QWORD PTR [rip+0xa487],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  216bc9:	48 85 c9             	test   rcx,rcx
  216bcc:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  216bcf:	48 8d 35 82 a4 00 00 	lea    rsi,[rip+0xa482]        # 221058 <emfile_promise_queue+0x8>
  216bd6:	48 0f 45 f1          	cmovne rsi,rcx
  216bda:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  216bdd:	48 83 05 7b a4 00 00 	add    QWORD PTR [rip+0xa47b],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  216be4:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  216be5:	74 1e                	je     216c05 <printLineFromFile+0x395>
  216be7:	48 83 3d 61 a4 00 00 	cmp    QWORD PTR [rip+0xa461],0x0        # 221050 <emfile_promise_queue>
  216bee:	00 
  216bef:	0f 84 9f 00 00 00    	je     216c94 <printLineFromFile+0x424>
  216bf5:	48 8b 0d 5c a4 00 00 	mov    rcx,QWORD PTR [rip+0xa45c]        # 221058 <emfile_promise_queue+0x8>
  216bfc:	48 85 c9             	test   rcx,rcx
  216bff:	0f 84 8f 00 00 00    	je     216c94 <printLineFromFile+0x424>
  216c05:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  216c09:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  216c0d:	0f 1f 00             	nop    DWORD PTR [rax]
  216c10:	48 89 c1             	mov    rcx,rax
  216c13:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  216c17:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  216c1d:	75 f1                	jne    216c10 <printLineFromFile+0x3a0>
  216c1f:	a8 01                	test   al,0x1
  216c21:	75 02                	jne    216c25 <printLineFromFile+0x3b5>
  216c23:	ff 17                	call   QWORD PTR [rdi]
  216c25:	31 ed                	xor    ebp,ebp
  216c27:	e9 79 fc ff ff       	jmp    2168a5 <printLineFromFile+0x35>
                list.first = node.next;
  216c2c:	48 8b 48 08          	mov    rcx,QWORD PTR [rax+0x8]
  216c30:	48 89 0d 19 a4 00 00 	mov    QWORD PTR [rip+0xa419],rcx        # 221050 <emfile_promise_queue>
            if (node.next) |next_node| {
  216c37:	48 85 c9             	test   rcx,rcx
  216c3a:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  216c3d:	48 8d 35 14 a4 00 00 	lea    rsi,[rip+0xa414]        # 221058 <emfile_promise_queue+0x8>
  216c44:	48 0f 45 f1          	cmovne rsi,rcx
  216c48:	48 89 16             	mov    QWORD PTR [rsi],rdx
            list.len -= 1;
  216c4b:	48 83 05 0d a4 00 00 	add    QWORD PTR [rip+0xa40d],0xffffffffffffffff        # 221060 <emfile_promise_queue+0x10>
  216c52:	ff 
            assert(list.len == 0 or (list.first != null and list.last != null));
  216c53:	74 16                	je     216c6b <printLineFromFile+0x3fb>
  216c55:	48 83 3d f3 a3 00 00 	cmp    QWORD PTR [rip+0xa3f3],0x0        # 221050 <emfile_promise_queue>
  216c5c:	00 
  216c5d:	74 35                	je     216c94 <printLineFromFile+0x424>
  216c5f:	48 8b 0d f2 a3 00 00 	mov    rcx,QWORD PTR [rip+0xa3f2]        # 221058 <emfile_promise_queue+0x8>
  216c66:	48 85 c9             	test   rcx,rcx
  216c69:	74 29                	je     216c94 <printLineFromFile+0x424>
  216c6b:	48 8b 78 10          	mov    rdi,QWORD PTR [rax+0x10]
  216c6f:	48 8b 47 10          	mov    rax,QWORD PTR [rdi+0x10]
  216c73:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  216c7a:	84 00 00 00 00 00 
  216c80:	48 89 c1             	mov    rcx,rax
  216c83:	48 83 e1 fd          	and    rcx,0xfffffffffffffffd
  216c87:	f0 48 0f b1 4f 10    	lock cmpxchg QWORD PTR [rdi+0x10],rcx
  216c8d:	75 f1                	jne    216c80 <printLineFromFile+0x410>
  216c8f:	e9 1b ff ff ff       	jmp    216baf <printLineFromFile+0x33f>
            @panic("assertion failure");
  216c94:	e8 17 30 ff ff       	call   209cb0 <panic>
  216c99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000216ca0 <Allocator_alignedRealloc.71>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  216ca0:	41 56                	push   r14
  216ca2:	53                   	push   rbx
  216ca3:	48 83 ec 78          	sub    rsp,0x78
  216ca7:	49 89 ce             	mov    r14,rcx
  216caa:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  216cad:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  216cb1:	48 85 c0             	test   rax,rax
  216cb4:	74 59                	je     216d0f <Allocator_alignedRealloc.71+0x6f>
        if (n == 0) {
  216cb6:	4d 85 f6             	test   r14,r14
  216cb9:	0f 84 92 00 00 00    	je     216d51 <Allocator_alignedRealloc.71+0xb1>
        const old_byte_slice = @sliceToBytes(old_mem);
  216cbf:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  216cc2:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  216cc7:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  216ccc:	48 8d 7c 24 48       	lea    rdi,[rsp+0x48]
  216cd1:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  216cd6:	41 b8 01 00 00 00    	mov    r8d,0x1
  216cdc:	4c 89 f1             	mov    rcx,r14
  216cdf:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  216ce2:	0f b7 44 24 48       	movzx  eax,WORD PTR [rsp+0x48]
  216ce7:	66 85 c0             	test   ax,ax
  216cea:	0f 84 9e 00 00 00    	je     216d8e <Allocator_alignedRealloc.71+0xee>
  216cf0:	66 89 03             	mov    WORD PTR [rbx],ax
  216cf3:	48 8b 44 24 70       	mov    rax,QWORD PTR [rsp+0x70]
  216cf8:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  216cfc:	c5 f8 10 44 24 62    	vmovups xmm0,XMMWORD PTR [rsp+0x62]
  216d02:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  216d07:	48 83 c4 78          	add    rsp,0x78
  216d0b:	5b                   	pop    rbx
  216d0c:	41 5e                	pop    r14
  216d0e:	c3                   	ret    
        if (n == 0) {
  216d0f:	4d 85 f6             	test   r14,r14
  216d12:	0f 84 a1 00 00 00    	je     216db9 <Allocator_alignedRealloc.71+0x119>
  216d18:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  216d1d:	b9 01 00 00 00       	mov    ecx,0x1
  216d22:	4c 89 f2             	mov    rdx,r14
  216d25:	ff 16                	call   QWORD PTR [rsi]
  216d27:	0f b7 4c 24 20       	movzx  ecx,WORD PTR [rsp+0x20]
  216d2c:	66 85 c9             	test   cx,cx
  216d2f:	0f 84 a6 00 00 00    	je     216ddb <Allocator_alignedRealloc.71+0x13b>
  216d35:	0f b7 44 24 1e       	movzx  eax,WORD PTR [rsp+0x1e]
  216d3a:	66 89 44 24 0c       	mov    WORD PTR [rsp+0xc],ax
  216d3f:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  216d44:	8b 54 24 1a          	mov    edx,DWORD PTR [rsp+0x1a]
  216d48:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
  216d4c:	e9 af 00 00 00       	jmp    216e00 <Allocator_alignedRealloc.71+0x160>
        const bytes = @sliceToBytes(memory);
  216d51:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  216d54:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  216d58:	48 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],rcx
  216d5d:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
  216d62:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  216d67:	48 89 f7             	mov    rdi,rsi
  216d6a:	48 89 c6             	mov    rsi,rax
  216d6d:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  216d6f:	48 8b 05 ba f7 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffef7ba]        # 206530 <__unnamed_81+0x10>
  216d76:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  216d7a:	c5 f8 10 05 9e f7 fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffef79e]        # 206520 <__unnamed_81>
  216d81:	ff 
  216d82:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  216d86:	48 83 c4 78          	add    rsp,0x78
  216d8a:	5b                   	pop    rbx
  216d8b:	41 5e                	pop    r14
  216d8d:	c3                   	ret    
        assert(byte_slice.len == byte_count);
  216d8e:	4c 39 74 24 58       	cmp    QWORD PTR [rsp+0x58],r14
    if (!ok) {
  216d93:	0f 85 87 00 00 00    	jne    216e20 <Allocator_alignedRealloc.71+0x180>
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  216d99:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  216d9e:	0f b7 44 24 12       	movzx  eax,WORD PTR [rsp+0x12]
  216da3:	66 89 43 06          	mov    WORD PTR [rbx+0x6],ax
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  216da7:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  216dac:	8b 4c 24 0e          	mov    ecx,DWORD PTR [rsp+0xe]
  216db0:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  216db3:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  216db7:	eb 5b                	jmp    216e14 <Allocator_alignedRealloc.71+0x174>
  216db9:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
            return ([*]align(alignment) T)(undefined)[0..0];
  216dbe:	0f b7 0d 61 f7 fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffef761]        # 206526 <__unnamed_81+0x6>
  216dc5:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  216dca:	8b 0d 52 f7 fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffef752]        # 206522 <__unnamed_81+0x2>
  216dd0:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  216dd4:	31 c9                	xor    ecx,ecx
  216dd6:	45 31 f6             	xor    r14d,r14d
  216dd9:	eb 25                	jmp    216e00 <Allocator_alignedRealloc.71+0x160>
        assert(byte_slice.len == byte_count);
  216ddb:	4c 39 74 24 30       	cmp    QWORD PTR [rsp+0x30],r14
  216de0:	75 3e                	jne    216e20 <Allocator_alignedRealloc.71+0x180>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  216de2:	48 8b 54 24 28       	mov    rdx,QWORD PTR [rsp+0x28]
  216de7:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  216dec:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  216df0:	89 4c 24 08          	mov    DWORD PTR [rsp+0x8],ecx
  216df4:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  216df9:	66 89 4c 24 0c       	mov    WORD PTR [rsp+0xc],cx
  216dfe:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  216e00:	66 89 0b             	mov    WORD PTR [rbx],cx
  216e03:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  216e07:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  216e0b:	8b 00                	mov    eax,DWORD PTR [rax]
  216e0d:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  216e10:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  216e14:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  216e18:	48 83 c4 78          	add    rsp,0x78
  216e1c:	5b                   	pop    rbx
  216e1d:	41 5e                	pop    r14
  216e1f:	c3                   	ret    
            @panic("assertion failure");
  216e20:	e8 8b 2e ff ff       	call   209cb0 <panic>
  216e25:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  216e2c:	00 00 00 00 

0000000000216e30 <LineNumberProgram_checkLineMatch>:
    pub fn checkLineMatch(self: *LineNumberProgram) !?LineInfo {
  216e30:	55                   	push   rbp
  216e31:	41 57                	push   r15
  216e33:	41 56                	push   r14
  216e35:	41 55                	push   r13
  216e37:	41 54                	push   r12
  216e39:	53                   	push   rbx
  216e3a:	48 83 ec 78          	sub    rsp,0x78
  216e3e:	48 89 f3             	mov    rbx,rsi
  216e41:	49 89 fe             	mov    r14,rdi
  216e44:	48 8b 03             	mov    rax,QWORD PTR [rbx]
        if (self.target_address >= self.prev_address and self.target_address < self.address) {
  216e47:	48 8b 4b 28          	mov    rcx,QWORD PTR [rbx+0x28]
  216e4b:	48 3b 4b 48          	cmp    rcx,QWORD PTR [rbx+0x48]
  216e4f:	0f 82 aa 00 00 00    	jb     216eff <LineNumberProgram_checkLineMatch+0xcf>
  216e55:	48 39 c1             	cmp    rcx,rax
  216e58:	0f 83 a1 00 00 00    	jae    216eff <LineNumberProgram_checkLineMatch+0xcf>
            const file_entry = if (self.prev_file == 0) {
  216e5e:	48 8b 4b 50          	mov    rcx,QWORD PTR [rbx+0x50]
  216e62:	48 85 c9             	test   rcx,rcx
  216e65:	0f 84 ec 00 00 00    	je     216f57 <LineNumberProgram_checkLineMatch+0x127>
            } else if (self.prev_file - 1 >= self.file_entries.len) {
  216e6b:	48 83 c1 ff          	add    rcx,0xffffffffffffffff
  216e6f:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
  216e73:	48 3b 48 10          	cmp    rcx,QWORD PTR [rax+0x10]
  216e77:	0f 83 c2 00 00 00    	jae    216f3f <LineNumberProgram_checkLineMatch+0x10f>
                &self.file_entries.items[self.prev_file - 1];
  216e7d:	4c 8b 08             	mov    r9,QWORD PTR [rax]
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  216e80:	4c 8d 14 89          	lea    r10,[rcx+rcx*4]
  216e84:	4b 8b 4c d1 10       	mov    rcx,QWORD PTR [r9+r10*8+0x10]
  216e89:	48 3b 4b 38          	cmp    rcx,QWORD PTR [rbx+0x38]
  216e8d:	0f 83 ac 00 00 00    	jae    216f3f <LineNumberProgram_checkLineMatch+0x10f>
                self.include_dirs[file_entry.dir_index];
  216e93:	48 8b 53 30          	mov    rdx,QWORD PTR [rbx+0x30]
            const dir_name = if (file_entry.dir_index >= self.include_dirs.len) {
  216e97:	48 c1 e1 04          	shl    rcx,0x4
  216e9b:	4c 8b 2c 0a          	mov    r13,QWORD PTR [rdx+rcx*1]
  216e9f:	4c 8b 64 0a 08       	mov    r12,QWORD PTR [rdx+rcx*1+0x8]
  216ea4:	4f 8b 7c d1 08       	mov    r15,QWORD PTR [r9+r10*8+0x8]
    var total_strings_len: usize = strings.len; // 1 sep per string
    {
        comptime var string_i = 0;
        inline while (string_i < strings.len) : (string_i += 1) {
            const arg = ([]const u8)(strings[string_i]);
            total_strings_len += arg.len;
  216ea9:	4d 01 e7             	add    r15,r12
        if (n == 0) {
  216eac:	49 83 c7 02          	add    r15,0x2
  216eb0:	0f 84 ce 00 00 00    	je     216f84 <LineNumberProgram_checkLineMatch+0x154>
  216eb6:	4c 89 54 24 18       	mov    QWORD PTR [rsp+0x18],r10
  216ebb:	4c 89 4c 24 20       	mov    QWORD PTR [rsp+0x20],r9
  216ec0:	48 8b 70 18          	mov    rsi,QWORD PTR [rax+0x18]
  216ec4:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  216ec9:	b9 01 00 00 00       	mov    ecx,0x1
  216ece:	4c 89 fa             	mov    rdx,r15
  216ed1:	ff 16                	call   QWORD PTR [rsi]
  216ed3:	0f b7 44 24 28       	movzx  eax,WORD PTR [rsp+0x28]
  216ed8:	66 85 c0             	test   ax,ax
  216edb:	0f 84 b0 00 00 00    	je     216f91 <LineNumberProgram_checkLineMatch+0x161>
            const file_name = try os.path.join(self.file_entries.allocator, dir_name, file_entry.file_name);
  216ee1:	66 41 89 06          	mov    WORD PTR [r14],ax
  216ee5:	c5 fc 10 44 24 42    	vmovups ymm0,YMMWORD PTR [rsp+0x42]
  216eeb:	c5 fc 10 4c 24 58    	vmovups ymm1,YMMWORD PTR [rsp+0x58]
  216ef1:	c4 c1 7c 11 4e 18    	vmovups YMMWORD PTR [r14+0x18],ymm1
  216ef7:	c4 c1 7c 11 46 02    	vmovups YMMWORD PTR [r14+0x2],ymm0
  216efd:	eb 73                	jmp    216f72 <LineNumberProgram_checkLineMatch+0x142>
        self.prev_address = self.address;
  216eff:	48 89 43 48          	mov    QWORD PTR [rbx+0x48],rax
        self.prev_file = self.file;
  216f03:	c5 f8 10 43 08       	vmovups xmm0,XMMWORD PTR [rbx+0x8]
  216f08:	c5 f8 11 43 50       	vmovups XMMWORD PTR [rbx+0x50],xmm0
        self.prev_column = self.column;
  216f0d:	48 8b 43 18          	mov    rax,QWORD PTR [rbx+0x18]
  216f11:	48 89 43 60          	mov    QWORD PTR [rbx+0x60],rax
        self.prev_is_stmt = self.is_stmt;
  216f15:	8a 43 20             	mov    al,BYTE PTR [rbx+0x20]
  216f18:	88 43 68             	mov    BYTE PTR [rbx+0x68],al
        self.prev_basic_block = self.basic_block;
  216f1b:	8a 43 21             	mov    al,BYTE PTR [rbx+0x21]
  216f1e:	88 43 69             	mov    BYTE PTR [rbx+0x69],al
        self.prev_end_sequence = self.end_sequence;
  216f21:	8a 43 22             	mov    al,BYTE PTR [rbx+0x22]
  216f24:	88 43 6a             	mov    BYTE PTR [rbx+0x6a],al
        return null;
  216f27:	c5 fc 10 05 51 f7 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef751]        # 206680 <__unnamed_82+0x18>
  216f2e:	ff 
  216f2f:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  216f35:	c5 fc 10 05 2b f7 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef72b]        # 206668 <__unnamed_82>
  216f3c:	ff 
  216f3d:	eb 2e                	jmp    216f6d <LineNumberProgram_checkLineMatch+0x13d>
  216f3f:	c5 fc 10 05 01 f7 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef701]        # 206648 <__unnamed_83+0x18>
  216f46:	ff 
  216f47:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  216f4d:	c5 fc 10 05 db f6 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef6db]        # 206630 <__unnamed_83>
  216f54:	ff 
  216f55:	eb 16                	jmp    216f6d <LineNumberProgram_checkLineMatch+0x13d>
                return error.MissingDebugInfo;
  216f57:	c5 fc 10 05 b1 f6 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef6b1]        # 206610 <__unnamed_84+0x18>
  216f5e:	ff 
  216f5f:	c4 c1 7c 11 46 18    	vmovups YMMWORD PTR [r14+0x18],ymm0
  216f65:	c5 fc 10 05 8b f6 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffef68b]        # 2065f8 <__unnamed_84>
  216f6c:	ff 
  216f6d:	c4 c1 7c 11 06       	vmovups YMMWORD PTR [r14],ymm0
  216f72:	48 83 c4 78          	add    rsp,0x78
  216f76:	5b                   	pop    rbx
  216f77:	41 5c                	pop    r12
  216f79:	41 5d                	pop    r13
  216f7b:	41 5e                	pop    r14
  216f7d:	41 5f                	pop    r15
  216f7f:	5d                   	pop    rbp
  216f80:	c5 f8 77             	vzeroupper 
  216f83:	c3                   	ret    
  216f84:	45 31 ff             	xor    r15d,r15d
    assert(dest.len >= source.len);
  216f87:	4d 39 e7             	cmp    r15,r12
    if (!ok) {
  216f8a:	73 28                	jae    216fb4 <LineNumberProgram_checkLineMatch+0x184>
  216f8c:	e9 c6 05 00 00       	jmp    217557 <LineNumberProgram_checkLineMatch+0x727>
        assert(byte_slice.len == byte_count);
  216f91:	4c 39 7c 24 38       	cmp    QWORD PTR [rsp+0x38],r15
  216f96:	0f 85 bb 05 00 00    	jne    217557 <LineNumberProgram_checkLineMatch+0x727>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  216f9c:	48 8b 6c 24 30       	mov    rbp,QWORD PTR [rsp+0x30]
  216fa1:	4c 8b 4c 24 20       	mov    r9,QWORD PTR [rsp+0x20]
  216fa6:	4c 8b 54 24 18       	mov    r10,QWORD PTR [rsp+0x18]
    assert(dest.len >= source.len);
  216fab:	4d 39 e7             	cmp    r15,r12
  216fae:	0f 82 a3 05 00 00    	jb     217557 <LineNumberProgram_checkLineMatch+0x727>
    for (source) |s, i|
  216fb4:	4d 85 e4             	test   r12,r12
  216fb7:	0f 84 77 02 00 00    	je     217234 <LineNumberProgram_checkLineMatch+0x404>
  216fbd:	49 81 fc 80 00 00 00 	cmp    r12,0x80
  216fc4:	72 1a                	jb     216fe0 <LineNumberProgram_checkLineMatch+0x1b0>
  216fc6:	4b 8d 0c 2c          	lea    rcx,[r12+r13*1]
  216fca:	48 39 cd             	cmp    rbp,rcx
  216fcd:	0f 83 ab 00 00 00    	jae    21707e <LineNumberProgram_checkLineMatch+0x24e>
  216fd3:	49 8d 0c 2c          	lea    rcx,[r12+rbp*1]
  216fd7:	49 39 cd             	cmp    r13,rcx
  216fda:	0f 83 9e 00 00 00    	jae    21707e <LineNumberProgram_checkLineMatch+0x24e>
  216fe0:	31 c9                	xor    ecx,ecx
  216fe2:	49 8d 7c 24 ff       	lea    rdi,[r12-0x1]
  216fe7:	48 29 cf             	sub    rdi,rcx
  216fea:	4c 89 e6             	mov    rsi,r12
  216fed:	48 83 e6 07          	and    rsi,0x7
  216ff1:	74 21                	je     217014 <LineNumberProgram_checkLineMatch+0x1e4>
  216ff3:	48 f7 de             	neg    rsi
  216ff6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  216ffd:	00 00 00 
  217000:	41 0f b6 54 0d 00    	movzx  edx,BYTE PTR [r13+rcx*1+0x0]
        dest[i] = s;
  217006:	88 54 0d 00          	mov    BYTE PTR [rbp+rcx*1+0x0],dl
    for (source) |s, i|
  21700a:	48 83 c1 01          	add    rcx,0x1
  21700e:	48 83 c6 01          	add    rsi,0x1
  217012:	75 ec                	jne    217000 <LineNumberProgram_checkLineMatch+0x1d0>
  217014:	48 83 ff 07          	cmp    rdi,0x7
  217018:	0f 82 16 02 00 00    	jb     217234 <LineNumberProgram_checkLineMatch+0x404>
  21701e:	66 90                	xchg   ax,ax
  217020:	41 0f b6 54 0d 00    	movzx  edx,BYTE PTR [r13+rcx*1+0x0]
        dest[i] = s;
  217026:	88 54 0d 00          	mov    BYTE PTR [rbp+rcx*1+0x0],dl
    for (source) |s, i|
  21702a:	41 0f b6 54 0d 01    	movzx  edx,BYTE PTR [r13+rcx*1+0x1]
        dest[i] = s;
  217030:	88 54 0d 01          	mov    BYTE PTR [rbp+rcx*1+0x1],dl
    for (source) |s, i|
  217034:	41 0f b6 54 0d 02    	movzx  edx,BYTE PTR [r13+rcx*1+0x2]
        dest[i] = s;
  21703a:	88 54 0d 02          	mov    BYTE PTR [rbp+rcx*1+0x2],dl
    for (source) |s, i|
  21703e:	41 0f b6 54 0d 03    	movzx  edx,BYTE PTR [r13+rcx*1+0x3]
        dest[i] = s;
  217044:	88 54 0d 03          	mov    BYTE PTR [rbp+rcx*1+0x3],dl
    for (source) |s, i|
  217048:	41 0f b6 54 0d 04    	movzx  edx,BYTE PTR [r13+rcx*1+0x4]
        dest[i] = s;
  21704e:	88 54 0d 04          	mov    BYTE PTR [rbp+rcx*1+0x4],dl
    for (source) |s, i|
  217052:	41 0f b6 54 0d 05    	movzx  edx,BYTE PTR [r13+rcx*1+0x5]
        dest[i] = s;
  217058:	88 54 0d 05          	mov    BYTE PTR [rbp+rcx*1+0x5],dl
    for (source) |s, i|
  21705c:	41 0f b6 54 0d 06    	movzx  edx,BYTE PTR [r13+rcx*1+0x6]
        dest[i] = s;
  217062:	88 54 0d 06          	mov    BYTE PTR [rbp+rcx*1+0x6],dl
    for (source) |s, i|
  217066:	41 0f b6 54 0d 07    	movzx  edx,BYTE PTR [r13+rcx*1+0x7]
        dest[i] = s;
  21706c:	88 54 0d 07          	mov    BYTE PTR [rbp+rcx*1+0x7],dl
    for (source) |s, i|
  217070:	48 83 c1 08          	add    rcx,0x8
  217074:	49 39 cc             	cmp    r12,rcx
  217077:	75 a7                	jne    217020 <LineNumberProgram_checkLineMatch+0x1f0>
  217079:	e9 b6 01 00 00       	jmp    217234 <LineNumberProgram_checkLineMatch+0x404>
  21707e:	4c 89 e1             	mov    rcx,r12
  217081:	48 83 e1 80          	and    rcx,0xffffffffffffff80
  217085:	48 8d 79 80          	lea    rdi,[rcx-0x80]
  217089:	48 89 fe             	mov    rsi,rdi
  21708c:	48 c1 ee 07          	shr    rsi,0x7
  217090:	8d 56 01             	lea    edx,[rsi+0x1]
  217093:	83 e2 03             	and    edx,0x3
  217096:	48 81 ff 80 01 00 00 	cmp    rdi,0x180
  21709d:	73 10                	jae    2170af <LineNumberProgram_checkLineMatch+0x27f>
  21709f:	31 f6                	xor    esi,esi
  2170a1:	48 85 d2             	test   rdx,rdx
  2170a4:	0f 85 3c 01 00 00    	jne    2171e6 <LineNumberProgram_checkLineMatch+0x3b6>
  2170aa:	e9 7c 01 00 00       	jmp    21722b <LineNumberProgram_checkLineMatch+0x3fb>
  2170af:	48 8d 7a ff          	lea    rdi,[rdx-0x1]
  2170b3:	48 29 f7             	sub    rdi,rsi
  2170b6:	31 f6                	xor    esi,esi
  2170b8:	c4 c1 7c 10 44 35 00 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x0]
  2170bf:	c4 c1 7c 10 4c 35 20 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x20]
  2170c6:	c4 c1 7c 10 54 35 40 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0x40]
  2170cd:	c4 c1 7c 10 5c 35 60 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x60]
        dest[i] = s;
  2170d4:	c5 fc 11 44 35 00    	vmovups YMMWORD PTR [rbp+rsi*1+0x0],ymm0
  2170da:	c5 fc 11 4c 35 20    	vmovups YMMWORD PTR [rbp+rsi*1+0x20],ymm1
  2170e0:	c5 fc 11 54 35 40    	vmovups YMMWORD PTR [rbp+rsi*1+0x40],ymm2
  2170e6:	c5 fc 11 5c 35 60    	vmovups YMMWORD PTR [rbp+rsi*1+0x60],ymm3
    for (source) |s, i|
  2170ec:	c4 c1 7c 10 84 35 80 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x80]
  2170f3:	00 00 00 
  2170f6:	c4 c1 7c 10 8c 35 a0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0xa0]
  2170fd:	00 00 00 
  217100:	c4 c1 7c 10 94 35 c0 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0xc0]
  217107:	00 00 00 
  21710a:	c4 c1 7c 10 9c 35 e0 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0xe0]
  217111:	00 00 00 
        dest[i] = s;
  217114:	c5 fc 11 84 35 80 00 	vmovups YMMWORD PTR [rbp+rsi*1+0x80],ymm0
  21711b:	00 00 
  21711d:	c5 fc 11 8c 35 a0 00 	vmovups YMMWORD PTR [rbp+rsi*1+0xa0],ymm1
  217124:	00 00 
  217126:	c5 fc 11 94 35 c0 00 	vmovups YMMWORD PTR [rbp+rsi*1+0xc0],ymm2
  21712d:	00 00 
  21712f:	c5 fc 11 9c 35 e0 00 	vmovups YMMWORD PTR [rbp+rsi*1+0xe0],ymm3
  217136:	00 00 
    for (source) |s, i|
  217138:	c4 c1 7c 10 84 35 00 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x100]
  21713f:	01 00 00 
  217142:	c4 c1 7c 10 8c 35 20 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x120]
  217149:	01 00 00 
  21714c:	c4 c1 7c 10 94 35 40 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0x140]
  217153:	01 00 00 
  217156:	c4 c1 7c 10 9c 35 60 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x160]
  21715d:	01 00 00 
        dest[i] = s;
  217160:	c5 fc 11 84 35 00 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x100],ymm0
  217167:	00 00 
  217169:	c5 fc 11 8c 35 20 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x120],ymm1
  217170:	00 00 
  217172:	c5 fc 11 94 35 40 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x140],ymm2
  217179:	00 00 
  21717b:	c5 fc 11 9c 35 60 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x160],ymm3
  217182:	00 00 
    for (source) |s, i|
  217184:	c4 c1 7c 10 84 35 80 	vmovups ymm0,YMMWORD PTR [r13+rsi*1+0x180]
  21718b:	01 00 00 
  21718e:	c4 c1 7c 10 8c 35 a0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1+0x1a0]
  217195:	01 00 00 
  217198:	c4 c1 7c 10 94 35 c0 	vmovups ymm2,YMMWORD PTR [r13+rsi*1+0x1c0]
  21719f:	01 00 00 
  2171a2:	c4 c1 7c 10 9c 35 e0 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x1e0]
  2171a9:	01 00 00 
        dest[i] = s;
  2171ac:	c5 fc 11 84 35 80 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x180],ymm0
  2171b3:	00 00 
  2171b5:	c5 fc 11 8c 35 a0 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x1a0],ymm1
  2171bc:	00 00 
  2171be:	c5 fc 11 94 35 c0 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x1c0],ymm2
  2171c5:	00 00 
  2171c7:	c5 fc 11 9c 35 e0 01 	vmovups YMMWORD PTR [rbp+rsi*1+0x1e0],ymm3
  2171ce:	00 00 
    for (source) |s, i|
  2171d0:	48 81 c6 00 02 00 00 	add    rsi,0x200
  2171d7:	48 83 c7 04          	add    rdi,0x4
  2171db:	0f 85 d7 fe ff ff    	jne    2170b8 <LineNumberProgram_checkLineMatch+0x288>
  2171e1:	48 85 d2             	test   rdx,rdx
  2171e4:	74 45                	je     21722b <LineNumberProgram_checkLineMatch+0x3fb>
  2171e6:	48 83 c6 60          	add    rsi,0x60
  2171ea:	48 f7 da             	neg    rdx
  2171ed:	c4 c1 7c 10 44 35 a0 	vmovups ymm0,YMMWORD PTR [r13+rsi*1-0x60]
  2171f4:	c4 c1 7c 10 4c 35 c0 	vmovups ymm1,YMMWORD PTR [r13+rsi*1-0x40]
  2171fb:	c4 c1 7c 10 54 35 e0 	vmovups ymm2,YMMWORD PTR [r13+rsi*1-0x20]
  217202:	c4 c1 7c 10 5c 35 00 	vmovups ymm3,YMMWORD PTR [r13+rsi*1+0x0]
        dest[i] = s;
  217209:	c5 fc 11 44 35 a0    	vmovups YMMWORD PTR [rbp+rsi*1-0x60],ymm0
  21720f:	c5 fc 11 4c 35 c0    	vmovups YMMWORD PTR [rbp+rsi*1-0x40],ymm1
  217215:	c5 fc 11 54 35 e0    	vmovups YMMWORD PTR [rbp+rsi*1-0x20],ymm2
  21721b:	c5 fc 11 5c 35 00    	vmovups YMMWORD PTR [rbp+rsi*1+0x0],ymm3
    for (source) |s, i|
  217221:	48 83 ee 80          	sub    rsi,0xffffffffffffff80
  217225:	48 83 c2 01          	add    rdx,0x1
  217229:	75 c2                	jne    2171ed <LineNumberProgram_checkLineMatch+0x3bd>
  21722b:	49 39 cc             	cmp    r12,rcx
  21722e:	0f 85 ae fd ff ff    	jne    216fe2 <LineNumberProgram_checkLineMatch+0x1b2>
  217234:	4b 8d 0c d1          	lea    rcx,[r9+r10*8]
  217238:	48 83 c1 08          	add    rcx,0x8
        const arg = ([]const u8)(strings[string_i]);
        string_i += 1;
        copy(u8, buf[buf_index..], arg);
        buf_index += arg.len;
        if (string_i >= strings.len) break;
        if (buf[buf_index - 1] != sep) {
  21723c:	42 80 7c 25 ff 2f    	cmp    BYTE PTR [rbp+r12*1-0x1],0x2f
  217242:	74 0a                	je     21724e <LineNumberProgram_checkLineMatch+0x41e>
            buf[buf_index] = sep;
  217244:	42 c6 44 25 00 2f    	mov    BYTE PTR [rbp+r12*1+0x0],0x2f
            buf_index += 1;
  21724a:	49 83 c4 01          	add    r12,0x1
        const arg = ([]const u8)(strings[string_i]);
  21724e:	4c 8b 01             	mov    r8,QWORD PTR [rcx]
        copy(u8, buf[buf_index..], arg);
  217251:	4d 29 e7             	sub    r15,r12
    assert(dest.len >= source.len);
  217254:	4d 39 c7             	cmp    r15,r8
  217257:	0f 82 fa 02 00 00    	jb     217557 <LineNumberProgram_checkLineMatch+0x727>
    for (source) |s, i|
  21725d:	4d 85 c0             	test   r8,r8
  217260:	0f 84 7a 02 00 00    	je     2174e0 <LineNumberProgram_checkLineMatch+0x6b0>
  217266:	4b 8b 14 d1          	mov    rdx,QWORD PTR [r9+r10*8]
  21726a:	4d 8d 0c 2c          	lea    r9,[r12+rbp*1]
  21726e:	49 81 f8 80 00 00 00 	cmp    r8,0x80
  217275:	72 1d                	jb     217294 <LineNumberProgram_checkLineMatch+0x464>
  217277:	4a 8d 0c 02          	lea    rcx,[rdx+r8*1]
  21727b:	49 39 c9             	cmp    r9,rcx
  21727e:	0f 83 b0 00 00 00    	jae    217334 <LineNumberProgram_checkLineMatch+0x504>
  217284:	4b 8d 0c 04          	lea    rcx,[r12+r8*1]
  217288:	48 01 e9             	add    rcx,rbp
  21728b:	48 39 ca             	cmp    rdx,rcx
  21728e:	0f 83 a0 00 00 00    	jae    217334 <LineNumberProgram_checkLineMatch+0x504>
  217294:	31 f6                	xor    esi,esi
  217296:	49 8d 40 ff          	lea    rax,[r8-0x1]
  21729a:	48 29 f0             	sub    rax,rsi
  21729d:	4c 89 c7             	mov    rdi,r8
  2172a0:	48 83 e7 07          	and    rdi,0x7
  2172a4:	74 1c                	je     2172c2 <LineNumberProgram_checkLineMatch+0x492>
  2172a6:	48 f7 df             	neg    rdi
  2172a9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  2172b0:	0f b6 0c 32          	movzx  ecx,BYTE PTR [rdx+rsi*1]
        dest[i] = s;
  2172b4:	41 88 0c 31          	mov    BYTE PTR [r9+rsi*1],cl
    for (source) |s, i|
  2172b8:	48 83 c6 01          	add    rsi,0x1
  2172bc:	48 83 c7 01          	add    rdi,0x1
  2172c0:	75 ee                	jne    2172b0 <LineNumberProgram_checkLineMatch+0x480>
  2172c2:	48 83 f8 07          	cmp    rax,0x7
  2172c6:	0f 82 14 02 00 00    	jb     2174e0 <LineNumberProgram_checkLineMatch+0x6b0>
  2172cc:	49 8d 0c 2c          	lea    rcx,[r12+rbp*1]
  2172d0:	48 83 c1 07          	add    rcx,0x7
  2172d4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2172db:	00 00 00 00 00 
  2172e0:	0f b6 04 32          	movzx  eax,BYTE PTR [rdx+rsi*1]
        dest[i] = s;
  2172e4:	88 44 31 f9          	mov    BYTE PTR [rcx+rsi*1-0x7],al
    for (source) |s, i|
  2172e8:	0f b6 44 32 01       	movzx  eax,BYTE PTR [rdx+rsi*1+0x1]
        dest[i] = s;
  2172ed:	88 44 31 fa          	mov    BYTE PTR [rcx+rsi*1-0x6],al
    for (source) |s, i|
  2172f1:	0f b6 44 32 02       	movzx  eax,BYTE PTR [rdx+rsi*1+0x2]
        dest[i] = s;
  2172f6:	88 44 31 fb          	mov    BYTE PTR [rcx+rsi*1-0x5],al
    for (source) |s, i|
  2172fa:	0f b6 44 32 03       	movzx  eax,BYTE PTR [rdx+rsi*1+0x3]
        dest[i] = s;
  2172ff:	88 44 31 fc          	mov    BYTE PTR [rcx+rsi*1-0x4],al
    for (source) |s, i|
  217303:	0f b6 44 32 04       	movzx  eax,BYTE PTR [rdx+rsi*1+0x4]
        dest[i] = s;
  217308:	88 44 31 fd          	mov    BYTE PTR [rcx+rsi*1-0x3],al
    for (source) |s, i|
  21730c:	0f b6 44 32 05       	movzx  eax,BYTE PTR [rdx+rsi*1+0x5]
        dest[i] = s;
  217311:	88 44 31 fe          	mov    BYTE PTR [rcx+rsi*1-0x2],al
    for (source) |s, i|
  217315:	0f b6 44 32 06       	movzx  eax,BYTE PTR [rdx+rsi*1+0x6]
        dest[i] = s;
  21731a:	88 44 31 ff          	mov    BYTE PTR [rcx+rsi*1-0x1],al
    for (source) |s, i|
  21731e:	0f b6 44 32 07       	movzx  eax,BYTE PTR [rdx+rsi*1+0x7]
        dest[i] = s;
  217323:	88 04 31             	mov    BYTE PTR [rcx+rsi*1],al
    for (source) |s, i|
  217326:	48 83 c6 08          	add    rsi,0x8
  21732a:	49 39 f0             	cmp    r8,rsi
  21732d:	75 b1                	jne    2172e0 <LineNumberProgram_checkLineMatch+0x4b0>
  21732f:	e9 ac 01 00 00       	jmp    2174e0 <LineNumberProgram_checkLineMatch+0x6b0>
  217334:	4c 89 c6             	mov    rsi,r8
  217337:	48 83 e6 80          	and    rsi,0xffffffffffffff80
  21733b:	48 8d 7e 80          	lea    rdi,[rsi-0x80]
  21733f:	48 89 f9             	mov    rcx,rdi
  217342:	48 c1 e9 07          	shr    rcx,0x7
  217346:	44 8d 51 01          	lea    r10d,[rcx+0x1]
  21734a:	41 83 e2 03          	and    r10d,0x3
  21734e:	48 81 ff 80 01 00 00 	cmp    rdi,0x180
  217355:	73 10                	jae    217367 <LineNumberProgram_checkLineMatch+0x537>
  217357:	31 c9                	xor    ecx,ecx
  217359:	4d 85 d2             	test   r10,r10
  21735c:	0f 85 32 01 00 00    	jne    217494 <LineNumberProgram_checkLineMatch+0x664>
  217362:	e9 70 01 00 00       	jmp    2174d7 <LineNumberProgram_checkLineMatch+0x6a7>
  217367:	49 8d 3c 2c          	lea    rdi,[r12+rbp*1]
  21736b:	48 81 c7 e0 01 00 00 	add    rdi,0x1e0
  217372:	49 8d 42 ff          	lea    rax,[r10-0x1]
  217376:	48 29 c8             	sub    rax,rcx
  217379:	31 c9                	xor    ecx,ecx
  21737b:	c5 fc 10 04 0a       	vmovups ymm0,YMMWORD PTR [rdx+rcx*1]
  217380:	c5 fc 10 4c 0a 20    	vmovups ymm1,YMMWORD PTR [rdx+rcx*1+0x20]
  217386:	c5 fc 10 54 0a 40    	vmovups ymm2,YMMWORD PTR [rdx+rcx*1+0x40]
  21738c:	c5 fc 10 5c 0a 60    	vmovups ymm3,YMMWORD PTR [rdx+rcx*1+0x60]
        dest[i] = s;
  217392:	c5 fc 11 84 0f 20 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x1e0],ymm0
  217399:	ff ff 
  21739b:	c5 fc 11 8c 0f 40 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x1c0],ymm1
  2173a2:	ff ff 
  2173a4:	c5 fc 11 94 0f 60 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x1a0],ymm2
  2173ab:	ff ff 
  2173ad:	c5 fc 11 9c 0f 80 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x180],ymm3
  2173b4:	ff ff 
    for (source) |s, i|
  2173b6:	c5 fc 10 84 0a 80 00 	vmovups ymm0,YMMWORD PTR [rdx+rcx*1+0x80]
  2173bd:	00 00 
  2173bf:	c5 fc 10 8c 0a a0 00 	vmovups ymm1,YMMWORD PTR [rdx+rcx*1+0xa0]
  2173c6:	00 00 
  2173c8:	c5 fc 10 94 0a c0 00 	vmovups ymm2,YMMWORD PTR [rdx+rcx*1+0xc0]
  2173cf:	00 00 
  2173d1:	c5 fc 10 9c 0a e0 00 	vmovups ymm3,YMMWORD PTR [rdx+rcx*1+0xe0]
  2173d8:	00 00 
        dest[i] = s;
  2173da:	c5 fc 11 84 0f a0 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x160],ymm0
  2173e1:	ff ff 
  2173e3:	c5 fc 11 8c 0f c0 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x140],ymm1
  2173ea:	ff ff 
  2173ec:	c5 fc 11 94 0f e0 fe 	vmovups YMMWORD PTR [rdi+rcx*1-0x120],ymm2
  2173f3:	ff ff 
  2173f5:	c5 fc 11 9c 0f 00 ff 	vmovups YMMWORD PTR [rdi+rcx*1-0x100],ymm3
  2173fc:	ff ff 
    for (source) |s, i|
  2173fe:	c5 fc 10 84 0a 00 01 	vmovups ymm0,YMMWORD PTR [rdx+rcx*1+0x100]
  217405:	00 00 
  217407:	c5 fc 10 8c 0a 20 01 	vmovups ymm1,YMMWORD PTR [rdx+rcx*1+0x120]
  21740e:	00 00 
  217410:	c5 fc 10 94 0a 40 01 	vmovups ymm2,YMMWORD PTR [rdx+rcx*1+0x140]
  217417:	00 00 
  217419:	c5 fc 10 9c 0a 60 01 	vmovups ymm3,YMMWORD PTR [rdx+rcx*1+0x160]
  217420:	00 00 
        dest[i] = s;
  217422:	c5 fc 11 84 0f 20 ff 	vmovups YMMWORD PTR [rdi+rcx*1-0xe0],ymm0
  217429:	ff ff 
  21742b:	c5 fc 11 8c 0f 40 ff 	vmovups YMMWORD PTR [rdi+rcx*1-0xc0],ymm1
  217432:	ff ff 
  217434:	c5 fc 11 94 0f 60 ff 	vmovups YMMWORD PTR [rdi+rcx*1-0xa0],ymm2
  21743b:	ff ff 
  21743d:	c5 fc 11 5c 0f 80    	vmovups YMMWORD PTR [rdi+rcx*1-0x80],ymm3
    for (source) |s, i|
  217443:	c5 fc 10 84 0a 80 01 	vmovups ymm0,YMMWORD PTR [rdx+rcx*1+0x180]
  21744a:	00 00 
  21744c:	c5 fc 10 8c 0a a0 01 	vmovups ymm1,YMMWORD PTR [rdx+rcx*1+0x1a0]
  217453:	00 00 
  217455:	c5 fc 10 94 0a c0 01 	vmovups ymm2,YMMWORD PTR [rdx+rcx*1+0x1c0]
  21745c:	00 00 
  21745e:	c5 fc 10 9c 0a e0 01 	vmovups ymm3,YMMWORD PTR [rdx+rcx*1+0x1e0]
  217465:	00 00 
        dest[i] = s;
  217467:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  21746d:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  217473:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  217479:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
    for (source) |s, i|
  21747e:	48 81 c1 00 02 00 00 	add    rcx,0x200
  217485:	48 83 c0 04          	add    rax,0x4
  217489:	0f 85 ec fe ff ff    	jne    21737b <LineNumberProgram_checkLineMatch+0x54b>
  21748f:	4d 85 d2             	test   r10,r10
  217492:	74 43                	je     2174d7 <LineNumberProgram_checkLineMatch+0x6a7>
  217494:	48 83 c1 60          	add    rcx,0x60
  217498:	49 f7 da             	neg    r10
  21749b:	c5 fc 10 44 0a a0    	vmovups ymm0,YMMWORD PTR [rdx+rcx*1-0x60]
  2174a1:	c5 fc 10 4c 0a c0    	vmovups ymm1,YMMWORD PTR [rdx+rcx*1-0x40]
  2174a7:	c5 fc 10 54 0a e0    	vmovups ymm2,YMMWORD PTR [rdx+rcx*1-0x20]
  2174ad:	c5 fc 10 1c 0a       	vmovups ymm3,YMMWORD PTR [rdx+rcx*1]
        dest[i] = s;
  2174b2:	c4 c1 7c 11 44 09 a0 	vmovups YMMWORD PTR [r9+rcx*1-0x60],ymm0
  2174b9:	c4 c1 7c 11 4c 09 c0 	vmovups YMMWORD PTR [r9+rcx*1-0x40],ymm1
  2174c0:	c4 c1 7c 11 54 09 e0 	vmovups YMMWORD PTR [r9+rcx*1-0x20],ymm2
  2174c7:	c4 c1 7c 11 1c 09    	vmovups YMMWORD PTR [r9+rcx*1],ymm3
    for (source) |s, i|
  2174cd:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  2174d1:	49 83 c2 01          	add    r10,0x1
  2174d5:	75 c4                	jne    21749b <LineNumberProgram_checkLineMatch+0x66b>
  2174d7:	49 39 f0             	cmp    r8,rsi
  2174da:	0f 85 b6 fd ff ff    	jne    217296 <LineNumberProgram_checkLineMatch+0x466>
        buf_index += arg.len;
  2174e0:	4d 01 e0             	add    r8,r12
                .allocator = self.file_entries.allocator,
  2174e3:	48 8b 43 40          	mov    rax,QWORD PTR [rbx+0x40]
                .line = if (self.prev_line >= 0) @intCast(usize, self.prev_line) else 0,
  2174e7:	48 8b 4b 58          	mov    rcx,QWORD PTR [rbx+0x58]
  2174eb:	48 89 ca             	mov    rdx,rcx
  2174ee:	48 c1 fa 3f          	sar    rdx,0x3f
  2174f2:	c4 e2 e8 f2 c9       	andn   rcx,rdx,rcx
                .column = self.prev_column,
  2174f7:	48 8b 53 60          	mov    rdx,QWORD PTR [rbx+0x60]
                .allocator = self.file_entries.allocator,
  2174fb:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
            return LineInfo{
  2174ff:	c6 44 24 0a 01       	mov    BYTE PTR [rsp+0xa],0x1
  217504:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  21750a:	0f b7 74 24 16       	movzx  esi,WORD PTR [rsp+0x16]
  21750f:	66 41 89 76 06       	mov    WORD PTR [r14+0x6],si
  217514:	8b 74 24 12          	mov    esi,DWORD PTR [rsp+0x12]
  217518:	41 89 76 02          	mov    DWORD PTR [r14+0x2],esi
  21751c:	49 89 4e 08          	mov    QWORD PTR [r14+0x8],rcx
  217520:	49 89 56 10          	mov    QWORD PTR [r14+0x10],rdx
  217524:	49 89 6e 18          	mov    QWORD PTR [r14+0x18],rbp
  217528:	4d 89 46 20          	mov    QWORD PTR [r14+0x20],r8
  21752c:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
  217530:	8a 44 24 0a          	mov    al,BYTE PTR [rsp+0xa]
  217534:	41 88 46 30          	mov    BYTE PTR [r14+0x30],al
  217538:	8a 44 24 11          	mov    al,BYTE PTR [rsp+0x11]
  21753c:	41 88 46 37          	mov    BYTE PTR [r14+0x37],al
  217540:	0f b7 44 24 0f       	movzx  eax,WORD PTR [rsp+0xf]
  217545:	66 41 89 46 35       	mov    WORD PTR [r14+0x35],ax
  21754a:	8b 44 24 0b          	mov    eax,DWORD PTR [rsp+0xb]
  21754e:	41 89 46 31          	mov    DWORD PTR [r14+0x31],eax
  217552:	e9 1b fa ff ff       	jmp    216f72 <LineNumberProgram_checkLineMatch+0x142>
            @panic("assertion failure");
  217557:	c5 f8 77             	vzeroupper 
  21755a:	e8 51 27 ff ff       	call   209cb0 <panic>
  21755f:	90                   	nop

0000000000217560 <Allocator_alignedRealloc.76>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  217560:	41 56                	push   r14
  217562:	53                   	push   rbx
  217563:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  21756a:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  21756d:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  217571:	48 85 c0             	test   rax,rax
  217574:	74 5e                	je     2175d4 <Allocator_alignedRealloc.76+0x74>
        if (n == 0) {
  217576:	48 85 c9             	test   rcx,rcx
  217579:	0f 84 a6 00 00 00    	je     217625 <Allocator_alignedRealloc.76+0xc5>
        const old_byte_slice = @sliceToBytes(old_mem);
  21757f:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  217582:	48 c1 e0 04          	shl    rax,0x4
  217586:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  21758b:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;
  217590:	ba 10 00 00 00       	mov    edx,0x10
  217595:	48 89 c8             	mov    rax,rcx
  217598:	48 f7 e2             	mul    rdx
  21759b:	0f 81 ca 00 00 00    	jno    21766b <Allocator_alignedRealloc.76+0x10b>
  2175a1:	48 8d 0d 28 92 fe ff 	lea    rcx,[rip+0xfffffffffffe9228]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2175a8:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2175ac:	0f 84 d4 00 00 00    	je     217686 <Allocator_alignedRealloc.76+0x126>
  2175b2:	48 8b 05 07 f0 fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffef007]        # 2065c0 <__unnamed_85+0x10>
  2175b9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2175bd:	c5 f8 10 05 eb ef fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffeefeb]        # 2065b0 <__unnamed_85>
  2175c4:	ff 
  2175c5:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2175c9:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2175d0:	5b                   	pop    rbx
  2175d1:	41 5e                	pop    r14
  2175d3:	c3                   	ret    
        if (n == 0) {
  2175d4:	48 85 c9             	test   rcx,rcx
  2175d7:	0f 84 f6 00 00 00    	je     2176d3 <Allocator_alignedRealloc.76+0x173>
  2175dd:	ba 10 00 00 00       	mov    edx,0x10
  2175e2:	48 89 c8             	mov    rax,rcx
  2175e5:	48 f7 e2             	mul    rdx
  2175e8:	0f 81 07 01 00 00    	jno    2176f5 <Allocator_alignedRealloc.76+0x195>
  2175ee:	48 8d 0d db 91 fe ff 	lea    rcx,[rip+0xfffffffffffe91db]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2175f5:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2175f9:	0f 84 11 01 00 00    	je     217710 <Allocator_alignedRealloc.76+0x1b0>
  2175ff:	0f b7 05 b0 ef fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffeefb0]        # 2065b6 <__unnamed_85+0x6>
  217606:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21760b:	8b 05 a1 ef fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffeefa1]        # 2065b2 <__unnamed_85+0x2>
  217611:	89 04 24             	mov    DWORD PTR [rsp],eax
  217614:	48 89 e0             	mov    rax,rsp
  217617:	66 b9 05 00          	mov    cx,0x5
  21761b:	31 d2                	xor    edx,edx
  21761d:	45 31 f6             	xor    r14d,r14d
  217620:	e9 6f 01 00 00       	jmp    217794 <Allocator_alignedRealloc.76+0x234>
        const bytes = @sliceToBytes(memory);
  217625:	48 c1 e0 04          	shl    rax,0x4
        if (bytes.len == 0) return;
  217629:	74 1e                	je     217649 <Allocator_alignedRealloc.76+0xe9>
        const bytes = @sliceToBytes(memory);
  21762b:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  21762e:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  217632:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  217637:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  21763c:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  217641:	48 89 f7             	mov    rdi,rsi
  217644:	48 89 c6             	mov    rsi,rax
  217647:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  217649:	48 8b 05 58 ef fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffeef58]        # 2065a8 <__unnamed_86+0x10>
  217650:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  217654:	c5 f8 10 05 3c ef fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffeef3c]        # 206598 <__unnamed_86>
  21765b:	ff 
  21765c:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  217660:	48 81 c4 88 00 00 00 	add    rsp,0x88
  217667:	5b                   	pop    rbx
  217668:	41 5e                	pop    r14
  21766a:	c3                   	ret    
  21766b:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  217670:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  217677:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21767c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  217680:	0f 85 2c ff ff ff    	jne    2175b2 <Allocator_alignedRealloc.76+0x52>
  217686:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21768a:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  21768f:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  217694:	41 b8 08 00 00 00    	mov    r8d,0x8
  21769a:	4c 89 f1             	mov    rcx,r14
  21769d:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  2176a0:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  2176a5:	66 85 c0             	test   ax,ax
  2176a8:	0f 84 95 00 00 00    	je     217743 <Allocator_alignedRealloc.76+0x1e3>
  2176ae:	66 89 03             	mov    WORD PTR [rbx],ax
  2176b1:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  2176b8:	00 
  2176b9:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2176bd:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  2176c3:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  2176c8:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2176cf:	5b                   	pop    rbx
  2176d0:	41 5e                	pop    r14
  2176d2:	c3                   	ret    
  2176d3:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  2176d6:	0f b7 0d c1 ee fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffeeec1]        # 20659e <__unnamed_86+0x6>
  2176dd:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  2176e2:	8b 0d b2 ee fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffeeeb2]        # 20659a <__unnamed_86+0x2>
  2176e8:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  2176eb:	31 c9                	xor    ecx,ecx
  2176ed:	45 31 f6             	xor    r14d,r14d
  2176f0:	e9 9f 00 00 00       	jmp    217794 <Allocator_alignedRealloc.76+0x234>
  2176f5:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  2176fa:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  217701:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  217706:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21770a:	0f 85 ef fe ff ff    	jne    2175ff <Allocator_alignedRealloc.76+0x9f>
  217710:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  217714:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  217719:	b9 08 00 00 00       	mov    ecx,0x8
  21771e:	4c 89 f2             	mov    rdx,r14
  217721:	ff 16                	call   QWORD PTR [rsi]
  217723:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  217728:	66 85 c9             	test   cx,cx
  21772b:	74 41                	je     21776e <Allocator_alignedRealloc.76+0x20e>
  21772d:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  217732:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  217737:	48 89 e0             	mov    rax,rsp
  21773a:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  21773e:	89 14 24             	mov    DWORD PTR [rsp],edx
  217741:	eb 51                	jmp    217794 <Allocator_alignedRealloc.76+0x234>
        assert(byte_slice.len == byte_count);
  217743:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  217748:	75 6d                	jne    2177b7 <Allocator_alignedRealloc.76+0x257>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  21774a:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21774f:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  217754:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  217759:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21775d:	49 c1 ee 04          	shr    r14,0x4
  217761:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  217765:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  217768:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  21776c:	eb 3a                	jmp    2177a8 <Allocator_alignedRealloc.76+0x248>
        assert(byte_slice.len == byte_count);
  21776e:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  217773:	75 42                	jne    2177b7 <Allocator_alignedRealloc.76+0x257>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  217775:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  21777a:	49 c1 ee 04          	shr    r14,0x4
  21777e:	48 89 e0             	mov    rax,rsp
  217781:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  217785:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  217788:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  21778d:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  217792:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  217794:	66 89 0b             	mov    WORD PTR [rbx],cx
  217797:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  21779b:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  21779f:	8b 00                	mov    eax,DWORD PTR [rax]
  2177a1:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  2177a4:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
  2177a8:	4c 89 73 10          	mov    QWORD PTR [rbx+0x10],r14
  2177ac:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2177b3:	5b                   	pop    rbx
  2177b4:	41 5e                	pop    r14
  2177b6:	c3                   	ret    
            @panic("assertion failure");
  2177b7:	e8 f4 24 ff ff       	call   209cb0 <panic>
  2177bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000002177c0 <Allocator_alignedRealloc.79>:
    pub fn alignedRealloc(self: *Allocator, comptime T: type, comptime alignment: u29, old_mem: []align(alignment) T, n: usize) ![]align(alignment) T {
  2177c0:	41 56                	push   r14
  2177c2:	53                   	push   rbx
  2177c3:	48 81 ec 88 00 00 00 	sub    rsp,0x88
  2177ca:	48 89 fb             	mov    rbx,rdi
        if (old_mem.len == 0) {
  2177cd:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
  2177d1:	48 85 c0             	test   rax,rax
  2177d4:	74 62                	je     217838 <Allocator_alignedRealloc.79+0x78>
        if (n == 0) {
  2177d6:	48 85 c9             	test   rcx,rcx
  2177d9:	0f 84 a9 00 00 00    	je     217888 <Allocator_alignedRealloc.79+0xc8>
        const old_byte_slice = @sliceToBytes(old_mem);
  2177df:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
  2177e2:	48 c1 e0 03          	shl    rax,0x3
  2177e6:	48 8d 04 80          	lea    rax,[rax+rax*4]
  2177ea:	48 89 54 24 38       	mov    QWORD PTR [rsp+0x38],rdx
  2177ef:	48 89 44 24 40       	mov    QWORD PTR [rsp+0x40],rax
  2177f4:	ba 28 00 00 00       	mov    edx,0x28
  2177f9:	48 89 c8             	mov    rax,rcx
  2177fc:	48 f7 e2             	mul    rdx
  2177ff:	0f 81 d0 00 00 00    	jno    2178d5 <Allocator_alignedRealloc.79+0x115>
  217805:	48 8d 0d c4 8f fe ff 	lea    rcx,[rip+0xfffffffffffe8fc4]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21780c:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  217810:	0f 84 da 00 00 00    	je     2178f0 <Allocator_alignedRealloc.79+0x130>
  217816:	48 8b 05 d3 ed fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffeedd3]        # 2065f0 <__unnamed_87+0x10>
  21781d:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  217821:	c5 f8 10 05 b7 ed fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffeedb7]        # 2065e0 <__unnamed_87>
  217828:	ff 
  217829:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  21782d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  217834:	5b                   	pop    rbx
  217835:	41 5e                	pop    r14
  217837:	c3                   	ret    
        if (n == 0) {
  217838:	48 85 c9             	test   rcx,rcx
  21783b:	0f 84 fc 00 00 00    	je     21793d <Allocator_alignedRealloc.79+0x17d>
  217841:	ba 28 00 00 00       	mov    edx,0x28
  217846:	48 89 c8             	mov    rax,rcx
  217849:	48 f7 e2             	mul    rdx
  21784c:	0f 81 0c 01 00 00    	jno    21795e <Allocator_alignedRealloc.79+0x19e>
  217852:	48 8d 0d 77 8f fe ff 	lea    rcx,[rip+0xfffffffffffe8f77]        # 2007d0 <__unnamed_59>
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  217859:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  21785d:	0f 84 16 01 00 00    	je     217979 <Allocator_alignedRealloc.79+0x1b9>
  217863:	0f b7 05 7c ed fe ff 	movzx  eax,WORD PTR [rip+0xfffffffffffeed7c]        # 2065e6 <__unnamed_87+0x6>
  21786a:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  21786f:	8b 05 6d ed fe ff    	mov    eax,DWORD PTR [rip+0xfffffffffffeed6d]        # 2065e2 <__unnamed_87+0x2>
  217875:	89 04 24             	mov    DWORD PTR [rsp],eax
  217878:	48 89 e0             	mov    rax,rsp
  21787b:	66 b9 05 00          	mov    cx,0x5
  21787f:	31 f6                	xor    esi,esi
  217881:	31 d2                	xor    edx,edx
  217883:	e9 9d 01 00 00       	jmp    217a25 <Allocator_alignedRealloc.79+0x265>
        const bytes = @sliceToBytes(memory);
  217888:	48 c1 e0 03          	shl    rax,0x3
  21788c:	48 8d 04 80          	lea    rax,[rax+rax*4]
        if (bytes.len == 0) return;
  217890:	48 85 c0             	test   rax,rax
  217893:	74 1e                	je     2178b3 <Allocator_alignedRealloc.79+0xf3>
        const bytes = @sliceToBytes(memory);
  217895:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
        self.freeFn(self, non_const_ptr[0..bytes.len]);
  217898:	48 8b 56 10          	mov    rdx,QWORD PTR [rsi+0x10]
  21789c:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  2178a1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  2178a6:	48 8d 44 24 08       	lea    rax,[rsp+0x8]
  2178ab:	48 89 f7             	mov    rdi,rsi
  2178ae:	48 89 c6             	mov    rsi,rax
  2178b1:	ff d2                	call   rdx
            return ([*]align(alignment) T)(undefined)[0..0];
  2178b3:	48 8b 05 1e ed fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffeed1e]        # 2065d8 <__unnamed_88+0x10>
  2178ba:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  2178be:	c5 f8 10 05 02 ed fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffeed02]        # 2065c8 <__unnamed_88>
  2178c5:	ff 
  2178c6:	c5 f8 11 03          	vmovups XMMWORD PTR [rbx],xmm0
  2178ca:	48 81 c4 88 00 00 00 	add    rsp,0x88
  2178d1:	5b                   	pop    rbx
  2178d2:	41 5e                	pop    r14
  2178d4:	c3                   	ret    
  2178d5:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
  2178da:	66 c7 44 24 08 00 00 	mov    WORD PTR [rsp+0x8],0x0
  2178e1:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  2178e6:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  2178ea:	0f 85 26 ff ff ff    	jne    217816 <Allocator_alignedRealloc.79+0x56>
  2178f0:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  2178f4:	48 8d 7c 24 58       	lea    rdi,[rsp+0x58]
  2178f9:	48 8d 54 24 38       	lea    rdx,[rsp+0x38]
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2178fe:	41 b8 08 00 00 00    	mov    r8d,0x8
  217904:	4c 89 f1             	mov    rcx,r14
  217907:	ff 56 08             	call   QWORD PTR [rsi+0x8]
  21790a:	0f b7 44 24 58       	movzx  eax,WORD PTR [rsp+0x58]
  21790f:	66 85 c0             	test   ax,ax
  217912:	0f 84 94 00 00 00    	je     2179ac <Allocator_alignedRealloc.79+0x1ec>
  217918:	66 89 03             	mov    WORD PTR [rbx],ax
  21791b:	48 8b 84 24 80 00 00 	mov    rax,QWORD PTR [rsp+0x80]
  217922:	00 
  217923:	48 89 43 10          	mov    QWORD PTR [rbx+0x10],rax
  217927:	c5 f8 10 44 24 72    	vmovups xmm0,XMMWORD PTR [rsp+0x72]
  21792d:	c5 f8 11 43 02       	vmovups XMMWORD PTR [rbx+0x2],xmm0
  217932:	48 81 c4 88 00 00 00 	add    rsp,0x88
  217939:	5b                   	pop    rbx
  21793a:	41 5e                	pop    r14
  21793c:	c3                   	ret    
  21793d:	48 89 e0             	mov    rax,rsp
            return ([*]align(alignment) T)(undefined)[0..0];
  217940:	0f b7 0d 87 ec fe ff 	movzx  ecx,WORD PTR [rip+0xfffffffffffeec87]        # 2065ce <__unnamed_88+0x6>
  217947:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  21794c:	8b 0d 78 ec fe ff    	mov    ecx,DWORD PTR [rip+0xfffffffffffeec78]        # 2065ca <__unnamed_88+0x2>
  217952:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  217955:	31 c9                	xor    ecx,ecx
  217957:	31 d2                	xor    edx,edx
  217959:	e9 c7 00 00 00       	jmp    217a25 <Allocator_alignedRealloc.79+0x265>
  21795e:	48 8d 4c 24 48       	lea    rcx,[rsp+0x48]
  217963:	66 c7 44 24 48 00 00 	mov    WORD PTR [rsp+0x48],0x0
  21796a:	48 89 44 24 50       	mov    QWORD PTR [rsp+0x50],rax
        const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;
  21796f:	66 83 39 00          	cmp    WORD PTR [rcx],0x0
  217973:	0f 85 ea fe ff ff    	jne    217863 <Allocator_alignedRealloc.79+0xa3>
  217979:	4c 8b 71 08          	mov    r14,QWORD PTR [rcx+0x8]
  21797d:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  217982:	b9 08 00 00 00       	mov    ecx,0x8
  217987:	4c 89 f2             	mov    rdx,r14
  21798a:	ff 16                	call   QWORD PTR [rsi]
  21798c:	0f b7 4c 24 08       	movzx  ecx,WORD PTR [rsp+0x8]
  217991:	66 85 c9             	test   cx,cx
  217994:	74 57                	je     2179ed <Allocator_alignedRealloc.79+0x22d>
  217996:	0f b7 44 24 36       	movzx  eax,WORD PTR [rsp+0x36]
  21799b:	66 89 44 24 04       	mov    WORD PTR [rsp+0x4],ax
  2179a0:	48 89 e0             	mov    rax,rsp
  2179a3:	8b 54 24 32          	mov    edx,DWORD PTR [rsp+0x32]
  2179a7:	89 14 24             	mov    DWORD PTR [rsp],edx
  2179aa:	eb 79                	jmp    217a25 <Allocator_alignedRealloc.79+0x265>
        assert(byte_slice.len == byte_count);
  2179ac:	4c 39 74 24 68       	cmp    QWORD PTR [rsp+0x68],r14
    if (!ok) {
  2179b1:	0f 85 91 00 00 00    	jne    217a48 <Allocator_alignedRealloc.79+0x288>
        const byte_slice = try self.reallocFn(self, old_byte_slice, byte_count, alignment);
  2179b7:	48 8b 44 24 60       	mov    rax,QWORD PTR [rsp+0x60]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2179bc:	48 b9 cd cc cc cc cc 	movabs rcx,0xcccccccccccccccd
  2179c3:	cc cc cc 
  2179c6:	4c 89 f2             	mov    rdx,r14
  2179c9:	c4 e2 f3 f6 d1       	mulx   rdx,rcx,rcx
  2179ce:	66 c7 03 00 00       	mov    WORD PTR [rbx],0x0
  2179d3:	0f b7 4c 24 2a       	movzx  ecx,WORD PTR [rsp+0x2a]
  2179d8:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  2179dc:	48 c1 ea 05          	shr    rdx,0x5
  2179e0:	8b 4c 24 26          	mov    ecx,DWORD PTR [rsp+0x26]
  2179e4:	89 4b 02             	mov    DWORD PTR [rbx+0x2],ecx
  2179e7:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
  2179eb:	eb 4c                	jmp    217a39 <Allocator_alignedRealloc.79+0x279>
        assert(byte_slice.len == byte_count);
  2179ed:	4c 39 74 24 18       	cmp    QWORD PTR [rsp+0x18],r14
  2179f2:	75 54                	jne    217a48 <Allocator_alignedRealloc.79+0x288>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2179f4:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
        return @bytesToSlice(T, @alignCast(alignment, byte_slice));
  2179f9:	48 b8 cd cc cc cc cc 	movabs rax,0xcccccccccccccccd
  217a00:	cc cc cc 
  217a03:	4c 89 f2             	mov    rdx,r14
  217a06:	c4 e2 fb f6 d0       	mulx   rdx,rax,rax
  217a0b:	48 c1 ea 05          	shr    rdx,0x5
  217a0f:	48 89 e0             	mov    rax,rsp
  217a12:	8b 4c 24 2c          	mov    ecx,DWORD PTR [rsp+0x2c]
  217a16:	89 0c 24             	mov    DWORD PTR [rsp],ecx
  217a19:	0f b7 4c 24 30       	movzx  ecx,WORD PTR [rsp+0x30]
  217a1e:	66 89 4c 24 04       	mov    WORD PTR [rsp+0x4],cx
  217a23:	31 c9                	xor    ecx,ecx
            return self.alignedAlloc(T, alignment, n);
  217a25:	66 89 0b             	mov    WORD PTR [rbx],cx
  217a28:	0f b7 48 04          	movzx  ecx,WORD PTR [rax+0x4]
  217a2c:	66 89 4b 06          	mov    WORD PTR [rbx+0x6],cx
  217a30:	8b 00                	mov    eax,DWORD PTR [rax]
  217a32:	89 43 02             	mov    DWORD PTR [rbx+0x2],eax
  217a35:	48 89 73 08          	mov    QWORD PTR [rbx+0x8],rsi
  217a39:	48 89 53 10          	mov    QWORD PTR [rbx+0x10],rdx
  217a3d:	48 81 c4 88 00 00 00 	add    rsp,0x88
  217a44:	5b                   	pop    rbx
  217a45:	41 5e                	pop    r14
  217a47:	c3                   	ret    
            @panic("assertion failure");
  217a48:	e8 63 22 ff ff       	call   209cb0 <panic>
  217a4d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000217a50 <DirectAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  217a50:	41 57                	push   r15
  217a52:	41 56                	push   r14
  217a54:	41 55                	push   r13
  217a56:	41 54                	push   r12
  217a58:	53                   	push   rbx
  217a59:	48 83 ec 10          	sub    rsp,0x10
  217a5d:	41 89 cc             	mov    r12d,ecx
  217a60:	49 89 d6             	mov    r14,rdx
  217a63:	49 89 ff             	mov    r15,rdi
  217a66:	45 89 e5             	mov    r13d,r12d
  217a69:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  217a70:	31 c0                	xor    eax,eax
  217a72:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  217a79:	4c 89 eb             	mov    rbx,r13
  217a7c:	48 0f 42 d8          	cmovb  rbx,rax
  217a80:	4a 8d 34 33          	lea    rsi,[rbx+r14*1]
    return asm volatile ("syscall"
  217a84:	b8 09 00 00 00       	mov    eax,0x9
  217a89:	bf 00 00 00 00       	mov    edi,0x0
  217a8e:	ba 03 00 00 00       	mov    edx,0x3
  217a93:	41 ba 22 00 00 00    	mov    r10d,0x22
  217a99:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  217aa0:	45 31 c9             	xor    r9d,r9d
  217aa3:	0f 05                	syscall 
  217aa5:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  217aa8:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  217aac:	74 55                	je     217b03 <DirectAllocator_alloc+0xb3>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  217aae:	48 85 db             	test   rbx,rbx
  217ab1:	74 6a                	je     217b1d <DirectAllocator_alloc+0xcd>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  217ab3:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  217aba:	41 f7 d4             	not    r12d
  217abd:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  217ac4:	49 21 cc             	and    r12,rcx
  217ac7:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  217aca:	48 89 ce             	mov    rsi,rcx
  217acd:	48 f7 d6             	not    rsi
  217ad0:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  217ad3:	b8 0b 00 00 00       	mov    eax,0xb
  217ad8:	48 89 cf             	mov    rdi,rcx
  217adb:	0f 05                	syscall 
  217add:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  217ae3:	73 69                	jae    217b4e <DirectAllocator_alloc+0xfe>
                return @intToPtr([*]u8, aligned_addr)[0..n];
  217ae5:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  217aeb:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  217af0:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  217af5:	8b 44 24 04          	mov    eax,DWORD PTR [rsp+0x4]
  217af9:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  217afd:	4d 89 67 08          	mov    QWORD PTR [r15+0x8],r12
  217b01:	eb 36                	jmp    217b39 <DirectAllocator_alloc+0xe9>
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  217b03:	48 8b 05 3e fc fe ff 	mov    rax,QWORD PTR [rip+0xfffffffffffefc3e]        # 207748 <__unnamed_61+0x10>
  217b0a:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  217b0e:	c5 f8 10 05 22 fc fe 	vmovups xmm0,XMMWORD PTR [rip+0xfffffffffffefc22]        # 207738 <__unnamed_61>
  217b15:	ff 
  217b16:	c4 c1 78 11 07       	vmovups XMMWORD PTR [r15],xmm0
  217b1b:	eb 20                	jmp    217b3d <DirectAllocator_alloc+0xed>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  217b1d:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  217b23:	0f b7 44 24 0e       	movzx  eax,WORD PTR [rsp+0xe]
  217b28:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  217b2d:	8b 44 24 0a          	mov    eax,DWORD PTR [rsp+0xa]
  217b31:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  217b35:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  217b39:	4d 89 77 10          	mov    QWORD PTR [r15+0x10],r14
  217b3d:	4c 89 f8             	mov    rax,r15
  217b40:	48 83 c4 10          	add    rsp,0x10
  217b44:	5b                   	pop    rbx
  217b45:	41 5c                	pop    r12
  217b47:	41 5d                	pop    r13
  217b49:	41 5e                	pop    r14
  217b4b:	41 5f                	pop    r15
  217b4d:	c3                   	ret    
            @panic("assertion failure");
  217b4e:	e8 5d 21 ff ff       	call   209cb0 <panic>
  217b53:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  217b5a:	84 00 00 00 00 00 

0000000000217b60 <DirectAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  217b60:	55                   	push   rbp
  217b61:	41 57                	push   r15
  217b63:	41 56                	push   r14
  217b65:	41 55                	push   r13
  217b67:	41 54                	push   r12
  217b69:	53                   	push   rbx
  217b6a:	48 83 ec 28          	sub    rsp,0x28
  217b6e:	45 89 c4             	mov    r12d,r8d
  217b71:	48 89 cb             	mov    rbx,rcx
  217b74:	49 89 d6             	mov    r14,rdx
  217b77:	49 89 ff             	mov    r15,rdi
                if (new_size <= old_mem.len) {
  217b7a:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  217b7e:	48 39 de             	cmp    rsi,rbx
  217b81:	0f 83 c7 00 00 00    	jae    217c4e <DirectAllocator_realloc+0xee>
                const alloc_size = if (alignment <= os.page_size) n else n + alignment;
  217b87:	45 89 e5             	mov    r13d,r12d
  217b8a:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  217b91:	31 c0                	xor    eax,eax
  217b93:	41 81 fd 01 10 00 00 	cmp    r13d,0x1001
  217b9a:	4c 89 ed             	mov    rbp,r13
  217b9d:	48 0f 42 e8          	cmovb  rbp,rax
  217ba1:	48 8d 74 1d 00       	lea    rsi,[rbp+rbx*1+0x0]
    return asm volatile ("syscall"
  217ba6:	b8 09 00 00 00       	mov    eax,0x9
  217bab:	bf 00 00 00 00       	mov    edi,0x0
  217bb0:	ba 03 00 00 00       	mov    edx,0x3
  217bb5:	41 ba 22 00 00 00    	mov    r10d,0x22
  217bbb:	49 c7 c0 ff ff ff ff 	mov    r8,0xffffffffffffffff
  217bc2:	45 31 c9             	xor    r9d,r9d
  217bc5:	0f 05                	syscall 
  217bc7:	48 89 c1             	mov    rcx,rax
                if (addr == p.MAP_FAILED) return error.OutOfMemory;
  217bca:	48 83 f9 ff          	cmp    rcx,0xffffffffffffffff
  217bce:	0f 84 d2 00 00 00    	je     217ca6 <DirectAllocator_realloc+0x146>
                if (alloc_size == n) return @intToPtr([*]u8, addr)[0..n];
  217bd4:	48 85 ed             	test   rbp,rbp
  217bd7:	74 39                	je     217c12 <DirectAllocator_realloc+0xb2>
                const aligned_addr = (addr & ~usize(alignment - 1)) + alignment;
  217bd9:	41 81 c4 ff ff ff 1f 	add    r12d,0x1fffffff
  217be0:	41 f7 d4             	not    r12d
  217be3:	49 81 cc 00 00 00 e0 	or     r12,0xffffffffe0000000
  217bea:	49 21 cc             	and    r12,rcx
  217bed:	4d 01 ec             	add    r12,r13
                const unused_len = aligned_addr - 1 - unused_start;
  217bf0:	48 89 ce             	mov    rsi,rcx
  217bf3:	48 f7 d6             	not    rsi
  217bf6:	4c 01 e6             	add    rsi,r12
    return asm volatile ("syscall"
  217bf9:	b8 0b 00 00 00       	mov    eax,0xb
  217bfe:	48 89 cf             	mov    rdi,rcx
  217c01:	0f 05                	syscall 
  217c03:	4c 89 e1             	mov    rcx,r12
  217c06:	48 3d 01 f0 ff ff    	cmp    rax,0xfffffffffffff001
    if (!ok) {
  217c0c:	0f 83 74 01 00 00    	jae    217d86 <DirectAllocator_realloc+0x226>
    assert(dest.len >= source.len);
  217c12:	49 8b 76 08          	mov    rsi,QWORD PTR [r14+0x8]
  217c16:	48 89 dd             	mov    rbp,rbx
  217c19:	48 39 de             	cmp    rsi,rbx
  217c1c:	0f 87 64 01 00 00    	ja     217d86 <DirectAllocator_realloc+0x226>
    for (source) |s, i|
  217c22:	48 85 f6             	test   rsi,rsi
  217c25:	0f 84 29 01 00 00    	je     217d54 <DirectAllocator_realloc+0x1f4>
  217c2b:	48 8d 56 ff          	lea    rdx,[rsi-0x1]
  217c2f:	89 f0                	mov    eax,esi
  217c31:	83 e0 07             	and    eax,0x7
  217c34:	48 83 fa 07          	cmp    rdx,0x7
  217c38:	0f 83 88 00 00 00    	jae    217cc6 <DirectAllocator_realloc+0x166>
  217c3e:	31 d2                	xor    edx,edx
  217c40:	48 85 c0             	test   rax,rax
  217c43:	0f 85 f3 00 00 00    	jne    217d3c <DirectAllocator_realloc+0x1dc>
  217c49:	e9 06 01 00 00       	jmp    217d54 <DirectAllocator_realloc+0x1f4>
                    const base_addr = @ptrToInt(old_mem.ptr);
  217c4e:	49 8b 06             	mov    rax,QWORD PTR [r14]
                    const old_addr_end = base_addr + old_mem.len;
  217c51:	48 01 c6             	add    rsi,rax
                    const new_addr_end = base_addr + new_size;
  217c54:	48 8d 0c 18          	lea    rcx,[rax+rbx*1]
                    const rem = @rem(new_addr_end, os.page_size);
  217c58:	89 ca                	mov    edx,ecx
  217c5a:	81 e2 ff 0f 00 00    	and    edx,0xfff
                    const new_addr_end_rounded = new_addr_end + if (rem == 0) 0 else (os.page_size - rem);
  217c60:	bf 00 10 00 00       	mov    edi,0x1000
  217c65:	48 29 d7             	sub    rdi,rdx
  217c68:	48 85 d2             	test   rdx,rdx
  217c6b:	48 0f 44 fa          	cmove  rdi,rdx
  217c6f:	48 01 cf             	add    rdi,rcx
                    if (old_addr_end > new_addr_end_rounded) {
  217c72:	48 29 fe             	sub    rsi,rdi
  217c75:	76 0a                	jbe    217c81 <DirectAllocator_realloc+0x121>
  217c77:	b8 0b 00 00 00       	mov    eax,0xb
  217c7c:	0f 05                	syscall 
                    return old_mem[0..new_size];
  217c7e:	49 8b 06             	mov    rax,QWORD PTR [r14]
  217c81:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  217c87:	0f b7 4c 24 10       	movzx  ecx,WORD PTR [rsp+0x10]
  217c8c:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  217c91:	8b 4c 24 0c          	mov    ecx,DWORD PTR [rsp+0xc]
  217c95:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  217c99:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  217c9d:	49 89 5f 10          	mov    QWORD PTR [r15+0x10],rbx
  217ca1:	e9 ce 00 00 00       	jmp    217d74 <DirectAllocator_realloc+0x214>
                const result = try alloc(allocator, new_size, alignment);
  217ca6:	66 41 c7 07 05 00    	mov    WORD PTR [r15],0x5
  217cac:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  217cb1:	49 89 47 10          	mov    QWORD PTR [r15+0x10],rax
  217cb5:	c5 f8 10 44 24 12    	vmovups xmm0,XMMWORD PTR [rsp+0x12]
  217cbb:	c4 c1 78 11 47 02    	vmovups XMMWORD PTR [r15+0x2],xmm0
  217cc1:	e9 ae 00 00 00       	jmp    217d74 <DirectAllocator_realloc+0x214>
  217cc6:	48 29 c6             	sub    rsi,rax
  217cc9:	31 d2                	xor    edx,edx
  217ccb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  217cd0:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217cd3:	0f b6 1c 17          	movzx  ebx,BYTE PTR [rdi+rdx*1]
        dest[i] = s;
  217cd7:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  217cda:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217cdd:	0f b6 5c 17 01       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x1]
        dest[i] = s;
  217ce2:	88 5c 11 01          	mov    BYTE PTR [rcx+rdx*1+0x1],bl
    for (source) |s, i|
  217ce6:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217ce9:	0f b6 5c 17 02       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x2]
        dest[i] = s;
  217cee:	88 5c 11 02          	mov    BYTE PTR [rcx+rdx*1+0x2],bl
    for (source) |s, i|
  217cf2:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217cf5:	0f b6 5c 17 03       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x3]
        dest[i] = s;
  217cfa:	88 5c 11 03          	mov    BYTE PTR [rcx+rdx*1+0x3],bl
    for (source) |s, i|
  217cfe:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217d01:	0f b6 5c 17 04       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x4]
        dest[i] = s;
  217d06:	88 5c 11 04          	mov    BYTE PTR [rcx+rdx*1+0x4],bl
    for (source) |s, i|
  217d0a:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217d0d:	0f b6 5c 17 05       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x5]
        dest[i] = s;
  217d12:	88 5c 11 05          	mov    BYTE PTR [rcx+rdx*1+0x5],bl
    for (source) |s, i|
  217d16:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217d19:	0f b6 5c 17 06       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x6]
        dest[i] = s;
  217d1e:	88 5c 11 06          	mov    BYTE PTR [rcx+rdx*1+0x6],bl
    for (source) |s, i|
  217d22:	49 8b 3e             	mov    rdi,QWORD PTR [r14]
  217d25:	0f b6 5c 17 07       	movzx  ebx,BYTE PTR [rdi+rdx*1+0x7]
        dest[i] = s;
  217d2a:	88 5c 11 07          	mov    BYTE PTR [rcx+rdx*1+0x7],bl
    for (source) |s, i|
  217d2e:	48 83 c2 08          	add    rdx,0x8
  217d32:	48 39 d6             	cmp    rsi,rdx
  217d35:	75 99                	jne    217cd0 <DirectAllocator_realloc+0x170>
  217d37:	48 85 c0             	test   rax,rax
  217d3a:	74 18                	je     217d54 <DirectAllocator_realloc+0x1f4>
  217d3c:	48 f7 d8             	neg    rax
  217d3f:	90                   	nop
  217d40:	49 8b 36             	mov    rsi,QWORD PTR [r14]
  217d43:	0f b6 1c 16          	movzx  ebx,BYTE PTR [rsi+rdx*1]
        dest[i] = s;
  217d47:	88 1c 11             	mov    BYTE PTR [rcx+rdx*1],bl
    for (source) |s, i|
  217d4a:	48 83 c2 01          	add    rdx,0x1
  217d4e:	48 83 c0 01          	add    rax,0x1
  217d52:	75 ec                	jne    217d40 <DirectAllocator_realloc+0x1e0>
                return result;
  217d54:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  217d5a:	0f b7 44 24 0a       	movzx  eax,WORD PTR [rsp+0xa]
  217d5f:	66 41 89 47 06       	mov    WORD PTR [r15+0x6],ax
  217d64:	8b 44 24 06          	mov    eax,DWORD PTR [rsp+0x6]
  217d68:	41 89 47 02          	mov    DWORD PTR [r15+0x2],eax
  217d6c:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  217d70:	49 89 6f 10          	mov    QWORD PTR [r15+0x10],rbp
  217d74:	4c 89 f8             	mov    rax,r15
  217d77:	48 83 c4 28          	add    rsp,0x28
  217d7b:	5b                   	pop    rbx
  217d7c:	41 5c                	pop    r12
  217d7e:	41 5d                	pop    r13
  217d80:	41 5e                	pop    r14
  217d82:	41 5f                	pop    r15
  217d84:	5d                   	pop    rbp
  217d85:	c3                   	ret    
            @panic("assertion failure");
  217d86:	e8 25 1f ff ff       	call   209cb0 <panic>
  217d8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000217d90 <DirectAllocator_free>:
                _ = os.posix.munmap(@ptrToInt(bytes.ptr), bytes.len);
  217d90:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  217d93:	48 8b 76 08          	mov    rsi,QWORD PTR [rsi+0x8]
  217d97:	b8 0b 00 00 00       	mov    eax,0xb
  217d9c:	0f 05                	syscall 
    fn free(allocator: *Allocator, bytes: []u8) void {
  217d9e:	c3                   	ret    
  217d9f:	90                   	nop

0000000000217da0 <ArenaAllocator_alloc>:
    fn alloc(allocator: *Allocator, n: usize, alignment: u29) ![]u8 {
  217da0:	55                   	push   rbp
  217da1:	41 57                	push   r15
  217da3:	41 56                	push   r14
  217da5:	41 55                	push   r13
  217da7:	41 54                	push   r12
  217da9:	53                   	push   rbx
  217daa:	48 83 ec 58          	sub    rsp,0x58
  217dae:	89 cb                	mov    ebx,ecx
  217db0:	49 89 d7             	mov    r15,rdx
  217db3:	49 89 f4             	mov    r12,rsi
  217db6:	49 89 fe             	mov    r14,rdi
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  217db9:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  217dbe:	81 e3 ff ff ff 1f    	and    ebx,0x1fffffff
  217dc4:	4e 8d 2c 3b          	lea    r13,[rbx+r15*1]
  217dc8:	48 85 c0             	test   rax,rax
  217dcb:	74 29                	je     217df6 <ArenaAllocator_alloc+0x56>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  217dcd:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  217dd1:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  217dd5:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  217dd9:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  217dde:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  217de2:	48 83 c0 20          	add    rax,0x20
  217de6:	48 89 c2             	mov    rdx,rax
  217de9:	48 c1 ea 20          	shr    rdx,0x20
  217ded:	74 3f                	je     217e2e <ArenaAllocator_alloc+0x8e>
  217def:	31 d2                	xor    edx,edx
  217df1:	48 f7 f3             	div    rbx
  217df4:	eb 3c                	jmp    217e32 <ArenaAllocator_alloc+0x92>
  217df6:	48 8d 7c 24 18       	lea    rdi,[rsp+0x18]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  217dfb:	31 d2                	xor    edx,edx
  217dfd:	4c 89 e6             	mov    rsi,r12
  217e00:	4c 89 e9             	mov    rcx,r13
  217e03:	e8 68 03 00 00       	call   218170 <ArenaAllocator_createNode>
  217e08:	0f b7 44 24 18       	movzx  eax,WORD PTR [rsp+0x18]
  217e0d:	66 85 c0             	test   ax,ax
  217e10:	0f 84 fe 00 00 00    	je     217f14 <ArenaAllocator_alloc+0x174>
  217e16:	66 41 89 06          	mov    WORD PTR [r14],ax
  217e1a:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  217e1f:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  217e23:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  217e29:	e9 ce 00 00 00       	jmp    217efc <ArenaAllocator_alloc+0x15c>
  217e2e:	31 d2                	xor    edx,edx
  217e30:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  217e32:	48 89 d8             	mov    rax,rbx
  217e35:	48 29 d0             	sub    rax,rdx
  217e38:	48 85 d2             	test   rdx,rdx
  217e3b:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  217e3f:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  217e42:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  217e46:	48 39 ca             	cmp    rdx,rcx
  217e49:	76 72                	jbe    217ebd <ArenaAllocator_alloc+0x11d>
  217e4b:	48 8d 6c 24 08       	lea    rbp,[rsp+0x8]
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  217e50:	48 89 ef             	mov    rdi,rbp
  217e53:	4c 89 e6             	mov    rsi,r12
  217e56:	48 89 ca             	mov    rdx,rcx
  217e59:	4c 89 e9             	mov    rcx,r13
  217e5c:	e8 0f 03 00 00       	call   218170 <ArenaAllocator_createNode>
  217e61:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  217e66:	66 85 c0             	test   ax,ax
  217e69:	75 7e                	jne    217ee9 <ArenaAllocator_alloc+0x149>
  217e6b:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  217e70:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  217e74:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  217e78:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  217e7c:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  217e81:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  217e85:	48 83 c0 20          	add    rax,0x20
  217e89:	48 89 c2             	mov    rdx,rax
  217e8c:	48 c1 ea 20          	shr    rdx,0x20
  217e90:	74 0e                	je     217ea0 <ArenaAllocator_alloc+0x100>
  217e92:	31 d2                	xor    edx,edx
  217e94:	48 f7 f3             	div    rbx
  217e97:	eb 0b                	jmp    217ea4 <ArenaAllocator_alloc+0x104>
  217e99:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  217ea0:	31 d2                	xor    edx,edx
  217ea2:	f7 f3                	div    ebx
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  217ea4:	48 89 d8             	mov    rax,rbx
  217ea7:	48 29 d0             	sub    rax,rdx
  217eaa:	48 85 d2             	test   rdx,rdx
  217ead:	48 0f 44 c2          	cmove  rax,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  217eb1:	48 01 f8             	add    rax,rdi
            const new_end_index = adjusted_index + n;
  217eb4:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
            if (new_end_index > cur_buf.len) {
  217eb8:	48 39 ca             	cmp    rdx,rcx
  217ebb:	77 93                	ja     217e50 <ArenaAllocator_alloc+0xb0>
            self.end_index = new_end_index;
  217ebd:	49 89 54 24 38       	mov    QWORD PTR [r12+0x38],rdx
            return result;
  217ec2:	66 41 c7 06 00 00    	mov    WORD PTR [r14],0x0
  217ec8:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  217ecd:	66 41 89 4e 06       	mov    WORD PTR [r14+0x6],cx
            const result = cur_buf[adjusted_index..new_end_index];
  217ed2:	48 8d 44 06 20       	lea    rax,[rsi+rax*1+0x20]
            return result;
  217ed7:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  217edb:	41 89 4e 02          	mov    DWORD PTR [r14+0x2],ecx
  217edf:	49 89 46 08          	mov    QWORD PTR [r14+0x8],rax
  217ee3:	4d 89 7e 10          	mov    QWORD PTR [r14+0x10],r15
  217ee7:	eb 19                	jmp    217f02 <ArenaAllocator_alloc+0x162>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  217ee9:	66 41 89 06          	mov    WORD PTR [r14],ax
  217eed:	48 8b 44 24 3a       	mov    rax,QWORD PTR [rsp+0x3a]
  217ef2:	49 89 46 10          	mov    QWORD PTR [r14+0x10],rax
  217ef6:	c5 f8 10 44 24 2c    	vmovups xmm0,XMMWORD PTR [rsp+0x2c]
  217efc:	c4 c1 78 11 46 02    	vmovups XMMWORD PTR [r14+0x2],xmm0
  217f02:	4c 89 f0             	mov    rax,r14
  217f05:	48 83 c4 58          	add    rsp,0x58
  217f09:	5b                   	pop    rbx
  217f0a:	41 5c                	pop    r12
  217f0c:	41 5d                	pop    r13
  217f0e:	41 5e                	pop    r14
  217f10:	41 5f                	pop    r15
  217f12:	5d                   	pop    rbp
  217f13:	c3                   	ret    
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  217f14:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
  217f19:	e9 af fe ff ff       	jmp    217dcd <ArenaAllocator_alloc+0x2d>
  217f1e:	66 90                	xchg   ax,ax

0000000000217f20 <ArenaAllocator_realloc>:
    fn realloc(allocator: *Allocator, old_mem: []u8, new_size: usize, alignment: u29) ![]u8 {
  217f20:	55                   	push   rbp
  217f21:	41 57                	push   r15
  217f23:	41 56                	push   r14
  217f25:	41 55                	push   r13
  217f27:	41 54                	push   r12
  217f29:	53                   	push   rbx
  217f2a:	48 83 ec 58          	sub    rsp,0x58
  217f2e:	45 89 c5             	mov    r13d,r8d
  217f31:	49 89 cf             	mov    r15,rcx
  217f34:	48 89 d3             	mov    rbx,rdx
  217f37:	49 89 f4             	mov    r12,rsi
  217f3a:	48 89 fd             	mov    rbp,rdi
        if (new_size <= old_mem.len) {
  217f3d:	4c 39 7b 08          	cmp    QWORD PTR [rbx+0x8],r15
  217f41:	73 43                	jae    217f86 <ArenaAllocator_realloc+0x66>
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  217f43:	49 8b 44 24 28       	mov    rax,QWORD PTR [r12+0x28]
  217f48:	41 81 e5 ff ff ff 1f 	and    r13d,0x1fffffff
  217f4f:	4f 8d 34 2f          	lea    r14,[r15+r13*1]
  217f53:	48 85 c0             	test   rax,rax
  217f56:	74 54                	je     217fac <ArenaAllocator_realloc+0x8c>
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  217f58:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  217f5c:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  217f60:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  217f64:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  217f69:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  217f6d:	48 83 c0 20          	add    rax,0x20
  217f71:	48 89 c2             	mov    rdx,rax
  217f74:	48 c1 ea 20          	shr    rdx,0x20
  217f78:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
  217f7d:	75 77                	jne    217ff6 <ArenaAllocator_realloc+0xd6>
  217f7f:	31 d2                	xor    edx,edx
  217f81:	41 f7 f5             	div    r13d
  217f84:	eb 75                	jmp    217ffb <ArenaAllocator_realloc+0xdb>
            return old_mem[0..new_size];
  217f86:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  217f89:	66 c7 45 00 00 00    	mov    WORD PTR [rbp+0x0],0x0
  217f8f:	0f b7 4c 24 1e       	movzx  ecx,WORD PTR [rsp+0x1e]
  217f94:	66 89 4d 06          	mov    WORD PTR [rbp+0x6],cx
  217f98:	8b 4c 24 1a          	mov    ecx,DWORD PTR [rsp+0x1a]
  217f9c:	89 4d 02             	mov    DWORD PTR [rbp+0x2],ecx
  217f9f:	48 89 45 08          	mov    QWORD PTR [rbp+0x8],rax
  217fa3:	4c 89 7d 10          	mov    QWORD PTR [rbp+0x10],r15
  217fa7:	e9 a2 00 00 00       	jmp    21804e <ArenaAllocator_realloc+0x12e>
  217fac:	48 8d 7c 24 30       	lea    rdi,[rsp+0x30]
        var cur_node = if (self.buffer_list.last) |last_node| last_node else try self.createNode(0, n + alignment);
  217fb1:	31 d2                	xor    edx,edx
  217fb3:	4c 89 e6             	mov    rsi,r12
  217fb6:	4c 89 f1             	mov    rcx,r14
  217fb9:	e8 b2 01 00 00       	call   218170 <ArenaAllocator_createNode>
  217fbe:	0f b7 44 24 30       	movzx  eax,WORD PTR [rsp+0x30]
  217fc3:	66 85 c0             	test   ax,ax
  217fc6:	75 6e                	jne    218036 <ArenaAllocator_realloc+0x116>
  217fc8:	48 8b 44 24 38       	mov    rax,QWORD PTR [rsp+0x38]
  217fcd:	eb 89                	jmp    217f58 <ArenaAllocator_realloc+0x38>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  217fcf:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
            const cur_buf = cur_node.data[@sizeOf(BufNode)..];
  217fd4:	48 8b 70 10          	mov    rsi,QWORD PTR [rax+0x10]
  217fd8:	48 8b 48 18          	mov    rcx,QWORD PTR [rax+0x18]
  217fdc:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
            const addr = @ptrToInt(cur_buf.ptr) + self.end_index;
  217fe0:	49 8b 7c 24 38       	mov    rdi,QWORD PTR [r12+0x38]
  217fe5:	48 8d 04 37          	lea    rax,[rdi+rsi*1]
  217fe9:	48 83 c0 20          	add    rax,0x20
  217fed:	48 89 c2             	mov    rdx,rax
  217ff0:	48 c1 ea 20          	shr    rdx,0x20
  217ff4:	74 89                	je     217f7f <ArenaAllocator_realloc+0x5f>
  217ff6:	31 d2                	xor    edx,edx
  217ff8:	49 f7 f5             	div    r13
            const march_forward_bytes = if (rem == 0) 0 else (alignment - rem);
  217ffb:	4c 89 ed             	mov    rbp,r13
  217ffe:	48 29 d5             	sub    rbp,rdx
  218001:	48 85 d2             	test   rdx,rdx
  218004:	48 0f 44 ea          	cmove  rbp,rdx
            const adjusted_index = self.end_index + march_forward_bytes;
  218008:	48 01 fd             	add    rbp,rdi
            const new_end_index = adjusted_index + n;
  21800b:	49 8d 04 2f          	lea    rax,[r15+rbp*1]
            if (new_end_index > cur_buf.len) {
  21800f:	48 39 c8             	cmp    rax,rcx
  218012:	76 42                	jbe    218056 <ArenaAllocator_realloc+0x136>
                cur_node = try self.createNode(cur_buf.len, n + alignment);
  218014:	48 8d 7c 24 20       	lea    rdi,[rsp+0x20]
  218019:	4c 89 e6             	mov    rsi,r12
  21801c:	48 89 ca             	mov    rdx,rcx
  21801f:	4c 89 f1             	mov    rcx,r14
  218022:	e8 49 01 00 00       	call   218170 <ArenaAllocator_createNode>
  218027:	0f b7 44 24 20       	movzx  eax,WORD PTR [rsp+0x20]
  21802c:	66 85 c0             	test   ax,ax
  21802f:	74 9e                	je     217fcf <ArenaAllocator_realloc+0xaf>
  218031:	48 8b 6c 24 08       	mov    rbp,QWORD PTR [rsp+0x8]
            const result = try alloc(allocator, new_size, alignment);
  218036:	66 89 45 00          	mov    WORD PTR [rbp+0x0],ax
  21803a:	48 8b 44 24 50       	mov    rax,QWORD PTR [rsp+0x50]
  21803f:	48 89 45 10          	mov    QWORD PTR [rbp+0x10],rax
  218043:	c5 f8 10 44 24 42    	vmovups xmm0,XMMWORD PTR [rsp+0x42]
  218049:	c5 f8 11 45 02       	vmovups XMMWORD PTR [rbp+0x2],xmm0
  21804e:	48 89 e8             	mov    rax,rbp
  218051:	e9 f1 00 00 00       	jmp    218147 <ArenaAllocator_realloc+0x227>
            self.end_index = new_end_index;
  218056:	49 89 44 24 38       	mov    QWORD PTR [r12+0x38],rax
    assert(dest.len >= source.len);
  21805b:	48 8b 7b 08          	mov    rdi,QWORD PTR [rbx+0x8]
  21805f:	4c 39 ff             	cmp    rdi,r15
    if (!ok) {
  218062:	0f 87 ee 00 00 00    	ja     218156 <ArenaAllocator_realloc+0x236>
  218068:	4c 8d 04 2e          	lea    r8,[rsi+rbp*1]
  21806c:	49 83 c0 20          	add    r8,0x20
    for (source) |s, i|
  218070:	48 85 ff             	test   rdi,rdi
  218073:	0f 84 ac 00 00 00    	je     218125 <ArenaAllocator_realloc+0x205>
  218079:	48 8d 57 ff          	lea    rdx,[rdi-0x1]
  21807d:	89 f9                	mov    ecx,edi
  21807f:	83 e1 07             	and    ecx,0x7
  218082:	48 83 fa 07          	cmp    rdx,0x7
  218086:	73 0c                	jae    218094 <ArenaAllocator_realloc+0x174>
  218088:	31 d2                	xor    edx,edx
  21808a:	48 85 c9             	test   rcx,rcx
  21808d:	75 7e                	jne    21810d <ArenaAllocator_realloc+0x1ed>
  21808f:	e9 91 00 00 00       	jmp    218125 <ArenaAllocator_realloc+0x205>
  218094:	48 29 cf             	sub    rdi,rcx
  218097:	48 01 ee             	add    rsi,rbp
  21809a:	48 83 c6 27          	add    rsi,0x27
  21809e:	31 d2                	xor    edx,edx
  2180a0:	48 8b 2b             	mov    rbp,QWORD PTR [rbx]
  2180a3:	0f b6 44 15 00       	movzx  eax,BYTE PTR [rbp+rdx*1+0x0]
        dest[i] = s;
  2180a8:	88 44 16 f9          	mov    BYTE PTR [rsi+rdx*1-0x7],al
    for (source) |s, i|
  2180ac:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  2180af:	0f b6 44 10 01       	movzx  eax,BYTE PTR [rax+rdx*1+0x1]
        dest[i] = s;
  2180b4:	88 44 16 fa          	mov    BYTE PTR [rsi+rdx*1-0x6],al
    for (source) |s, i|
  2180b8:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  2180bb:	0f b6 44 10 02       	movzx  eax,BYTE PTR [rax+rdx*1+0x2]
        dest[i] = s;
  2180c0:	88 44 16 fb          	mov    BYTE PTR [rsi+rdx*1-0x5],al
    for (source) |s, i|
  2180c4:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  2180c7:	0f b6 44 10 03       	movzx  eax,BYTE PTR [rax+rdx*1+0x3]
        dest[i] = s;
  2180cc:	88 44 16 fc          	mov    BYTE PTR [rsi+rdx*1-0x4],al
    for (source) |s, i|
  2180d0:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  2180d3:	0f b6 44 10 04       	movzx  eax,BYTE PTR [rax+rdx*1+0x4]
        dest[i] = s;
  2180d8:	88 44 16 fd          	mov    BYTE PTR [rsi+rdx*1-0x3],al
    for (source) |s, i|
  2180dc:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  2180df:	0f b6 44 10 05       	movzx  eax,BYTE PTR [rax+rdx*1+0x5]
        dest[i] = s;
  2180e4:	88 44 16 fe          	mov    BYTE PTR [rsi+rdx*1-0x2],al
    for (source) |s, i|
  2180e8:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  2180eb:	0f b6 44 10 06       	movzx  eax,BYTE PTR [rax+rdx*1+0x6]
        dest[i] = s;
  2180f0:	88 44 16 ff          	mov    BYTE PTR [rsi+rdx*1-0x1],al
    for (source) |s, i|
  2180f4:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  2180f7:	0f b6 44 10 07       	movzx  eax,BYTE PTR [rax+rdx*1+0x7]
        dest[i] = s;
  2180fc:	88 04 16             	mov    BYTE PTR [rsi+rdx*1],al
    for (source) |s, i|
  2180ff:	48 83 c2 08          	add    rdx,0x8
  218103:	48 39 d7             	cmp    rdi,rdx
  218106:	75 98                	jne    2180a0 <ArenaAllocator_realloc+0x180>
  218108:	48 85 c9             	test   rcx,rcx
  21810b:	74 18                	je     218125 <ArenaAllocator_realloc+0x205>
  21810d:	48 f7 d9             	neg    rcx
  218110:	48 8b 03             	mov    rax,QWORD PTR [rbx]
  218113:	0f b6 04 10          	movzx  eax,BYTE PTR [rax+rdx*1]
        dest[i] = s;
  218117:	41 88 04 10          	mov    BYTE PTR [r8+rdx*1],al
    for (source) |s, i|
  21811b:	48 83 c2 01          	add    rdx,0x1
  21811f:	48 83 c1 01          	add    rcx,0x1
  218123:	75 eb                	jne    218110 <ArenaAllocator_realloc+0x1f0>
  218125:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
            return result;
  21812a:	66 c7 00 00 00       	mov    WORD PTR [rax],0x0
  21812f:	0f b7 4c 24 18       	movzx  ecx,WORD PTR [rsp+0x18]
  218134:	66 89 48 06          	mov    WORD PTR [rax+0x6],cx
  218138:	8b 4c 24 14          	mov    ecx,DWORD PTR [rsp+0x14]
  21813c:	89 48 02             	mov    DWORD PTR [rax+0x2],ecx
  21813f:	4c 89 40 08          	mov    QWORD PTR [rax+0x8],r8
  218143:	4c 89 78 10          	mov    QWORD PTR [rax+0x10],r15
  218147:	48 83 c4 58          	add    rsp,0x58
  21814b:	5b                   	pop    rbx
  21814c:	41 5c                	pop    r12
  21814e:	41 5d                	pop    r13
  218150:	41 5e                	pop    r14
  218152:	41 5f                	pop    r15
  218154:	5d                   	pop    rbp
  218155:	c3                   	ret    
            @panic("assertion failure");
  218156:	e8 55 1b ff ff       	call   209cb0 <panic>
  21815b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000218160 <ArenaAllocator_free>:
    fn free(allocator: *Allocator, bytes: []u8) void {}
  218160:	c3                   	ret    
  218161:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  218168:	0f 1f 84 00 00 00 00 
  21816f:	00 

0000000000218170 <ArenaAllocator_createNode>:
    fn createNode(self: *ArenaAllocator, prev_len: usize, minimum_size: usize) !*BufNode {
  218170:	41 57                	push   r15
  218172:	41 56                	push   r14
  218174:	53                   	push   rbx
  218175:	48 83 ec 30          	sub    rsp,0x30
  218179:	48 89 d3             	mov    rbx,rdx
  21817c:	49 89 f6             	mov    r14,rsi
  21817f:	49 89 ff             	mov    r15,rdi
        const actual_min_size = minimum_size + @sizeOf(BufNode);
  218182:	48 83 c1 20          	add    rcx,0x20
  218186:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21818d:	00 00 00 
            len += len / 2;
  218190:	48 89 d8             	mov    rax,rbx
  218193:	48 d1 e8             	shr    rax,1
  218196:	48 01 d8             	add    rax,rbx
            len += os.page_size - @rem(len, os.page_size);
  218199:	89 c2                	mov    edx,eax
  21819b:	81 e2 ff 0f 00 00    	and    edx,0xfff
  2181a1:	bb 00 10 00 00       	mov    ebx,0x1000
  2181a6:	48 29 d3             	sub    rbx,rdx
  2181a9:	48 01 c3             	add    rbx,rax
            if (len >= actual_min_size) break;
  2181ac:	48 39 cb             	cmp    rbx,rcx
  2181af:	72 df                	jb     218190 <ArenaAllocator_createNode+0x20>
        if (n == 0) {
  2181b1:	48 85 db             	test   rbx,rbx
  2181b4:	74 38                	je     2181ee <ArenaAllocator_createNode+0x7e>
  2181b6:	49 8b 76 18          	mov    rsi,QWORD PTR [r14+0x18]
  2181ba:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2181bf:	b9 08 00 00 00       	mov    ecx,0x8
  2181c4:	48 89 da             	mov    rdx,rbx
  2181c7:	ff 16                	call   QWORD PTR [rsi]
  2181c9:	0f b7 44 24 08       	movzx  eax,WORD PTR [rsp+0x8]
  2181ce:	66 85 c0             	test   ax,ax
  2181d1:	74 1f                	je     2181f2 <ArenaAllocator_createNode+0x82>
        const buf = try self.child_allocator.alignedAlloc(u8, @alignOf(BufNode), len);
  2181d3:	66 41 89 07          	mov    WORD PTR [r15],ax
  2181d7:	48 8b 44 24 22       	mov    rax,QWORD PTR [rsp+0x22]
  2181dc:	48 8b 4c 24 28       	mov    rcx,QWORD PTR [rsp+0x28]
  2181e1:	49 89 4f 08          	mov    QWORD PTR [r15+0x8],rcx
  2181e5:	49 89 47 02          	mov    QWORD PTR [r15+0x2],rax
  2181e9:	e9 c6 00 00 00       	jmp    2182b4 <ArenaAllocator_createNode+0x144>
  2181ee:	31 db                	xor    ebx,ebx
  2181f0:	eb 10                	jmp    218202 <ArenaAllocator_createNode+0x92>
        assert(byte_slice.len == byte_count);
  2181f2:	48 39 5c 24 18       	cmp    QWORD PTR [rsp+0x18],rbx
    if (!ok) {
  2181f7:	0f 85 c1 00 00 00    	jne    2182be <ArenaAllocator_createNode+0x14e>
        const byte_slice = try self.allocFn(self, byte_count, alignment);
  2181fd:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
        buf_node.* = BufNode{
  218202:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  218206:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
  21820a:	48 89 40 10          	mov    QWORD PTR [rax+0x10],rax
  21820e:	48 89 58 18          	mov    QWORD PTR [rax+0x18],rbx
            if (list.last) |last| {
  218212:	49 8b 4e 28          	mov    rcx,QWORD PTR [r14+0x28]
  218216:	48 85 c9             	test   rcx,rcx
  218219:	74 12                	je     21822d <ArenaAllocator_createNode+0xbd>
            new_node.prev = node;
  21821b:	48 89 08             	mov    QWORD PTR [rax],rcx
            if (node.next) |next_node| {
  21821e:	48 8b 51 08          	mov    rdx,QWORD PTR [rcx+0x8]
  218222:	48 85 d2             	test   rdx,rdx
  218225:	74 24                	je     21824b <ArenaAllocator_createNode+0xdb>
                new_node.next = next_node;
  218227:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
  21822b:	eb 2a                	jmp    218257 <ArenaAllocator_createNode+0xe7>
            if (list.first) |first| {
  21822d:	49 8b 4e 20          	mov    rcx,QWORD PTR [r14+0x20]
  218231:	48 85 c9             	test   rcx,rcx
  218234:	74 2a                	je     218260 <ArenaAllocator_createNode+0xf0>
            new_node.next = node;
  218236:	48 89 48 08          	mov    QWORD PTR [rax+0x8],rcx
            if (node.prev) |prev_node| {
  21823a:	48 8b 11             	mov    rdx,QWORD PTR [rcx]
  21823d:	48 85 d2             	test   rdx,rdx
  218240:	74 38                	je     21827a <ArenaAllocator_createNode+0x10a>
                new_node.prev = prev_node;
  218242:	48 89 10             	mov    QWORD PTR [rax],rdx
                prev_node.next = new_node;
  218245:	48 83 c2 08          	add    rdx,0x8
  218249:	eb 3a                	jmp    218285 <ArenaAllocator_createNode+0x115>
  21824b:	49 8d 56 28          	lea    rdx,[r14+0x28]
                new_node.next = null;
  21824f:	48 c7 40 08 00 00 00 	mov    QWORD PTR [rax+0x8],0x0
  218256:	00 
  218257:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.next = new_node;
  21825a:	48 89 41 08          	mov    QWORD PTR [rcx+0x8],rax
  21825e:	eb 2b                	jmp    21828b <ArenaAllocator_createNode+0x11b>
                list.first = new_node;
  218260:	49 89 46 20          	mov    QWORD PTR [r14+0x20],rax
                list.last = new_node;
  218264:	49 89 46 28          	mov    QWORD PTR [r14+0x28],rax
                new_node.next = null;
  218268:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21826c:	c5 f8 11 00          	vmovups XMMWORD PTR [rax],xmm0
                list.len = 1;
  218270:	49 c7 46 30 01 00 00 	mov    QWORD PTR [r14+0x30],0x1
  218277:	00 
  218278:	eb 16                	jmp    218290 <ArenaAllocator_createNode+0x120>
  21827a:	49 8d 56 20          	lea    rdx,[r14+0x20]
                new_node.prev = null;
  21827e:	48 c7 00 00 00 00 00 	mov    QWORD PTR [rax],0x0
  218285:	48 89 02             	mov    QWORD PTR [rdx],rax
            node.prev = new_node;
  218288:	48 89 01             	mov    QWORD PTR [rcx],rax
  21828b:	49 83 46 30 01       	add    QWORD PTR [r14+0x30],0x1
        self.end_index = 0;
  218290:	49 c7 46 38 00 00 00 	mov    QWORD PTR [r14+0x38],0x0
  218297:	00 
        return buf_node;
  218298:	66 41 c7 07 00 00    	mov    WORD PTR [r15],0x0
  21829e:	0f b7 4c 24 06       	movzx  ecx,WORD PTR [rsp+0x6]
  2182a3:	66 41 89 4f 06       	mov    WORD PTR [r15+0x6],cx
  2182a8:	8b 4c 24 02          	mov    ecx,DWORD PTR [rsp+0x2]
  2182ac:	41 89 4f 02          	mov    DWORD PTR [r15+0x2],ecx
  2182b0:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
  2182b4:	48 83 c4 30          	add    rsp,0x30
  2182b8:	5b                   	pop    rbx
  2182b9:	41 5e                	pop    r14
  2182bb:	41 5f                	pop    r15
  2182bd:	c3                   	ret    
            @panic("assertion failure");
  2182be:	e8 ed 19 ff ff       	call   209cb0 <panic>
  2182c3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2182ca:	84 00 00 00 00 00 

00000000002182d0 <u64toa>:
    if (value < kTen8) {
  2182d0:	41 57                	push   r15
  2182d2:	41 56                	push   r14
  2182d4:	53                   	push   rbx
  2182d5:	48 81 ff ff e0 f5 05 	cmp    rdi,0x5f5e0ff
  2182dc:	77 4b                	ja     218329 <u64toa+0x59>
            const b: u32 = v / 10000;
  2182de:	89 f8                	mov    eax,edi
        if (v < 10000) {
  2182e0:	81 ff 0f 27 00 00    	cmp    edi,0x270f
  2182e6:	0f 87 48 01 00 00    	ja     218434 <u64toa+0x164>
            const d1: u32 = (v / 100) << 1;
  2182ec:	48 69 d0 1f 85 eb 51 	imul   rdx,rax,0x51eb851f
  2182f3:	48 c1 ea 25          	shr    rdx,0x25
            const d2: u32 = (v % 100) << 1;
  2182f7:	6b c2 64             	imul   eax,edx,0x64
            const d1: u32 = (v / 100) << 1;
  2182fa:	48 01 d2             	add    rdx,rdx
            const d2: u32 = (v % 100) << 1;
  2182fd:	89 f9                	mov    ecx,edi
  2182ff:	29 c1                	sub    ecx,eax
  218301:	48 01 c9             	add    rcx,rcx
            if (v >= 1000) {
  218304:	81 ff e8 03 00 00    	cmp    edi,0x3e8
  21830a:	0f 82 bf 01 00 00    	jb     2184cf <u64toa+0x1ff>
                buffer[buf_index] = c_digits_lut[d1];
  218310:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  218313:	48 8d 3d ae dc fe ff 	lea    rdi,[rip+0xfffffffffffedcae]        # 205fc8 <c_digits_lut>
  21831a:	8a 1c 3a             	mov    bl,BYTE PTR [rdx+rdi*1]
  21831d:	88 18                	mov    BYTE PTR [rax],bl
  21831f:	b8 01 00 00 00       	mov    eax,0x1
  218324:	e9 b1 01 00 00       	jmp    2184da <u64toa+0x20a>
  218329:	48 b9 00 00 c1 6f f2 	movabs rcx,0x2386f26fc10000
  218330:	86 23 00 
    } else if (value < kTen16) {
  218333:	48 39 cf             	cmp    rdi,rcx
  218336:	0f 83 71 01 00 00    	jae    2184ad <u64toa+0x1dd>
        const v0: u32 = @intCast(u32, value / kTen8);
  21833c:	48 b8 fd ce 61 84 11 	movabs rax,0xabcc77118461cefd
  218343:	77 cc ab 
  218346:	48 89 fa             	mov    rdx,rdi
  218349:	c4 62 fb f6 f8       	mulx   r15,rax,rax
  21834e:	49 c1 ef 1a          	shr    r15,0x1a
        const v1: u32 = @intCast(u32, value % kTen8);
  218352:	49 69 cf 00 e1 f5 05 	imul   rcx,r15,0x5f5e100
  218359:	48 89 f8             	mov    rax,rdi
  21835c:	48 29 c8             	sub    rax,rcx
        const b0: u32 = v0 / 10000;
  21835f:	44 89 fb             	mov    ebx,r15d
  218362:	41 be 59 17 b7 d1    	mov    r14d,0xd1b71759
        const d1: u32 = (b0 / 100) << 1;
  218368:	48 69 cb 83 de 1b 43 	imul   rcx,rbx,0x431bde83
        const b0: u32 = v0 / 10000;
  21836f:	49 0f af de          	imul   rbx,r14
  218373:	48 c1 eb 2d          	shr    rbx,0x2d
        const c0: u32 = v0 % 10000;
  218377:	69 d3 10 27 00 00    	imul   edx,ebx,0x2710
  21837d:	41 29 d7             	sub    r15d,edx
        const d1: u32 = (b0 / 100) << 1;
  218380:	48 c1 e9 31          	shr    rcx,0x31
  218384:	81 e1 fe 3f 00 00    	and    ecx,0x3ffe
        const d2: u32 = (b0 % 100) << 1;
  21838a:	48 69 d3 1f 85 eb 51 	imul   rdx,rbx,0x51eb851f
  218391:	48 c1 ea 25          	shr    rdx,0x25
  218395:	6b d2 64             	imul   edx,edx,0x64
  218398:	29 d3                	sub    ebx,edx
  21839a:	48 01 db             	add    rbx,rbx
        const d3: u32 = (c0 / 100) << 1;
  21839d:	4d 69 df 1f 85 eb 51 	imul   r11,r15,0x51eb851f
  2183a4:	49 c1 eb 25          	shr    r11,0x25
        const d4: u32 = (c0 % 100) << 1;
  2183a8:	41 6b d3 64          	imul   edx,r11d,0x64
        const d3: u32 = (c0 / 100) << 1;
  2183ac:	4d 01 db             	add    r11,r11
        const d4: u32 = (c0 % 100) << 1;
  2183af:	41 29 d7             	sub    r15d,edx
  2183b2:	4d 01 ff             	add    r15,r15
        const b1: u32 = v1 / 10000;
  2183b5:	4c 0f af f0          	imul   r14,rax
  2183b9:	49 c1 ee 2d          	shr    r14,0x2d
        const c1: u32 = v1 % 10000;
  2183bd:	41 69 d6 10 27 00 00 	imul   edx,r14d,0x2710
        const d5: u32 = (b1 / 100) << 1;
  2183c4:	4c 69 c8 83 de 1b 43 	imul   r9,rax,0x431bde83
        const c1: u32 = v1 % 10000;
  2183cb:	41 89 c0             	mov    r8d,eax
  2183ce:	41 29 d0             	sub    r8d,edx
        const d5: u32 = (b1 / 100) << 1;
  2183d1:	49 c1 e9 31          	shr    r9,0x31
  2183d5:	41 81 e1 fe 01 00 00 	and    r9d,0x1fe
        const d6: u32 = (b1 % 100) << 1;
  2183dc:	49 69 c6 1f 85 eb 51 	imul   rax,r14,0x51eb851f
  2183e3:	48 c1 e8 25          	shr    rax,0x25
  2183e7:	6b c0 64             	imul   eax,eax,0x64
  2183ea:	41 29 c6             	sub    r14d,eax
  2183ed:	4d 01 f6             	add    r14,r14
        const d7: u32 = (c1 / 100) << 1;
  2183f0:	4d 69 d0 1f 85 eb 51 	imul   r10,r8,0x51eb851f
  2183f7:	49 c1 ea 25          	shr    r10,0x25
        const d8: u32 = (c1 % 100) << 1;
  2183fb:	41 6b c2 64          	imul   eax,r10d,0x64
        const d7: u32 = (c1 / 100) << 1;
  2183ff:	4d 01 d2             	add    r10,r10
        const d8: u32 = (c1 % 100) << 1;
  218402:	41 29 c0             	sub    r8d,eax
  218405:	4d 01 c0             	add    r8,r8
        if (value >= kTen15) {
  218408:	48 b8 00 80 c6 a4 7e 	movabs rax,0x38d7ea4c68000
  21840f:	8d 03 00 
  218412:	48 39 c7             	cmp    rdi,rax
  218415:	0f 82 07 01 00 00    	jb     218522 <u64toa+0x252>
            buffer[buf_index] = c_digits_lut[d1];
  21841b:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  21841e:	48 8d 15 a3 db fe ff 	lea    rdx,[rip+0xfffffffffffedba3]        # 205fc8 <c_digits_lut>
  218425:	8a 14 11             	mov    dl,BYTE PTR [rcx+rdx*1]
  218428:	88 10                	mov    BYTE PTR [rax],dl
  21842a:	b8 01 00 00 00       	mov    eax,0x1
  21842f:	e9 03 01 00 00       	jmp    218537 <u64toa+0x267>
            const b: u32 = v / 10000;
  218434:	ba 59 17 b7 d1       	mov    edx,0xd1b71759
  218439:	48 0f af d0          	imul   rdx,rax
  21843d:	48 c1 ea 2d          	shr    rdx,0x2d
            const c: u32 = v % 10000;
  218441:	69 da 10 27 00 00    	imul   ebx,edx,0x2710
  218447:	89 f9                	mov    ecx,edi
  218449:	29 d9                	sub    ecx,ebx
            const d1: u32 = (b / 100) << 1;
  21844b:	48 69 d8 83 de 1b 43 	imul   rbx,rax,0x431bde83
  218452:	48 c1 eb 31          	shr    rbx,0x31
            const d2: u32 = (b % 100) << 1;
  218456:	48 69 c2 1f 85 eb 51 	imul   rax,rdx,0x51eb851f
  21845d:	48 c1 e8 25          	shr    rax,0x25
  218461:	6b c0 64             	imul   eax,eax,0x64
            const d1: u32 = (b / 100) << 1;
  218464:	81 e3 fe 3f 00 00    	and    ebx,0x3ffe
            const d2: u32 = (b % 100) << 1;
  21846a:	29 c2                	sub    edx,eax
  21846c:	48 01 d2             	add    rdx,rdx
            const d3: u32 = (c / 100) << 1;
  21846f:	4c 69 c1 1f 85 eb 51 	imul   r8,rcx,0x51eb851f
  218476:	49 c1 e8 25          	shr    r8,0x25
            const d4: u32 = (c % 100) << 1;
  21847a:	41 6b c0 64          	imul   eax,r8d,0x64
            const d3: u32 = (c / 100) << 1;
  21847e:	4d 01 c0             	add    r8,r8
            const d4: u32 = (c % 100) << 1;
  218481:	29 c1                	sub    ecx,eax
  218483:	48 01 c9             	add    rcx,rcx
            if (value >= 10000000) {
  218486:	48 81 ff 80 96 98 00 	cmp    rdi,0x989680
  21848d:	0f 82 b0 01 00 00    	jb     218643 <u64toa+0x373>
                buffer[buf_index] = c_digits_lut[d1];
  218493:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  218496:	48 8d 3d 2b db fe ff 	lea    rdi,[rip+0xfffffffffffedb2b]        # 205fc8 <c_digits_lut>
  21849d:	8a 04 3b             	mov    al,BYTE PTR [rbx+rdi*1]
  2184a0:	41 88 01             	mov    BYTE PTR [r9],al
  2184a3:	b8 01 00 00 00       	mov    eax,0x1
  2184a8:	e9 a5 01 00 00       	jmp    218652 <u64toa+0x382>
        value %= kTen16;
  2184ad:	31 d2                	xor    edx,edx
  2184af:	48 89 f8             	mov    rax,rdi
  2184b2:	48 f7 f1             	div    rcx
        if (a < 10) {
  2184b5:	83 f8 09             	cmp    eax,0x9
  2184b8:	0f 87 0e 02 00 00    	ja     2186cc <u64toa+0x3fc>
            buffer[buf_index] = '0' + @intCast(u8, a);
  2184be:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2184c1:	04 30                	add    al,0x30
  2184c3:	88 01                	mov    BYTE PTR [rcx],al
  2184c5:	b8 01 00 00 00       	mov    eax,0x1
  2184ca:	e9 06 03 00 00       	jmp    2187d5 <u64toa+0x505>
  2184cf:	31 c0                	xor    eax,eax
            if (v >= 100) {
  2184d1:	83 ff 64             	cmp    edi,0x64
  2184d4:	0f 82 21 02 00 00    	jb     2186fb <u64toa+0x42b>
                buffer[buf_index] = c_digits_lut[d1 + 1];
  2184da:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  2184dd:	83 ca 01             	or     edx,0x1
  2184e0:	48 8d 1d e1 da fe ff 	lea    rbx,[rip+0xfffffffffffedae1]        # 205fc8 <c_digits_lut>
  2184e7:	8a 14 1a             	mov    dl,BYTE PTR [rdx+rbx*1]
  2184ea:	88 14 07             	mov    BYTE PTR [rdi+rax*1],dl
                buf_index += 1;
  2184ed:	48 83 c0 01          	add    rax,0x1
                buffer[buf_index] = c_digits_lut[d2];
  2184f1:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2184f4:	48 8d 3d cd da fe ff 	lea    rdi,[rip+0xfffffffffffedacd]        # 205fc8 <c_digits_lut>
  2184fb:	8a 1c 39             	mov    bl,BYTE PTR [rcx+rdi*1]
  2184fe:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
                buf_index += 1;
  218501:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  218505:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218508:	83 c9 01             	or     ecx,0x1
  21850b:	48 8d 35 b6 da fe ff 	lea    rsi,[rip+0xfffffffffffedab6]        # 205fc8 <c_digits_lut>
  218512:	8a 0c 31             	mov    cl,BYTE PTR [rcx+rsi*1]
  218515:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            buf_index += 1;
  218518:	48 83 c0 01          	add    rax,0x1
    return buf_index;
  21851c:	5b                   	pop    rbx
  21851d:	41 5e                	pop    r14
  21851f:	41 5f                	pop    r15
  218521:	c3                   	ret    
        if (value >= kTen14) {
  218522:	48 b8 00 40 7a 10 f3 	movabs rax,0x5af3107a4000
  218529:	5a 00 00 
  21852c:	48 39 c7             	cmp    rdi,rax
  21852f:	0f 82 d4 01 00 00    	jb     218709 <u64toa+0x439>
  218535:	31 c0                	xor    eax,eax
            buffer[buf_index] = c_digits_lut[d1 + 1];
  218537:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  21853a:	83 c9 01             	or     ecx,0x1
  21853d:	48 8d 3d 84 da fe ff 	lea    rdi,[rip+0xfffffffffffeda84]        # 205fc8 <c_digits_lut>
  218544:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  218547:	88 0c 02             	mov    BYTE PTR [rdx+rax*1],cl
            buf_index += 1;
  21854a:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2];
  21854e:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218551:	48 8d 15 70 da fe ff 	lea    rdx,[rip+0xfffffffffffeda70]        # 205fc8 <c_digits_lut>
  218558:	8a 14 13             	mov    dl,BYTE PTR [rbx+rdx*1]
  21855b:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  21855e:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  218562:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218565:	83 cb 01             	or     ebx,0x1
  218568:	48 8d 15 59 da fe ff 	lea    rdx,[rip+0xfffffffffffeda59]        # 205fc8 <c_digits_lut>
  21856f:	8a 14 13             	mov    dl,BYTE PTR [rbx+rdx*1]
  218572:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  218575:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d3];
  218579:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  21857c:	48 8d 15 45 da fe ff 	lea    rdx,[rip+0xfffffffffffeda45]        # 205fc8 <c_digits_lut>
  218583:	41 8a 14 13          	mov    dl,BYTE PTR [r11+rdx*1]
  218587:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  21858a:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d3 + 1];
  21858e:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218591:	41 83 cb 01          	or     r11d,0x1
  218595:	48 8d 15 2c da fe ff 	lea    rdx,[rip+0xfffffffffffeda2c]        # 205fc8 <c_digits_lut>
  21859c:	41 8a 14 13          	mov    dl,BYTE PTR [r11+rdx*1]
  2185a0:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  2185a3:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d4];
  2185a7:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2185aa:	48 8d 15 17 da fe ff 	lea    rdx,[rip+0xfffffffffffeda17]        # 205fc8 <c_digits_lut>
  2185b1:	41 8a 14 17          	mov    dl,BYTE PTR [r15+rdx*1]
  2185b5:	88 14 01             	mov    BYTE PTR [rcx+rax*1],dl
            buf_index += 1;
  2185b8:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d4 + 1];
  2185bc:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2185bf:	41 83 cf 01          	or     r15d,0x1
  2185c3:	48 8d 0d fe d9 fe ff 	lea    rcx,[rip+0xfffffffffffed9fe]        # 205fc8 <c_digits_lut>
  2185ca:	41 8a 1c 0f          	mov    bl,BYTE PTR [r15+rcx*1]
  2185ce:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
        buffer[buf_index] = c_digits_lut[d5];
  2185d1:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2185d4:	41 8a 1c 09          	mov    bl,BYTE PTR [r9+rcx*1]
  2185d8:	88 5c 02 01          	mov    BYTE PTR [rdx+rax*1+0x1],bl
        buffer[buf_index] = c_digits_lut[d5 + 1];
  2185dc:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2185df:	41 83 c9 01          	or     r9d,0x1
  2185e3:	41 8a 1c 09          	mov    bl,BYTE PTR [r9+rcx*1]
  2185e7:	88 5c 02 02          	mov    BYTE PTR [rdx+rax*1+0x2],bl
        buffer[buf_index] = c_digits_lut[d6];
  2185eb:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2185ee:	41 8a 1c 0e          	mov    bl,BYTE PTR [r14+rcx*1]
  2185f2:	88 5c 02 03          	mov    BYTE PTR [rdx+rax*1+0x3],bl
        buffer[buf_index] = c_digits_lut[d6 + 1];
  2185f6:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2185f9:	41 83 ce 01          	or     r14d,0x1
  2185fd:	41 8a 1c 0e          	mov    bl,BYTE PTR [r14+rcx*1]
  218601:	88 5c 02 04          	mov    BYTE PTR [rdx+rax*1+0x4],bl
        buffer[buf_index] = c_digits_lut[d7];
  218605:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218608:	41 8a 1c 0a          	mov    bl,BYTE PTR [r10+rcx*1]
  21860c:	88 5c 02 05          	mov    BYTE PTR [rdx+rax*1+0x5],bl
        buffer[buf_index] = c_digits_lut[d7 + 1];
  218610:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218613:	41 83 ca 01          	or     r10d,0x1
  218617:	41 8a 1c 0a          	mov    bl,BYTE PTR [r10+rcx*1]
  21861b:	88 5c 02 06          	mov    BYTE PTR [rdx+rax*1+0x6],bl
        buffer[buf_index] = c_digits_lut[d8];
  21861f:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218622:	41 8a 1c 08          	mov    bl,BYTE PTR [r8+rcx*1]
  218626:	88 5c 02 07          	mov    BYTE PTR [rdx+rax*1+0x7],bl
        buffer[buf_index] = c_digits_lut[d8 + 1];
  21862a:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  21862d:	41 83 c8 01          	or     r8d,0x1
  218631:	41 8a 0c 08          	mov    cl,BYTE PTR [r8+rcx*1]
  218635:	88 4c 02 08          	mov    BYTE PTR [rdx+rax*1+0x8],cl
        buf_index += 1;
  218639:	48 83 c0 09          	add    rax,0x9
    return buf_index;
  21863d:	5b                   	pop    rbx
  21863e:	41 5e                	pop    r14
  218640:	41 5f                	pop    r15
  218642:	c3                   	ret    
  218643:	31 c0                	xor    eax,eax
            if (value >= 1000000) {
  218645:	48 81 ff 40 42 0f 00 	cmp    rdi,0xf4240
  21864c:	0f 82 cd 00 00 00    	jb     21871f <u64toa+0x44f>
                buffer[buf_index] = c_digits_lut[d1 + 1];
  218652:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  218655:	83 cb 01             	or     ebx,0x1
  218658:	48 8d 3d 69 d9 fe ff 	lea    rdi,[rip+0xfffffffffffed969]        # 205fc8 <c_digits_lut>
  21865f:	8a 1c 3b             	mov    bl,BYTE PTR [rbx+rdi*1]
  218662:	41 88 1c 01          	mov    BYTE PTR [r9+rax*1],bl
                buf_index += 1;
  218666:	48 83 c0 01          	add    rax,0x1
                buffer[buf_index] = c_digits_lut[d2];
  21866a:	48 8b 3e             	mov    rdi,QWORD PTR [rsi]
  21866d:	48 8d 1d 54 d9 fe ff 	lea    rbx,[rip+0xfffffffffffed954]        # 205fc8 <c_digits_lut>
  218674:	8a 1c 1a             	mov    bl,BYTE PTR [rdx+rbx*1]
  218677:	88 1c 07             	mov    BYTE PTR [rdi+rax*1],bl
                buf_index += 1;
  21867a:	48 83 c0 01          	add    rax,0x1
            buffer[buf_index] = c_digits_lut[d2 + 1];
  21867e:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  218681:	83 ca 01             	or     edx,0x1
  218684:	48 8d 3d 3d d9 fe ff 	lea    rdi,[rip+0xfffffffffffed93d]        # 205fc8 <c_digits_lut>
  21868b:	8a 14 3a             	mov    dl,BYTE PTR [rdx+rdi*1]
  21868e:	88 14 03             	mov    BYTE PTR [rbx+rax*1],dl
            buffer[buf_index] = c_digits_lut[d3];
  218691:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218694:	41 8a 1c 38          	mov    bl,BYTE PTR [r8+rdi*1]
  218698:	88 5c 02 01          	mov    BYTE PTR [rdx+rax*1+0x1],bl
            buffer[buf_index] = c_digits_lut[d3 + 1];
  21869c:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  21869f:	41 83 c8 01          	or     r8d,0x1
  2186a3:	41 8a 1c 38          	mov    bl,BYTE PTR [r8+rdi*1]
  2186a7:	88 5c 02 02          	mov    BYTE PTR [rdx+rax*1+0x2],bl
            buffer[buf_index] = c_digits_lut[d4];
  2186ab:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2186ae:	8a 1c 39             	mov    bl,BYTE PTR [rcx+rdi*1]
  2186b1:	88 5c 02 03          	mov    BYTE PTR [rdx+rax*1+0x3],bl
            buffer[buf_index] = c_digits_lut[d4 + 1];
  2186b5:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  2186b8:	83 c9 01             	or     ecx,0x1
  2186bb:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  2186be:	88 4c 02 04          	mov    BYTE PTR [rdx+rax*1+0x4],cl
            buf_index += 1;
  2186c2:	48 83 c0 05          	add    rax,0x5
    return buf_index;
  2186c6:	5b                   	pop    rbx
  2186c7:	41 5e                	pop    r14
  2186c9:	41 5f                	pop    r15
  2186cb:	c3                   	ret    
        } else if (a < 100) {
  2186cc:	83 f8 63             	cmp    eax,0x63
  2186cf:	77 60                	ja     218731 <u64toa+0x461>
            buffer[buf_index] = c_digits_lut[i];
  2186d1:	89 c0                	mov    eax,eax
  2186d3:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2186d6:	48 8d 3d eb d8 fe ff 	lea    rdi,[rip+0xfffffffffffed8eb]        # 205fc8 <c_digits_lut>
  2186dd:	8a 1c 47             	mov    bl,BYTE PTR [rdi+rax*2]
            const i: u32 = a << 1;
  2186e0:	48 01 c0             	add    rax,rax
            buffer[buf_index] = c_digits_lut[i];
  2186e3:	88 19                	mov    BYTE PTR [rcx],bl
            buffer[buf_index] = c_digits_lut[i + 1];
  2186e5:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2186e8:	83 c8 01             	or     eax,0x1
  2186eb:	8a 04 38             	mov    al,BYTE PTR [rax+rdi*1]
  2186ee:	88 41 01             	mov    BYTE PTR [rcx+0x1],al
  2186f1:	b8 02 00 00 00       	mov    eax,0x2
  2186f6:	e9 da 00 00 00       	jmp    2187d5 <u64toa+0x505>
            if (v >= 10) {
  2186fb:	83 ff 0a             	cmp    edi,0xa
  2186fe:	0f 83 ed fd ff ff    	jae    2184f1 <u64toa+0x221>
  218704:	e9 fc fd ff ff       	jmp    218505 <u64toa+0x235>
        if (value >= kTen13) {
  218709:	48 89 f8             	mov    rax,rdi
  21870c:	48 c1 e8 0d          	shr    rax,0xd
  218710:	48 3d 95 73 c2 48    	cmp    rax,0x48c27395
  218716:	72 60                	jb     218778 <u64toa+0x4a8>
  218718:	31 c0                	xor    eax,eax
  21871a:	e9 2f fe ff ff       	jmp    21854e <u64toa+0x27e>
            if (value >= 100000) {
  21871f:	48 81 ff a0 86 01 00 	cmp    rdi,0x186a0
  218726:	0f 83 3e ff ff ff    	jae    21866a <u64toa+0x39a>
  21872c:	e9 4d ff ff ff       	jmp    21867e <u64toa+0x3ae>
            const i: u32 = (a / 100) << 1;
  218731:	89 c1                	mov    ecx,eax
  218733:	48 69 c9 1f 85 eb 51 	imul   rcx,rcx,0x51eb851f
  21873a:	48 c1 e9 25          	shr    rcx,0x25
            const j: u32 = (a % 100) << 1;
  21873e:	6b f9 64             	imul   edi,ecx,0x64
        } else if (a < 1000) {
  218741:	3d e7 03 00 00       	cmp    eax,0x3e7
  218746:	77 4a                	ja     218792 <u64toa+0x4c2>
            buffer[buf_index] = '0' + @intCast(u8, a / 100);
  218748:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  21874b:	80 c1 30             	add    cl,0x30
  21874e:	88 0b                	mov    BYTE PTR [rbx],cl
            const i: u32 = (a % 100) << 1;
  218750:	29 f8                	sub    eax,edi
            buffer[buf_index] = c_digits_lut[i];
  218752:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218755:	48 8d 3d 6c d8 fe ff 	lea    rdi,[rip+0xfffffffffffed86c]        # 205fc8 <c_digits_lut>
  21875c:	8a 1c 47             	mov    bl,BYTE PTR [rdi+rax*2]
            const i: u32 = (a % 100) << 1;
  21875f:	48 01 c0             	add    rax,rax
            buffer[buf_index] = c_digits_lut[i];
  218762:	88 59 01             	mov    BYTE PTR [rcx+0x1],bl
            buffer[buf_index] = c_digits_lut[i + 1];
  218765:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218768:	83 c8 01             	or     eax,0x1
  21876b:	8a 04 38             	mov    al,BYTE PTR [rax+rdi*1]
  21876e:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
  218771:	b8 03 00 00 00       	mov    eax,0x3
  218776:	eb 5d                	jmp    2187d5 <u64toa+0x505>
        if (value >= kTen12) {
  218778:	48 89 f8             	mov    rax,rdi
  21877b:	48 c1 e8 0c          	shr    rax,0xc
  21877f:	48 3d 51 4a 8d 0e    	cmp    rax,0xe8d4a51
  218785:	0f 82 e9 01 00 00    	jb     218974 <u64toa+0x6a4>
  21878b:	31 c0                	xor    eax,eax
  21878d:	e9 d0 fd ff ff       	jmp    218562 <u64toa+0x292>
            const j: u32 = (a % 100) << 1;
  218792:	29 f8                	sub    eax,edi
  218794:	48 8d 3c 00          	lea    rdi,[rax+rax*1]
            buffer[buf_index] = c_digits_lut[i];
  218798:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  21879b:	4c 8d 05 26 d8 fe ff 	lea    r8,[rip+0xfffffffffffed826]        # 205fc8 <c_digits_lut>
  2187a2:	41 8a 1c 48          	mov    bl,BYTE PTR [r8+rcx*2]
  2187a6:	41 88 19             	mov    BYTE PTR [r9],bl
            const i: u32 = (a / 100) << 1;
  2187a9:	48 01 c9             	add    rcx,rcx
            buffer[buf_index] = c_digits_lut[i + 1];
  2187ac:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  2187af:	83 c9 01             	or     ecx,0x1
  2187b2:	42 8a 0c 01          	mov    cl,BYTE PTR [rcx+r8*1]
  2187b6:	88 4b 01             	mov    BYTE PTR [rbx+0x1],cl
            buffer[buf_index] = c_digits_lut[j];
  2187b9:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  2187bc:	41 8a 04 40          	mov    al,BYTE PTR [r8+rax*2]
  2187c0:	88 41 02             	mov    BYTE PTR [rcx+0x2],al
            buffer[buf_index] = c_digits_lut[j + 1];
  2187c3:	48 8b 06             	mov    rax,QWORD PTR [rsi]
  2187c6:	83 cf 01             	or     edi,0x1
  2187c9:	42 8a 0c 07          	mov    cl,BYTE PTR [rdi+r8*1]
  2187cd:	88 48 03             	mov    BYTE PTR [rax+0x3],cl
  2187d0:	b8 04 00 00 00       	mov    eax,0x4
        const v0 = @intCast(u32, value / kTen8);
  2187d5:	48 b9 fd ce 61 84 11 	movabs rcx,0xabcc77118461cefd
  2187dc:	77 cc ab 
  2187df:	c4 62 f3 f6 f1       	mulx   r14,rcx,rcx
  2187e4:	49 c1 ee 1a          	shr    r14,0x1a
        const v1 = @intCast(u32, value % kTen8);
  2187e8:	4d 69 c6 00 e1 f5 05 	imul   r8,r14,0x5f5e100
        const b0: u32 = v0 / 10000;
  2187ef:	44 89 f3             	mov    ebx,r14d
  2187f2:	41 ba 59 17 b7 d1    	mov    r10d,0xd1b71759
        const d1: u32 = (b0 / 100) << 1;
  2187f8:	4c 69 cb 83 de 1b 43 	imul   r9,rbx,0x431bde83
        const b0: u32 = v0 / 10000;
  2187ff:	49 0f af da          	imul   rbx,r10
  218803:	48 c1 eb 2d          	shr    rbx,0x2d
        const d1: u32 = (b0 / 100) << 1;
  218807:	49 c1 e9 32          	shr    r9,0x32
        buffer[buf_index] = c_digits_lut[d1];
  21880b:	4c 8b 1e             	mov    r11,QWORD PTR [rsi]
  21880e:	48 8d 3d b3 d7 fe ff 	lea    rdi,[rip+0xfffffffffffed7b3]        # 205fc8 <c_digits_lut>
  218815:	42 8a 0c 4f          	mov    cl,BYTE PTR [rdi+r9*2]
  218819:	41 88 0c 03          	mov    BYTE PTR [r11+rax*1],cl
        const c0: u32 = v0 % 10000;
  21881d:	44 69 db 10 27 00 00 	imul   r11d,ebx,0x2710
        const d2: u32 = (b0 % 100) << 1;
  218824:	48 69 cb 1f 85 eb 51 	imul   rcx,rbx,0x51eb851f
  21882b:	48 c1 e9 25          	shr    rcx,0x25
  21882f:	6b c9 64             	imul   ecx,ecx,0x64
        const c0: u32 = v0 % 10000;
  218832:	45 29 de             	sub    r14d,r11d
        const d2: u32 = (b0 % 100) << 1;
  218835:	29 cb                	sub    ebx,ecx
        const d1: u32 = (b0 / 100) << 1;
  218837:	4b 8d 0c 09          	lea    rcx,[r9+r9*1]
        buffer[buf_index] = c_digits_lut[d1 + 1];
  21883b:	83 c9 01             	or     ecx,0x1
  21883e:	44 8a 0c 39          	mov    r9b,BYTE PTR [rcx+rdi*1]
  218842:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218845:	44 88 4c 01 01       	mov    BYTE PTR [rcx+rax*1+0x1],r9b
        buffer[buf_index] = c_digits_lut[d2];
  21884a:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  21884d:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  218850:	41 88 4c 01 02       	mov    BYTE PTR [r9+rax*1+0x2],cl
        const d2: u32 = (b0 % 100) << 1;
  218855:	48 8d 0c 1b          	lea    rcx,[rbx+rbx*1]
        const d3: u32 = (c0 / 100) << 1;
  218859:	49 69 de 1f 85 eb 51 	imul   rbx,r14,0x51eb851f
  218860:	48 c1 eb 25          	shr    rbx,0x25
        buffer[buf_index] = c_digits_lut[d2 + 1];
  218864:	83 c9 01             	or     ecx,0x1
  218867:	44 8a 0c 39          	mov    r9b,BYTE PTR [rcx+rdi*1]
  21886b:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  21886e:	44 88 4c 01 03       	mov    BYTE PTR [rcx+rax*1+0x3],r9b
        buffer[buf_index] = c_digits_lut[d3];
  218873:	4c 8b 0e             	mov    r9,QWORD PTR [rsi]
  218876:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  218879:	41 88 4c 01 04       	mov    BYTE PTR [r9+rax*1+0x4],cl
        const d4: u32 = (c0 % 100) << 1;
  21887e:	6b cb 64             	imul   ecx,ebx,0x64
        const v1 = @intCast(u32, value % kTen8);
  218881:	4c 29 c2             	sub    rdx,r8
        const d3: u32 = (c0 / 100) << 1;
  218884:	48 8d 1c 1b          	lea    rbx,[rbx+rbx*1]
        const d4: u32 = (c0 % 100) << 1;
  218888:	41 29 ce             	sub    r14d,ecx
        buffer[buf_index] = c_digits_lut[d3 + 1];
  21888b:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  21888e:	83 cb 01             	or     ebx,0x1
  218891:	8a 1c 3b             	mov    bl,BYTE PTR [rbx+rdi*1]
  218894:	88 5c 01 05          	mov    BYTE PTR [rcx+rax*1+0x5],bl
        const d4: u32 = (c0 % 100) << 1;
  218898:	4b 8d 0c 36          	lea    rcx,[r14+r14*1]
        const b1: u32 = v1 / 10000;
  21889c:	4c 0f af d2          	imul   r10,rdx
  2188a0:	49 c1 ea 2d          	shr    r10,0x2d
        buffer[buf_index] = c_digits_lut[d4];
  2188a4:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  2188a7:	42 8a 1c 77          	mov    bl,BYTE PTR [rdi+r14*2]
  2188ab:	41 88 5c 00 06       	mov    BYTE PTR [r8+rax*1+0x6],bl
        const d5: u32 = (b1 / 100) << 1;
  2188b0:	48 69 da 83 de 1b 43 	imul   rbx,rdx,0x431bde83
  2188b7:	48 c1 eb 31          	shr    rbx,0x31
  2188bb:	81 e3 fe 01 00 00    	and    ebx,0x1fe
        buffer[buf_index] = c_digits_lut[d4 + 1];
  2188c1:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  2188c4:	83 c9 01             	or     ecx,0x1
  2188c7:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  2188ca:	41 88 4c 00 07       	mov    BYTE PTR [r8+rax*1+0x7],cl
        buf_index += 1;
  2188cf:	48 83 c8 08          	or     rax,0x8
        buffer[buf_index] = c_digits_lut[d5];
  2188d3:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  2188d6:	8a 0c 3b             	mov    cl,BYTE PTR [rbx+rdi*1]
  2188d9:	41 88 0c 00          	mov    BYTE PTR [r8+rax*1],cl
        const c1: u32 = v1 % 10000;
  2188dd:	45 69 c2 10 27 00 00 	imul   r8d,r10d,0x2710
        const d6: u32 = (b1 % 100) << 1;
  2188e4:	49 69 ca 1f 85 eb 51 	imul   rcx,r10,0x51eb851f
  2188eb:	48 c1 e9 25          	shr    rcx,0x25
  2188ef:	6b c9 64             	imul   ecx,ecx,0x64
        const c1: u32 = v1 % 10000;
  2188f2:	44 29 c2             	sub    edx,r8d
        const d6: u32 = (b1 % 100) << 1;
  2188f5:	41 29 ca             	sub    r10d,ecx
        buffer[buf_index] = c_digits_lut[d5 + 1];
  2188f8:	8d 4b 01             	lea    ecx,[rbx+0x1]
  2188fb:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  2188fe:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  218901:	88 4c 03 01          	mov    BYTE PTR [rbx+rax*1+0x1],cl
        buffer[buf_index] = c_digits_lut[d6];
  218905:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218908:	42 8a 1c 57          	mov    bl,BYTE PTR [rdi+r10*2]
  21890c:	88 5c 01 02          	mov    BYTE PTR [rcx+rax*1+0x2],bl
        const d6: u32 = (b1 % 100) << 1;
  218910:	4b 8d 0c 12          	lea    rcx,[r10+r10*1]
        const d7: u32 = (c1 / 100) << 1;
  218914:	48 69 da 1f 85 eb 51 	imul   rbx,rdx,0x51eb851f
  21891b:	48 c1 eb 25          	shr    rbx,0x25
        buffer[buf_index] = c_digits_lut[d6 + 1];
  21891f:	83 c9 01             	or     ecx,0x1
  218922:	44 8a 04 39          	mov    r8b,BYTE PTR [rcx+rdi*1]
  218926:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218929:	44 88 44 01 03       	mov    BYTE PTR [rcx+rax*1+0x3],r8b
        buffer[buf_index] = c_digits_lut[d7];
  21892e:	4c 8b 06             	mov    r8,QWORD PTR [rsi]
  218931:	8a 0c 5f             	mov    cl,BYTE PTR [rdi+rbx*2]
  218934:	41 88 4c 00 04       	mov    BYTE PTR [r8+rax*1+0x4],cl
        const d8: u32 = (c1 % 100) << 1;
  218939:	6b cb 64             	imul   ecx,ebx,0x64
  21893c:	29 ca                	sub    edx,ecx
        const d7: u32 = (c1 / 100) << 1;
  21893e:	48 8d 0c 1b          	lea    rcx,[rbx+rbx*1]
        buffer[buf_index] = c_digits_lut[d7 + 1];
  218942:	83 c9 01             	or     ecx,0x1
  218945:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  218948:	48 8b 1e             	mov    rbx,QWORD PTR [rsi]
  21894b:	88 4c 03 05          	mov    BYTE PTR [rbx+rax*1+0x5],cl
        buffer[buf_index] = c_digits_lut[d8];
  21894f:	48 8b 0e             	mov    rcx,QWORD PTR [rsi]
  218952:	8a 1c 57             	mov    bl,BYTE PTR [rdi+rdx*2]
  218955:	88 5c 01 06          	mov    BYTE PTR [rcx+rax*1+0x6],bl
        const d8: u32 = (c1 % 100) << 1;
  218959:	48 8d 0c 12          	lea    rcx,[rdx+rdx*1]
        buffer[buf_index] = c_digits_lut[d8 + 1];
  21895d:	83 c9 01             	or     ecx,0x1
  218960:	8a 0c 39             	mov    cl,BYTE PTR [rcx+rdi*1]
  218963:	48 8b 16             	mov    rdx,QWORD PTR [rsi]
  218966:	88 4c 02 07          	mov    BYTE PTR [rdx+rax*1+0x7],cl
        buf_index += 1;
  21896a:	48 83 c0 08          	add    rax,0x8
    return buf_index;
  21896e:	5b                   	pop    rbx
  21896f:	41 5e                	pop    r14
  218971:	41 5f                	pop    r15
  218973:	c3                   	ret    
        if (value >= kTen11) {
  218974:	48 89 f8             	mov    rax,rdi
  218977:	48 c1 e8 0b          	shr    rax,0xb
  21897b:	48 3d dd 0e e9 02    	cmp    rax,0x2e90edd
  218981:	72 07                	jb     21898a <u64toa+0x6ba>
  218983:	31 c0                	xor    eax,eax
  218985:	e9 ef fb ff ff       	jmp    218579 <u64toa+0x2a9>
        if (value >= kTen10) {
  21898a:	48 89 f8             	mov    rax,rdi
  21898d:	48 c1 e8 0a          	shr    rax,0xa
  218991:	48 3d f9 02 95 00    	cmp    rax,0x9502f9
  218997:	72 07                	jb     2189a0 <u64toa+0x6d0>
  218999:	31 c0                	xor    eax,eax
  21899b:	e9 ee fb ff ff       	jmp    21858e <u64toa+0x2be>
  2189a0:	31 c0                	xor    eax,eax
        if (value >= kTen9) {
  2189a2:	48 81 ff 00 ca 9a 3b 	cmp    rdi,0x3b9aca00
  2189a9:	0f 83 f8 fb ff ff    	jae    2185a7 <u64toa+0x2d7>
  2189af:	e9 08 fc ff ff       	jmp    2185bc <u64toa+0x2ec>
  2189b4:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2189bb:	00 00 00 00 00 

00000000002189c0 <frexp64>:
    y |= 0x3F000000;
    result.significand = @bitCast(f32, y);
    return result;
}

fn frexp64(x: f64) frexp64_result {
  2189c0:	53                   	push   rbx
  2189c1:	48 83 ec 10          	sub    rsp,0x10
  2189c5:	48 89 fb             	mov    rbx,rdi
    var result: frexp64_result = undefined;

    var y = @bitCast(u64, x);
  2189c8:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    const e = @intCast(i32, y >> 52) & 0x7FF;
  2189cd:	48 89 c8             	mov    rax,rcx
  2189d0:	48 c1 e8 34          	shr    rax,0x34

    if (e == 0) {
  2189d4:	89 c2                	mov    edx,eax
  2189d6:	81 e2 ff 07 00 00    	and    edx,0x7ff
  2189dc:	81 fa ff 07 00 00    	cmp    edx,0x7ff
  2189e2:	74 31                	je     218a15 <frexp64+0x55>
  2189e4:	66 85 d2             	test   dx,dx
  2189e7:	75 3d                	jne    218a26 <frexp64+0x66>
        if (x != 0) {
  2189e9:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  2189ed:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  2189f1:	74 63                	je     218a56 <frexp64+0x96>
            // subnormal
            result = frexp64(x * 0x1.0p64);
  2189f3:	c5 fb 59 05 6d 82 fe 	vmulsd xmm0,xmm0,QWORD PTR [rip+0xfffffffffffe826d]        # 200c68 <app_mask+0x30>
  2189fa:	ff 
  2189fb:	48 89 e7             	mov    rdi,rsp
  2189fe:	e8 bd ff ff ff       	call   2189c0 <frexp64>
  218a03:	c5 fb 10 04 24       	vmovsd xmm0,QWORD PTR [rsp]
  218a08:	8b 44 24 08          	mov    eax,DWORD PTR [rsp+0x8]
  218a0c:	8b 4c 24 0c          	mov    ecx,DWORD PTR [rsp+0xc]
            result.exponent -= 64;
  218a10:	83 c0 c0             	add    eax,0xffffffc0
  218a13:	eb 43                	jmp    218a58 <frexp64+0x98>
        // frexp(+-inf) = (+-inf, 0)
        if (math.isInf(x)) {
            result.exponent = 0;
        }

        return result;
  218a15:	c5 fb 11 03          	vmovsd QWORD PTR [rbx],xmm0
  218a19:	c7 43 08 00 00 00 00 	mov    DWORD PTR [rbx+0x8],0x0
  218a20:	48 83 c4 10          	add    rsp,0x10
  218a24:	5b                   	pop    rbx
  218a25:	c3                   	ret    
    const e = @intCast(i32, y >> 52) & 0x7FF;
  218a26:	25 ff 07 00 00       	and    eax,0x7ff
    }

    result.exponent = e - 0x3FE;
  218a2b:	05 02 fc ff ff       	add    eax,0xfffffc02
    y &= 0x800FFFFFFFFFFFFF;
  218a30:	48 ba ff ff ff ff ff 	movabs rdx,0x800fffffffffffff
  218a37:	ff 0f 80 
  218a3a:	48 21 d1             	and    rcx,rdx
    y |= 0x3FE0000000000000;
  218a3d:	48 ba 00 00 00 00 00 	movabs rdx,0x3fe0000000000000
  218a44:	00 e0 3f 
  218a47:	48 09 ca             	or     rdx,rcx
    result.significand = @bitCast(f64, y);
    return result;
  218a4a:	48 89 13             	mov    QWORD PTR [rbx],rdx
  218a4d:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  218a50:	48 83 c4 10          	add    rsp,0x10
  218a54:	5b                   	pop    rbx
  218a55:	c3                   	ret    
  218a56:	31 c0                	xor    eax,eax
        return result;
  218a58:	c5 fb 11 03          	vmovsd QWORD PTR [rbx],xmm0
  218a5c:	89 43 08             	mov    DWORD PTR [rbx+0x8],eax
  218a5f:	89 4b 0c             	mov    DWORD PTR [rbx+0xc],ecx
  218a62:	48 83 c4 10          	add    rsp,0x10
  218a66:	5b                   	pop    rbx
  218a67:	c3                   	ret    
  218a68:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  218a6f:	00 

0000000000218a70 <_start>:
}

nakedcc fn _start() noreturn {
    switch (builtin.arch) {
        builtin.Arch.x86_64 => {
            argc_ptr = asm ("lea (%%rsp), %[argc]"
  218a70:	48 8d 04 24          	lea    rax,[rsp]
  218a74:	48 89 05 35 46 00 00 	mov    QWORD PTR [rip+0x4635],rax        # 21d0b0 <argc_ptr>
        },
        else => @compileError("unsupported arch"),
    }
    // If LLVM inlines stack variables into _start, they will overwrite
    // the command line argument data.
    @noInlineCall(posixCallMainAndExit);
  218a7b:	e8 00 00 00 00       	call   218a80 <posixCallMainAndExit>

0000000000218a80 <posixCallMainAndExit>:
    std.os.windows.ExitProcess(callMain());
}

// TODO https://github.com/ziglang/zig/issues/265
fn posixCallMainAndExit() noreturn {
    const argc = argc_ptr[0];
  218a80:	41 56                	push   r14
  218a82:	53                   	push   rbx
  218a83:	48 83 ec 18          	sub    rsp,0x18
  218a87:	48 8b 15 22 46 00 00 	mov    rdx,QWORD PTR [rip+0x4622]        # 21d0b0 <argc_ptr>
  218a8e:	48 8b 1a             	mov    rbx,QWORD PTR [rdx]
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);

    const envp_optional = @ptrCast([*]?[*]u8, argv + argc + 1);
  218a91:	48 8d 0c da          	lea    rcx,[rdx+rbx*8]
  218a95:	48 83 c1 10          	add    rcx,0x10
    var envp_count: usize = 0;
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  218a99:	48 8d 04 da          	lea    rax,[rdx+rbx*8]
  218a9d:	48 83 c0 20          	add    rax,0x20
    const argv = @ptrCast([*][*]u8, argc_ptr + 1);
  218aa1:	4c 8d 72 08          	lea    r14,[rdx+0x8]
  218aa5:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
  218aac:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}
  218ab0:	48 83 c2 01          	add    rdx,0x1
  218ab4:	48 83 78 f0 00       	cmp    QWORD PTR [rax-0x10],0x0
  218ab9:	48 8d 40 08          	lea    rax,[rax+0x8]
  218abd:	75 f1                	jne    218ab0 <posixCallMainAndExit+0x30>
    const envp = @ptrCast([*][*]u8, envp_optional)[0..envp_count];
  218abf:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
  218ac4:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
    if (builtin.os == builtin.Os.linux) {
        const auxv = @ptrCast([*]usize, envp.ptr + envp_count + 1);
        var i: usize = 0;
        while (auxv[i] != 0) : (i += 2) {
  218ac9:	48 8b 48 f0          	mov    rcx,QWORD PTR [rax-0x10]
  218acd:	48 85 c9             	test   rcx,rcx
  218ad0:	74 28                	je     218afa <posixCallMainAndExit+0x7a>
  218ad2:	48 8d 15 8f 85 00 00 	lea    rdx,[rip+0x858f]        # 221068 <linux_aux_raw>
  218ad9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
            if (auxv[i] < std.os.linux_aux_raw.len) std.os.linux_aux_raw[auxv[i]] = auxv[i + 1];
  218ae0:	48 83 f9 25          	cmp    rcx,0x25
  218ae4:	77 08                	ja     218aee <posixCallMainAndExit+0x6e>
  218ae6:	48 8b 70 f8          	mov    rsi,QWORD PTR [rax-0x8]
  218aea:	48 89 34 ca          	mov    QWORD PTR [rdx+rcx*8],rsi
        while (auxv[i] != 0) : (i += 2) {
  218aee:	48 8b 08             	mov    rcx,QWORD PTR [rax]
  218af1:	48 83 c0 10          	add    rax,0x10
  218af5:	48 85 c9             	test   rcx,rcx
  218af8:	75 e6                	jne    218ae0 <posixCallMainAndExit+0x60>
        }
        std.debug.assert(std.os.linux_aux_raw[std.elf.AT_PAGESZ] == std.os.page_size);
  218afa:	31 ff                	xor    edi,edi
  218afc:	48 81 3d 91 85 00 00 	cmp    QWORD PTR [rip+0x8591],0x1000        # 221098 <linux_aux_raw+0x30>
  218b03:	00 10 00 00 
  218b07:	40 0f 94 c7          	sete   dil
  218b0b:	e8 f0 f4 fe ff       	call   208000 <assert>
  218b10:	48 8d 54 24 08       	lea    rdx,[rsp+0x8]
    }

    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
  218b15:	48 89 df             	mov    rdi,rbx
  218b18:	4c 89 f6             	mov    rsi,r14
  218b1b:	e8 10 00 00 00       	call   218b30 <callMainWithArgs>
    _ = syscall1(SYS_exit, @bitCast(usize, isize(status)));
  218b20:	0f b6 f8             	movzx  edi,al
    return asm volatile ("syscall"
  218b23:	b8 3c 00 00 00       	mov    eax,0x3c
  218b28:	0f 05                	syscall 
  218b2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000218b30 <callMainWithArgs>:
}

fn callMainWithArgs(argc: usize, argv: [*][*]u8, envp: [][*]u8) u8 {
    std.os.ArgIteratorPosix.raw = argv[0..argc];
  218b30:	55                   	push   rbp
  218b31:	41 57                	push   r15
  218b33:	41 56                	push   r14
  218b35:	53                   	push   rbx
  218b36:	48 83 ec 58          	sub    rsp,0x58
  218b3a:	48 89 35 77 45 00 00 	mov    QWORD PTR [rip+0x4577],rsi        # 21d0b8 <raw>
  218b41:	48 89 3d 78 45 00 00 	mov    QWORD PTR [rip+0x4578],rdi        # 21d0c0 <raw+0x8>
    std.os.posix_environ_raw = envp;
  218b48:	c5 f8 10 02          	vmovups xmm0,XMMWORD PTR [rdx]
  218b4c:	c5 f8 11 05 4c 45 00 	vmovups XMMWORD PTR [rip+0x454c],xmm0        # 21d0a0 <posix_environ_raw>
  218b53:	00 
    if (stderr_stream) |st| {
  218b54:	48 8b 1d d5 84 00 00 	mov    rbx,QWORD PTR [rip+0x84d5]        # 221030 <stderr_stream>
  218b5b:	48 85 db             	test   rbx,rbx
  218b5e:	74 09                	je     218b69 <callMainWithArgs+0x39>
            return std.fmt.format(self, Error, self.writeFn, format, args);
  218b60:	48 8b 2d c9 44 00 00 	mov    rbp,QWORD PTR [rip+0x44c9]        # 21d030 <stderr_file_out_stream+0x8>
  218b67:	eb 34                	jmp    218b9d <callMainWithArgs+0x6d>
        stderr_file = try io.getStdErr();
  218b69:	48 8d 05 b0 44 00 00 	lea    rax,[rip+0x44b0]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218b70:	48 89 05 b1 44 00 00 	mov    QWORD PTR [rip+0x44b1],rax        # 21d028 <stderr_file_out_stream>
  218b77:	48 8d 2d 92 2e ff ff 	lea    rbp,[rip+0xffffffffffff2e92]        # 20ba10 <FileOutStream_writeFn>
  218b7e:	48 89 2d ab 44 00 00 	mov    QWORD PTR [rip+0x44ab],rbp        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  218b85:	c7 05 91 44 00 00 02 	mov    DWORD PTR [rip+0x4491],0x2        # 21d020 <stderr_file>
  218b8c:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218b8f:	48 8d 1d 9a 44 00 00 	lea    rbx,[rip+0x449a]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  218b96:	48 89 1d 93 84 00 00 	mov    QWORD PTR [rip+0x8493],rbx        # 221030 <stderr_stream>
  218b9d:	4c 8d 74 24 4f       	lea    r14,[rsp+0x4f]
                        try output(context, fmt[start_index..i]);
  218ba2:	48 8d 35 8f 82 00 00 	lea    rsi,[rip+0x828f]        # 220e38 <__unnamed_89>
  218ba9:	48 89 df             	mov    rdi,rbx
  218bac:	ff d5                	call   rbp
  218bae:	66 85 c0             	test   ax,ax
  218bb1:	0f 85 cb 00 00 00    	jne    218c82 <callMainWithArgs+0x152>
    var buf: [max_int_digits - 1]u8 = undefined;
  218bb7:	c5 fc 10 05 b9 eb fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffeebb9]        # 207778 <__unnamed_14+0x1f>
  218bbe:	ff 
  218bbf:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  218bc5:	c5 fc 10 05 8c eb fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffeeb8c]        # 207759 <__unnamed_14>
  218bcc:	ff 
  218bcd:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  218bd3:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  218bd8:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  218bdc:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  218be3:	00 00 
  218be5:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  218be8:	48 89 df             	mov    rdi,rbx
  218beb:	c5 f8 77             	vzeroupper 
  218bee:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218bf0:	66 85 c0             	test   ax,ax
  218bf3:	0f 85 89 00 00 00    	jne    218c82 <callMainWithArgs+0x152>
                        try output(context, fmt[start_index..i]);
  218bf9:	48 8d 35 48 82 00 00 	lea    rsi,[rip+0x8248]        # 220e48 <__unnamed_90>
  218c00:	48 89 df             	mov    rdi,rbx
  218c03:	ff d5                	call   rbp
  218c05:	66 85 c0             	test   ax,ax
  218c08:	75 78                	jne    218c82 <callMainWithArgs+0x152>
    var buf: [max_int_digits - 1]u8 = undefined;
  218c0a:	c5 fc 10 05 66 eb fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffeeb66]        # 207778 <__unnamed_14+0x1f>
  218c11:	ff 
  218c12:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  218c18:	c5 fc 10 05 39 eb fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffeeb39]        # 207759 <__unnamed_14>
  218c1f:	ff 
  218c20:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  218c26:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  218c2b:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  218c2f:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  218c36:	00 00 
  218c38:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  218c3b:	48 89 df             	mov    rdi,rbx
  218c3e:	c5 f8 77             	vzeroupper 
  218c41:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218c43:	66 85 c0             	test   ax,ax
  218c46:	75 3a                	jne    218c82 <callMainWithArgs+0x152>
                        try output(context, fmt[start_index..i]);
  218c48:	48 8d 35 09 82 00 00 	lea    rsi,[rip+0x8209]        # 220e58 <__unnamed_91>
  218c4f:	48 89 df             	mov    rdi,rbx
  218c52:	ff d5                	call   rbp
  218c54:	66 85 c0             	test   ax,ax
  218c57:	75 29                	jne    218c82 <callMainWithArgs+0x152>
                const casted_value = ([]const u8)(value);
  218c59:	c5 f8 10 05 bf 7e 00 	vmovups xmm0,XMMWORD PTR [rip+0x7ebf]        # 220b20 <__unnamed_92>
  218c60:	00 
  218c61:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  218c67:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  218c6c:	48 89 df             	mov    rdi,rbx
  218c6f:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218c71:	66 85 c0             	test   ax,ax
  218c74:	75 0c                	jne    218c82 <callMainWithArgs+0x152>
        try output(context, fmt[start_index..]);
  218c76:	48 8d 35 eb 81 00 00 	lea    rsi,[rip+0x81eb]        # 220e68 <__unnamed_93>
  218c7d:	48 89 df             	mov    rdi,rbx
  218c80:	ff d5                	call   rbp
    var ok_count: usize = 0;
    var skip_count: usize = 0;
    for (test_fn_list) |test_fn, i| {
        warn("Test {}/{} {}...", i + 1, test_fn_list.len, test_fn.name);

        if (test_fn.func()) |_| {
  218c82:	e8 49 f9 fe ff       	call   2085d0 <Futex>
  218c87:	89 c5                	mov    ebp,eax
  218c89:	0f b7 c5             	movzx  eax,bp
  218c8c:	83 f8 29             	cmp    eax,0x29
  218c8f:	74 1a                	je     218cab <callMainWithArgs+0x17b>
  218c91:	66 85 ed             	test   bp,bp
  218c94:	75 31                	jne    218cc7 <callMainWithArgs+0x197>
    if (stderr_stream) |st| {
  218c96:	48 8b 3d 93 83 00 00 	mov    rdi,QWORD PTR [rip+0x8393]        # 221030 <stderr_stream>
  218c9d:	48 85 ff             	test   rdi,rdi
  218ca0:	74 41                	je     218ce3 <callMainWithArgs+0x1b3>
  218ca2:	48 8b 0d 87 43 00 00 	mov    rcx,QWORD PTR [rip+0x4387]        # 21d030 <stderr_file_out_stream+0x8>
  218ca9:	eb 6c                	jmp    218d17 <callMainWithArgs+0x1e7>
  218cab:	48 8b 3d 7e 83 00 00 	mov    rdi,QWORD PTR [rip+0x837e]        # 221030 <stderr_stream>
  218cb2:	48 85 ff             	test   rdi,rdi
  218cb5:	0f 84 81 00 00 00    	je     218d3c <callMainWithArgs+0x20c>
  218cbb:	48 8b 05 6e 43 00 00 	mov    rax,QWORD PTR [rip+0x436e]        # 21d030 <stderr_file_out_stream+0x8>
  218cc2:	e9 a9 00 00 00       	jmp    218d70 <callMainWithArgs+0x240>
  218cc7:	4c 8b 35 62 83 00 00 	mov    r14,QWORD PTR [rip+0x8362]        # 221030 <stderr_stream>
  218cce:	4d 85 f6             	test   r14,r14
  218cd1:	0f 84 be 00 00 00    	je     218d95 <callMainWithArgs+0x265>
  218cd7:	4c 8b 3d 52 43 00 00 	mov    r15,QWORD PTR [rip+0x4352]        # 21d030 <stderr_file_out_stream+0x8>
  218cde:	e9 e6 00 00 00       	jmp    218dc9 <callMainWithArgs+0x299>
        stderr_file = try io.getStdErr();
  218ce3:	48 8d 05 36 43 00 00 	lea    rax,[rip+0x4336]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218cea:	48 89 05 37 43 00 00 	mov    QWORD PTR [rip+0x4337],rax        # 21d028 <stderr_file_out_stream>
  218cf1:	48 8d 0d 18 2d ff ff 	lea    rcx,[rip+0xffffffffffff2d18]        # 20ba10 <FileOutStream_writeFn>
  218cf8:	48 89 0d 31 43 00 00 	mov    QWORD PTR [rip+0x4331],rcx        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  218cff:	c7 05 17 43 00 00 02 	mov    DWORD PTR [rip+0x4317],0x2        # 21d020 <stderr_file>
  218d06:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218d09:	48 8d 3d 20 43 00 00 	lea    rdi,[rip+0x4320]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  218d10:	48 89 3d 19 83 00 00 	mov    QWORD PTR [rip+0x8319],rdi        # 221030 <stderr_stream>
  218d17:	48 8d 35 5a 81 00 00 	lea    rsi,[rip+0x815a]        # 220e78 <__unnamed_94>
  218d1e:	ff d1                	call   rcx
    if (stderr_stream) |st| {
  218d20:	48 8b 3d 09 83 00 00 	mov    rdi,QWORD PTR [rip+0x8309]        # 221030 <stderr_stream>
  218d27:	48 85 ff             	test   rdi,rdi
  218d2a:	0f 84 f3 00 00 00    	je     218e23 <callMainWithArgs+0x2f3>
  218d30:	48 8b 0d f9 42 00 00 	mov    rcx,QWORD PTR [rip+0x42f9]        # 21d030 <stderr_file_out_stream+0x8>
  218d37:	e9 1b 01 00 00       	jmp    218e57 <callMainWithArgs+0x327>
        stderr_file = try io.getStdErr();
  218d3c:	48 8d 05 dd 42 00 00 	lea    rax,[rip+0x42dd]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218d43:	48 89 05 de 42 00 00 	mov    QWORD PTR [rip+0x42de],rax        # 21d028 <stderr_file_out_stream>
  218d4a:	48 8d 05 bf 2c ff ff 	lea    rax,[rip+0xffffffffffff2cbf]        # 20ba10 <FileOutStream_writeFn>
  218d51:	48 89 05 d8 42 00 00 	mov    QWORD PTR [rip+0x42d8],rax        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  218d58:	c7 05 be 42 00 00 02 	mov    DWORD PTR [rip+0x42be],0x2        # 21d020 <stderr_file>
  218d5f:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218d62:	48 8d 3d c7 42 00 00 	lea    rdi,[rip+0x42c7]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  218d69:	48 89 3d c0 82 00 00 	mov    QWORD PTR [rip+0x82c0],rdi        # 221030 <stderr_stream>
  218d70:	48 8d 35 11 81 00 00 	lea    rsi,[rip+0x8111]        # 220e88 <__unnamed_95>
  218d77:	ff d0                	call   rax
    if (stderr_stream) |st| {
  218d79:	48 8b 1d b0 82 00 00 	mov    rbx,QWORD PTR [rip+0x82b0]        # 221030 <stderr_stream>
  218d80:	48 85 db             	test   rbx,rbx
  218d83:	0f 84 dc 00 00 00    	je     218e65 <callMainWithArgs+0x335>
  218d89:	48 8b 2d a0 42 00 00 	mov    rbp,QWORD PTR [rip+0x42a0]        # 21d030 <stderr_file_out_stream+0x8>
  218d90:	e9 04 01 00 00       	jmp    218e99 <callMainWithArgs+0x369>
        stderr_file = try io.getStdErr();
  218d95:	48 8d 05 84 42 00 00 	lea    rax,[rip+0x4284]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218d9c:	48 89 05 85 42 00 00 	mov    QWORD PTR [rip+0x4285],rax        # 21d028 <stderr_file_out_stream>
  218da3:	4c 8d 3d 66 2c ff ff 	lea    r15,[rip+0xffffffffffff2c66]        # 20ba10 <FileOutStream_writeFn>
  218daa:	4c 89 3d 7f 42 00 00 	mov    QWORD PTR [rip+0x427f],r15        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  218db1:	c7 05 65 42 00 00 02 	mov    DWORD PTR [rip+0x4265],0x2        # 21d020 <stderr_file>
  218db8:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218dbb:	4c 8d 35 6e 42 00 00 	lea    r14,[rip+0x426e]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  218dc2:	4c 89 35 67 82 00 00 	mov    QWORD PTR [rip+0x8267],r14        # 221030 <stderr_stream>
                        try output(context, fmt[start_index..i]);
  218dc9:	48 8d 35 f8 80 00 00 	lea    rsi,[rip+0x80f8]        # 220ec8 <__unnamed_96>
  218dd0:	4c 89 f7             	mov    rdi,r14
  218dd3:	41 ff d7             	call   r15
  218dd6:	b3 01                	mov    bl,0x1
  218dd8:	66 85 c0             	test   ax,ax
  218ddb:	0f 85 53 01 00 00    	jne    218f34 <callMainWithArgs+0x404>
  218de1:	48 0f bf c5          	movsx  rax,bp
  218de5:	48 c1 e0 04          	shl    rax,0x4
  218de9:	48 8d 0d 10 52 00 00 	lea    rcx,[rip+0x5210]        # 21e000 <raw+0xf48>
  218df0:	48 01 c1             	add    rcx,rax
                const casted_value = ([]const u8)(value);
  218df3:	c5 f8 10 01          	vmovups xmm0,XMMWORD PTR [rcx]
  218df7:	c5 f8 29 44 24 10    	vmovaps XMMWORD PTR [rsp+0x10],xmm0
  218dfd:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
                return output(context, casted_value);
  218e02:	4c 89 f7             	mov    rdi,r14
  218e05:	41 ff d7             	call   r15
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218e08:	66 85 c0             	test   ax,ax
  218e0b:	0f 85 23 01 00 00    	jne    218f34 <callMainWithArgs+0x404>
        try output(context, fmt[start_index..]);
  218e11:	48 8d 35 c0 80 00 00 	lea    rsi,[rip+0x80c0]        # 220ed8 <__unnamed_97>
  218e18:	4c 89 f7             	mov    rdi,r14
  218e1b:	41 ff d7             	call   r15
  218e1e:	e9 11 01 00 00       	jmp    218f34 <callMainWithArgs+0x404>
        stderr_file = try io.getStdErr();
  218e23:	48 8d 05 f6 41 00 00 	lea    rax,[rip+0x41f6]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218e2a:	48 89 05 f7 41 00 00 	mov    QWORD PTR [rip+0x41f7],rax        # 21d028 <stderr_file_out_stream>
  218e31:	48 8d 0d d8 2b ff ff 	lea    rcx,[rip+0xffffffffffff2bd8]        # 20ba10 <FileOutStream_writeFn>
  218e38:	48 89 0d f1 41 00 00 	mov    QWORD PTR [rip+0x41f1],rcx        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  218e3f:	c7 05 d7 41 00 00 02 	mov    DWORD PTR [rip+0x41d7],0x2        # 21d020 <stderr_file>
  218e46:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218e49:	48 8d 3d e0 41 00 00 	lea    rdi,[rip+0x41e0]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  218e50:	48 89 3d d9 81 00 00 	mov    QWORD PTR [rip+0x81d9],rdi        # 221030 <stderr_stream>
  218e57:	48 8d 35 3a 80 00 00 	lea    rsi,[rip+0x803a]        # 220e98 <__unnamed_98>
  218e5e:	ff d1                	call   rcx
  218e60:	e9 cd 00 00 00       	jmp    218f32 <callMainWithArgs+0x402>
        stderr_file = try io.getStdErr();
  218e65:	48 8d 05 b4 41 00 00 	lea    rax,[rip+0x41b4]        # 21d020 <stderr_file>
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218e6c:	48 89 05 b5 41 00 00 	mov    QWORD PTR [rip+0x41b5],rax        # 21d028 <stderr_file_out_stream>
  218e73:	48 8d 2d 96 2b ff ff 	lea    rbp,[rip+0xffffffffffff2b96]        # 20ba10 <FileOutStream_writeFn>
  218e7a:	48 89 2d af 41 00 00 	mov    QWORD PTR [rip+0x41af],rbp        # 21d030 <stderr_file_out_stream+0x8>
        stderr_file = try io.getStdErr();
  218e81:	c7 05 95 41 00 00 02 	mov    DWORD PTR [rip+0x4195],0x2        # 21d020 <stderr_file>
  218e88:	00 00 00 
        stderr_file_out_stream = io.FileOutStream.init(&stderr_file);
  218e8b:	48 8d 1d 9e 41 00 00 	lea    rbx,[rip+0x419e]        # 21d030 <stderr_file_out_stream+0x8>
        stderr_stream = st;
  218e92:	48 89 1d 97 81 00 00 	mov    QWORD PTR [rip+0x8197],rbx        # 221030 <stderr_stream>
    var buf: [max_int_digits - 1]u8 = undefined;
  218e99:	c5 fc 10 05 d7 e8 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffee8d7]        # 207778 <__unnamed_14+0x1f>
  218ea0:	ff 
  218ea1:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  218ea7:	c5 fc 10 05 aa e8 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffee8aa]        # 207759 <__unnamed_14>
  218eae:	ff 
  218eaf:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  218eb5:	c6 44 24 4f 30       	mov    BYTE PTR [rsp+0x4f],0x30
        const padded_buf = buf[index - padding ..];
  218eba:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  218ebe:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  218ec5:	00 00 
  218ec7:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  218eca:	48 89 df             	mov    rdi,rbx
  218ecd:	c5 f8 77             	vzeroupper 
  218ed0:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218ed2:	66 85 c0             	test   ax,ax
  218ed5:	75 5b                	jne    218f32 <callMainWithArgs+0x402>
                        try output(context, fmt[start_index..i]);
  218ed7:	48 8d 35 ca 7f 00 00 	lea    rsi,[rip+0x7fca]        # 220ea8 <__unnamed_99>
  218ede:	48 89 df             	mov    rdi,rbx
  218ee1:	ff d5                	call   rbp
  218ee3:	66 85 c0             	test   ax,ax
  218ee6:	75 4a                	jne    218f32 <callMainWithArgs+0x402>
    var buf: [max_int_digits - 1]u8 = undefined;
  218ee8:	c5 fc 10 05 88 e8 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffee888]        # 207778 <__unnamed_14+0x1f>
  218eef:	ff 
  218ef0:	c5 fc 11 44 24 2f    	vmovups YMMWORD PTR [rsp+0x2f],ymm0
  218ef6:	c5 fc 10 05 5b e8 fe 	vmovups ymm0,YMMWORD PTR [rip+0xfffffffffffee85b]        # 207759 <__unnamed_14>
  218efd:	ff 
  218efe:	c5 fc 11 44 24 10    	vmovups YMMWORD PTR [rsp+0x10],ymm0
        buf[index] = digitToChar(@intCast(u8, digit), uppercase);
  218f04:	c6 44 24 4f 31       	mov    BYTE PTR [rsp+0x4f],0x31
        const padded_buf = buf[index - padding ..];
  218f09:	4c 89 34 24          	mov    QWORD PTR [rsp],r14
  218f0d:	48 c7 44 24 08 01 00 	mov    QWORD PTR [rsp+0x8],0x1
  218f14:	00 00 
  218f16:	48 89 e6             	mov    rsi,rsp
        return output(context, padded_buf);
  218f19:	48 89 df             	mov    rdi,rbx
  218f1c:	c5 f8 77             	vzeroupper 
  218f1f:	ff d5                	call   rbp
                    try formatType(args[next_arg], fmt[0..0], context, Errors, output);
  218f21:	66 85 c0             	test   ax,ax
  218f24:	75 0c                	jne    218f32 <callMainWithArgs+0x402>
        try output(context, fmt[start_index..]);
  218f26:	48 8d 35 8b 7f 00 00 	lea    rsi,[rip+0x7f8b]        # 220eb8 <__unnamed_100>
  218f2d:	48 89 df             	mov    rdi,rbx
  218f30:	ff d5                	call   rbp
  218f32:	31 db                	xor    ebx,ebx
    return callMain();
  218f34:	89 d8                	mov    eax,ebx
  218f36:	48 83 c4 58          	add    rsp,0x58
  218f3a:	5b                   	pop    rbx
  218f3b:	41 5e                	pop    r14
  218f3d:	41 5f                	pop    r15
  218f3f:	5d                   	pop    rbp
  218f40:	c3                   	ret    
  218f41:	cc                   	int3   
  218f42:	cc                   	int3   
  218f43:	cc                   	int3   
  218f44:	cc                   	int3   
  218f45:	cc                   	int3   
  218f46:	cc                   	int3   
  218f47:	cc                   	int3   
  218f48:	cc                   	int3   
  218f49:	cc                   	int3   
  218f4a:	cc                   	int3   
  218f4b:	cc                   	int3   
  218f4c:	cc                   	int3   
  218f4d:	cc                   	int3   
  218f4e:	cc                   	int3   
  218f4f:	cc                   	int3   

0000000000218f50 <memset>:

export fn memset(dest: ?[*]u8, c: u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  218f50:	48 85 d2             	test   rdx,rdx
  218f53:	0f 84 d4 01 00 00    	je     21912d <memset+0x1dd>
  218f59:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  218f60:	73 08                	jae    218f6a <memset+0x1a>
  218f62:	45 31 c0             	xor    r8d,r8d
  218f65:	e9 a8 01 00 00       	jmp    219112 <memset+0x1c2>
  218f6a:	49 89 d0             	mov    r8,rdx
  218f6d:	49 83 e0 80          	and    r8,0xffffffffffffff80
  218f71:	c5 f9 6e c6          	vmovd  xmm0,esi
  218f75:	c4 e2 7d 78 c0       	vpbroadcastb ymm0,xmm0
  218f7a:	49 8d 48 80          	lea    rcx,[r8-0x80]
  218f7e:	48 89 c8             	mov    rax,rcx
  218f81:	48 c1 e8 07          	shr    rax,0x7
  218f85:	44 8d 48 01          	lea    r9d,[rax+0x1]
  218f89:	41 83 e1 07          	and    r9d,0x7
  218f8d:	48 81 f9 80 03 00 00 	cmp    rcx,0x380
  218f94:	73 10                	jae    218fa6 <memset+0x56>
  218f96:	31 c0                	xor    eax,eax
  218f98:	4d 85 c9             	test   r9,r9
  218f9b:	0f 85 44 01 00 00    	jne    2190e5 <memset+0x195>
  218fa1:	e9 67 01 00 00       	jmp    21910d <memset+0x1bd>
  218fa6:	48 8d 8f e0 03 00 00 	lea    rcx,[rdi+0x3e0]
  218fad:	4d 8d 51 ff          	lea    r10,[r9-0x1]
  218fb1:	49 29 c2             	sub    r10,rax
  218fb4:	31 c0                	xor    eax,eax
  218fb6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  218fbd:	00 00 00 
        dest.?[index] = c;
  218fc0:	c5 fe 7f 84 01 20 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3e0],ymm0
  218fc7:	ff ff 
  218fc9:	c5 fe 7f 84 01 40 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3c0],ymm0
  218fd0:	ff ff 
  218fd2:	c5 fe 7f 84 01 60 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x3a0],ymm0
  218fd9:	ff ff 
  218fdb:	c5 fe 7f 84 01 80 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x380],ymm0
  218fe2:	ff ff 
  218fe4:	c5 fe 7f 84 01 a0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x360],ymm0
  218feb:	ff ff 
  218fed:	c5 fe 7f 84 01 c0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x340],ymm0
  218ff4:	ff ff 
  218ff6:	c5 fe 7f 84 01 e0 fc 	vmovdqu YMMWORD PTR [rcx+rax*1-0x320],ymm0
  218ffd:	ff ff 
  218fff:	c5 fe 7f 84 01 00 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x300],ymm0
  219006:	ff ff 
  219008:	c5 fe 7f 84 01 20 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2e0],ymm0
  21900f:	ff ff 
  219011:	c5 fe 7f 84 01 40 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2c0],ymm0
  219018:	ff ff 
  21901a:	c5 fe 7f 84 01 60 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x2a0],ymm0
  219021:	ff ff 
  219023:	c5 fe 7f 84 01 80 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x280],ymm0
  21902a:	ff ff 
  21902c:	c5 fe 7f 84 01 a0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x260],ymm0
  219033:	ff ff 
  219035:	c5 fe 7f 84 01 c0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x240],ymm0
  21903c:	ff ff 
  21903e:	c5 fe 7f 84 01 e0 fd 	vmovdqu YMMWORD PTR [rcx+rax*1-0x220],ymm0
  219045:	ff ff 
  219047:	c5 fe 7f 84 01 00 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x200],ymm0
  21904e:	ff ff 
  219050:	c5 fe 7f 84 01 20 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  219057:	ff ff 
  219059:	c5 fe 7f 84 01 40 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1c0],ymm0
  219060:	ff ff 
  219062:	c5 fe 7f 84 01 60 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x1a0],ymm0
  219069:	ff ff 
  21906b:	c5 fe 7f 84 01 80 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x180],ymm0
  219072:	ff ff 
  219074:	c5 fe 7f 84 01 a0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x160],ymm0
  21907b:	ff ff 
  21907d:	c5 fe 7f 84 01 c0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x140],ymm0
  219084:	ff ff 
  219086:	c5 fe 7f 84 01 e0 fe 	vmovdqu YMMWORD PTR [rcx+rax*1-0x120],ymm0
  21908d:	ff ff 
  21908f:	c5 fe 7f 84 01 00 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0x100],ymm0
  219096:	ff ff 
  219098:	c5 fe 7f 84 01 20 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  21909f:	ff ff 
  2190a1:	c5 fe 7f 84 01 40 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xc0],ymm0
  2190a8:	ff ff 
  2190aa:	c5 fe 7f 84 01 60 ff 	vmovdqu YMMWORD PTR [rcx+rax*1-0xa0],ymm0
  2190b1:	ff ff 
  2190b3:	c5 fe 7f 44 01 80    	vmovdqu YMMWORD PTR [rcx+rax*1-0x80],ymm0
  2190b9:	c5 fe 7f 44 01 a0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x60],ymm0
  2190bf:	c5 fe 7f 44 01 c0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x40],ymm0
  2190c5:	c5 fe 7f 44 01 e0    	vmovdqu YMMWORD PTR [rcx+rax*1-0x20],ymm0
  2190cb:	c5 fe 7f 04 01       	vmovdqu YMMWORD PTR [rcx+rax*1],ymm0
    while (index != n) : (index += 1)
  2190d0:	48 05 00 04 00 00    	add    rax,0x400
  2190d6:	49 83 c2 08          	add    r10,0x8
  2190da:	0f 85 e0 fe ff ff    	jne    218fc0 <memset+0x70>
  2190e0:	4d 85 c9             	test   r9,r9
  2190e3:	74 28                	je     21910d <memset+0x1bd>
  2190e5:	48 01 f8             	add    rax,rdi
  2190e8:	48 83 c0 60          	add    rax,0x60
  2190ec:	49 f7 d9             	neg    r9
  2190ef:	90                   	nop
        dest.?[index] = c;
  2190f0:	c5 fe 7f 40 a0       	vmovdqu YMMWORD PTR [rax-0x60],ymm0
  2190f5:	c5 fe 7f 40 c0       	vmovdqu YMMWORD PTR [rax-0x40],ymm0
  2190fa:	c5 fe 7f 40 e0       	vmovdqu YMMWORD PTR [rax-0x20],ymm0
  2190ff:	c5 fe 7f 00          	vmovdqu YMMWORD PTR [rax],ymm0
    while (index != n) : (index += 1)
  219103:	48 83 e8 80          	sub    rax,0xffffffffffffff80
  219107:	49 83 c1 01          	add    r9,0x1
  21910b:	75 e3                	jne    2190f0 <memset+0x1a0>
  21910d:	49 39 d0             	cmp    r8,rdx
  219110:	74 1b                	je     21912d <memset+0x1dd>
        dest.?[index] = c;
  219112:	4a 8d 04 07          	lea    rax,[rdi+r8*1]
  219116:	4c 29 c2             	sub    rdx,r8
  219119:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  219120:	40 88 30             	mov    BYTE PTR [rax],sil
    while (index != n) : (index += 1)
  219123:	48 83 c0 01          	add    rax,0x1
  219127:	48 83 c2 ff          	add    rdx,0xffffffffffffffff
  21912b:	75 f3                	jne    219120 <memset+0x1d0>

    return dest;
  21912d:	48 89 f8             	mov    rax,rdi
  219130:	c5 f8 77             	vzeroupper 
  219133:	c3                   	ret    
  219134:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21913b:	00 00 00 00 00 

0000000000219140 <memcpy>:

export fn memcpy(noalias dest: ?[*]u8, noalias src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    var index: usize = 0;
    while (index != n) : (index += 1)
  219140:	48 85 d2             	test   rdx,rdx
  219143:	0f 84 d7 01 00 00    	je     219320 <memcpy+0x1e0>
  219149:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  219150:	73 07                	jae    219159 <memcpy+0x19>
  219152:	31 c0                	xor    eax,eax
  219154:	e9 b7 01 00 00       	jmp    219310 <memcpy+0x1d0>
  219159:	48 89 d0             	mov    rax,rdx
  21915c:	48 83 e0 80          	and    rax,0xffffffffffffff80
  219160:	4c 8d 48 80          	lea    r9,[rax-0x80]
  219164:	4c 89 c9             	mov    rcx,r9
  219167:	48 c1 e9 07          	shr    rcx,0x7
  21916b:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  21916f:	41 83 e0 03          	and    r8d,0x3
  219173:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  21917a:	73 10                	jae    21918c <memcpy+0x4c>
  21917c:	31 c9                	xor    ecx,ecx
  21917e:	4d 85 c0             	test   r8,r8
  219181:	0f 85 35 01 00 00    	jne    2192bc <memcpy+0x17c>
  219187:	e9 7c 01 00 00       	jmp    219308 <memcpy+0x1c8>
  21918c:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  219190:	49 29 c9             	sub    r9,rcx
  219193:	31 c9                	xor    ecx,ecx
  219195:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21919c:	00 00 00 00 
        dest.?[index] = src.?[index];
  2191a0:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  2191a5:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  2191ab:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  2191b1:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  2191b7:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  2191bc:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  2191c2:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  2191c8:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  2191ce:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  2191d5:	00 00 
  2191d7:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  2191de:	00 00 
  2191e0:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  2191e7:	00 00 
  2191e9:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  2191f0:	00 00 
  2191f2:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  2191f9:	00 00 
  2191fb:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  219202:	00 00 
  219204:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  21920b:	00 00 
  21920d:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  219214:	00 00 
  219216:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  21921d:	00 00 
  21921f:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  219226:	00 00 
  219228:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  21922f:	00 00 
  219231:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  219238:	00 00 
  21923a:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  219241:	00 00 
  219243:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  21924a:	00 00 
  21924c:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  219253:	00 00 
  219255:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  21925c:	00 00 
  21925e:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  219265:	00 00 
  219267:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  21926e:	00 00 
  219270:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  219277:	00 00 
  219279:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  219280:	00 00 
  219282:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  219289:	00 00 
  21928b:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  219292:	00 00 
  219294:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  21929b:	00 00 
  21929d:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  2192a4:	00 00 
    while (index != n) : (index += 1)
  2192a6:	48 81 c1 00 02 00 00 	add    rcx,0x200
  2192ad:	49 83 c1 04          	add    r9,0x4
  2192b1:	0f 85 e9 fe ff ff    	jne    2191a0 <memcpy+0x60>
  2192b7:	4d 85 c0             	test   r8,r8
  2192ba:	74 4c                	je     219308 <memcpy+0x1c8>
  2192bc:	48 83 c1 60          	add    rcx,0x60
  2192c0:	49 f7 d8             	neg    r8
  2192c3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2192ca:	84 00 00 00 00 00 
        dest.?[index] = src.?[index];
  2192d0:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  2192d6:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  2192dc:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  2192e2:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  2192e7:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  2192ed:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  2192f3:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  2192f9:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
    while (index != n) : (index += 1)
  2192fe:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  219302:	49 83 c0 01          	add    r8,0x1
  219306:	75 c8                	jne    2192d0 <memcpy+0x190>
  219308:	48 39 d0             	cmp    rax,rdx
  21930b:	74 13                	je     219320 <memcpy+0x1e0>
  21930d:	0f 1f 00             	nop    DWORD PTR [rax]
        dest.?[index] = src.?[index];
  219310:	0f b6 0c 06          	movzx  ecx,BYTE PTR [rsi+rax*1]
  219314:	88 0c 07             	mov    BYTE PTR [rdi+rax*1],cl
    while (index != n) : (index += 1)
  219317:	48 83 c0 01          	add    rax,0x1
  21931b:	48 39 c2             	cmp    rdx,rax
  21931e:	75 f0                	jne    219310 <memcpy+0x1d0>

    return dest;
  219320:	48 89 f8             	mov    rax,rdi
  219323:	c5 f8 77             	vzeroupper 
  219326:	c3                   	ret    
  219327:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21932e:	00 00 

0000000000219330 <memmove>:
}

export fn memmove(dest: ?[*]u8, src: ?[*]const u8, n: usize) ?[*]u8 {
    @setRuntimeSafety(false);

    if (@ptrToInt(dest) < @ptrToInt(src)) {
  219330:	48 39 f7             	cmp    rdi,rsi
  219333:	0f 83 cb 00 00 00    	jae    219404 <memmove+0xd4>
  219339:	48 85 d2             	test   rdx,rdx
        var index: usize = 0;
        while (index != n) : (index += 1) {
  21933c:	0f 84 0f 05 00 00    	je     219851 <memmove+0x521>
  219342:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  219349:	72 1a                	jb     219365 <memmove+0x35>
  21934b:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  21934f:	48 39 f8             	cmp    rax,rdi
  219352:	0f 86 0b 01 00 00    	jbe    219463 <memmove+0x133>
  219358:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  21935c:	48 39 f0             	cmp    rax,rsi
  21935f:	0f 86 fe 00 00 00    	jbe    219463 <memmove+0x133>
  219365:	45 31 d2             	xor    r10d,r10d
            dest.?[index] = src.?[index];
  219368:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  21936c:	4d 29 d0             	sub    r8,r10
  21936f:	48 89 d1             	mov    rcx,rdx
  219372:	48 83 e1 07          	and    rcx,0x7
  219376:	74 1b                	je     219393 <memmove+0x63>
  219378:	48 f7 d9             	neg    rcx
  21937b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  219380:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  219385:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
        while (index != n) : (index += 1) {
  219389:	49 83 c2 01          	add    r10,0x1
  21938d:	48 83 c1 01          	add    rcx,0x1
  219391:	75 ed                	jne    219380 <memmove+0x50>
            dest.?[index] = src.?[index];
  219393:	49 83 f8 07          	cmp    r8,0x7
  219397:	0f 82 b4 04 00 00    	jb     219851 <memmove+0x521>
  21939d:	0f 1f 00             	nop    DWORD PTR [rax]
  2193a0:	42 0f b6 04 16       	movzx  eax,BYTE PTR [rsi+r10*1]
  2193a5:	42 88 04 17          	mov    BYTE PTR [rdi+r10*1],al
  2193a9:	42 0f b6 44 16 01    	movzx  eax,BYTE PTR [rsi+r10*1+0x1]
  2193af:	42 88 44 17 01       	mov    BYTE PTR [rdi+r10*1+0x1],al
  2193b4:	42 0f b6 44 16 02    	movzx  eax,BYTE PTR [rsi+r10*1+0x2]
  2193ba:	42 88 44 17 02       	mov    BYTE PTR [rdi+r10*1+0x2],al
  2193bf:	42 0f b6 44 16 03    	movzx  eax,BYTE PTR [rsi+r10*1+0x3]
  2193c5:	42 88 44 17 03       	mov    BYTE PTR [rdi+r10*1+0x3],al
  2193ca:	42 0f b6 44 16 04    	movzx  eax,BYTE PTR [rsi+r10*1+0x4]
  2193d0:	42 88 44 17 04       	mov    BYTE PTR [rdi+r10*1+0x4],al
  2193d5:	42 0f b6 44 16 05    	movzx  eax,BYTE PTR [rsi+r10*1+0x5]
  2193db:	42 88 44 17 05       	mov    BYTE PTR [rdi+r10*1+0x5],al
  2193e0:	42 0f b6 44 16 06    	movzx  eax,BYTE PTR [rsi+r10*1+0x6]
  2193e6:	42 88 44 17 06       	mov    BYTE PTR [rdi+r10*1+0x6],al
  2193eb:	42 0f b6 44 16 07    	movzx  eax,BYTE PTR [rsi+r10*1+0x7]
  2193f1:	42 88 44 17 07       	mov    BYTE PTR [rdi+r10*1+0x7],al
        while (index != n) : (index += 1) {
  2193f6:	49 83 c2 08          	add    r10,0x8
  2193fa:	4c 39 d2             	cmp    rdx,r10
  2193fd:	75 a1                	jne    2193a0 <memmove+0x70>
  2193ff:	e9 4d 04 00 00       	jmp    219851 <memmove+0x521>
  219404:	48 85 d2             	test   rdx,rdx
        }
    } else {
        var index = n;
        while (index != 0) {
  219407:	0f 84 44 04 00 00    	je     219851 <memmove+0x521>
  21940d:	48 81 fa 80 00 00 00 	cmp    rdx,0x80
  219414:	0f 82 2a 02 00 00    	jb     219644 <memmove+0x314>
  21941a:	48 8d 04 16          	lea    rax,[rsi+rdx*1]
  21941e:	48 39 f8             	cmp    rax,rdi
  219421:	76 0d                	jbe    219430 <memmove+0x100>
  219423:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  219427:	48 39 f0             	cmp    rax,rsi
  21942a:	0f 87 14 02 00 00    	ja     219644 <memmove+0x314>
  219430:	49 89 d0             	mov    r8,rdx
  219433:	49 83 e0 80          	and    r8,0xffffffffffffff80
  219437:	49 8d 48 80          	lea    rcx,[r8-0x80]
  21943b:	48 89 c8             	mov    rax,rcx
  21943e:	48 c1 e8 07          	shr    rax,0x7
  219442:	44 8d 48 01          	lea    r9d,[rax+0x1]
  219446:	41 83 e1 03          	and    r9d,0x3
  21944a:	48 81 f9 80 01 00 00 	cmp    rcx,0x180
  219451:	73 47                	jae    21949a <memmove+0x16a>
  219453:	31 c0                	xor    eax,eax
  219455:	4d 85 c9             	test   r9,r9
  219458:	0f 85 8a 01 00 00    	jne    2195e8 <memmove+0x2b8>
  21945e:	e9 d5 01 00 00       	jmp    219638 <memmove+0x308>
        while (index != n) : (index += 1) {
  219463:	49 89 d2             	mov    r10,rdx
  219466:	49 83 e2 80          	and    r10,0xffffffffffffff80
  21946a:	4d 8d 4a 80          	lea    r9,[r10-0x80]
  21946e:	4c 89 c9             	mov    rcx,r9
  219471:	48 c1 e9 07          	shr    rcx,0x7
  219475:	44 8d 41 01          	lea    r8d,[rcx+0x1]
  219479:	41 83 e0 03          	and    r8d,0x3
  21947d:	49 81 f9 80 01 00 00 	cmp    r9,0x180
  219484:	0f 83 4c 02 00 00    	jae    2196d6 <memmove+0x3a6>
  21948a:	31 c9                	xor    ecx,ecx
  21948c:	4d 85 c0             	test   r8,r8
  21948f:	0f 85 67 03 00 00    	jne    2197fc <memmove+0x4cc>
  219495:	e9 ae 03 00 00       	jmp    219848 <memmove+0x518>
        while (index != 0) {
  21949a:	4c 8d 14 16          	lea    r10,[rsi+rdx*1]
  21949e:	49 83 c2 e0          	add    r10,0xffffffffffffffe0
  2194a2:	48 8d 0c 17          	lea    rcx,[rdi+rdx*1]
  2194a6:	48 83 c1 e0          	add    rcx,0xffffffffffffffe0
  2194aa:	4d 8d 59 ff          	lea    r11,[r9-0x1]
  2194ae:	49 29 c3             	sub    r11,rax
  2194b1:	31 c0                	xor    eax,eax
  2194b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2194ba:	84 00 00 00 00 00 
            index -= 1;
            dest.?[index] = src.?[index];
  2194c0:	c4 c1 7c 10 44 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x60]
  2194c7:	c4 c1 7c 10 4c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x40]
  2194ce:	c4 c1 7c 10 54 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x20]
  2194d5:	c4 c1 7c 10 1c 02    	vmovups ymm3,YMMWORD PTR [r10+rax*1]
  2194db:	c5 fc 11 1c 01       	vmovups YMMWORD PTR [rcx+rax*1],ymm3
  2194e0:	c5 fc 11 54 01 e0    	vmovups YMMWORD PTR [rcx+rax*1-0x20],ymm2
  2194e6:	c5 fc 11 4c 01 c0    	vmovups YMMWORD PTR [rcx+rax*1-0x40],ymm1
  2194ec:	c5 fc 11 44 01 a0    	vmovups YMMWORD PTR [rcx+rax*1-0x60],ymm0
  2194f2:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0xe0]
  2194f9:	ff ff ff 
  2194fc:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0xc0]
  219503:	ff ff ff 
  219506:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0xa0]
  21950d:	ff ff ff 
  219510:	c4 c1 7c 10 5c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x80]
  219517:	c5 fc 11 5c 01 80    	vmovups YMMWORD PTR [rcx+rax*1-0x80],ymm3
  21951d:	c5 fc 11 94 01 60 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xa0],ymm2
  219524:	ff ff 
  219526:	c5 fc 11 8c 01 40 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xc0],ymm1
  21952d:	ff ff 
  21952f:	c5 fc 11 84 01 20 ff 	vmovups YMMWORD PTR [rcx+rax*1-0xe0],ymm0
  219536:	ff ff 
  219538:	c4 c1 7c 10 84 02 a0 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x160]
  21953f:	fe ff ff 
  219542:	c4 c1 7c 10 8c 02 c0 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x140]
  219549:	fe ff ff 
  21954c:	c4 c1 7c 10 94 02 e0 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x120]
  219553:	fe ff ff 
  219556:	c4 c1 7c 10 9c 02 00 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x100]
  21955d:	ff ff ff 
  219560:	c5 fc 11 9c 01 00 ff 	vmovups YMMWORD PTR [rcx+rax*1-0x100],ymm3
  219567:	ff ff 
  219569:	c5 fc 11 94 01 e0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x120],ymm2
  219570:	ff ff 
  219572:	c5 fc 11 8c 01 c0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x140],ymm1
  219579:	ff ff 
  21957b:	c5 fc 11 84 01 a0 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x160],ymm0
  219582:	ff ff 
  219584:	c4 c1 7c 10 84 02 20 	vmovups ymm0,YMMWORD PTR [r10+rax*1-0x1e0]
  21958b:	fe ff ff 
  21958e:	c4 c1 7c 10 8c 02 40 	vmovups ymm1,YMMWORD PTR [r10+rax*1-0x1c0]
  219595:	fe ff ff 
  219598:	c4 c1 7c 10 94 02 60 	vmovups ymm2,YMMWORD PTR [r10+rax*1-0x1a0]
  21959f:	fe ff ff 
  2195a2:	c4 c1 7c 10 9c 02 80 	vmovups ymm3,YMMWORD PTR [r10+rax*1-0x180]
  2195a9:	fe ff ff 
  2195ac:	c5 fc 11 9c 01 80 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x180],ymm3
  2195b3:	ff ff 
  2195b5:	c5 fc 11 94 01 60 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1a0],ymm2
  2195bc:	ff ff 
  2195be:	c5 fc 11 8c 01 40 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1c0],ymm1
  2195c5:	ff ff 
  2195c7:	c5 fc 11 84 01 20 fe 	vmovups YMMWORD PTR [rcx+rax*1-0x1e0],ymm0
  2195ce:	ff ff 
  2195d0:	48 05 00 fe ff ff    	add    rax,0xfffffffffffffe00
  2195d6:	49 83 c3 04          	add    r11,0x4
  2195da:	0f 85 e0 fe ff ff    	jne    2194c0 <memmove+0x190>
  2195e0:	48 f7 d8             	neg    rax
  2195e3:	4d 85 c9             	test   r9,r9
  2195e6:	74 50                	je     219638 <memmove+0x308>
  2195e8:	48 8d 4a e0          	lea    rcx,[rdx-0x20]
  2195ec:	48 29 c1             	sub    rcx,rax
  2195ef:	49 f7 d9             	neg    r9
  2195f2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2195f9:	1f 84 00 00 00 00 00 
  219600:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  219606:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  21960c:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  219612:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  219617:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
  21961c:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  219622:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  219628:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  21962e:	48 83 c1 80          	add    rcx,0xffffffffffffff80
  219632:	49 83 c1 01          	add    r9,0x1
  219636:	75 c8                	jne    219600 <memmove+0x2d0>
  219638:	49 39 d0             	cmp    r8,rdx
        while (index != 0) {
  21963b:	0f 84 10 02 00 00    	je     219851 <memmove+0x521>
  219641:	4c 29 c2             	sub    rdx,r8
            index -= 1;
  219644:	4c 8d 42 ff          	lea    r8,[rdx-0x1]
  219648:	48 89 d1             	mov    rcx,rdx
  21964b:	48 83 e1 07          	and    rcx,0x7
  21964f:	74 22                	je     219673 <memmove+0x343>
  219651:	48 f7 d9             	neg    rcx
  219654:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21965b:	00 00 00 00 00 
            dest.?[index] = src.?[index];
  219660:	0f b6 44 16 ff       	movzx  eax,BYTE PTR [rsi+rdx*1-0x1]
  219665:	88 44 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],al
            index -= 1;
  219669:	48 8d 52 ff          	lea    rdx,[rdx-0x1]
        while (index != 0) {
  21966d:	48 83 c1 01          	add    rcx,0x1
  219671:	75 ed                	jne    219660 <memmove+0x330>
            index -= 1;
  219673:	49 83 f8 07          	cmp    r8,0x7
  219677:	0f 82 d4 01 00 00    	jb     219851 <memmove+0x521>
        while (index != 0) {
  21967d:	48 89 d0             	mov    rax,rdx
            dest.?[index] = src.?[index];
  219680:	0f b6 4c 16 ff       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x1]
  219685:	88 4c 17 ff          	mov    BYTE PTR [rdi+rdx*1-0x1],cl
  219689:	0f b6 4c 16 fe       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x2]
  21968e:	88 4c 17 fe          	mov    BYTE PTR [rdi+rdx*1-0x2],cl
  219692:	0f b6 4c 16 fd       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x3]
  219697:	88 4c 17 fd          	mov    BYTE PTR [rdi+rdx*1-0x3],cl
  21969b:	0f b6 4c 16 fc       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x4]
  2196a0:	88 4c 17 fc          	mov    BYTE PTR [rdi+rdx*1-0x4],cl
  2196a4:	0f b6 4c 16 fb       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x5]
  2196a9:	88 4c 17 fb          	mov    BYTE PTR [rdi+rdx*1-0x5],cl
  2196ad:	0f b6 4c 16 fa       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x6]
  2196b2:	88 4c 17 fa          	mov    BYTE PTR [rdi+rdx*1-0x6],cl
  2196b6:	0f b6 4c 16 f9       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x7]
  2196bb:	88 4c 17 f9          	mov    BYTE PTR [rdi+rdx*1-0x7],cl
  2196bf:	0f b6 4c 16 f8       	movzx  ecx,BYTE PTR [rsi+rdx*1-0x8]
  2196c4:	88 4c 17 f8          	mov    BYTE PTR [rdi+rdx*1-0x8],cl
        while (index != 0) {
  2196c8:	48 83 c0 f8          	add    rax,0xfffffffffffffff8
  2196cc:	48 89 c2             	mov    rdx,rax
  2196cf:	75 af                	jne    219680 <memmove+0x350>
  2196d1:	e9 7b 01 00 00       	jmp    219851 <memmove+0x521>
        while (index != n) : (index += 1) {
  2196d6:	4d 8d 48 ff          	lea    r9,[r8-0x1]
  2196da:	49 29 c9             	sub    r9,rcx
  2196dd:	31 c9                	xor    ecx,ecx
  2196df:	90                   	nop
            dest.?[index] = src.?[index];
  2196e0:	c5 fc 10 04 0e       	vmovups ymm0,YMMWORD PTR [rsi+rcx*1]
  2196e5:	c5 fc 10 4c 0e 20    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x20]
  2196eb:	c5 fc 10 54 0e 40    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x40]
  2196f1:	c5 fc 10 5c 0e 60    	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x60]
  2196f7:	c5 fc 11 04 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm0
  2196fc:	c5 fc 11 4c 0f 20    	vmovups YMMWORD PTR [rdi+rcx*1+0x20],ymm1
  219702:	c5 fc 11 54 0f 40    	vmovups YMMWORD PTR [rdi+rcx*1+0x40],ymm2
  219708:	c5 fc 11 5c 0f 60    	vmovups YMMWORD PTR [rdi+rcx*1+0x60],ymm3
  21970e:	c5 fc 10 84 0e 80 00 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x80]
  219715:	00 00 
  219717:	c5 fc 10 8c 0e a0 00 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0xa0]
  21971e:	00 00 
  219720:	c5 fc 10 94 0e c0 00 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0xc0]
  219727:	00 00 
  219729:	c5 fc 10 9c 0e e0 00 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0xe0]
  219730:	00 00 
  219732:	c5 fc 11 84 0f 80 00 	vmovups YMMWORD PTR [rdi+rcx*1+0x80],ymm0
  219739:	00 00 
  21973b:	c5 fc 11 8c 0f a0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xa0],ymm1
  219742:	00 00 
  219744:	c5 fc 11 94 0f c0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xc0],ymm2
  21974b:	00 00 
  21974d:	c5 fc 11 9c 0f e0 00 	vmovups YMMWORD PTR [rdi+rcx*1+0xe0],ymm3
  219754:	00 00 
  219756:	c5 fc 10 84 0e 00 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x100]
  21975d:	00 00 
  21975f:	c5 fc 10 8c 0e 20 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x120]
  219766:	00 00 
  219768:	c5 fc 10 94 0e 40 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x140]
  21976f:	00 00 
  219771:	c5 fc 10 9c 0e 60 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x160]
  219778:	00 00 
  21977a:	c5 fc 11 84 0f 00 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x100],ymm0
  219781:	00 00 
  219783:	c5 fc 11 8c 0f 20 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x120],ymm1
  21978a:	00 00 
  21978c:	c5 fc 11 94 0f 40 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x140],ymm2
  219793:	00 00 
  219795:	c5 fc 11 9c 0f 60 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x160],ymm3
  21979c:	00 00 
  21979e:	c5 fc 10 84 0e 80 01 	vmovups ymm0,YMMWORD PTR [rsi+rcx*1+0x180]
  2197a5:	00 00 
  2197a7:	c5 fc 10 8c 0e a0 01 	vmovups ymm1,YMMWORD PTR [rsi+rcx*1+0x1a0]
  2197ae:	00 00 
  2197b0:	c5 fc 10 94 0e c0 01 	vmovups ymm2,YMMWORD PTR [rsi+rcx*1+0x1c0]
  2197b7:	00 00 
  2197b9:	c5 fc 10 9c 0e e0 01 	vmovups ymm3,YMMWORD PTR [rsi+rcx*1+0x1e0]
  2197c0:	00 00 
  2197c2:	c5 fc 11 84 0f 80 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x180],ymm0
  2197c9:	00 00 
  2197cb:	c5 fc 11 8c 0f a0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1a0],ymm1
  2197d2:	00 00 
  2197d4:	c5 fc 11 94 0f c0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1c0],ymm2
  2197db:	00 00 
  2197dd:	c5 fc 11 9c 0f e0 01 	vmovups YMMWORD PTR [rdi+rcx*1+0x1e0],ymm3
  2197e4:	00 00 
        while (index != n) : (index += 1) {
  2197e6:	48 81 c1 00 02 00 00 	add    rcx,0x200
  2197ed:	49 83 c1 04          	add    r9,0x4
  2197f1:	0f 85 e9 fe ff ff    	jne    2196e0 <memmove+0x3b0>
  2197f7:	4d 85 c0             	test   r8,r8
  2197fa:	74 4c                	je     219848 <memmove+0x518>
  2197fc:	48 83 c1 60          	add    rcx,0x60
  219800:	49 f7 d8             	neg    r8
  219803:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21980a:	84 00 00 00 00 00 
            dest.?[index] = src.?[index];
  219810:	c5 fc 10 44 0e a0    	vmovups ymm0,YMMWORD PTR [rsi+rcx*1-0x60]
  219816:	c5 fc 10 4c 0e c0    	vmovups ymm1,YMMWORD PTR [rsi+rcx*1-0x40]
  21981c:	c5 fc 10 54 0e e0    	vmovups ymm2,YMMWORD PTR [rsi+rcx*1-0x20]
  219822:	c5 fc 10 1c 0e       	vmovups ymm3,YMMWORD PTR [rsi+rcx*1]
  219827:	c5 fc 11 44 0f a0    	vmovups YMMWORD PTR [rdi+rcx*1-0x60],ymm0
  21982d:	c5 fc 11 4c 0f c0    	vmovups YMMWORD PTR [rdi+rcx*1-0x40],ymm1
  219833:	c5 fc 11 54 0f e0    	vmovups YMMWORD PTR [rdi+rcx*1-0x20],ymm2
  219839:	c5 fc 11 1c 0f       	vmovups YMMWORD PTR [rdi+rcx*1],ymm3
        while (index != n) : (index += 1) {
  21983e:	48 83 e9 80          	sub    rcx,0xffffffffffffff80
  219842:	49 83 c0 01          	add    r8,0x1
  219846:	75 c8                	jne    219810 <memmove+0x4e0>
  219848:	49 39 d2             	cmp    r10,rdx
  21984b:	0f 85 17 fb ff ff    	jne    219368 <memmove+0x38>
        }
    }

    return dest;
  219851:	48 89 f8             	mov    rax,rdi
  219854:	c5 f8 77             	vzeroupper 
  219857:	c3                   	ret    
  219858:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21985f:	00 

0000000000219860 <clone>:

// TODO we should be able to put this directly in std/linux/x86_64.zig but
// it causes a segfault in release mode. this is a workaround of calling it
// across .o file boundaries. fix comptime @ptrCast of nakedcc functions.
nakedcc fn clone() void {
    asm volatile (
  219860:	31 c0                	xor    eax,eax
  219862:	b0 38                	mov    al,0x38
  219864:	49 89 fb             	mov    r11,rdi
  219867:	48 89 d7             	mov    rdi,rdx
  21986a:	4c 89 c2             	mov    rdx,r8
  21986d:	4d 89 c8             	mov    r8,r9
  219870:	4c 8b 54 24 08       	mov    r10,QWORD PTR [rsp+0x8]
  219875:	4d 89 d9             	mov    r9,r11
  219878:	48 83 e6 f0          	and    rsi,0xfffffffffffffff0
  21987c:	48 83 ee 08          	sub    rsi,0x8
  219880:	48 89 0e             	mov    QWORD PTR [rsi],rcx
  219883:	0f 05                	syscall 
  219885:	85 c0                	test   eax,eax
  219887:	75 0f                	jne    219898 <clone+0x38>
  219889:	31 ed                	xor    ebp,ebp
  21988b:	5f                   	pop    rdi
  21988c:	41 ff d1             	call   r9
  21988f:	89 c7                	mov    edi,eax
  219891:	31 c0                	xor    eax,eax
  219893:	b0 3c                	mov    al,0x3c
  219895:	0f 05                	syscall 
  219897:	f4                   	hlt    
  219898:	c3                   	ret    
nakedcc fn clone() void {
  219899:	c3                   	ret    
  21989a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000002198a0 <fmodf>:
    );
}

const math = @import("../math/index.zig");

export fn fmodf(x: f32, y: f32) f32 {
  2198a0:	c5 f9 6f d0          	vmovdqa xmm2,xmm0
    const digits = if (T == f32) 23 else 52;
    const exp_bits = if (T == f32) 9 else 12;
    const bits_minus_1 = T.bit_count - 1;
    const mask = if (T == f32) 0xff else 0x7ff;
    var ux = @bitCast(uint, x);
    var uy = @bitCast(uint, y);
  2198a4:	c4 c1 79 7e c9       	vmovd  r9d,xmm1
    var ex = @intCast(i32, (ux >> digits) & mask);
    var ey = @intCast(i32, (uy >> digits) & mask);
    const sx = if (T == f32) @intCast(u32, ux & 0x80000000) else @intCast(i32, ux >> bits_minus_1);
    var i: uint = undefined;

    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  2198a9:	44 89 c8             	mov    eax,r9d
  2198ac:	c5 fa 10 05 20 df fe 	vmovss xmm0,DWORD PTR [rip+0xfffffffffffedf20]        # 2077d4 <__unnamed_605+0xa>
  2198b3:	ff 
  2198b4:	01 c0                	add    eax,eax
  2198b6:	0f 84 4a 01 00 00    	je     219a06 <fmodf+0x166>

fn isNan(comptime T: type, bits: T) bool {
    if (T == u16) {
        return (bits & 0x7fff) > 0x7c00;
    } else if (T == u32) {
        return (bits & 0x7fffffff) > 0x7f800000;
  2198bc:	44 89 c9             	mov    ecx,r9d
  2198bf:	81 e1 ff ff ff 7f    	and    ecx,0x7fffffff
  2198c5:	81 f9 00 00 80 7f    	cmp    ecx,0x7f800000
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  2198cb:	0f 87 35 01 00 00    	ja     219a06 <fmodf+0x166>
  2198d1:	c4 c1 79 7e d0       	vmovd  r8d,xmm2
  2198d6:	ba 17 08 00 00       	mov    edx,0x817
  2198db:	c4 c2 68 f7 c8       	bextr  ecx,r8d,edx
  2198e0:	81 f9 ff 00 00 00    	cmp    ecx,0xff
  2198e6:	0f 84 1a 01 00 00    	je     219a06 <fmodf+0x166>
    if (ux << 1 <= uy << 1) {
  2198ec:	43 8d 34 00          	lea    esi,[r8+r8*1]
  2198f0:	39 c6                	cmp    esi,eax
  2198f2:	76 2a                	jbe    21991e <fmodf+0x7e>
  2198f4:	c4 c2 68 f7 f9       	bextr  edi,r9d,edx
        ux &= @maxValue(uint) >> exp_bits;
  2198f9:	44 89 c0             	mov    eax,r8d
    if (ex == 0) {
  2198fc:	85 c9                	test   ecx,ecx
  2198fe:	74 2d                	je     21992d <fmodf+0x8d>
        ux &= @maxValue(uint) >> exp_bits;
  219900:	25 ff ff 7f 00       	and    eax,0x7fffff
        ux |= 1 << digits;
  219905:	0d 00 00 80 00       	or     eax,0x800000
    if (ey == 0) {
  21990a:	85 ff                	test   edi,edi
  21990c:	74 49                	je     219957 <fmodf+0xb7>
        uy &= @maxValue(uint) >> exp_bits;
  21990e:	41 81 e1 ff ff 7f 00 	and    r9d,0x7fffff
        uy |= 1 << digits;
  219915:	41 81 c9 00 00 80 00 	or     r9d,0x800000
  21991c:	eb 77                	jmp    219995 <fmodf+0xf5>
  21991e:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  219922:	0f 84 de 00 00 00    	je     219a06 <fmodf+0x166>
  219928:	c5 f9 6f c2          	vmovdqa xmm0,xmm2
    return generic_fmod(f32, x, y);
  21992c:	c3                   	ret    
  21992d:	31 c9                	xor    ecx,ecx
        i = ux << exp_bits;
  21992f:	c1 e0 09             	shl    eax,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  219932:	78 13                	js     219947 <fmodf+0xa7>
  219934:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21993b:	00 00 00 00 00 
            ex -= 1;
  219940:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  219943:	01 c0                	add    eax,eax
        while (i >> bits_minus_1 == 0) : (b: {
  219945:	79 f9                	jns    219940 <fmodf+0xa0>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  219947:	b8 01 00 00 00       	mov    eax,0x1
  21994c:	29 c8                	sub    eax,ecx
  21994e:	c4 c2 79 f7 c0       	shlx   eax,r8d,eax
    if (ey == 0) {
  219953:	85 ff                	test   edi,edi
  219955:	75 b7                	jne    21990e <fmodf+0x6e>
        i = uy << exp_bits;
  219957:	44 89 ca             	mov    edx,r9d
  21995a:	31 ff                	xor    edi,edi
  21995c:	c1 e2 09             	shl    edx,0x9
        while (i >> bits_minus_1 == 0) : (b: {
  21995f:	78 16                	js     219977 <fmodf+0xd7>
  219961:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219968:	0f 1f 84 00 00 00 00 
  21996f:	00 
            ey -= 1;
  219970:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  219973:	01 d2                	add    edx,edx
        while (i >> bits_minus_1 == 0) : (b: {
  219975:	79 f9                	jns    219970 <fmodf+0xd0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  219977:	ba 01 00 00 00       	mov    edx,0x1
  21997c:	29 fa                	sub    edx,edi
  21997e:	c4 42 69 f7 c9       	shlx   r9d,r9d,edx
  219983:	eb 10                	jmp    219995 <fmodf+0xf5>
  219985:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21998c:	00 00 00 00 
        ux <<= 1;
  219990:	01 c0                	add    eax,eax
    while (ex > ey) : (ex -= 1) {
  219992:	83 c1 ff             	add    ecx,0xffffffff
  219995:	89 c6                	mov    esi,eax
  219997:	44 29 ce             	sub    esi,r9d
  21999a:	0f 99 c2             	setns  dl
  21999d:	39 f9                	cmp    ecx,edi
  21999f:	7e 10                	jle    2199b1 <fmodf+0x111>
        if (i >> bits_minus_1 == 0) {
  2199a1:	f6 c2 01             	test   dl,0x1
  2199a4:	74 ea                	je     219990 <fmodf+0xf0>
  2199a6:	89 f0                	mov    eax,esi
            if (i == 0)
  2199a8:	85 f6                	test   esi,esi
  2199aa:	75 e4                	jne    219990 <fmodf+0xf0>
  2199ac:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
    return generic_fmod(f32, x, y);
  2199b0:	c3                   	ret    
    if (i >> bits_minus_1 == 0) {
  2199b1:	84 d2                	test   dl,dl
  2199b3:	74 06                	je     2199bb <fmodf+0x11b>
  2199b5:	89 f0                	mov    eax,esi
        if (i == 0)
  2199b7:	85 f6                	test   esi,esi
  2199b9:	74 4c                	je     219a07 <fmodf+0x167>
    while (ux >> digits == 0) : (b: {
  2199bb:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  2199c0:	77 1a                	ja     2199dc <fmodf+0x13c>
  2199c2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  2199c9:	1f 84 00 00 00 00 00 
        ux <<= 1;
  2199d0:	01 c0                	add    eax,eax
        ex -= 1;
  2199d2:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  2199d5:	3d 00 00 80 00       	cmp    eax,0x800000
  2199da:	72 f4                	jb     2199d0 <fmodf+0x130>
  2199dc:	41 81 e0 00 00 00 80 	and    r8d,0x80000000
    if (ex > 0) {
  2199e3:	85 c9                	test   ecx,ecx
  2199e5:	7e 0c                	jle    2199f3 <fmodf+0x153>
        ux -%= 1 << digits;
  2199e7:	05 00 00 80 ff       	add    eax,0xff800000
        ux |= uint(@bitCast(u32, ex)) << digits;
  2199ec:	c1 e1 17             	shl    ecx,0x17
  2199ef:	09 c1                	or     ecx,eax
  2199f1:	eb 0c                	jmp    2199ff <fmodf+0x15f>
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  2199f3:	ba 01 00 00 00       	mov    edx,0x1
  2199f8:	29 ca                	sub    edx,ecx
  2199fa:	c4 e2 6b f7 c8       	shrx   ecx,eax,edx
        ux |= sx;
  2199ff:	44 09 c1             	or     ecx,r8d
    return @bitCast(T, ux);
  219a02:	c5 f9 6e c1          	vmovd  xmm0,ecx
    return generic_fmod(f32, x, y);
  219a06:	c3                   	ret    
  219a07:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  219a0b:	c3                   	ret    
  219a0c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000219a10 <fmod>:
export fn fmod(x: f64, y: f64) f64 {
  219a10:	c5 f9 6f d0          	vmovdqa xmm2,xmm0
    var uy = @bitCast(uint, y);
  219a14:	c4 c1 f9 7e cb       	vmovq  r11,xmm1
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  219a19:	4c 89 d8             	mov    rax,r11
  219a1c:	c5 fb 10 05 b4 71 fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffe71b4]        # 200bd8 <__unnamed_441+0x38>
  219a23:	ff 
  219a24:	48 01 c0             	add    rax,rax
  219a27:	0f 84 6f 01 00 00    	je     219b9c <fmod+0x18c>
  219a2d:	49 b9 ff ff ff ff ff 	movabs r9,0x7fffffffffffffff
  219a34:	ff ff 7f 
    } else if (T == u64) {
        return (bits & (@maxValue(u64) >> 1)) > (u64(0x7ff) << 52);
  219a37:	4c 89 d9             	mov    rcx,r11
  219a3a:	4c 21 c9             	and    rcx,r9
  219a3d:	48 ba 00 00 00 00 00 	movabs rdx,0x7ff0000000000000
  219a44:	00 f0 7f 
  219a47:	48 39 d1             	cmp    rcx,rdx
    if (uy << 1 == 0 or isNan(uint, uy) or ex == mask)
  219a4a:	0f 87 4c 01 00 00    	ja     219b9c <fmod+0x18c>
  219a50:	c4 c1 f9 7e d2       	vmovq  r10,xmm2
  219a55:	4c 89 d1             	mov    rcx,r10
  219a58:	48 c1 e9 34          	shr    rcx,0x34
  219a5c:	81 e1 ff 07 00 00    	and    ecx,0x7ff
  219a62:	81 f9 ff 07 00 00    	cmp    ecx,0x7ff
  219a68:	0f 84 2e 01 00 00    	je     219b9c <fmod+0x18c>
    if (ux << 1 <= uy << 1) {
  219a6e:	4b 8d 14 12          	lea    rdx,[r10+r10*1]
  219a72:	48 39 c2             	cmp    rdx,rax
  219a75:	76 35                	jbe    219aac <fmod+0x9c>
  219a77:	4c 89 df             	mov    rdi,r11
  219a7a:	48 c1 ef 34          	shr    rdi,0x34
  219a7e:	81 e7 ff 07 00 00    	and    edi,0x7ff
  219a84:	49 b8 00 00 00 00 00 	movabs r8,0x10000000000000
  219a8b:	00 10 00 
    if (ex == 0) {
  219a8e:	85 c9                	test   ecx,ecx
  219a90:	74 29                	je     219abb <fmod+0xab>
        ux &= @maxValue(uint) >> exp_bits;
  219a92:	49 8d 40 ff          	lea    rax,[r8-0x1]
  219a96:	4c 21 d0             	and    rax,r10
        ux |= 1 << digits;
  219a99:	4c 09 c0             	or     rax,r8
    if (ey == 0) {
  219a9c:	85 ff                	test   edi,edi
  219a9e:	74 48                	je     219ae8 <fmod+0xd8>
        uy &= @maxValue(uint) >> exp_bits;
  219aa0:	49 8d 50 ff          	lea    rdx,[r8-0x1]
  219aa4:	49 21 d3             	and    r11,rdx
        uy |= 1 << digits;
  219aa7:	4d 09 c3             	or     r11,r8
  219aaa:	eb 7a                	jmp    219b26 <fmod+0x116>
  219aac:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  219ab0:	0f 84 e6 00 00 00    	je     219b9c <fmod+0x18c>
  219ab6:	c5 f9 6f c2          	vmovdqa xmm0,xmm2
    return generic_fmod(f64, x, y);
  219aba:	c3                   	ret    
        i = ux << exp_bits;
  219abb:	4c 89 d0             	mov    rax,r10
  219abe:	31 c9                	xor    ecx,ecx
  219ac0:	48 c1 e0 0c          	shl    rax,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  219ac4:	78 12                	js     219ad8 <fmod+0xc8>
  219ac6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  219acd:	00 00 00 
            ex -= 1;
  219ad0:	83 c1 ff             	add    ecx,0xffffffff
            i <<= 1;
  219ad3:	48 01 c0             	add    rax,rax
        while (i >> bits_minus_1 == 0) : (b: {
  219ad6:	79 f8                	jns    219ad0 <fmod+0xc0>
        ux <<= @intCast(log2uint, @bitCast(u32, -ex + 1));
  219ad8:	b8 01 00 00 00       	mov    eax,0x1
  219add:	29 c8                	sub    eax,ecx
  219adf:	c4 c2 f9 f7 c2       	shlx   rax,r10,rax
    if (ey == 0) {
  219ae4:	85 ff                	test   edi,edi
  219ae6:	75 b8                	jne    219aa0 <fmod+0x90>
        i = uy << exp_bits;
  219ae8:	4c 89 da             	mov    rdx,r11
  219aeb:	31 ff                	xor    edi,edi
  219aed:	48 c1 e2 0c          	shl    rdx,0xc
        while (i >> bits_minus_1 == 0) : (b: {
  219af1:	78 15                	js     219b08 <fmod+0xf8>
  219af3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219afa:	84 00 00 00 00 00 
            ey -= 1;
  219b00:	83 c7 ff             	add    edi,0xffffffff
            i <<= 1;
  219b03:	48 01 d2             	add    rdx,rdx
        while (i >> bits_minus_1 == 0) : (b: {
  219b06:	79 f8                	jns    219b00 <fmod+0xf0>
        uy <<= @intCast(log2uint, @bitCast(u32, -ey + 1));
  219b08:	ba 01 00 00 00       	mov    edx,0x1
  219b0d:	29 fa                	sub    edx,edi
  219b0f:	c4 42 e9 f7 db       	shlx   r11,r11,rdx
  219b14:	eb 10                	jmp    219b26 <fmod+0x116>
  219b16:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  219b1d:	00 00 00 
        ux <<= 1;
  219b20:	48 01 c0             	add    rax,rax
    while (ex > ey) : (ex -= 1) {
  219b23:	83 c1 ff             	add    ecx,0xffffffff
  219b26:	48 89 c6             	mov    rsi,rax
  219b29:	4c 29 de             	sub    rsi,r11
  219b2c:	0f 99 c2             	setns  dl
  219b2f:	39 f9                	cmp    ecx,edi
  219b31:	7e 12                	jle    219b45 <fmod+0x135>
        if (i >> bits_minus_1 == 0) {
  219b33:	f6 c2 01             	test   dl,0x1
  219b36:	74 e8                	je     219b20 <fmod+0x110>
  219b38:	48 89 f0             	mov    rax,rsi
            if (i == 0)
  219b3b:	48 85 f6             	test   rsi,rsi
  219b3e:	75 e0                	jne    219b20 <fmod+0x110>
  219b40:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
    return generic_fmod(f64, x, y);
  219b44:	c3                   	ret    
    if (i >> bits_minus_1 == 0) {
  219b45:	84 d2                	test   dl,dl
  219b47:	74 08                	je     219b51 <fmod+0x141>
  219b49:	48 89 f0             	mov    rax,rsi
        if (i == 0)
  219b4c:	48 85 f6             	test   rsi,rsi
  219b4f:	74 4c                	je     219b9d <fmod+0x18d>
  219b51:	49 83 c1 01          	add    r9,0x1
    while (ux >> digits == 0) : (b: {
  219b55:	4c 39 c0             	cmp    rax,r8
  219b58:	73 11                	jae    219b6b <fmod+0x15b>
  219b5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        ux <<= 1;
  219b60:	48 01 c0             	add    rax,rax
        ex -= 1;
  219b63:	83 c1 ff             	add    ecx,0xffffffff
    while (ux >> digits == 0) : (b: {
  219b66:	4c 39 c0             	cmp    rax,r8
  219b69:	72 f5                	jb     219b60 <fmod+0x150>
  219b6b:	4d 21 ca             	and    r10,r9
    if (ex > 0) {
  219b6e:	85 c9                	test   ecx,ecx
  219b70:	7e 16                	jle    219b88 <fmod+0x178>
        ux -%= 1 << digits;
  219b72:	48 ba 00 00 00 00 00 	movabs rdx,0xfff0000000000000
  219b79:	00 f0 ff 
  219b7c:	48 01 d0             	add    rax,rdx
        ux |= uint(@bitCast(u32, ex)) << digits;
  219b7f:	48 c1 e1 34          	shl    rcx,0x34
  219b83:	48 09 c1             	or     rcx,rax
  219b86:	eb 0c                	jmp    219b94 <fmod+0x184>
        ux >>= @intCast(log2uint, @bitCast(u32, -ex + 1));
  219b88:	ba 01 00 00 00       	mov    edx,0x1
  219b8d:	29 ca                	sub    edx,ecx
  219b8f:	c4 e2 eb f7 c8       	shrx   rcx,rax,rdx
        ux |= @intCast(uint, sx) << bits_minus_1;
  219b94:	4c 09 d1             	or     rcx,r10
    return @bitCast(T, ux);
  219b97:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
    return generic_fmod(f64, x, y);
  219b9c:	c3                   	ret    
  219b9d:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  219ba1:	c3                   	ret    
  219ba2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219ba9:	1f 84 00 00 00 00 00 

0000000000219bb0 <floorf>:
    if (x == 0.0) {
  219bb0:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  219bb4:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  219bb8:	75 02                	jne    219bbc <floorf+0xc>
  219bba:	7b 57                	jnp    219c13 <floorf+0x63>
  219bbc:	c5 f9 7e c1          	vmovd  ecx,xmm0
  219bc0:	89 c8                	mov    eax,ecx
  219bc2:	c1 e8 17             	shr    eax,0x17
  219bc5:	0f b6 d0             	movzx  edx,al
  219bc8:	81 fa 95 00 00 00    	cmp    edx,0x95
  219bce:	77 43                	ja     219c13 <floorf+0x63>
    if (e >= 0) {
  219bd0:	83 fa 7f             	cmp    edx,0x7f
  219bd3:	72 2e                	jb     219c03 <floorf+0x53>
  219bd5:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  219bd8:	83 e0 1f             	and    eax,0x1f
  219bdb:	ba ff ff 7f 00       	mov    edx,0x7fffff
  219be0:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  219be5:	85 ca                	test   edx,ecx
  219be7:	74 2a                	je     219c13 <floorf+0x63>
        if (u >> 31 != 0) {
  219be9:	89 ce                	mov    esi,ecx
  219beb:	c1 fe 1f             	sar    esi,0x1f
  219bee:	21 d6                	and    esi,edx
  219bf0:	01 ce                	add    esi,ecx
        return @bitCast(f32, u & ~m);
  219bf2:	b9 00 00 80 ff       	mov    ecx,0xff800000
  219bf7:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  219bfc:	21 f0                	and    eax,esi
  219bfe:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.floor(x);
  219c02:	c3                   	ret    
        if (u >> 31 == 0) {
  219c03:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  219c07:	85 c9                	test   ecx,ecx
  219c09:	79 08                	jns    219c13 <floorf+0x63>
  219c0b:	c5 f9 6e 05 c5 db fe 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffedbc5]        # 2077d8 <__unnamed_605+0xe>
  219c12:	ff 
  219c13:	c3                   	ret    
  219c14:	66 66 66 2e 0f 1f 84 	data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  219c1b:	00 00 00 00 00 

0000000000219c20 <ceilf>:
    var u = @bitCast(u32, x);
    var e = @intCast(i32, (u >> 23) & 0xFF) - 0x7F;
    var m: u32 = undefined;

    // TODO: Shouldn't need this explicit check.
    if (x == 0.0) {
  219c20:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  219c24:	c5 f8 2e c1          	vucomiss xmm0,xmm1
  219c28:	75 02                	jne    219c2c <ceilf+0xc>
  219c2a:	7b 5a                	jnp    219c86 <ceilf+0x66>
  219c2c:	c5 f9 7e c1          	vmovd  ecx,xmm0
  219c30:	89 c8                	mov    eax,ecx
  219c32:	c1 e8 17             	shr    eax,0x17
  219c35:	0f b6 d0             	movzx  edx,al
  219c38:	81 fa 95 00 00 00    	cmp    edx,0x95
  219c3e:	77 46                	ja     219c86 <ceilf+0x66>
        return x;
    }

    if (e >= 23) {
        return x;
    } else if (e >= 0) {
  219c40:	83 fa 7f             	cmp    edx,0x7f
  219c43:	72 31                	jb     219c76 <ceilf+0x56>
  219c45:	83 c0 01             	add    eax,0x1
        m = u32(0x007FFFFF) >> @intCast(u5, e);
  219c48:	83 e0 1f             	and    eax,0x1f
  219c4b:	ba ff ff 7f 00       	mov    edx,0x7fffff
  219c50:	c4 e2 7b f7 d2       	shrx   edx,edx,eax
        if (u & m == 0) {
  219c55:	85 ca                	test   edx,ecx
  219c57:	74 2d                	je     219c86 <ceilf+0x66>
            return x;
        }
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 == 0) {
  219c59:	89 ce                	mov    esi,ecx
  219c5b:	c1 fe 1f             	sar    esi,0x1f
  219c5e:	c4 e2 48 f2 d2       	andn   edx,esi,edx
  219c63:	01 ca                	add    edx,ecx
            u += m;
        }
        u &= ~m;
  219c65:	b9 00 00 80 ff       	mov    ecx,0xff800000
  219c6a:	c4 e2 7a f7 c1       	sarx   eax,ecx,eax
  219c6f:	21 d0                	and    eax,edx
        return @bitCast(f32, u);
  219c71:	c5 f9 6e c0          	vmovd  xmm0,eax
    return math.ceil(x);
  219c75:	c3                   	ret    
    } else {
        math.forceEval(x + 0x1.0p120);
        if (u >> 31 != 0) {
  219c76:	c5 f9 ef c0          	vpxor  xmm0,xmm0,xmm0
  219c7a:	85 c9                	test   ecx,ecx
  219c7c:	78 08                	js     219c86 <ceilf+0x66>
  219c7e:	c5 f9 6e 05 4e db fe 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffedb4e]        # 2077d4 <__unnamed_605+0xa>
  219c85:	ff 
  219c86:	c3                   	ret    
  219c87:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  219c8e:	00 00 

0000000000219c90 <floor>:
    if (e >= 0x3FF + 52 or x == 0) {
  219c90:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  219c94:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  219c98:	75 02                	jne    219c9c <floor+0xc>
  219c9a:	7b 54                	jnp    219cf0 <floor+0x60>
  219c9c:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  219ca1:	b9 34 0b 00 00       	mov    ecx,0xb34
  219ca6:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  219cab:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  219cb2:	77 3c                	ja     219cf0 <floor+0x60>
        y = x - math.f64_toint + math.f64_toint - x;
  219cb4:	c5 fb 10 0d 2c 6f fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe6f2c]        # 200be8 <__unnamed_441+0x48>
  219cbb:	ff 
  219cbc:	c5 fb 10 15 5c 6f fe 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffe6f5c]        # 200c20 <__unnamed_441+0x80>
  219cc3:	ff 
    if (u >> 63 != 0) {
  219cc4:	48 85 c0             	test   rax,rax
  219cc7:	78 28                	js     219cf1 <floor+0x61>
  219cc9:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  219ccd:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    if (e <= 0x3FF - 1) {
  219cd1:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  219cd8:	76 28                	jbe    219d02 <floor+0x72>
  219cda:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
    } else if (y > 0) {
  219cde:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  219ce2:	c5 f9 2e c2          	vucomisd xmm0,xmm2
  219ce6:	76 24                	jbe    219d0c <floor+0x7c>
        return x + y - 1;
  219ce8:	c5 f3 58 05 10 6f fe 	vaddsd xmm0,xmm1,QWORD PTR [rip+0xfffffffffffe6f10]        # 200c00 <__unnamed_441+0x60>
  219cef:	ff 
    return math.floor(x);
  219cf0:	c3                   	ret    
  219cf1:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  219cf5:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  219cf9:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  219d00:	77 d8                	ja     219cda <floor+0x4a>
    if (u >> 63 != 0) {
  219d02:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  219d05:	78 0a                	js     219d11 <floor+0x81>
  219d07:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
  219d0b:	c3                   	ret    
  219d0c:	c5 f9 28 c1          	vmovapd xmm0,xmm1
  219d10:	c3                   	ret    
  219d11:	c5 fb 10 05 e7 6e fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffe6ee7]        # 200c00 <__unnamed_441+0x60>
  219d18:	ff 
  219d19:	c3                   	ret    
  219d1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000219d20 <ceil>:
fn ceil64(x: f64) f64 {
    const u = @bitCast(u64, x);
    const e = (u >> 52) & 0x7FF;
    var y: f64 = undefined;

    if (e >= 0x3FF + 52 or x == 0) {
  219d20:	c5 f1 57 c9          	vxorpd xmm1,xmm1,xmm1
  219d24:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  219d28:	75 02                	jne    219d2c <ceil+0xc>
  219d2a:	7b 79                	jnp    219da5 <ceil+0x85>
  219d2c:	c4 e1 f9 7e c0       	vmovq  rax,xmm0
  219d31:	b9 34 0b 00 00       	mov    ecx,0xb34
  219d36:	c4 e2 f0 f7 c8       	bextr  rcx,rax,rcx
  219d3b:	48 81 f9 32 04 00 00 	cmp    rcx,0x432
  219d42:	77 61                	ja     219da5 <ceil+0x85>
        return x;
    }

    if (u >> 63 != 0) {
        @setFloatMode(this, builtin.FloatMode.Strict);
        y = x - math.f64_toint + math.f64_toint - x;
  219d44:	c5 fb 10 0d 9c 6e fe 	vmovsd xmm1,QWORD PTR [rip+0xfffffffffffe6e9c]        # 200be8 <__unnamed_441+0x48>
  219d4b:	ff 
  219d4c:	c5 fb 10 15 cc 6e fe 	vmovsd xmm2,QWORD PTR [rip+0xfffffffffffe6ecc]        # 200c20 <__unnamed_441+0x80>
  219d53:	ff 
    if (u >> 63 != 0) {
  219d54:	48 85 c0             	test   rax,rax
  219d57:	78 29                	js     219d82 <ceil+0x62>
  219d59:	c5 fb 58 d2          	vaddsd xmm2,xmm0,xmm2
  219d5d:	c5 eb 58 c9          	vaddsd xmm1,xmm2,xmm1
    } else {
        @setFloatMode(this, builtin.FloatMode.Strict);
        y = x + math.f64_toint - math.f64_toint - x;
    }

    if (e <= 0x3FF - 1) {
  219d61:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  219d68:	76 29                	jbe    219d93 <ceil+0x73>
  219d6a:	c5 f3 5c c0          	vsubsd xmm0,xmm1,xmm0
        if (u >> 63 != 0) {
            return -0.0;
        } else {
            return 1.0;
        }
    } else if (y < 0) {
  219d6e:	c5 e9 57 d2          	vxorpd xmm2,xmm2,xmm2
  219d72:	c5 f9 2e d0          	vucomisd xmm2,xmm0
  219d76:	76 2e                	jbe    219da6 <ceil+0x86>
        return x + y + 1;
  219d78:	c5 f3 58 05 58 6e fe 	vaddsd xmm0,xmm1,QWORD PTR [rip+0xfffffffffffe6e58]        # 200bd8 <__unnamed_441+0x38>
  219d7f:	ff 
  219d80:	eb 23                	jmp    219da5 <ceil+0x85>
  219d82:	c5 fb 58 c9          	vaddsd xmm1,xmm0,xmm1
  219d86:	c5 f3 58 ca          	vaddsd xmm1,xmm1,xmm2
    if (e <= 0x3FF - 1) {
  219d8a:	48 81 f9 fe 03 00 00 	cmp    rcx,0x3fe
  219d91:	77 d7                	ja     219d6a <ceil+0x4a>
        if (u >> 63 != 0) {
  219d93:	c5 f9 57 c0          	vxorpd xmm0,xmm0,xmm0
    if (u >> 63 != 0) {
  219d97:	48 85 c0             	test   rax,rax
        if (u >> 63 != 0) {
  219d9a:	78 09                	js     219da5 <ceil+0x85>
  219d9c:	c5 fb 10 05 34 6e fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffe6e34]        # 200bd8 <__unnamed_441+0x38>
  219da3:	ff 
    return math.ceil(x);
  219da4:	c3                   	ret    
  219da5:	c3                   	ret    
  219da6:	c5 f9 28 c1          	vmovapd xmm0,xmm1
  219daa:	c3                   	ret    
  219dab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000219db0 <sqrt>:
// behaviour. Most intermediate i32 values are changed to u32 where appropriate but there are
// potentially some edge cases remaining that are not handled in the same way.
export fn sqrt(x: f64) f64 {
    const tiny: f64 = 1.0e-300;
    const sign: u32 = 0x80000000;
    const u = @bitCast(u64, x);
  219db0:	c4 e1 f9 7e c0       	vmovq  rax,xmm0

    var ix0 = @intCast(u32, u >> 32);
  219db5:	48 89 c7             	mov    rdi,rax
  219db8:	48 c1 ef 20          	shr    rdi,0x20
    var ix1 = @intCast(u32, u & 0xFFFFFFFF);

    // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = nan
    if (ix0 & 0x7FF00000 == 0x7FF00000) {
  219dbc:	b9 00 00 f0 7f       	mov    ecx,0x7ff00000
  219dc1:	c4 e2 40 f2 c9       	andn   ecx,edi,ecx
  219dc6:	75 06                	jne    219dce <sqrt+0x1e>
        return x * x + x;
  219dc8:	c4 e2 f9 a9 c0       	vfmadd213sd xmm0,xmm0,xmm0
  219dcd:	c3                   	ret    
    }

    // sqrt(+-0) = +-0
    if (x == 0.0) {
  219dce:	c5 f0 57 c9          	vxorps xmm1,xmm1,xmm1
  219dd2:	c5 f9 2e c1          	vucomisd xmm0,xmm1
  219dd6:	75 03                	jne    219ddb <sqrt+0x2b>
  219dd8:	7a 01                	jp     219ddb <sqrt+0x2b>
        return x;
  219dda:	c3                   	ret    
    }
    // sqrt(-ve) = snan
    if (ix0 & sign != 0) {
  219ddb:	85 ff                	test   edi,edi
  219ddd:	0f 88 d2 00 00 00    	js     219eb5 <sqrt+0x105>
        return math.snan(f64);
    }

    // normalize x
    var m = @intCast(i32, ix0 >> 20);
  219de3:	49 89 c0             	mov    r8,rax
  219de6:	49 c1 e8 34          	shr    r8,0x34
    if (m == 0) {
  219dea:	45 85 c0             	test   r8d,r8d
  219ded:	75 5e                	jne    219e4d <sqrt+0x9d>
  219def:	31 d2                	xor    edx,edx
  219df1:	31 c9                	xor    ecx,ecx
        // subnormal
        while (ix0 == 0) {
  219df3:	85 ff                	test   edi,edi
  219df5:	75 18                	jne    219e0f <sqrt+0x5f>
  219df7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  219dfe:	00 00 
            m -= 21;
  219e00:	83 c1 eb             	add    ecx,0xffffffeb
            ix0 |= ix1 >> 11;
  219e03:	89 c7                	mov    edi,eax
  219e05:	c1 ef 0b             	shr    edi,0xb
            ix1 <<= 21;
  219e08:	c1 e0 15             	shl    eax,0x15
        while (ix0 == 0) {
  219e0b:	85 ff                	test   edi,edi
  219e0d:	74 f1                	je     219e00 <sqrt+0x50>
  219e0f:	31 f6                	xor    esi,esi
        }

        // subnormal
        var i: u32 = 0;
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  219e11:	0f ba e7 14          	bt     edi,0x14
  219e15:	72 20                	jb     219e37 <sqrt+0x87>
  219e17:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  219e1e:	00 00 
  219e20:	89 fa                	mov    edx,edi
            ix0 <<= 1;
  219e22:	8d 3c 12             	lea    edi,[rdx+rdx*1]
        while (ix0 & 0x00100000 == 0) : (i += 1) {
  219e25:	83 c6 ff             	add    esi,0xffffffff
  219e28:	f7 c2 00 00 08 00    	test   edx,0x80000
  219e2e:	74 f0                	je     219e20 <sqrt+0x70>
  219e30:	89 f2                	mov    edx,esi
  219e32:	f7 da                	neg    edx
  219e34:	83 e2 1f             	and    edx,0x1f
        }
        m -= @intCast(i32, i) - 1;
  219e37:	44 8d 04 31          	lea    r8d,[rcx+rsi*1]
  219e3b:	41 83 c0 01          	add    r8d,0x1
        ix0 |= ix1 >> @intCast(u5, 32 - i);
  219e3f:	c4 e2 4b f7 c8       	shrx   ecx,eax,esi
  219e44:	09 f9                	or     ecx,edi
        ix1 <<= @intCast(u5, i);
  219e46:	c4 e2 69 f7 c0       	shlx   eax,eax,edx
  219e4b:	89 cf                	mov    edi,ecx
    }

    // unbias exponent
    m -= 1023;
  219e4d:	41 81 c0 01 fc ff ff 	add    r8d,0xfffffc01
    ix0 = (ix0 & 0x000FFFFF) | 0x00100000;
  219e54:	81 e7 ff ff 0f 00    	and    edi,0xfffff
  219e5a:	81 cf 00 00 10 00    	or     edi,0x100000
    if (m & 1 != 0) {
  219e60:	41 f6 c0 01          	test   r8b,0x1
  219e64:	74 06                	je     219e6c <sqrt+0xbc>
        ix0 += ix0 + (ix1 >> 31);
  219e66:	0f a4 c7 01          	shld   edi,eax,0x1
        ix1 = ix1 +% ix1;
  219e6a:	01 c0                	add    eax,eax
    }
    m >>= 1;

    // sqrt(x) bit by bit
    ix0 += ix0 + (ix1 >> 31);
  219e6c:	0f a4 c7 01          	shld   edi,eax,0x1
    var t: u32 = undefined;
    var t1: u32 = undefined;

    while (r != 0) {
        t = s0 +% r;
        if (t <= ix0) {
  219e70:	31 f6                	xor    esi,esi
  219e72:	81 ff ff ff 1f 00    	cmp    edi,0x1fffff
  219e78:	40 0f 97 c6          	seta   sil
  219e7c:	41 89 f1             	mov    r9d,esi
  219e7f:	41 c1 e1 15          	shl    r9d,0x15
  219e83:	c1 e6 16             	shl    esi,0x16
            s0 = t + r;
            ix0 -= t;
            q += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219e86:	8d 0c 3f             	lea    ecx,[rdi+rdi*1]
        if (t <= ix0) {
  219e89:	81 ff 00 00 20 00    	cmp    edi,0x200000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219e8f:	8d bc 3f 00 00 c0 ff 	lea    edi,[rdi+rdi*1-0x400000]
  219e96:	0f 42 f9             	cmovb  edi,ecx
  219e99:	b9 1e 01 00 00       	mov    ecx,0x11e
  219e9e:	c4 e2 70 f7 d0       	bextr  edx,eax,ecx
  219ea3:	09 fa                	or     edx,edi
        t = s0 +% r;
  219ea5:	8d be 00 00 10 00    	lea    edi,[rsi+0x100000]
        if (t <= ix0) {
  219eab:	89 d1                	mov    ecx,edx
  219ead:	29 f9                	sub    ecx,edi
  219eaf:	73 0d                	jae    219ebe <sqrt+0x10e>
  219eb1:	89 d1                	mov    ecx,edx
  219eb3:	eb 18                	jmp    219ecd <sqrt+0x11d>
  219eb5:	c5 fb 10 05 b3 6d fe 	vmovsd xmm0,QWORD PTR [rip+0xfffffffffffe6db3]        # 200c70 <app_mask+0x38>
  219ebc:	ff 
        return x;
  219ebd:	c3                   	ret    
            s0 = t + r;
  219ebe:	81 c7 00 00 10 00    	add    edi,0x100000
            q += r;
  219ec4:	41 81 c9 00 00 10 00 	or     r9d,0x100000
  219ecb:	89 fe                	mov    esi,edi
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219ecd:	ba 1d 01 00 00       	mov    edx,0x11d
  219ed2:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219ed7:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219eda:	8d be 00 00 08 00    	lea    edi,[rsi+0x80000]
        if (t <= ix0) {
  219ee0:	89 d1                	mov    ecx,edx
  219ee2:	29 f9                	sub    ecx,edi
  219ee4:	73 04                	jae    219eea <sqrt+0x13a>
  219ee6:	89 d1                	mov    ecx,edx
  219ee8:	eb 0d                	jmp    219ef7 <sqrt+0x147>
            s0 = t + r;
  219eea:	81 c6 00 00 10 00    	add    esi,0x100000
            q += r;
  219ef0:	41 81 c1 00 00 08 00 	add    r9d,0x80000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219ef7:	ba 1c 01 00 00       	mov    edx,0x11c
  219efc:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219f01:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219f04:	8d be 00 00 04 00    	lea    edi,[rsi+0x40000]
        if (t <= ix0) {
  219f0a:	89 d1                	mov    ecx,edx
  219f0c:	29 f9                	sub    ecx,edi
  219f0e:	73 04                	jae    219f14 <sqrt+0x164>
  219f10:	89 d1                	mov    ecx,edx
  219f12:	eb 0d                	jmp    219f21 <sqrt+0x171>
            s0 = t + r;
  219f14:	81 c6 00 00 08 00    	add    esi,0x80000
            q += r;
  219f1a:	41 81 c1 00 00 04 00 	add    r9d,0x40000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219f21:	ba 1b 01 00 00       	mov    edx,0x11b
  219f26:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219f2b:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219f2e:	8d be 00 00 02 00    	lea    edi,[rsi+0x20000]
        if (t <= ix0) {
  219f34:	89 d1                	mov    ecx,edx
  219f36:	29 f9                	sub    ecx,edi
  219f38:	73 04                	jae    219f3e <sqrt+0x18e>
  219f3a:	89 d1                	mov    ecx,edx
  219f3c:	eb 0d                	jmp    219f4b <sqrt+0x19b>
            s0 = t + r;
  219f3e:	81 c6 00 00 04 00    	add    esi,0x40000
            q += r;
  219f44:	41 81 c1 00 00 02 00 	add    r9d,0x20000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219f4b:	ba 1a 01 00 00       	mov    edx,0x11a
  219f50:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219f55:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219f58:	8d be 00 00 01 00    	lea    edi,[rsi+0x10000]
        if (t <= ix0) {
  219f5e:	89 d1                	mov    ecx,edx
  219f60:	29 f9                	sub    ecx,edi
  219f62:	73 04                	jae    219f68 <sqrt+0x1b8>
  219f64:	89 d1                	mov    ecx,edx
  219f66:	eb 0d                	jmp    219f75 <sqrt+0x1c5>
            s0 = t + r;
  219f68:	81 c6 00 00 02 00    	add    esi,0x20000
            q += r;
  219f6e:	41 81 c1 00 00 01 00 	add    r9d,0x10000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219f75:	ba 19 01 00 00       	mov    edx,0x119
  219f7a:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219f7f:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219f82:	8d be 00 80 00 00    	lea    edi,[rsi+0x8000]
        if (t <= ix0) {
  219f88:	89 d1                	mov    ecx,edx
  219f8a:	29 f9                	sub    ecx,edi
  219f8c:	73 04                	jae    219f92 <sqrt+0x1e2>
  219f8e:	89 d1                	mov    ecx,edx
  219f90:	eb 0d                	jmp    219f9f <sqrt+0x1ef>
            s0 = t + r;
  219f92:	81 c6 00 00 01 00    	add    esi,0x10000
            q += r;
  219f98:	41 81 c1 00 80 00 00 	add    r9d,0x8000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219f9f:	ba 18 01 00 00       	mov    edx,0x118
  219fa4:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219fa9:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219fac:	8d be 00 40 00 00    	lea    edi,[rsi+0x4000]
        if (t <= ix0) {
  219fb2:	89 d1                	mov    ecx,edx
  219fb4:	29 f9                	sub    ecx,edi
  219fb6:	73 04                	jae    219fbc <sqrt+0x20c>
  219fb8:	89 d1                	mov    ecx,edx
  219fba:	eb 0d                	jmp    219fc9 <sqrt+0x219>
            s0 = t + r;
  219fbc:	81 c6 00 80 00 00    	add    esi,0x8000
            q += r;
  219fc2:	41 81 c1 00 40 00 00 	add    r9d,0x4000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219fc9:	ba 17 01 00 00       	mov    edx,0x117
  219fce:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219fd3:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  219fd6:	8d be 00 20 00 00    	lea    edi,[rsi+0x2000]
        if (t <= ix0) {
  219fdc:	89 d1                	mov    ecx,edx
  219fde:	29 f9                	sub    ecx,edi
  219fe0:	73 04                	jae    219fe6 <sqrt+0x236>
  219fe2:	89 d1                	mov    ecx,edx
  219fe4:	eb 0d                	jmp    219ff3 <sqrt+0x243>
            s0 = t + r;
  219fe6:	81 c6 00 40 00 00    	add    esi,0x4000
            q += r;
  219fec:	41 81 c1 00 20 00 00 	add    r9d,0x2000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  219ff3:	ba 16 01 00 00       	mov    edx,0x116
  219ff8:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  219ffd:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a000:	8d be 00 10 00 00    	lea    edi,[rsi+0x1000]
        if (t <= ix0) {
  21a006:	89 d1                	mov    ecx,edx
  21a008:	29 f9                	sub    ecx,edi
  21a00a:	73 04                	jae    21a010 <sqrt+0x260>
  21a00c:	89 d1                	mov    ecx,edx
  21a00e:	eb 0d                	jmp    21a01d <sqrt+0x26d>
            s0 = t + r;
  21a010:	81 c6 00 20 00 00    	add    esi,0x2000
            q += r;
  21a016:	41 81 c1 00 10 00 00 	add    r9d,0x1000
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a01d:	ba 15 01 00 00       	mov    edx,0x115
  21a022:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a027:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a02a:	8d be 00 08 00 00    	lea    edi,[rsi+0x800]
        if (t <= ix0) {
  21a030:	89 d1                	mov    ecx,edx
  21a032:	29 f9                	sub    ecx,edi
  21a034:	73 04                	jae    21a03a <sqrt+0x28a>
  21a036:	89 d1                	mov    ecx,edx
  21a038:	eb 0d                	jmp    21a047 <sqrt+0x297>
            s0 = t + r;
  21a03a:	81 c6 00 10 00 00    	add    esi,0x1000
            q += r;
  21a040:	41 81 c1 00 08 00 00 	add    r9d,0x800
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a047:	ba 14 01 00 00       	mov    edx,0x114
  21a04c:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a051:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a054:	8d be 00 04 00 00    	lea    edi,[rsi+0x400]
        if (t <= ix0) {
  21a05a:	89 d1                	mov    ecx,edx
  21a05c:	29 f9                	sub    ecx,edi
  21a05e:	73 04                	jae    21a064 <sqrt+0x2b4>
  21a060:	89 d1                	mov    ecx,edx
  21a062:	eb 0d                	jmp    21a071 <sqrt+0x2c1>
            s0 = t + r;
  21a064:	81 c6 00 08 00 00    	add    esi,0x800
            q += r;
  21a06a:	41 81 c1 00 04 00 00 	add    r9d,0x400
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a071:	ba 13 01 00 00       	mov    edx,0x113
  21a076:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a07b:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a07e:	8d be 00 02 00 00    	lea    edi,[rsi+0x200]
        if (t <= ix0) {
  21a084:	89 d1                	mov    ecx,edx
  21a086:	29 f9                	sub    ecx,edi
  21a088:	73 04                	jae    21a08e <sqrt+0x2de>
  21a08a:	89 d1                	mov    ecx,edx
  21a08c:	eb 0d                	jmp    21a09b <sqrt+0x2eb>
            s0 = t + r;
  21a08e:	81 c6 00 04 00 00    	add    esi,0x400
            q += r;
  21a094:	41 81 c1 00 02 00 00 	add    r9d,0x200
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a09b:	ba 12 01 00 00       	mov    edx,0x112
  21a0a0:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a0a5:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a0a8:	8d be 00 01 00 00    	lea    edi,[rsi+0x100]
        if (t <= ix0) {
  21a0ae:	89 d1                	mov    ecx,edx
  21a0b0:	29 f9                	sub    ecx,edi
  21a0b2:	73 04                	jae    21a0b8 <sqrt+0x308>
  21a0b4:	89 d1                	mov    ecx,edx
  21a0b6:	eb 0d                	jmp    21a0c5 <sqrt+0x315>
            s0 = t + r;
  21a0b8:	81 c6 00 02 00 00    	add    esi,0x200
            q += r;
  21a0be:	41 81 c1 00 01 00 00 	add    r9d,0x100
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a0c5:	ba 11 01 00 00       	mov    edx,0x111
  21a0ca:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a0cf:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a0d2:	89 f7                	mov    edi,esi
  21a0d4:	83 ef 80             	sub    edi,0xffffff80
        if (t <= ix0) {
  21a0d7:	89 d1                	mov    ecx,edx
  21a0d9:	29 f9                	sub    ecx,edi
  21a0db:	73 04                	jae    21a0e1 <sqrt+0x331>
  21a0dd:	89 d1                	mov    ecx,edx
  21a0df:	eb 0a                	jmp    21a0eb <sqrt+0x33b>
            s0 = t + r;
  21a0e1:	81 c6 00 01 00 00    	add    esi,0x100
            q += r;
  21a0e7:	41 83 e9 80          	sub    r9d,0xffffff80
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a0eb:	ba 10 01 00 00       	mov    edx,0x110
  21a0f0:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a0f5:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a0f8:	8d 7e 40             	lea    edi,[rsi+0x40]
        if (t <= ix0) {
  21a0fb:	89 d1                	mov    ecx,edx
  21a0fd:	29 f9                	sub    ecx,edi
  21a0ff:	73 04                	jae    21a105 <sqrt+0x355>
  21a101:	89 d1                	mov    ecx,edx
  21a103:	eb 07                	jmp    21a10c <sqrt+0x35c>
            s0 = t + r;
  21a105:	83 ee 80             	sub    esi,0xffffff80
            q += r;
  21a108:	41 83 c1 40          	add    r9d,0x40
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a10c:	ba 0f 01 00 00       	mov    edx,0x10f
  21a111:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a116:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a119:	8d 7e 20             	lea    edi,[rsi+0x20]
        if (t <= ix0) {
  21a11c:	89 d1                	mov    ecx,edx
  21a11e:	29 f9                	sub    ecx,edi
  21a120:	73 04                	jae    21a126 <sqrt+0x376>
  21a122:	89 d1                	mov    ecx,edx
  21a124:	eb 07                	jmp    21a12d <sqrt+0x37d>
            s0 = t + r;
  21a126:	83 c6 40             	add    esi,0x40
            q += r;
  21a129:	41 83 c1 20          	add    r9d,0x20
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a12d:	ba 0e 01 00 00       	mov    edx,0x10e
  21a132:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a137:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a13a:	8d 7e 10             	lea    edi,[rsi+0x10]
        if (t <= ix0) {
  21a13d:	89 d1                	mov    ecx,edx
  21a13f:	29 f9                	sub    ecx,edi
  21a141:	73 04                	jae    21a147 <sqrt+0x397>
  21a143:	89 d1                	mov    ecx,edx
  21a145:	eb 07                	jmp    21a14e <sqrt+0x39e>
            s0 = t + r;
  21a147:	83 c6 20             	add    esi,0x20
            q += r;
  21a14a:	41 83 c1 10          	add    r9d,0x10
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a14e:	ba 0d 01 00 00       	mov    edx,0x10d
  21a153:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a158:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a15b:	8d 7e 08             	lea    edi,[rsi+0x8]
        if (t <= ix0) {
  21a15e:	89 d1                	mov    ecx,edx
  21a160:	29 f9                	sub    ecx,edi
  21a162:	73 04                	jae    21a168 <sqrt+0x3b8>
  21a164:	89 d1                	mov    ecx,edx
  21a166:	eb 07                	jmp    21a16f <sqrt+0x3bf>
            s0 = t + r;
  21a168:	83 c6 10             	add    esi,0x10
            q += r;
  21a16b:	41 83 c1 08          	add    r9d,0x8
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a16f:	ba 0c 01 00 00       	mov    edx,0x10c
  21a174:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a179:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a17c:	8d 7e 04             	lea    edi,[rsi+0x4]
        if (t <= ix0) {
  21a17f:	89 d1                	mov    ecx,edx
  21a181:	29 f9                	sub    ecx,edi
  21a183:	73 04                	jae    21a189 <sqrt+0x3d9>
  21a185:	89 d1                	mov    ecx,edx
  21a187:	eb 07                	jmp    21a190 <sqrt+0x3e0>
            s0 = t + r;
  21a189:	83 c6 08             	add    esi,0x8
            q += r;
  21a18c:	41 83 c1 04          	add    r9d,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a190:	ba 0b 01 00 00       	mov    edx,0x10b
  21a195:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a19a:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a19d:	8d 7e 02             	lea    edi,[rsi+0x2]
        if (t <= ix0) {
  21a1a0:	89 d1                	mov    ecx,edx
  21a1a2:	29 f9                	sub    ecx,edi
  21a1a4:	73 04                	jae    21a1aa <sqrt+0x3fa>
  21a1a6:	89 d1                	mov    ecx,edx
  21a1a8:	eb 07                	jmp    21a1b1 <sqrt+0x401>
            s0 = t + r;
  21a1aa:	83 c6 04             	add    esi,0x4
            q += r;
  21a1ad:	41 83 c1 02          	add    r9d,0x2
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a1b1:	ba 0a 01 00 00       	mov    edx,0x10a
  21a1b6:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a1bb:	8d 14 4a             	lea    edx,[rdx+rcx*2]
        t = s0 +% r;
  21a1be:	8d 7e 01             	lea    edi,[rsi+0x1]
        if (t <= ix0) {
  21a1c1:	89 d1                	mov    ecx,edx
  21a1c3:	29 f9                	sub    ecx,edi
  21a1c5:	73 04                	jae    21a1cb <sqrt+0x41b>
  21a1c7:	89 d1                	mov    ecx,edx
  21a1c9:	eb 07                	jmp    21a1d2 <sqrt+0x422>
            s0 = t + r;
  21a1cb:	83 c6 02             	add    esi,0x2
            q += r;
  21a1ce:	41 83 c1 01          	add    r9d,0x1
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a1d2:	55                   	push   rbp
  21a1d3:	41 56                	push   r14
  21a1d5:	53                   	push   rbx
  21a1d6:	ba 09 01 00 00       	mov    edx,0x109
  21a1db:	c4 e2 68 f7 d0       	bextr  edx,eax,edx
  21a1e0:	c1 e0 17             	shl    eax,0x17
  21a1e3:	8d 1c 4a             	lea    ebx,[rdx+rcx*2]
    m >>= 1;
  21a1e6:	41 d1 e8             	shr    r8d,1
  21a1e9:	31 d2                	xor    edx,edx
  21a1eb:	bf 00 00 00 80       	mov    edi,0x80000000
  21a1f0:	41 ba 1e 01 00 00    	mov    r10d,0x11e
  21a1f6:	41 bb 1d 01 00 00    	mov    r11d,0x11d
  21a1fc:	41 be 1c 01 00 00    	mov    r14d,0x11c
  21a202:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a209:	1f 84 00 00 00 00 00 

    r = sign;
    while (r != 0) {
        t = s1 +% r;
        t = s0;
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a210:	89 fd                	mov    ebp,edi
  21a212:	89 f1                	mov    ecx,esi
  21a214:	39 f3                	cmp    ebx,esi
  21a216:	73 04                	jae    21a21c <sqrt+0x46c>
  21a218:	31 ed                	xor    ebp,ebp
  21a21a:	31 c9                	xor    ecx,ecx
  21a21c:	01 d5                	add    ebp,edx
  21a21e:	29 cb                	sub    ebx,ecx
                ix0 -= 1;
            }
            ix1 = ix1 -% t1;
            q1 += r;
        }
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a220:	0f a4 c3 01          	shld   ebx,eax,0x1
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a224:	39 f3                	cmp    ebx,esi
  21a226:	73 08                	jae    21a230 <sqrt+0x480>
  21a228:	31 d2                	xor    edx,edx
  21a22a:	31 c9                	xor    ecx,ecx
  21a22c:	eb 08                	jmp    21a236 <sqrt+0x486>
  21a22e:	66 90                	xchg   ax,ax
  21a230:	89 fa                	mov    edx,edi
  21a232:	d1 ea                	shr    edx,1
  21a234:	89 f1                	mov    ecx,esi
  21a236:	01 ea                	add    edx,ebp
  21a238:	29 cb                	sub    ebx,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a23a:	c4 e2 28 f7 c8       	bextr  ecx,eax,r10d
  21a23f:	8d 2c 59             	lea    ebp,[rcx+rbx*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a242:	39 f5                	cmp    ebp,esi
  21a244:	73 0a                	jae    21a250 <sqrt+0x4a0>
  21a246:	31 db                	xor    ebx,ebx
  21a248:	31 c9                	xor    ecx,ecx
  21a24a:	eb 0b                	jmp    21a257 <sqrt+0x4a7>
  21a24c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  21a250:	89 fb                	mov    ebx,edi
  21a252:	c1 eb 02             	shr    ebx,0x2
  21a255:	89 f1                	mov    ecx,esi
  21a257:	01 d3                	add    ebx,edx
  21a259:	29 cd                	sub    ebp,ecx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a25b:	c4 e2 20 f7 c8       	bextr  ecx,eax,r11d
  21a260:	8d 2c 69             	lea    ebp,[rcx+rbp*2]
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a263:	39 f5                	cmp    ebp,esi
  21a265:	73 09                	jae    21a270 <sqrt+0x4c0>
  21a267:	31 d2                	xor    edx,edx
  21a269:	31 c9                	xor    ecx,ecx
  21a26b:	eb 0a                	jmp    21a277 <sqrt+0x4c7>
  21a26d:	0f 1f 00             	nop    DWORD PTR [rax]
  21a270:	89 fa                	mov    edx,edi
  21a272:	c1 ea 03             	shr    edx,0x3
  21a275:	89 f1                	mov    ecx,esi
  21a277:	01 da                	add    edx,ebx
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a279:	c4 e2 08 f7 d8       	bextr  ebx,eax,r14d
        if (t < ix0 or (t == ix0 and t1 <= ix1)) {
  21a27e:	29 cd                	sub    ebp,ecx
  21a280:	c1 e0 04             	shl    eax,0x4
        ix0 = ix0 +% ix0 +% (ix1 >> 31);
  21a283:	8d 1c 6b             	lea    ebx,[rbx+rbp*2]
        ix1 = ix1 +% ix1;
        r >>= 1;
  21a286:	c1 ef 04             	shr    edi,0x4
    while (r != 0) {
  21a289:	75 85                	jne    21a210 <sqrt+0x460>
    }

    // rounding direction
    if (ix0 | ix1 != 0) {
  21a28b:	09 c3                	or     ebx,eax
  21a28d:	5b                   	pop    rbx
  21a28e:	41 5e                	pop    r14
  21a290:	5d                   	pop    rbp
  21a291:	74 16                	je     21a2a9 <sqrt+0x4f9>
        var z = 1.0 - tiny; // raise inexact
        if (z >= 1.0) {
            z = 1.0 + tiny;
            if (q1 == 0xFFFFFFFF) {
  21a293:	83 fa ff             	cmp    edx,0xffffffff
  21a296:	74 0b                	je     21a2a3 <sqrt+0x4f3>
                if (q1 == 0xFFFFFFFE) {
                    q += 1;
                }
                q1 += 2;
            } else {
                q1 += q1 & 1;
  21a298:	89 d0                	mov    eax,edx
  21a29a:	83 e0 01             	and    eax,0x1
  21a29d:	01 d0                	add    eax,edx
  21a29f:	89 c2                	mov    edx,eax
  21a2a1:	eb 06                	jmp    21a2a9 <sqrt+0x4f9>
                q += 1;
  21a2a3:	41 83 c1 01          	add    r9d,0x1
  21a2a7:	31 d2                	xor    edx,edx
            }
        }
    }

    ix0 = (q >> 1) + 0x3FE00000;
  21a2a9:	44 89 c8             	mov    eax,r9d
  21a2ac:	d1 e8                	shr    eax,1
    ix1 = q1 >> 1;
    if (q & 1 != 0) {
  21a2ae:	44 0f ac ca 01       	shrd   edx,r9d,0x1
    }

    // NOTE: musl here appears to rely on signed twos-complement wraparound. +% has the same
    // behaviour at least.
    var iix0 = @intCast(i32, ix0);
    iix0 = iix0 +% (m << 20);
  21a2b3:	41 c1 e0 14          	shl    r8d,0x14
  21a2b7:	41 8d 04 00          	lea    eax,[r8+rax*1]
  21a2bb:	05 00 00 e0 3f       	add    eax,0x3fe00000

    const uz = (@intCast(u64, iix0) << 32) | ix1;
  21a2c0:	48 c1 e0 20          	shl    rax,0x20
  21a2c4:	48 09 c2             	or     rdx,rax
    return @bitCast(f64, uz);
  21a2c7:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  21a2cc:	c3                   	ret    
  21a2cd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000021a2d0 <sqrtf>:
}

export fn sqrtf(x: f32) f32 {
    const tiny: f32 = 1.0e-30;
    const sign: i32 = @bitCast(i32, u32(0x80000000));
    var ix: i32 = @bitCast(i32, x);
  21a2d0:	c5 f9 7e c1          	vmovd  ecx,xmm0

    if ((ix & 0x7F800000) == 0x7F800000) {
  21a2d4:	b8 00 00 80 7f       	mov    eax,0x7f800000
  21a2d9:	c4 e2 70 f2 c0       	andn   eax,ecx,eax
  21a2de:	75 06                	jne    21a2e6 <sqrtf+0x16>
        return x * x + x; // sqrt(nan) = nan, sqrt(+inf) = +inf, sqrt(-inf) = snan
  21a2e0:	c4 e2 79 a9 c0       	vfmadd213ss xmm0,xmm0,xmm0
  21a2e5:	c3                   	ret    
    }

    // zero
    if (ix <= 0) {
  21a2e6:	85 c9                	test   ecx,ecx
  21a2e8:	7e 15                	jle    21a2ff <sqrtf+0x2f>
  21a2ea:	41 89 c8             	mov    r8d,ecx
  21a2ed:	41 c1 e8 17          	shr    r8d,0x17
        }
    }

    // normalize
    var m = ix >> 23;
    if (m == 0) {
  21a2f1:	75 48                	jne    21a33b <sqrtf+0x6b>
  21a2f3:	31 d2                	xor    edx,edx
        // subnormal
        var i: i32 = 0;
        while (ix & 0x00800000 == 0) : (i += 1) {
  21a2f5:	0f ba e1 17          	bt     ecx,0x17
  21a2f9:	73 18                	jae    21a313 <sqrtf+0x43>
  21a2fb:	89 ce                	mov    esi,ecx
  21a2fd:	eb 31                	jmp    21a330 <sqrtf+0x60>
        if (ix & ~sign == 0) {
  21a2ff:	f7 c1 ff ff ff 7f    	test   ecx,0x7fffffff
  21a305:	0f 84 29 03 00 00    	je     21a634 <sqrtf+0x364>
        if (ix < 0) {
  21a30b:	85 c9                	test   ecx,ecx
  21a30d:	0f 88 19 03 00 00    	js     21a62c <sqrtf+0x35c>
  21a313:	31 d2                	xor    edx,edx
  21a315:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a31c:	00 00 00 00 
            ix <<= 1;
  21a320:	8d 34 09             	lea    esi,[rcx+rcx*1]
        while (ix & 0x00800000 == 0) : (i += 1) {
  21a323:	83 c2 01             	add    edx,0x1
  21a326:	f7 c1 00 00 40 00    	test   ecx,0x400000
  21a32c:	89 f1                	mov    ecx,esi
  21a32e:	74 f0                	je     21a320 <sqrtf+0x50>
        }
        m -= i - 1;
  21a330:	41 b8 01 00 00 00    	mov    r8d,0x1
  21a336:	41 29 d0             	sub    r8d,edx
  21a339:	89 f1                	mov    ecx,esi
    }

    m -= 127; // unbias exponent
  21a33b:	41 83 c0 81          	add    r8d,0xffffff81
    ix = (ix & 0x007FFFFF) | 0x00800000;
  21a33f:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  21a345:	81 c9 00 00 80 00    	or     ecx,0x800000

    if (m & 1 != 0) { // odd m, double x to even
  21a34b:	44 89 c0             	mov    eax,r8d
  21a34e:	24 01                	and    al,0x1
  21a350:	c4 e2 79 f7 c1       	shlx   eax,ecx,eax
  21a355:	8d 34 85 00 00 00 00 	lea    esi,[rax*4+0x0]
    var s: i32 = 0;
    var r: i32 = 0x01000000; // r = moving bit right -> left

    while (r != 0) {
        const t = s + r;
        if (t <= ix) {
  21a35c:	31 d2                	xor    edx,edx
  21a35e:	3d ff ff 7f 00       	cmp    eax,0x7fffff
  21a363:	0f 9f c2             	setg   dl
  21a366:	89 d1                	mov    ecx,edx
  21a368:	c1 e1 18             	shl    ecx,0x18
  21a36b:	c1 e2 19             	shl    edx,0x19
  21a36e:	3d 00 00 80 00       	cmp    eax,0x800000
  21a373:	8d 3c 85 00 00 00 fe 	lea    edi,[rax*4-0x2000000]
  21a37a:	0f 4c fe             	cmovl  edi,esi
        const t = s + r;
  21a37d:	8d 82 00 00 80 00    	lea    eax,[rdx+0x800000]
        if (t <= ix) {
  21a383:	89 fe                	mov    esi,edi
  21a385:	29 c6                	sub    esi,eax
  21a387:	7d 04                	jge    21a38d <sqrtf+0xbd>
  21a389:	89 fe                	mov    esi,edi
  21a38b:	eb 0d                	jmp    21a39a <sqrtf+0xca>
            s = t + r;
  21a38d:	05 00 00 80 00       	add    eax,0x800000
            ix -= t;
            q += r;
  21a392:	81 c9 00 00 80 00    	or     ecx,0x800000
  21a398:	89 c2                	mov    edx,eax
  21a39a:	01 f6                	add    esi,esi
        const t = s + r;
  21a39c:	8d 82 00 00 40 00    	lea    eax,[rdx+0x400000]
        if (t <= ix) {
  21a3a2:	89 f7                	mov    edi,esi
  21a3a4:	29 c7                	sub    edi,eax
  21a3a6:	7d 04                	jge    21a3ac <sqrtf+0xdc>
  21a3a8:	89 f7                	mov    edi,esi
  21a3aa:	eb 0c                	jmp    21a3b8 <sqrtf+0xe8>
            s = t + r;
  21a3ac:	81 c2 00 00 80 00    	add    edx,0x800000
            q += r;
  21a3b2:	81 c1 00 00 40 00    	add    ecx,0x400000
  21a3b8:	01 ff                	add    edi,edi
        const t = s + r;
  21a3ba:	8d 82 00 00 20 00    	lea    eax,[rdx+0x200000]
        if (t <= ix) {
  21a3c0:	89 fe                	mov    esi,edi
  21a3c2:	29 c6                	sub    esi,eax
  21a3c4:	7d 04                	jge    21a3ca <sqrtf+0xfa>
  21a3c6:	89 fe                	mov    esi,edi
  21a3c8:	eb 0c                	jmp    21a3d6 <sqrtf+0x106>
            s = t + r;
  21a3ca:	81 c2 00 00 40 00    	add    edx,0x400000
            q += r;
  21a3d0:	81 c1 00 00 20 00    	add    ecx,0x200000
  21a3d6:	01 f6                	add    esi,esi
        const t = s + r;
  21a3d8:	8d 82 00 00 10 00    	lea    eax,[rdx+0x100000]
        if (t <= ix) {
  21a3de:	89 f7                	mov    edi,esi
  21a3e0:	29 c7                	sub    edi,eax
  21a3e2:	7d 04                	jge    21a3e8 <sqrtf+0x118>
  21a3e4:	89 f7                	mov    edi,esi
  21a3e6:	eb 0c                	jmp    21a3f4 <sqrtf+0x124>
            s = t + r;
  21a3e8:	81 c2 00 00 20 00    	add    edx,0x200000
            q += r;
  21a3ee:	81 c1 00 00 10 00    	add    ecx,0x100000
  21a3f4:	01 ff                	add    edi,edi
        const t = s + r;
  21a3f6:	8d 82 00 00 08 00    	lea    eax,[rdx+0x80000]
        if (t <= ix) {
  21a3fc:	89 fe                	mov    esi,edi
  21a3fe:	29 c6                	sub    esi,eax
  21a400:	7d 04                	jge    21a406 <sqrtf+0x136>
  21a402:	89 fe                	mov    esi,edi
  21a404:	eb 0c                	jmp    21a412 <sqrtf+0x142>
            s = t + r;
  21a406:	81 c2 00 00 10 00    	add    edx,0x100000
            q += r;
  21a40c:	81 c1 00 00 08 00    	add    ecx,0x80000
  21a412:	01 f6                	add    esi,esi
        const t = s + r;
  21a414:	8d 82 00 00 04 00    	lea    eax,[rdx+0x40000]
        if (t <= ix) {
  21a41a:	89 f7                	mov    edi,esi
  21a41c:	29 c7                	sub    edi,eax
  21a41e:	7d 04                	jge    21a424 <sqrtf+0x154>
  21a420:	89 f7                	mov    edi,esi
  21a422:	eb 0c                	jmp    21a430 <sqrtf+0x160>
            s = t + r;
  21a424:	81 c2 00 00 08 00    	add    edx,0x80000
            q += r;
  21a42a:	81 c1 00 00 04 00    	add    ecx,0x40000
  21a430:	01 ff                	add    edi,edi
        const t = s + r;
  21a432:	8d 82 00 00 02 00    	lea    eax,[rdx+0x20000]
        if (t <= ix) {
  21a438:	89 fe                	mov    esi,edi
  21a43a:	29 c6                	sub    esi,eax
  21a43c:	7d 04                	jge    21a442 <sqrtf+0x172>
  21a43e:	89 fe                	mov    esi,edi
  21a440:	eb 0c                	jmp    21a44e <sqrtf+0x17e>
            s = t + r;
  21a442:	81 c2 00 00 04 00    	add    edx,0x40000
            q += r;
  21a448:	81 c1 00 00 02 00    	add    ecx,0x20000
  21a44e:	01 f6                	add    esi,esi
        const t = s + r;
  21a450:	8d 82 00 00 01 00    	lea    eax,[rdx+0x10000]
        if (t <= ix) {
  21a456:	89 f7                	mov    edi,esi
  21a458:	29 c7                	sub    edi,eax
  21a45a:	7d 04                	jge    21a460 <sqrtf+0x190>
  21a45c:	89 f7                	mov    edi,esi
  21a45e:	eb 0c                	jmp    21a46c <sqrtf+0x19c>
            s = t + r;
  21a460:	81 c2 00 00 02 00    	add    edx,0x20000
            q += r;
  21a466:	81 c1 00 00 01 00    	add    ecx,0x10000
  21a46c:	01 ff                	add    edi,edi
        const t = s + r;
  21a46e:	8d 82 00 80 00 00    	lea    eax,[rdx+0x8000]
        if (t <= ix) {
  21a474:	89 fe                	mov    esi,edi
  21a476:	29 c6                	sub    esi,eax
  21a478:	7d 04                	jge    21a47e <sqrtf+0x1ae>
  21a47a:	89 fe                	mov    esi,edi
  21a47c:	eb 0c                	jmp    21a48a <sqrtf+0x1ba>
            s = t + r;
  21a47e:	81 c2 00 00 01 00    	add    edx,0x10000
            q += r;
  21a484:	81 c1 00 80 00 00    	add    ecx,0x8000
  21a48a:	01 f6                	add    esi,esi
        const t = s + r;
  21a48c:	8d 82 00 40 00 00    	lea    eax,[rdx+0x4000]
        if (t <= ix) {
  21a492:	89 f7                	mov    edi,esi
  21a494:	29 c7                	sub    edi,eax
  21a496:	7d 04                	jge    21a49c <sqrtf+0x1cc>
  21a498:	89 f7                	mov    edi,esi
  21a49a:	eb 0c                	jmp    21a4a8 <sqrtf+0x1d8>
            s = t + r;
  21a49c:	81 c2 00 80 00 00    	add    edx,0x8000
            q += r;
  21a4a2:	81 c1 00 40 00 00    	add    ecx,0x4000
  21a4a8:	01 ff                	add    edi,edi
        const t = s + r;
  21a4aa:	8d 82 00 20 00 00    	lea    eax,[rdx+0x2000]
        if (t <= ix) {
  21a4b0:	89 fe                	mov    esi,edi
  21a4b2:	29 c6                	sub    esi,eax
  21a4b4:	7d 04                	jge    21a4ba <sqrtf+0x1ea>
  21a4b6:	89 fe                	mov    esi,edi
  21a4b8:	eb 0c                	jmp    21a4c6 <sqrtf+0x1f6>
            s = t + r;
  21a4ba:	81 c2 00 40 00 00    	add    edx,0x4000
            q += r;
  21a4c0:	81 c1 00 20 00 00    	add    ecx,0x2000
  21a4c6:	01 f6                	add    esi,esi
        const t = s + r;
  21a4c8:	8d 82 00 10 00 00    	lea    eax,[rdx+0x1000]
        if (t <= ix) {
  21a4ce:	89 f7                	mov    edi,esi
  21a4d0:	29 c7                	sub    edi,eax
  21a4d2:	7d 04                	jge    21a4d8 <sqrtf+0x208>
  21a4d4:	89 f7                	mov    edi,esi
  21a4d6:	eb 0c                	jmp    21a4e4 <sqrtf+0x214>
            s = t + r;
  21a4d8:	81 c2 00 20 00 00    	add    edx,0x2000
            q += r;
  21a4de:	81 c1 00 10 00 00    	add    ecx,0x1000
  21a4e4:	01 ff                	add    edi,edi
        const t = s + r;
  21a4e6:	8d 82 00 08 00 00    	lea    eax,[rdx+0x800]
        if (t <= ix) {
  21a4ec:	89 fe                	mov    esi,edi
  21a4ee:	29 c6                	sub    esi,eax
  21a4f0:	7d 04                	jge    21a4f6 <sqrtf+0x226>
  21a4f2:	89 fe                	mov    esi,edi
  21a4f4:	eb 0c                	jmp    21a502 <sqrtf+0x232>
            s = t + r;
  21a4f6:	81 c2 00 10 00 00    	add    edx,0x1000
            q += r;
  21a4fc:	81 c1 00 08 00 00    	add    ecx,0x800
  21a502:	01 f6                	add    esi,esi
        const t = s + r;
  21a504:	8d 82 00 04 00 00    	lea    eax,[rdx+0x400]
        if (t <= ix) {
  21a50a:	89 f7                	mov    edi,esi
  21a50c:	29 c7                	sub    edi,eax
  21a50e:	7d 04                	jge    21a514 <sqrtf+0x244>
  21a510:	89 f7                	mov    edi,esi
  21a512:	eb 0c                	jmp    21a520 <sqrtf+0x250>
            s = t + r;
  21a514:	81 c2 00 08 00 00    	add    edx,0x800
            q += r;
  21a51a:	81 c1 00 04 00 00    	add    ecx,0x400
  21a520:	01 ff                	add    edi,edi
        const t = s + r;
  21a522:	8d 82 00 02 00 00    	lea    eax,[rdx+0x200]
        if (t <= ix) {
  21a528:	89 fe                	mov    esi,edi
  21a52a:	29 c6                	sub    esi,eax
  21a52c:	7d 04                	jge    21a532 <sqrtf+0x262>
  21a52e:	89 fe                	mov    esi,edi
  21a530:	eb 0c                	jmp    21a53e <sqrtf+0x26e>
            s = t + r;
  21a532:	81 c2 00 04 00 00    	add    edx,0x400
            q += r;
  21a538:	81 c1 00 02 00 00    	add    ecx,0x200
  21a53e:	01 f6                	add    esi,esi
        const t = s + r;
  21a540:	8d 82 00 01 00 00    	lea    eax,[rdx+0x100]
        if (t <= ix) {
  21a546:	89 f7                	mov    edi,esi
  21a548:	29 c7                	sub    edi,eax
  21a54a:	7d 04                	jge    21a550 <sqrtf+0x280>
  21a54c:	89 f7                	mov    edi,esi
  21a54e:	eb 0c                	jmp    21a55c <sqrtf+0x28c>
            s = t + r;
  21a550:	81 c2 00 02 00 00    	add    edx,0x200
            q += r;
  21a556:	81 c1 00 01 00 00    	add    ecx,0x100
  21a55c:	01 ff                	add    edi,edi
        const t = s + r;
  21a55e:	89 d0                	mov    eax,edx
  21a560:	83 e8 80             	sub    eax,0xffffff80
        if (t <= ix) {
  21a563:	89 fe                	mov    esi,edi
  21a565:	29 c6                	sub    esi,eax
  21a567:	7d 04                	jge    21a56d <sqrtf+0x29d>
  21a569:	89 fe                	mov    esi,edi
  21a56b:	eb 09                	jmp    21a576 <sqrtf+0x2a6>
            s = t + r;
  21a56d:	81 c2 00 01 00 00    	add    edx,0x100
            q += r;
  21a573:	83 e9 80             	sub    ecx,0xffffff80
  21a576:	01 f6                	add    esi,esi
        const t = s + r;
  21a578:	8d 42 40             	lea    eax,[rdx+0x40]
        if (t <= ix) {
  21a57b:	89 f7                	mov    edi,esi
  21a57d:	29 c7                	sub    edi,eax
  21a57f:	7d 04                	jge    21a585 <sqrtf+0x2b5>
  21a581:	89 f7                	mov    edi,esi
  21a583:	eb 06                	jmp    21a58b <sqrtf+0x2bb>
            s = t + r;
  21a585:	83 ea 80             	sub    edx,0xffffff80
            q += r;
  21a588:	83 c1 40             	add    ecx,0x40
  21a58b:	01 ff                	add    edi,edi
        const t = s + r;
  21a58d:	8d 42 20             	lea    eax,[rdx+0x20]
        if (t <= ix) {
  21a590:	89 fe                	mov    esi,edi
  21a592:	29 c6                	sub    esi,eax
  21a594:	7d 04                	jge    21a59a <sqrtf+0x2ca>
  21a596:	89 fe                	mov    esi,edi
  21a598:	eb 06                	jmp    21a5a0 <sqrtf+0x2d0>
            s = t + r;
  21a59a:	83 c2 40             	add    edx,0x40
            q += r;
  21a59d:	83 c1 20             	add    ecx,0x20
  21a5a0:	01 f6                	add    esi,esi
        const t = s + r;
  21a5a2:	8d 42 10             	lea    eax,[rdx+0x10]
        if (t <= ix) {
  21a5a5:	89 f7                	mov    edi,esi
  21a5a7:	29 c7                	sub    edi,eax
  21a5a9:	7d 04                	jge    21a5af <sqrtf+0x2df>
  21a5ab:	89 f7                	mov    edi,esi
  21a5ad:	eb 06                	jmp    21a5b5 <sqrtf+0x2e5>
            s = t + r;
  21a5af:	83 c2 20             	add    edx,0x20
            q += r;
  21a5b2:	83 c1 10             	add    ecx,0x10
  21a5b5:	01 ff                	add    edi,edi
        const t = s + r;
  21a5b7:	8d 42 08             	lea    eax,[rdx+0x8]
        if (t <= ix) {
  21a5ba:	89 fe                	mov    esi,edi
  21a5bc:	29 c6                	sub    esi,eax
  21a5be:	7d 04                	jge    21a5c4 <sqrtf+0x2f4>
  21a5c0:	89 fe                	mov    esi,edi
  21a5c2:	eb 06                	jmp    21a5ca <sqrtf+0x2fa>
            s = t + r;
  21a5c4:	83 c2 10             	add    edx,0x10
            q += r;
  21a5c7:	83 c1 08             	add    ecx,0x8
  21a5ca:	01 f6                	add    esi,esi
        const t = s + r;
  21a5cc:	8d 42 04             	lea    eax,[rdx+0x4]
        if (t <= ix) {
  21a5cf:	89 f7                	mov    edi,esi
  21a5d1:	29 c7                	sub    edi,eax
  21a5d3:	7d 04                	jge    21a5d9 <sqrtf+0x309>
  21a5d5:	89 f7                	mov    edi,esi
  21a5d7:	eb 06                	jmp    21a5df <sqrtf+0x30f>
            s = t + r;
  21a5d9:	83 c2 08             	add    edx,0x8
            q += r;
  21a5dc:	83 c1 04             	add    ecx,0x4
  21a5df:	01 ff                	add    edi,edi
        const t = s + r;
  21a5e1:	8d 42 02             	lea    eax,[rdx+0x2]
        if (t <= ix) {
  21a5e4:	89 fe                	mov    esi,edi
  21a5e6:	29 c6                	sub    esi,eax
  21a5e8:	7d 0a                	jge    21a5f4 <sqrtf+0x324>
  21a5ea:	89 fe                	mov    esi,edi
  21a5ec:	01 f6                	add    esi,esi
  21a5ee:	39 d6                	cmp    esi,edx
  21a5f0:	7f 0e                	jg     21a600 <sqrtf+0x330>
  21a5f2:	eb 14                	jmp    21a608 <sqrtf+0x338>
            s = t + r;
  21a5f4:	83 c2 04             	add    edx,0x4
            q += r;
  21a5f7:	83 c1 02             	add    ecx,0x2
  21a5fa:	01 f6                	add    esi,esi
        if (t <= ix) {
  21a5fc:	39 d6                	cmp    esi,edx
  21a5fe:	7e 08                	jle    21a608 <sqrtf+0x338>
        const t = s + r;
  21a600:	83 c2 01             	add    edx,0x1
            ix -= t;
  21a603:	29 d6                	sub    esi,edx
            q += r;
  21a605:	83 c1 01             	add    ecx,0x1
    m >>= 1; // m = [m / 2]
  21a608:	41 83 e0 fe          	and    r8d,0xfffffffe
  21a60c:	41 c1 e0 16          	shl    r8d,0x16
        ix += ix;
        r >>= 1;
    }

    // floating add to find rounding direction
    if (ix != 0) {
  21a610:	85 f6                	test   esi,esi
  21a612:	0f 95 c0             	setne  al
  21a615:	20 c8                	and    al,cl
  21a617:	0f b6 c0             	movzx  eax,al
  21a61a:	01 c8                	add    eax,ecx
                }
            }
        }
    }

    ix = (q >> 1) + 0x3f000000;
  21a61c:	d1 f8                	sar    eax,1
    ix += m << 23;
  21a61e:	41 8d 04 00          	lea    eax,[r8+rax*1]
  21a622:	05 00 00 00 3f       	add    eax,0x3f000000
    return @bitCast(f32, ix);
  21a627:	c5 f9 6e c0          	vmovd  xmm0,eax
  21a62b:	c3                   	ret    
  21a62c:	c5 f9 6e 05 a8 d1 fe 	vmovd  xmm0,DWORD PTR [rip+0xfffffffffffed1a8]        # 2077dc <__unnamed_605+0x12>
  21a633:	ff 
            return x; // sqrt (+-0) = +-0
  21a634:	c3                   	ret    
  21a635:	cc                   	int3   
  21a636:	cc                   	int3   
  21a637:	cc                   	int3   
  21a638:	cc                   	int3   
  21a639:	cc                   	int3   
  21a63a:	cc                   	int3   
  21a63b:	cc                   	int3   
  21a63c:	cc                   	int3   
  21a63d:	cc                   	int3   
  21a63e:	cc                   	int3   
  21a63f:	cc                   	int3   

000000000021a640 <__udivmoddi4>:
const udivmod = @import("udivmod.zig").udivmod;
const builtin = @import("builtin");

pub extern fn __udivmoddi4(a: u64, b: u64, maybe_rem: ?*u64) u64 {
  21a640:	55                   	push   rbp
  21a641:	41 57                	push   r15
  21a643:	41 56                	push   r14
  21a645:	41 54                	push   r12
  21a647:	53                   	push   rbx
  21a648:	49 89 d0             	mov    r8,rdx
  21a64b:	49 89 fa             	mov    r10,rdi
  21a64e:	4c 89 d3             	mov    rbx,r10
  21a651:	48 c1 eb 20          	shr    rbx,0x20
  21a655:	48 89 f1             	mov    rcx,rsi
  21a658:	48 c1 e9 20          	shr    rcx,0x20
    const d = @ptrCast(*const [2]SingleInt, &b).*; // TODO issue #421
    var q: [2]SingleInt = undefined;
    var r: [2]SingleInt = undefined;
    var sr: c_uint = undefined;
    // special cases, X is unknown, K != 0
    if (n[high] == 0) {
  21a65c:	85 db                	test   ebx,ebx
  21a65e:	74 2f                	je     21a68f <__udivmoddi4+0x4f>
            rem.* = n[low];
        }
        return 0;
    }
    // n[high] != 0
    if (d[low] == 0) {
  21a660:	85 f6                	test   esi,esi
  21a662:	74 46                	je     21a6aa <__udivmoddi4+0x6a>
  21a664:	85 c9                	test   ecx,ecx
        // r.all = a >> sr;
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
    } else {
        // d[low] != 0
        if (d[high] == 0) {
  21a666:	74 78                	je     21a6e0 <__udivmoddi4+0xa0>
            }
        } else {
            // K X
            // ---
            // K K
            sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  21a668:	f3 0f bd e9          	lzcnt  ebp,ecx
  21a66c:	f3 0f bd c3          	lzcnt  eax,ebx
  21a670:	29 c5                	sub    ebp,eax
            // 0 <= sr <= SingleInt.bit_count - 1 or sr large
            if (sr > SingleInt.bit_count - 1) {
  21a672:	83 fd 20             	cmp    ebp,0x20
  21a675:	0f 82 b3 00 00 00    	jb     21a72e <__udivmoddi4+0xee>
                if (maybe_rem) |rem| {
  21a67b:	4d 85 c0             	test   r8,r8
  21a67e:	0f 84 d5 00 00 00    	je     21a759 <__udivmoddi4+0x119>
  21a684:	4d 89 10             	mov    QWORD PTR [r8],r10
  21a687:	45 31 d2             	xor    r10d,r10d
  21a68a:	e9 06 03 00 00       	jmp    21a995 <__udivmoddi4+0x355>
        if (d[high] == 0) {
  21a68f:	85 c9                	test   ecx,ecx
  21a691:	74 7d                	je     21a710 <__udivmoddi4+0xd0>
  21a693:	4d 85 c0             	test   r8,r8
        if (maybe_rem) |rem| {
  21a696:	0f 84 bd 00 00 00    	je     21a759 <__udivmoddi4+0x119>
            rem.* = n[low];
  21a69c:	44 89 d0             	mov    eax,r10d
  21a69f:	49 89 00             	mov    QWORD PTR [r8],rax
  21a6a2:	45 31 d2             	xor    r10d,r10d
  21a6a5:	e9 eb 02 00 00       	jmp    21a995 <__udivmoddi4+0x355>
  21a6aa:	85 c9                	test   ecx,ecx
        if (d[high] == 0) {
  21a6ac:	0f 84 93 00 00 00    	je     21a745 <__udivmoddi4+0x105>
        if (n[low] == 0) {
  21a6b2:	45 85 d2             	test   r10d,r10d
  21a6b5:	0f 84 d2 00 00 00    	je     21a78d <__udivmoddi4+0x14d>
        if ((d[high] & (d[high] - 1)) == 0) {
  21a6bb:	8d 41 ff             	lea    eax,[rcx-0x1]
  21a6be:	85 c8                	test   eax,ecx
  21a6c0:	0f 84 5d 01 00 00    	je     21a823 <__udivmoddi4+0x1e3>
        sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  21a6c6:	f3 0f bd c9          	lzcnt  ecx,ecx
  21a6ca:	f3 0f bd c3          	lzcnt  eax,ebx
  21a6ce:	29 c1                	sub    ecx,eax
        if (sr > SingleInt.bit_count - 2) {
  21a6d0:	83 f9 1f             	cmp    ecx,0x1f
  21a6d3:	0f 82 6c 01 00 00    	jb     21a845 <__udivmoddi4+0x205>
            if (maybe_rem) |rem| {
  21a6d9:	4d 85 c0             	test   r8,r8
  21a6dc:	75 a6                	jne    21a684 <__udivmoddi4+0x44>
  21a6de:	eb 79                	jmp    21a759 <__udivmoddi4+0x119>
            if ((d[low] & (d[low] - 1)) == 0) {
  21a6e0:	8d 46 ff             	lea    eax,[rsi-0x1]
  21a6e3:	85 f0                	test   eax,esi
  21a6e5:	0f 84 c2 00 00 00    	je     21a7ad <__udivmoddi4+0x16d>
            sr = 1 + SingleInt.bit_count + c_uint(@clz(d[low])) - c_uint(@clz(n[high]));
  21a6eb:	f3 0f bd ce          	lzcnt  ecx,esi
  21a6ef:	83 c1 21             	add    ecx,0x21
  21a6f2:	f3 0f bd c3          	lzcnt  eax,ebx
  21a6f6:	29 c1                	sub    ecx,eax
  21a6f8:	31 d2                	xor    edx,edx
            if (sr == SingleInt.bit_count) {
  21a6fa:	83 f9 20             	cmp    ecx,0x20
  21a6fd:	0f 85 e7 00 00 00    	jne    21a7ea <__udivmoddi4+0x1aa>
  21a703:	45 31 ff             	xor    r15d,r15d
  21a706:	b9 20 00 00 00       	mov    ecx,0x20
  21a70b:	e9 7c 01 00 00       	jmp    21a88c <__udivmoddi4+0x24c>
  21a710:	4d 85 c0             	test   r8,r8
            if (maybe_rem) |rem| {
  21a713:	74 0a                	je     21a71f <__udivmoddi4+0xdf>
                rem.* = n[low] % d[low];
  21a715:	31 d2                	xor    edx,edx
  21a717:	44 89 d0             	mov    eax,r10d
  21a71a:	f7 f6                	div    esi
  21a71c:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[low] / d[low];
  21a71f:	31 d2                	xor    edx,edx
  21a721:	44 89 d0             	mov    eax,r10d
  21a724:	f7 f6                	div    esi
  21a726:	41 89 c2             	mov    r10d,eax
  21a729:	e9 67 02 00 00       	jmp    21a995 <__udivmoddi4+0x355>
                    rem.* = a;
                }
                return 0;
            }
            sr += 1;
  21a72e:	8d 4d 01             	lea    ecx,[rbp+0x1]
  21a731:	45 31 ff             	xor    r15d,r15d
            // 1 <= sr <= SingleInt.bit_count
            // q.all = a << (DoubleInt.bit_count - sr);
            // r.all = a >> sr;
            q[low] = 0;
            if (sr == SingleInt.bit_count) {
  21a734:	83 f9 20             	cmp    ecx,0x20
  21a737:	75 28                	jne    21a761 <__udivmoddi4+0x121>
  21a739:	31 d2                	xor    edx,edx
  21a73b:	b9 20 00 00 00       	mov    ecx,0x20
  21a740:	e9 47 01 00 00       	jmp    21a88c <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  21a745:	4d 85 c0             	test   r8,r8
  21a748:	74 0f                	je     21a759 <__udivmoddi4+0x119>
                rem.* = n[high] % d[low];
  21a74a:	49 c7 00 00 00 00 00 	mov    QWORD PTR [r8],0x0
  21a751:	45 31 d2             	xor    r10d,r10d
  21a754:	e9 3c 02 00 00       	jmp    21a995 <__udivmoddi4+0x355>
  21a759:	45 31 d2             	xor    r10d,r10d
  21a75c:	e9 34 02 00 00       	jmp    21a995 <__udivmoddi4+0x355>
                q[high] = n[low];
                r[high] = 0;
                r[low] = n[high];
            } else {
                r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21a761:	41 89 c9             	mov    r9d,ecx
  21a764:	41 83 e1 1f          	and    r9d,0x1f
  21a768:	c4 e2 33 f7 d3       	shrx   edx,ebx,r9d
  21a76d:	b8 1f 00 00 00       	mov    eax,0x1f
                r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21a772:	29 e8                	sub    eax,ebp
  21a774:	83 e0 1f             	and    eax,0x1f
  21a777:	c4 e2 79 f7 eb       	shlx   ebp,ebx,eax
  21a77c:	c4 c2 33 f7 da       	shrx   ebx,r10d,r9d
  21a781:	09 eb                	or     ebx,ebp
                q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21a783:	c4 42 79 f7 d2       	shlx   r10d,r10d,eax
  21a788:	e9 ff 00 00 00       	jmp    21a88c <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  21a78d:	4d 85 c0             	test   r8,r8
  21a790:	74 0d                	je     21a79f <__udivmoddi4+0x15f>
                r[high] = n[high] % d[high];
  21a792:	31 d2                	xor    edx,edx
  21a794:	89 d8                	mov    eax,ebx
  21a796:	f7 f1                	div    ecx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21a798:	48 c1 e2 20          	shl    rdx,0x20
  21a79c:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[high] / d[high];
  21a79f:	31 d2                	xor    edx,edx
  21a7a1:	89 d8                	mov    eax,ebx
  21a7a3:	f7 f1                	div    ecx
  21a7a5:	41 89 c2             	mov    r10d,eax
  21a7a8:	e9 e8 01 00 00       	jmp    21a995 <__udivmoddi4+0x355>
                if (maybe_rem) |rem| {
  21a7ad:	4d 85 c0             	test   r8,r8
  21a7b0:	74 06                	je     21a7b8 <__udivmoddi4+0x178>
                    rem.* = n[low] & (d[low] - 1);
  21a7b2:	44 21 d0             	and    eax,r10d
  21a7b5:	49 89 00             	mov    QWORD PTR [r8],rax
                if (d[low] == 1) {
  21a7b8:	83 fe 01             	cmp    esi,0x1
  21a7bb:	0f 84 d4 01 00 00    	je     21a995 <__udivmoddi4+0x355>
                sr = @ctz(d[low]);
  21a7c1:	f3 0f bc c6          	tzcnt  eax,esi
                q[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21a7c5:	89 c1                	mov    ecx,eax
  21a7c7:	83 e1 1f             	and    ecx,0x1f
  21a7ca:	c4 e2 73 f7 d3       	shrx   edx,ebx,ecx
                q[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21a7cf:	f7 d8                	neg    eax
  21a7d1:	c4 e2 79 f7 c3       	shlx   eax,ebx,eax
  21a7d6:	c4 42 73 f7 d2       	shrx   r10d,r10d,ecx
  21a7db:	41 09 c2             	or     r10d,eax
                return @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*; // TODO issue #421
  21a7de:	48 c1 e2 20          	shl    rdx,0x20
  21a7e2:	49 09 d2             	or     r10,rdx
  21a7e5:	e9 ab 01 00 00       	jmp    21a995 <__udivmoddi4+0x355>
  21a7ea:	89 cd                	mov    ebp,ecx
  21a7ec:	f7 dd                	neg    ebp
  21a7ee:	83 e5 1f             	and    ebp,0x1f
  21a7f1:	c4 42 51 f7 fa       	shlx   r15d,r10d,ebp
            } else if (sr < SingleInt.bit_count) {
  21a7f6:	83 f9 20             	cmp    ecx,0x20
  21a7f9:	73 7a                	jae    21a875 <__udivmoddi4+0x235>
  21a7fb:	31 d2                	xor    edx,edx
    // q.all = a << (DoubleInt.bit_count - sr);
    // r.all = a >> sr;
    // 1 <= sr <= DoubleInt.bit_count - 1
    var carry: u32 = 0;
    var r_all: DoubleInt = undefined;
    while (sr > 0) : (sr -= 1) {
  21a7fd:	85 c9                	test   ecx,ecx
  21a7ff:	0f 84 9c 01 00 00    	je     21a9a1 <__udivmoddi4+0x361>
  21a805:	89 c8                	mov    eax,ecx
  21a807:	83 e0 1f             	and    eax,0x1f
  21a80a:	c4 e2 7b f7 d3       	shrx   edx,ebx,eax
  21a80f:	c4 e2 51 f7 eb       	shlx   ebp,ebx,ebp
  21a814:	c4 c2 7b f7 da       	shrx   ebx,r10d,eax
  21a819:	09 eb                	or     ebx,ebp
  21a81b:	45 89 fa             	mov    r10d,r15d
  21a81e:	45 31 ff             	xor    r15d,r15d
  21a821:	eb 69                	jmp    21a88c <__udivmoddi4+0x24c>
            if (maybe_rem) |rem| {
  21a823:	4d 85 c0             	test   r8,r8
  21a826:	74 0f                	je     21a837 <__udivmoddi4+0x1f7>
                r[high] = n[high] & (d[high] - 1);
  21a828:	21 d8                	and    eax,ebx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21a82a:	48 c1 e0 20          	shl    rax,0x20
  21a82e:	44 89 d2             	mov    edx,r10d
  21a831:	48 09 c2             	or     rdx,rax
  21a834:	49 89 10             	mov    QWORD PTR [r8],rdx
            return n[high] >> @intCast(Log2SingleInt, @ctz(d[high]));
  21a837:	f3 0f bc c1          	tzcnt  eax,ecx
  21a83b:	c4 62 7b f7 d3       	shrx   r10d,ebx,eax
  21a840:	e9 50 01 00 00       	jmp    21a995 <__udivmoddi4+0x355>
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21a845:	b8 1f 00 00 00       	mov    eax,0x1f
  21a84a:	29 c8                	sub    eax,ecx
        sr += 1;
  21a84c:	83 c1 01             	add    ecx,0x1
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21a84f:	83 e0 1f             	and    eax,0x1f
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21a852:	89 cd                	mov    ebp,ecx
  21a854:	83 e5 1f             	and    ebp,0x1f
  21a857:	c4 e2 53 f7 d3       	shrx   edx,ebx,ebp
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21a85c:	c4 e2 79 f7 fb       	shlx   edi,ebx,eax
  21a861:	c4 c2 53 f7 da       	shrx   ebx,r10d,ebp
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21a866:	c4 c2 79 f7 ea       	shlx   ebp,r10d,eax
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21a86b:	09 fb                	or     ebx,edi
  21a86d:	45 31 ff             	xor    r15d,r15d
  21a870:	41 89 ea             	mov    r10d,ebp
  21a873:	eb 17                	jmp    21a88c <__udivmoddi4+0x24c>
                q[high] = (n[high] << @intCast(Log2SingleInt, DoubleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count));
  21a875:	c4 e2 51 f7 eb       	shlx   ebp,ebx,ebp
  21a87a:	89 c8                	mov    eax,ecx
  21a87c:	83 e0 1f             	and    eax,0x1f
  21a87f:	c4 42 7b f7 d2       	shrx   r10d,r10d,eax
  21a884:	41 09 ea             	or     r10d,ebp
                r[low] = n[high] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count);
  21a887:	c4 e2 7b f7 db       	shrx   ebx,ebx,eax
  21a88c:	4c 8d 4e ff          	lea    r9,[rsi-0x1]
    while (sr > 0) : (sr -= 1) {
  21a890:	41 89 cb             	mov    r11d,ecx
  21a893:	41 83 e3 01          	and    r11d,0x1
  21a897:	83 f9 01             	cmp    ecx,0x1
  21a89a:	75 10                	jne    21a8ac <__udivmoddi4+0x26c>
  21a89c:	31 c9                	xor    ecx,ecx
  21a89e:	45 85 db             	test   r11d,r11d
  21a8a1:	0f 85 9e 00 00 00    	jne    21a945 <__udivmoddi4+0x305>
  21a8a7:	e9 c9 00 00 00       	jmp    21a975 <__udivmoddi4+0x335>
  21a8ac:	45 89 dc             	mov    r12d,r11d
  21a8af:	41 29 cc             	sub    r12d,ecx
  21a8b2:	31 c9                	xor    ecx,ecx
  21a8b4:	41 be 1e 01 00 00    	mov    r14d,0x11e
  21a8ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
        // r:q = ((r:q)  << 1) | carry
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21a8c0:	0f a4 da 01          	shld   edx,ebx,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21a8c4:	44 0f a4 d3 01       	shld   ebx,r10d,0x1
  21a8c9:	c4 c2 08 f7 ea       	bextr  ebp,r10d,r14d
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21a8ce:	45 0f a4 fa 01       	shld   r10d,r15d,0x1
        q[low] = (q[low] << 1) | carry;
  21a8d3:	43 8d 04 3f          	lea    eax,[r15+r15*1]
  21a8d7:	09 c8                	or     eax,ecx
        // if (r.all >= b)
        // {
        //     r.all -= b;
        //      carry = 1;
        // }
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21a8d9:	48 c1 e2 20          	shl    rdx,0x20
  21a8dd:	48 09 d3             	or     rbx,rdx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21a8e0:	4c 89 c9             	mov    rcx,r9
  21a8e3:	48 29 d9             	sub    rcx,rbx
  21a8e6:	48 c1 f9 3f          	sar    rcx,0x3f
        carry = @intCast(u32, s & 1);
  21a8ea:	89 ca                	mov    edx,ecx
  21a8ec:	83 e2 01             	and    edx,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  21a8ef:	48 21 f1             	and    rcx,rsi
  21a8f2:	48 29 cb             	sub    rbx,rcx
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21a8f5:	48 89 d9             	mov    rcx,rbx
  21a8f8:	48 c1 e9 1f          	shr    rcx,0x1f
  21a8fc:	83 e1 fe             	and    ecx,0xfffffffe
  21a8ff:	89 df                	mov    edi,ebx
  21a901:	c1 ef 1f             	shr    edi,0x1f
  21a904:	09 cf                	or     edi,ecx
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21a906:	c4 c2 08 f7 cf       	bextr  ecx,r15d,r14d
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21a90b:	8d 5c 5d 00          	lea    ebx,[rbp+rbx*2+0x0]
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21a90f:	46 8d 14 51          	lea    r10d,[rcx+r10*2]
        q[low] = (q[low] << 1) | carry;
  21a913:	44 8d 3c 42          	lea    r15d,[rdx+rax*2]
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21a917:	48 c1 e7 20          	shl    rdi,0x20
  21a91b:	48 09 fb             	or     rbx,rdi
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21a91e:	4c 89 c8             	mov    rax,r9
  21a921:	48 29 d8             	sub    rax,rbx
  21a924:	48 c1 f8 3f          	sar    rax,0x3f
        carry = @intCast(u32, s & 1);
  21a928:	89 c1                	mov    ecx,eax
  21a92a:	83 e1 01             	and    ecx,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  21a92d:	48 21 f0             	and    rax,rsi
  21a930:	48 29 c3             	sub    rbx,rax
        r = @ptrCast(*[2]SingleInt, &r_all).*; // TODO issue #421
  21a933:	48 89 da             	mov    rdx,rbx
  21a936:	48 c1 ea 20          	shr    rdx,0x20
    while (sr > 0) : (sr -= 1) {
  21a93a:	41 83 c4 02          	add    r12d,0x2
  21a93e:	75 80                	jne    21a8c0 <__udivmoddi4+0x280>
  21a940:	45 85 db             	test   r11d,r11d
  21a943:	74 30                	je     21a975 <__udivmoddi4+0x335>
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21a945:	0f a4 da 01          	shld   edx,ebx,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21a949:	44 0f a4 d3 01       	shld   ebx,r10d,0x1
        r_all = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21a94e:	48 c1 e2 20          	shl    rdx,0x20
  21a952:	48 09 d3             	or     rbx,rdx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21a955:	49 29 d9             	sub    r9,rbx
  21a958:	49 c1 f9 3f          	sar    r9,0x3f
        r_all -= b & @bitCast(DoubleInt, s);
  21a95c:	4c 21 ce             	and    rsi,r9
  21a95f:	48 29 f3             	sub    rbx,rsi
        carry = @intCast(u32, s & 1);
  21a962:	41 83 e1 01          	and    r9d,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21a966:	45 0f a4 fa 01       	shld   r10d,r15d,0x1
        q[low] = (q[low] << 1) | carry;
  21a96b:	42 8d 04 79          	lea    eax,[rcx+r15*2]
  21a96f:	41 89 c7             	mov    r15d,eax
  21a972:	44 89 c9             	mov    ecx,r9d
    }
    const q_all = ((@ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*) << 1) | carry; // TODO issue #421
  21a975:	89 ca                	mov    edx,ecx
  21a977:	44 89 f9             	mov    ecx,r15d
  21a97a:	45 89 d7             	mov    r15d,r10d
  21a97d:	49 c1 e7 20          	shl    r15,0x20
  21a981:	49 09 cf             	or     r15,rcx
  21a984:	4d 01 ff             	add    r15,r15
  21a987:	4d 89 fa             	mov    r10,r15
  21a98a:	49 09 d2             	or     r10,rdx
    if (maybe_rem) |rem| {
  21a98d:	4d 85 c0             	test   r8,r8
  21a990:	74 03                	je     21a995 <__udivmoddi4+0x355>
        rem.* = r_all;
  21a992:	49 89 18             	mov    QWORD PTR [r8],rbx
    @setRuntimeSafety(builtin.is_test);
    return udivmod(u64, a, b, maybe_rem);
  21a995:	4c 89 d0             	mov    rax,r10
  21a998:	5b                   	pop    rbx
  21a999:	41 5c                	pop    r12
  21a99b:	41 5e                	pop    r14
  21a99d:	41 5f                	pop    r15
  21a99f:	5d                   	pop    rbp
  21a9a0:	c3                   	ret    
  21a9a1:	31 c9                	xor    ecx,ecx
  21a9a3:	eb d8                	jmp    21a97d <__udivmoddi4+0x33d>
  21a9a5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21a9ac:	00 00 00 00 

000000000021a9b0 <__cmptf2>:
const is_test = builtin.is_test;

pub extern fn __letf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aInt = @bitCast(rep_t, a);
  21a9b0:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  21a9b6:	4c 8b 5c 24 e8       	mov    r11,QWORD PTR [rsp-0x18]
  21a9bb:	4c 8b 44 24 f0       	mov    r8,QWORD PTR [rsp-0x10]
    const bInt = @bitCast(rep_t, b);
  21a9c0:	66 0f 7f 4c 24 d8    	movdqa XMMWORD PTR [rsp-0x28],xmm1

    const aAbs: rep_t = aInt & absMask;
  21a9c6:	40 b6 3f             	mov    sil,0x3f
  21a9c9:	c4 c2 c8 f5 c8       	bzhi   rcx,r8,rsi
    const bAbs: rep_t = bInt & absMask;

    // If either a or b is NaN, they are unordered.
    if (aAbs > infRep or bAbs > infRep) return LE_UNORDERED;
  21a9ce:	4c 89 d8             	mov    rax,r11
  21a9d1:	48 f7 d8             	neg    rax
  21a9d4:	49 ba 00 00 00 00 00 	movabs r10,0x7fff000000000000
  21a9db:	00 ff 7f 
  21a9de:	4c 89 d0             	mov    rax,r10
  21a9e1:	48 19 c8             	sbb    rax,rcx
  21a9e4:	b8 01 00 00 00       	mov    eax,0x1
  21a9e9:	72 68                	jb     21aa53 <__cmptf2+0xa3>
  21a9eb:	48 8b 7c 24 d8       	mov    rdi,QWORD PTR [rsp-0x28]
  21a9f0:	4c 8b 4c 24 e0       	mov    r9,QWORD PTR [rsp-0x20]
  21a9f5:	c4 c2 c8 f5 d1       	bzhi   rdx,r9,rsi
  21a9fa:	48 83 ff 01          	cmp    rdi,0x1
  21a9fe:	48 89 d6             	mov    rsi,rdx
  21aa01:	4c 19 d6             	sbb    rsi,r10
  21aa04:	73 4d                	jae    21aa53 <__cmptf2+0xa3>

    // If a and b are both zeros, they are equal.
    if ((aAbs | bAbs) == 0) return LE_EQUAL;
  21aa06:	48 89 f8             	mov    rax,rdi
  21aa09:	4c 09 d8             	or     rax,r11
  21aa0c:	48 09 ca             	or     rdx,rcx
  21aa0f:	48 09 c2             	or     rdx,rax
  21aa12:	74 40                	je     21aa54 <__cmptf2+0xa4>
  21aa14:	b8 ff ff ff ff       	mov    eax,0xffffffff

    // If at least one of a and b is positive, we get the same result comparing
    // a and b as signed integers as we would with a floating-point compare.
    return if ((aInt & bInt) >= 0) if (aInt < bInt)
  21aa19:	49 39 fb             	cmp    r11,rdi
  21aa1c:	4c 89 c1             	mov    rcx,r8
  21aa1f:	4c 19 c9             	sbb    rcx,r9
  21aa22:	72 2f                	jb     21aa53 <__cmptf2+0xa3>
        LE_LESS
    else if (aInt == bInt)
  21aa24:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  21aa29:	c4 c1 f9 6e c9       	vmovq  xmm1,r9
  21aa2e:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  21aa32:	c4 c1 f9 6e cb       	vmovq  xmm1,r11
  21aa37:	c4 c1 f9 6e d0       	vmovq  xmm2,r8
  21aa3c:	c5 f1 6c ca          	vpunpcklqdq xmm1,xmm1,xmm2
  21aa40:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  21aa44:	c5 f9 d7 c8          	vpmovmskb ecx,xmm0
  21aa48:	31 c0                	xor    eax,eax
  21aa4a:	81 f9 ff ff 00 00    	cmp    ecx,0xffff
  21aa50:	0f 95 c0             	setne  al
    if (aAbs > infRep or bAbs > infRep) return LE_UNORDERED;
  21aa53:	c3                   	ret    
  21aa54:	31 c0                	xor    eax,eax
  21aa56:	c3                   	ret    
  21aa57:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21aa5e:	00 00 

000000000021aa60 <__gttf2>:
const GE_UNORDERED = c_int(-1); // Note: different from LE_UNORDERED

pub extern fn __getf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aInt = @bitCast(srep_t, a);
  21aa60:	53                   	push   rbx
  21aa61:	0f 29 44 24 f0       	movaps XMMWORD PTR [rsp-0x10],xmm0
  21aa66:	4c 8b 54 24 f0       	mov    r10,QWORD PTR [rsp-0x10]
  21aa6b:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
    const bInt = @bitCast(srep_t, b);
  21aa70:	0f 29 4c 24 e0       	movaps XMMWORD PTR [rsp-0x20],xmm1
    const aAbs = @bitCast(rep_t, aInt) & absMask;
  21aa75:	41 b1 3f             	mov    r9b,0x3f
  21aa78:	c4 c2 b0 f5 c8       	bzhi   rcx,r8,r9
    const bAbs = @bitCast(rep_t, bInt) & absMask;

    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  21aa7d:	4c 89 d0             	mov    rax,r10
  21aa80:	48 f7 d8             	neg    rax
  21aa83:	48 bb 00 00 00 00 00 	movabs rbx,0x7fff000000000000
  21aa8a:	00 ff 7f 
  21aa8d:	48 89 d8             	mov    rax,rbx
  21aa90:	48 19 c8             	sbb    rax,rcx
  21aa93:	b8 ff ff ff ff       	mov    eax,0xffffffff
  21aa98:	72 39                	jb     21aad3 <__gttf2+0x73>
  21aa9a:	48 8b 7c 24 e0       	mov    rdi,QWORD PTR [rsp-0x20]
  21aa9f:	4c 8b 5c 24 e8       	mov    r11,QWORD PTR [rsp-0x18]
  21aaa4:	c4 c2 b0 f5 f3       	bzhi   rsi,r11,r9
  21aaa9:	48 83 ff 01          	cmp    rdi,0x1
  21aaad:	48 89 f2             	mov    rdx,rsi
  21aab0:	48 19 da             	sbb    rdx,rbx
  21aab3:	73 1e                	jae    21aad3 <__gttf2+0x73>
    if ((aAbs | bAbs) == 0) return GE_EQUAL;
  21aab5:	48 89 fa             	mov    rdx,rdi
  21aab8:	4c 09 d2             	or     rdx,r10
  21aabb:	48 09 ce             	or     rsi,rcx
  21aabe:	48 09 d6             	or     rsi,rdx
  21aac1:	74 12                	je     21aad5 <__gttf2+0x75>
    return if ((aInt & bInt) >= 0) if (aInt < bInt)
  21aac3:	4d 85 c3             	test   r11,r8
  21aac6:	78 11                	js     21aad9 <__gttf2+0x79>
  21aac8:	49 39 fa             	cmp    r10,rdi
  21aacb:	4c 89 c1             	mov    rcx,r8
  21aace:	4c 19 d9             	sbb    rcx,r11
  21aad1:	7d 11                	jge    21aae4 <__gttf2+0x84>
    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  21aad3:	5b                   	pop    rbx
  21aad4:	c3                   	ret    
  21aad5:	31 c0                	xor    eax,eax
  21aad7:	5b                   	pop    rbx
  21aad8:	c3                   	ret    
        GE_LESS
    else if (aInt == bInt)
        GE_EQUAL
    else
        GE_GREATER else if (aInt > bInt)
  21aad9:	4c 39 d7             	cmp    rdi,r10
  21aadc:	4c 89 d9             	mov    rcx,r11
  21aadf:	4c 19 c1             	sbb    rcx,r8
  21aae2:	7c ef                	jl     21aad3 <__gttf2+0x73>
  21aae4:	c4 e1 f9 6e c7       	vmovq  xmm0,rdi
  21aae9:	c4 c1 f9 6e cb       	vmovq  xmm1,r11
  21aaee:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  21aaf2:	c4 c1 f9 6e ca       	vmovq  xmm1,r10
  21aaf7:	c4 c1 f9 6e d0       	vmovq  xmm2,r8
  21aafc:	c5 f1 6c ca          	vpunpcklqdq xmm1,xmm1,xmm2
  21ab00:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  21ab04:	c5 f9 d7 c8          	vpmovmskb ecx,xmm0
  21ab08:	31 c0                	xor    eax,eax
  21ab0a:	81 f9 ff ff 00 00    	cmp    ecx,0xffff
  21ab10:	0f 95 c0             	setne  al
    if (aAbs > infRep or bAbs > infRep) return GE_UNORDERED;
  21ab13:	5b                   	pop    rbx
  21ab14:	c3                   	ret    
  21ab15:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21ab1c:	00 00 00 00 

000000000021ab20 <__extendhfsf2>:

    const dstMinNormal: dst_rep_t = dst_rep_t(1) << dstSigBits;

    // Break a into a sign and representation of the absolute value
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21ab20:	89 f9                	mov    ecx,edi
  21ab22:	81 e1 ff 7f 00 00    	and    ecx,0x7fff
    const sign: src_rep_t = aRep & srcSignMask;
  21ab28:	89 f8                	mov    eax,edi
  21ab2a:	25 00 80 00 00       	and    eax,0x8000
    var absResult: dst_rep_t = undefined;

    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  21ab2f:	89 ca                	mov    edx,ecx
  21ab31:	81 c2 00 fc ff ff    	add    edx,0xfffffc00
  21ab37:	0f b7 d2             	movzx  edx,dx
  21ab3a:	81 fa ff 77 00 00    	cmp    edx,0x77ff
  21ab40:	77 16                	ja     21ab58 <__extendhfsf2+0x38>
        // a is a normal number.
        // Extend to the destination type by shifting the significand and
        // exponent into the proper position and rebiasing the exponent.
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  21ab42:	0f b7 c9             	movzx  ecx,cx
  21ab45:	c1 e1 0d             	shl    ecx,0xd
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  21ab48:	81 c1 00 00 00 38    	add    ecx,0x38000000
        // a is zero.
        absResult = 0;
    }

    // Apply the signbit to (dst_t)abs(a).
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21ab4e:	c1 e0 10             	shl    eax,0x10
  21ab51:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  21ab53:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  21ab57:	c3                   	ret    
    } else if (aAbs >= srcInfinity) {
  21ab58:	0f b7 d1             	movzx  edx,cx
  21ab5b:	81 fa 00 7c 00 00    	cmp    edx,0x7c00
  21ab61:	72 16                	jb     21ab79 <__extendhfsf2+0x59>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  21ab63:	0f b7 cf             	movzx  ecx,di
  21ab66:	c1 e1 0d             	shl    ecx,0xd
  21ab69:	81 c9 00 00 80 7f    	or     ecx,0x7f800000
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21ab6f:	c1 e0 10             	shl    eax,0x10
  21ab72:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  21ab74:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  21ab78:	c3                   	ret    
    } else if (aAbs != 0) {
  21ab79:	66 85 c9             	test   cx,cx
  21ab7c:	74 2f                	je     21abad <__extendhfsf2+0x8d>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  21ab7e:	66 f3 0f bd c9       	lzcnt  cx,cx
  21ab83:	8d 71 1b             	lea    esi,[rcx+0x1b]
  21ab86:	83 e6 1f             	and    esi,0x1f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  21ab89:	83 c1 08             	add    ecx,0x8
  21ab8c:	c4 e2 71 f7 d2       	shlx   edx,edx,ecx
        absResult ^= dstMinNormal;
  21ab91:	81 f2 00 00 80 00    	xor    edx,0x800000
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  21ab97:	c1 e6 17             	shl    esi,0x17
  21ab9a:	b9 00 00 80 38       	mov    ecx,0x38800000
  21ab9f:	29 f1                	sub    ecx,esi
  21aba1:	09 d1                	or     ecx,edx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21aba3:	c1 e0 10             	shl    eax,0x10
  21aba6:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  21aba8:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  21abac:	c3                   	ret    
  21abad:	31 c9                	xor    ecx,ecx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21abaf:	c1 e0 10             	shl    eax,0x10
  21abb2:	09 c8                	or     eax,ecx
    return @bitCast(dst_t, result);
  21abb4:	c5 f9 6e c0          	vmovd  xmm0,eax
    return extendXfYf2(f32, f16, @bitCast(f16, a));
  21abb8:	c3                   	ret    
  21abb9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021abc0 <__truncsfhf2>:

    const dstQNaN = 1 << (dstSigBits - 1);
    const dstNaNCode = dstQNaN - 1;

    // Break a into a sign and representation of the absolute value
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21abc0:	c5 f9 7e c2          	vmovd  edx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21abc4:	89 d6                	mov    esi,edx
  21abc6:	81 e6 ff ff ff 7f    	and    esi,0x7fffffff
    const sign: src_rep_t = aRep & srcSignMask;
    var absResult: dst_rep_t = undefined;

    if (aAbs -% underflow < aAbs -% overflow) {
  21abcc:	8d 86 00 00 80 c7    	lea    eax,[rsi-0x38800000]
  21abd2:	8d 8e 00 00 80 b8    	lea    ecx,[rsi-0x47800000]
  21abd8:	39 c8                	cmp    eax,ecx
  21abda:	73 1f                	jae    21abfb <__truncsfhf2+0x3b>
        // The exponent of a is within the range of normal numbers in the
        // destination format.  We can convert by simply right-shifting with
        // rounding and adjusting the exponent.
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  21abdc:	89 d0                	mov    eax,edx
  21abde:	c1 e8 0d             	shr    eax,0xd
        absResult -%= dst_rep_t(srcExpBias - dstExpBias) << dstSigBits;

        const roundBits: src_rep_t = aAbs & roundMask;
  21abe1:	89 d1                	mov    ecx,edx
  21abe3:	81 e1 ff 1f 00 00    	and    ecx,0x1fff
        if (roundBits > halfway) {
  21abe9:	81 f9 01 10 00 00    	cmp    ecx,0x1001
  21abef:	72 23                	jb     21ac14 <__truncsfhf2+0x54>
            // Round to nearest
            absResult += 1;
  21abf1:	05 01 40 00 00       	add    eax,0x4001
  21abf6:	e9 83 00 00 00       	jmp    21ac7e <__truncsfhf2+0xbe>
        } else if (roundBits == halfway) {
            // Ties to even
            absResult += absResult & 1;
        }
    } else if (aAbs > srcInfinity) {
  21abfb:	81 fe 01 00 80 7f    	cmp    esi,0x7f800001
  21ac01:	72 29                	jb     21ac2c <__truncsfhf2+0x6c>
        // a is NaN.
        // Conjure the result by beginning with infinity, setting the qNaN
        // bit and inserting the (truncated) trailing NaN field.
        absResult = @intCast(dst_rep_t, dstInfExp) << dstSigBits;
        absResult |= dstQNaN;
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  21ac03:	b8 0d 09 00 00       	mov    eax,0x90d
  21ac08:	c4 e2 78 f7 c2       	bextr  eax,edx,eax
  21ac0d:	0d 00 7e 00 00       	or     eax,0x7e00
  21ac12:	eb 6a                	jmp    21ac7e <__truncsfhf2+0xbe>
  21ac14:	05 00 40 00 00       	add    eax,0x4000
        } else if (roundBits == halfway) {
  21ac19:	81 f9 00 10 00 00    	cmp    ecx,0x1000
  21ac1f:	75 5d                	jne    21ac7e <__truncsfhf2+0xbe>
  21ac21:	89 c1                	mov    ecx,eax
  21ac23:	83 e1 01             	and    ecx,0x1
  21ac26:	01 c1                	add    ecx,eax
  21ac28:	89 c8                	mov    eax,ecx
  21ac2a:	eb 52                	jmp    21ac7e <__truncsfhf2+0xbe>
  21ac2c:	66 b8 00 7c          	mov    ax,0x7c00
    } else if (aAbs >= overflow) {
  21ac30:	81 fe ff ff 7f 47    	cmp    esi,0x477fffff
  21ac36:	77 46                	ja     21ac7e <__truncsfhf2+0xbe>
        absResult = @intCast(dst_rep_t, dstInfExp) << dstSigBits;
    } else {
        // a underflows on conversion to the destination type or is an exact
        // zero.  The result may be a denormal or zero.  Extract the exponent
        // to get the shift amount for the denormalization.
        const aExp = @intCast(u32, aAbs >> srcSigBits);
  21ac38:	c1 ee 17             	shr    esi,0x17
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21ac3b:	b9 70 00 00 00       	mov    ecx,0x70
  21ac40:	29 f1                	sub    ecx,esi

        const significand: src_rep_t = (aRep & srcSignificandMask) | srcMinNormal;

        // Right shift by the denormalization amount with sticky.
        if (shift > srcSigBits) {
  21ac42:	83 f9 16             	cmp    ecx,0x16
  21ac45:	76 04                	jbe    21ac4b <__truncsfhf2+0x8b>
  21ac47:	31 c0                	xor    eax,eax
  21ac49:	eb 33                	jmp    21ac7e <__truncsfhf2+0xbe>
  21ac4b:	89 d6                	mov    esi,edx
  21ac4d:	81 e6 ff ff 7f 00    	and    esi,0x7fffff
  21ac53:	81 ce 00 00 80 00    	or     esi,0x800000
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21ac59:	83 c1 01             	add    ecx,0x1
            absResult = 0;
        } else {
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  21ac5c:	d3 ce                	ror    esi,cl
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  21ac5e:	89 f0                	mov    eax,esi
  21ac60:	c1 e8 0d             	shr    eax,0xd
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  21ac63:	81 e6 ff 1f 00 00    	and    esi,0x1fff
            if (roundBits > halfway) {
  21ac69:	81 fe 01 10 00 00    	cmp    esi,0x1001
  21ac6f:	72 05                	jb     21ac76 <__truncsfhf2+0xb6>
                // Round to nearest
                absResult += 1;
  21ac71:	83 c0 01             	add    eax,0x1
  21ac74:	eb 08                	jmp    21ac7e <__truncsfhf2+0xbe>
            } else if (roundBits == halfway) {
  21ac76:	81 fe 00 10 00 00    	cmp    esi,0x1000
  21ac7c:	74 a3                	je     21ac21 <__truncsfhf2+0x61>
                absResult += absResult & 1;
            }
        }
    }

    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  21ac7e:	c1 ea 10             	shr    edx,0x10
  21ac81:	81 e2 00 80 00 00    	and    edx,0x8000
  21ac87:	09 d0                	or     eax,edx
    return @bitCast(u16, truncXfYf2(f16, f32, a));
  21ac89:	c3                   	ret    
  21ac8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000021ac90 <__unordtf2>:
}

pub extern fn __unordtf2(a: f128, b: f128) c_int {
    @setRuntimeSafety(is_test);

    const aAbs = @bitCast(rep_t, a) & absMask;
  21ac90:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  21ac95:	b0 3f                	mov    al,0x3f
  21ac97:	c4 e2 f8 f5 4c 24 f0 	bzhi   rcx,QWORD PTR [rsp-0x10],rax
    const bAbs = @bitCast(rep_t, b) & absMask;
  21ac9e:	0f 29 4c 24 d8       	movaps XMMWORD PTR [rsp-0x28],xmm1
  21aca3:	c4 e2 f8 f5 44 24 e0 	bzhi   rax,QWORD PTR [rsp-0x20],rax
    return @boolToInt(aAbs > infRep or bAbs > infRep);
  21acaa:	31 d2                	xor    edx,edx
  21acac:	48 3b 54 24 e8       	cmp    rdx,QWORD PTR [rsp-0x18]
  21acb1:	48 be 00 00 00 00 00 	movabs rsi,0x7fff000000000000
  21acb8:	00 ff 7f 
  21acbb:	48 89 f7             	mov    rdi,rsi
  21acbe:	48 19 cf             	sbb    rdi,rcx
  21acc1:	0f 92 c1             	setb   cl
  21acc4:	48 3b 54 24 d8       	cmp    rdx,QWORD PTR [rsp-0x28]
  21acc9:	48 19 c6             	sbb    rsi,rax
  21accc:	0f 92 c0             	setb   al
  21accf:	08 c8                	or     al,cl
  21acd1:	0f b6 c0             	movzx  eax,al
  21acd4:	c3                   	ret    
  21acd5:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21acdc:	00 00 00 00 

000000000021ace0 <__floattitf>:
const LDBL_MANT_DIG = 113;

pub extern fn __floattitf(arg: i128) f128 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21ace0:	48 89 f8             	mov    rax,rdi
  21ace3:	48 09 f0             	or     rax,rsi
  21ace6:	0f 84 ba 00 00 00    	je     21ada6 <__floattitf+0xc6>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  21acec:	41 57                	push   r15
  21acee:	41 56                	push   r14
  21acf0:	53                   	push   rbx
  21acf1:	48 89 f0             	mov    rax,rsi
  21acf4:	48 c1 f8 3f          	sar    rax,0x3f
    ai = ((ai ^ si) -% si);
  21acf8:	48 89 c2             	mov    rdx,rax
  21acfb:	48 31 f2             	xor    rdx,rsi
  21acfe:	48 31 c7             	xor    rdi,rax
  21ad01:	48 29 c7             	sub    rdi,rax
  21ad04:	48 19 c2             	sbb    rdx,rax
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21ad07:	f3 48 0f bd c2       	lzcnt  rax,rdx
  21ad0c:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21ad11:	83 c1 40             	add    ecx,0x40
  21ad14:	48 85 d2             	test   rdx,rdx
  21ad17:	0f 45 c8             	cmovne ecx,eax
  21ad1a:	41 b9 80 00 00 00    	mov    r9d,0x80
  21ad20:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  21ad23:	41 ba 7f 00 00 00    	mov    r10d,0x7f
  21ad29:	41 29 ca             	sub    r10d,ecx
    if (sd > LDBL_MANT_DIG) {
  21ad2c:	41 83 f9 72          	cmp    r9d,0x72
  21ad30:	7c 7c                	jl     21adae <__floattitf+0xce>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit LDBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit LDBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21ad32:	0f 84 99 00 00 00    	je     21add1 <__floattitf+0xf1>
  21ad38:	41 83 f9 73          	cmp    r9d,0x73
  21ad3c:	0f 84 97 00 00 00    	je     21add9 <__floattitf+0xf9>
            LDBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            LDBL_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (LDBL_MANT_DIG + 2));
  21ad42:	41 8d 49 0d          	lea    ecx,[r9+0xd]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  21ad46:	41 b8 73 00 00 00    	mov    r8d,0x73
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21ad4c:	83 e1 7f             	and    ecx,0x7f
  21ad4f:	49 89 ff             	mov    r15,rdi
  21ad52:	49 0f ad d7          	shrd   r15,rdx,cl
                const shift2_amt = @intCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  21ad56:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21ad59:	c4 62 f3 f7 da       	shrx   r11,rdx,rcx
  21ad5e:	45 31 f6             	xor    r14d,r14d
  21ad61:	f6 c1 40             	test   cl,0x40
  21ad64:	4d 0f 45 fb          	cmovne r15,r11
  21ad68:	4d 0f 45 de          	cmovne r11,r14
  21ad6c:	41 83 e0 7f          	and    r8d,0x7f
  21ad70:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21ad77:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  21ad7c:	44 89 c1             	mov    ecx,r8d
  21ad7f:	48 0f ad db          	shrd   rbx,rbx,cl
  21ad83:	41 f6 c0 40          	test   r8b,0x40
  21ad87:	48 0f 45 d8          	cmovne rbx,rax
  21ad8b:	49 0f 45 c6          	cmovne rax,r14
  21ad8f:	48 21 fb             	and    rbx,rdi
  21ad92:	48 21 d0             	and    rax,rdx
  21ad95:	31 ff                	xor    edi,edi
  21ad97:	48 09 d8             	or     rax,rbx
  21ad9a:	40 0f 95 c7          	setne  dil
  21ad9e:	4c 09 ff             	or     rdi,r15
  21ada1:	4c 89 da             	mov    rdx,r11
  21ada4:	eb 33                	jmp    21add9 <__floattitf+0xf9>
        return 0.0;
  21ada6:	0f 28 05 f3 54 fe ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffe54f3]        # 2002a0 <__unnamed_2>
  21adad:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to LDBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, LDBL_MANT_DIG - sd);
  21adae:	b9 71 00 00 00       	mov    ecx,0x71
  21adb3:	44 29 c9             	sub    ecx,r9d
  21adb6:	83 e1 7f             	and    ecx,0x7f
  21adb9:	48 0f a5 fa          	shld   rdx,rdi,cl
  21adbd:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  21adc2:	31 c0                	xor    eax,eax
  21adc4:	f6 c1 40             	test   cl,0x40
  21adc7:	48 0f 45 d7          	cmovne rdx,rdi
  21adcb:	48 0f 44 c7          	cmove  rax,rdi
  21adcf:	eb 3b                	jmp    21ae0c <__floattitf+0x12c>
                a <<= 1;
  21add1:	48 0f a4 fa 01       	shld   rdx,rdi,0x1
  21add6:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21add9:	b8 02 01 00 00       	mov    eax,0x102
  21adde:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  21ade3:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  21ade6:	48 83 c0 01          	add    rax,0x1
  21adea:	48 83 d2 00          	adc    rdx,0x0
        if ((a & (u128(1) << LDBL_MANT_DIG)) != 0) {
  21adee:	48 0f ba e2 33       	bt     rdx,0x33
  21adf3:	72 0b                	jb     21ae00 <__floattitf+0x120>
  21adf5:	48 0f ac d0 02       	shrd   rax,rdx,0x2
  21adfa:	48 c1 ea 02          	shr    rdx,0x2
  21adfe:	eb 0c                	jmp    21ae0c <__floattitf+0x12c>
            a >>= 1;
  21ae00:	48 0f ac d0 03       	shrd   rax,rdx,0x3
  21ae05:	48 c1 ea 03          	shr    rdx,0x3
  21ae09:	45 89 ca             	mov    r10d,r9d
        // a is now rounded to LDBL_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 64);
    const high: u128 = (@intCast(u64, s) & 0x8000000000000000) | // sign
  21ae0c:	48 b9 00 00 00 00 00 	movabs rcx,0x8000000000000000
  21ae13:	00 00 80 
  21ae16:	48 21 ce             	and    rsi,rcx
        (@intCast(u64, (e + 16383)) << 48) | // exponent
  21ae19:	41 81 c2 ff 3f 00 00 	add    r10d,0x3fff
  21ae20:	49 c1 e2 30          	shl    r10,0x30
    const high: u128 = (@intCast(u64, s) & 0x8000000000000000) | // sign
  21ae24:	49 09 f2             	or     r10,rsi
        (@truncate(u64, a >> 64) & 0x0000ffffffffffff); // mantissa-high
  21ae27:	b1 30                	mov    cl,0x30
  21ae29:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
    const low = @truncate(u64, a); // mantissa-low

    return @bitCast(f128, low | (high << 64));
  21ae2e:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
        (@intCast(u64, (e + 16383)) << 48) | // exponent
  21ae33:	4c 09 d1             	or     rcx,r10
    return @bitCast(f128, low | (high << 64));
  21ae36:	48 89 4c 24 f8       	mov    QWORD PTR [rsp-0x8],rcx
  21ae3b:	0f 28 44 24 f0       	movaps xmm0,XMMWORD PTR [rsp-0x10]
  21ae40:	5b                   	pop    rbx
  21ae41:	41 5e                	pop    r14
  21ae43:	41 5f                	pop    r15
  21ae45:	c3                   	ret    
  21ae46:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21ae4d:	00 00 00 

000000000021ae50 <__floattidf>:
const DBL_MANT_DIG = 53;

pub extern fn __floattidf(arg: i128) f64 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21ae50:	48 89 f8             	mov    rax,rdi
  21ae53:	48 09 f0             	or     rax,rsi
  21ae56:	0f 84 b8 00 00 00    	je     21af14 <__floattidf+0xc4>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  21ae5c:	41 57                	push   r15
  21ae5e:	41 56                	push   r14
  21ae60:	53                   	push   rbx
  21ae61:	48 89 f0             	mov    rax,rsi
  21ae64:	48 c1 f8 3f          	sar    rax,0x3f
    ai = ((ai ^ si) -% si);
  21ae68:	48 89 c2             	mov    rdx,rax
  21ae6b:	48 31 f2             	xor    rdx,rsi
  21ae6e:	48 31 c7             	xor    rdi,rax
  21ae71:	48 29 c7             	sub    rdi,rax
  21ae74:	48 19 c2             	sbb    rdx,rax
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21ae77:	f3 48 0f bd c2       	lzcnt  rax,rdx
  21ae7c:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21ae81:	83 c1 40             	add    ecx,0x40
  21ae84:	48 85 d2             	test   rdx,rdx
  21ae87:	0f 45 c8             	cmovne ecx,eax
  21ae8a:	41 b9 80 00 00 00    	mov    r9d,0x80
  21ae90:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  21ae93:	b8 7f 00 00 00       	mov    eax,0x7f
  21ae98:	29 c8                	sub    eax,ecx
    if (sd > DBL_MANT_DIG) {
  21ae9a:	41 83 f9 36          	cmp    r9d,0x36
  21ae9e:	7c 79                	jl     21af19 <__floattidf+0xc9>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit DBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit DBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21aea0:	0f 84 9b 00 00 00    	je     21af41 <__floattidf+0xf1>
  21aea6:	41 83 f9 37          	cmp    r9d,0x37
  21aeaa:	0f 84 99 00 00 00    	je     21af49 <__floattidf+0xf9>
            DBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            DBL_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (DBL_MANT_DIG + 2));
  21aeb0:	41 8d 49 49          	lea    ecx,[r9+0x49]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  21aeb4:	41 b8 37 00 00 00    	mov    r8d,0x37
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21aeba:	83 e1 7f             	and    ecx,0x7f
  21aebd:	49 89 fa             	mov    r10,rdi
  21aec0:	49 0f ad d2          	shrd   r10,rdx,cl
                const shift2_amt = @intCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  21aec4:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21aec7:	c4 62 f3 f7 da       	shrx   r11,rdx,rcx
  21aecc:	45 31 f6             	xor    r14d,r14d
  21aecf:	f6 c1 40             	test   cl,0x40
  21aed2:	4d 0f 45 d3          	cmovne r10,r11
  21aed6:	4d 0f 45 de          	cmovne r11,r14
  21aeda:	41 83 e0 7f          	and    r8d,0x7f
  21aede:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21aee5:	c4 62 bb f7 fb       	shrx   r15,rbx,r8
  21aeea:	44 89 c1             	mov    ecx,r8d
  21aeed:	48 0f ad db          	shrd   rbx,rbx,cl
  21aef1:	41 f6 c0 40          	test   r8b,0x40
  21aef5:	49 0f 45 df          	cmovne rbx,r15
  21aef9:	4d 0f 45 fe          	cmovne r15,r14
  21aefd:	48 21 fb             	and    rbx,rdi
  21af00:	49 21 d7             	and    r15,rdx
  21af03:	31 ff                	xor    edi,edi
  21af05:	49 09 df             	or     r15,rbx
  21af08:	40 0f 95 c7          	setne  dil
  21af0c:	4c 09 d7             	or     rdi,r10
  21af0f:	4c 89 da             	mov    rdx,r11
  21af12:	eb 35                	jmp    21af49 <__floattidf+0xf9>
        return 0.0;
  21af14:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21af18:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to DBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, DBL_MANT_DIG - sd);
  21af19:	b9 35 00 00 00       	mov    ecx,0x35
  21af1e:	44 29 c9             	sub    ecx,r9d
  21af21:	83 e1 7f             	and    ecx,0x7f
  21af24:	48 0f a5 fa          	shld   rdx,rdi,cl
  21af28:	c4 e2 f1 f7 df       	shlx   rbx,rdi,rcx
  21af2d:	31 ff                	xor    edi,edi
  21af2f:	f6 c1 40             	test   cl,0x40
  21af32:	48 0f 45 d3          	cmovne rdx,rbx
  21af36:	48 0f 44 fb          	cmove  rdi,rbx
    if (sd > DBL_MANT_DIG) {
  21af3a:	48 0f a4 fa 20       	shld   rdx,rdi,0x20
  21af3f:	eb 40                	jmp    21af81 <__floattidf+0x131>
                a <<= 1;
  21af41:	48 0f a4 fa 01       	shld   rdx,rdi,0x1
  21af46:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21af49:	b9 02 01 00 00       	mov    ecx,0x102
  21af4e:	c4 e2 70 f7 cf       	bextr  ecx,edi,ecx
  21af53:	48 09 f9             	or     rcx,rdi
        a += 1; // round - this step may add a significant bit
  21af56:	48 83 c1 01          	add    rcx,0x1
  21af5a:	48 83 d2 00          	adc    rdx,0x0
            a >>= 1;
  21af5e:	48 89 d7             	mov    rdi,rdx
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  21af61:	48 0f ba e1 37       	bt     rcx,0x37
  21af66:	72 0c                	jb     21af74 <__floattidf+0x124>
  21af68:	48 0f a4 cf 3e       	shld   rdi,rcx,0x3e
  21af6d:	48 0f a4 ca 1e       	shld   rdx,rcx,0x1e
  21af72:	eb 0d                	jmp    21af81 <__floattidf+0x131>
            a >>= 1;
  21af74:	48 0f a4 cf 3d       	shld   rdi,rcx,0x3d
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  21af79:	48 0f a4 ca 1d       	shld   rdx,rcx,0x1d
  21af7e:	44 89 c8             	mov    eax,r9d
        // a is now rounded to DBL_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 32);
  21af81:	48 c1 ee 20          	shr    rsi,0x20
    const high: u64 = (@intCast(u64, s) & 0x80000000) | // sign
  21af85:	81 e6 00 00 00 80    	and    esi,0x80000000
        (@intCast(u32, (e + 1023)) << 20) | // exponent
  21af8b:	c1 e0 14             	shl    eax,0x14
  21af8e:	05 00 00 f0 3f       	add    eax,0x3ff00000
    const high: u64 = (@intCast(u64, s) & 0x80000000) | // sign
  21af93:	09 f0                	or     eax,esi
        (@truncate(u32, a >> 32) & 0x000fffff); // mantissa-high
  21af95:	81 e2 ff ff 0f 00    	and    edx,0xfffff
        (@intCast(u32, (e + 1023)) << 20) | // exponent
  21af9b:	09 c2                	or     edx,eax
    const low: u64 = @truncate(u32, a); // mantissa-low
  21af9d:	89 f8                	mov    eax,edi

    return @bitCast(f64, low | (high << 32));
  21af9f:	48 c1 e2 20          	shl    rdx,0x20
  21afa3:	48 09 c2             	or     rdx,rax
  21afa6:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  21afab:	5b                   	pop    rbx
  21afac:	41 5e                	pop    r14
  21afae:	41 5f                	pop    r15
  21afb0:	c3                   	ret    
  21afb1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21afb8:	0f 1f 84 00 00 00 00 
  21afbf:	00 

000000000021afc0 <__floattisf>:
const FLT_MANT_DIG = 24;

pub extern fn __floattisf(arg: i128) f32 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21afc0:	48 89 f8             	mov    rax,rdi
  21afc3:	48 09 f0             	or     rax,rsi
  21afc6:	0f 84 b2 00 00 00    	je     21b07e <__floattisf+0xbe>
        return 0.0;

    var ai = arg;
    const N: u32 = 128;
    const si = ai >> @intCast(u7, (N - 1));
  21afcc:	48 89 f1             	mov    rcx,rsi
  21afcf:	48 c1 f9 3f          	sar    rcx,0x3f
    ai = ((ai ^ si) -% si);
  21afd3:	48 89 c8             	mov    rax,rcx
  21afd6:	48 31 f0             	xor    rax,rsi
  21afd9:	48 31 cf             	xor    rdi,rcx
  21afdc:	48 29 cf             	sub    rdi,rcx
  21afdf:	48 19 c8             	sbb    rax,rcx
    var a = @bitCast(u128, ai);

    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21afe2:	f3 48 0f bd d0       	lzcnt  rdx,rax
  21afe7:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21afec:	83 c1 40             	add    ecx,0x40
  21afef:	48 85 c0             	test   rax,rax
  21aff2:	0f 45 ca             	cmovne ecx,edx
  21aff5:	41 b9 80 00 00 00    	mov    r9d,0x80
  21affb:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  21affe:	ba 7f 00 00 00       	mov    edx,0x7f
  21b003:	29 ca                	sub    edx,ecx

    if (sd > FLT_MANT_DIG) {
  21b005:	41 83 f9 19          	cmp    r9d,0x19
  21b009:	7c 78                	jl     21b083 <__floattisf+0xc3>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit FLT_MANT_DIG-1 bits to the right of 1
        //  Q = bit FLT_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21b00b:	0f 84 8d 00 00 00    	je     21b09e <__floattisf+0xde>
  21b011:	41 83 f9 1a          	cmp    r9d,0x1a
  21b015:	0f 84 86 00 00 00    	je     21b0a1 <__floattisf+0xe1>
            FLT_MANT_DIG + 1 => {
                a <<= 1;
            },
            FLT_MANT_DIG + 2 => {},
            else => {
                const shift1_amt = @intCast(i32, sd - (FLT_MANT_DIG + 2));
  21b01b:	41 56                	push   r14
  21b01d:	53                   	push   rbx
  21b01e:	41 8d 49 66          	lea    ecx,[r9+0x66]
                const shift1_amt_u7 = @intCast(u7, shift1_amt);

                const shift2_amt = @intCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
                const shift2_amt_u7 = @intCast(u7, shift2_amt);

                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21b022:	83 e1 7f             	and    ecx,0x7f
  21b025:	49 89 fa             	mov    r10,rdi
  21b028:	49 0f ad c2          	shrd   r10,rax,cl
                const shift2_amt = @intCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
  21b02c:	41 b8 1a 00 00 00    	mov    r8d,0x1a
  21b032:	45 29 c8             	sub    r8d,r9d
                a = (a >> shift1_amt_u7) | @boolToInt((a & (@intCast(u128, @maxValue(u128)) >> shift2_amt_u7)) != 0);
  21b035:	c4 62 f3 f7 d8       	shrx   r11,rax,rcx
  21b03a:	45 31 f6             	xor    r14d,r14d
  21b03d:	f6 c1 40             	test   cl,0x40
  21b040:	4d 0f 44 da          	cmove  r11,r10
  21b044:	41 83 e0 7f          	and    r8d,0x7f
  21b048:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21b04f:	c4 62 bb f7 d3       	shrx   r10,rbx,r8
  21b054:	44 89 c1             	mov    ecx,r8d
  21b057:	48 0f ad db          	shrd   rbx,rbx,cl
  21b05b:	41 f6 c0 40          	test   r8b,0x40
  21b05f:	49 0f 45 da          	cmovne rbx,r10
  21b063:	4d 0f 44 f2          	cmove  r14,r10
  21b067:	48 21 fb             	and    rbx,rdi
  21b06a:	49 21 c6             	and    r14,rax
  21b06d:	31 ff                	xor    edi,edi
  21b06f:	49 09 de             	or     r14,rbx
  21b072:	40 0f 95 c7          	setne  dil
  21b076:	4c 09 df             	or     rdi,r11
        switch (sd) {
  21b079:	5b                   	pop    rbx
  21b07a:	41 5e                	pop    r14
  21b07c:	eb 23                	jmp    21b0a1 <__floattisf+0xe1>
        return 0.0;
  21b07e:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21b082:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to FLT_MANT_DIG bits
    } else {
        a <<= @intCast(u7, FLT_MANT_DIG - sd);
  21b083:	b9 18 00 00 00       	mov    ecx,0x18
  21b088:	44 29 c9             	sub    ecx,r9d
  21b08b:	83 e1 7f             	and    ecx,0x7f
  21b08e:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  21b093:	31 c0                	xor    eax,eax
  21b095:	f6 c1 40             	test   cl,0x40
  21b098:	48 0f 44 c7          	cmove  rax,rdi
  21b09c:	eb 28                	jmp    21b0c6 <__floattisf+0x106>
                a <<= 1;
  21b09e:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21b0a1:	b8 02 01 00 00       	mov    eax,0x102
  21b0a6:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  21b0ab:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  21b0ae:	48 83 c0 01          	add    rax,0x1
        if ((a & (u128(1) << FLT_MANT_DIG)) != 0) {
  21b0b2:	a9 00 00 00 04       	test   eax,0x4000000
  21b0b7:	75 06                	jne    21b0bf <__floattisf+0xff>
  21b0b9:	48 c1 e8 02          	shr    rax,0x2
  21b0bd:	eb 07                	jmp    21b0c6 <__floattisf+0x106>
            a >>= 1;
  21b0bf:	48 c1 e8 03          	shr    rax,0x3
  21b0c3:	44 89 ca             	mov    edx,r9d
        // a is now rounded to FLT_MANT_DIG bits
    }

    const s = @bitCast(u128, arg) >> (128 - 32);
  21b0c6:	48 c1 ee 20          	shr    rsi,0x20
    const r = (@intCast(u32, s) & 0x80000000) | // sign
  21b0ca:	81 e6 00 00 00 80    	and    esi,0x80000000
        (@intCast(u32, (e + 127)) << 23) | // exponent
  21b0d0:	c1 e2 17             	shl    edx,0x17
  21b0d3:	81 c2 00 00 80 3f    	add    edx,0x3f800000
    const r = (@intCast(u32, s) & 0x80000000) | // sign
  21b0d9:	09 f2                	or     edx,esi
        (@truncate(u32, a) & 0x007fffff); // mantissa-high
  21b0db:	25 ff ff 7f 00       	and    eax,0x7fffff
        (@intCast(u32, (e + 127)) << 23) | // exponent
  21b0e0:	09 d0                	or     eax,edx

    return @bitCast(f32, r);
  21b0e2:	c5 f9 6e c0          	vmovd  xmm0,eax
  21b0e6:	c3                   	ret    
  21b0e7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21b0ee:	00 00 

000000000021b0f0 <__floatunditf>:
const std = @import("std");

pub extern fn __floatunditf(a: u128) f128 {
    @setRuntimeSafety(is_test);

    if (a == 0) {
  21b0f0:	48 89 f8             	mov    rax,rdi
  21b0f3:	48 09 f0             	or     rax,rsi
  21b0f6:	74 0f                	je     21b107 <__floatunditf+0x17>
    const mantissa_bits = std.math.floatMantissaBits(f128);
    const exponent_bits = std.math.floatExponentBits(f128);
    const exponent_bias = (1 << (exponent_bits - 1)) - 1;
    const implicit_bit = 1 << mantissa_bits;

    const exp = (u128.bit_count - 1) - @clz(a);
  21b0f8:	48 85 f6             	test   rsi,rsi
  21b0fb:	75 12                	jne    21b10f <__floatunditf+0x1f>
  21b0fd:	f3 48 0f bd c7       	lzcnt  rax,rdi
  21b102:	83 c0 40             	add    eax,0x40
  21b105:	eb 0d                	jmp    21b114 <__floatunditf+0x24>
        return 0;
  21b107:	0f 28 05 92 51 fe ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffe5192]        # 2002a0 <__unnamed_2>
  21b10e:	c3                   	ret    
  21b10f:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21b114:	b2 7f                	mov    dl,0x7f
    const exp = (u128.bit_count - 1) - @clz(a);
  21b116:	28 c2                	sub    dl,al
  21b118:	b1 70                	mov    cl,0x70
    const shift = mantissa_bits - @intCast(u7, exp);
  21b11a:	28 d1                	sub    cl,dl

    var result: u128 align(16) = (a << shift) ^ implicit_bit;
  21b11c:	48 0f a5 fe          	shld   rsi,rdi,cl
  21b120:	c4 e2 f1 f7 c7       	shlx   rax,rdi,rcx
  21b125:	31 ff                	xor    edi,edi
  21b127:	f6 c1 40             	test   cl,0x40
  21b12a:	48 0f 45 f0          	cmovne rsi,rax
  21b12e:	48 0f 44 f8          	cmove  rdi,rax
  21b132:	48 b8 00 00 00 00 00 	movabs rax,0x1000000000000
  21b139:	00 01 00 
  21b13c:	48 31 f0             	xor    rax,rsi
    result += (@intCast(u128, exp) + exponent_bias) << mantissa_bits;
  21b13f:	0f b6 ca             	movzx  ecx,dl
  21b142:	48 c1 e1 30          	shl    rcx,0x30
  21b146:	48 01 c1             	add    rcx,rax
  21b149:	48 89 7c 24 e8       	mov    QWORD PTR [rsp-0x18],rdi
  21b14e:	48 b8 00 00 00 00 00 	movabs rax,0x3fff000000000000
  21b155:	00 ff 3f 
  21b158:	48 01 c8             	add    rax,rcx
  21b15b:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  21b160:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]

    return @bitCast(f128, result);
  21b165:	c3                   	ret    
  21b166:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21b16d:	00 00 00 

000000000021b170 <__floatunsitf>:
const std = @import("std");

pub extern fn __floatunsitf(a: u64) f128 {
    @setRuntimeSafety(is_test);

    if (a == 0) {
  21b170:	48 85 ff             	test   rdi,rdi
  21b173:	74 5c                	je     21b1d1 <__floatunsitf+0x61>
    const mantissa_bits = std.math.floatMantissaBits(f128);
    const exponent_bits = std.math.floatExponentBits(f128);
    const exponent_bias = (1 << (exponent_bits - 1)) - 1;
    const implicit_bit = 1 << mantissa_bits;

    const exp = (u64.bit_count - 1) - @clz(a);
  21b175:	f3 48 0f bd c7       	lzcnt  rax,rdi
  21b17a:	b2 3f                	mov    dl,0x3f
  21b17c:	28 c2                	sub    dl,al
  21b17e:	b1 70                	mov    cl,0x70
    const shift = mantissa_bits - @intCast(u7, exp);
  21b180:	28 d1                	sub    cl,dl
  21b182:	31 c0                	xor    eax,eax

    // TODO(#1148): @bitCast alignment error
    var result align(16) = (@intCast(u128, a) << shift) ^ implicit_bit;
  21b184:	31 f6                	xor    esi,esi
  21b186:	48 0f a5 fe          	shld   rsi,rdi,cl
  21b18a:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  21b18f:	f6 c1 40             	test   cl,0x40
  21b192:	48 0f 45 f7          	cmovne rsi,rdi
  21b196:	48 0f 45 f8          	cmovne rdi,rax
  21b19a:	48 b8 00 00 00 00 00 	movabs rax,0x1000000000000
  21b1a1:	00 01 00 
  21b1a4:	48 31 f0             	xor    rax,rsi
    result += (@intCast(u128, exp) + exponent_bias) << mantissa_bits;
  21b1a7:	0f b6 ca             	movzx  ecx,dl
  21b1aa:	83 e1 7f             	and    ecx,0x7f
  21b1ad:	48 c1 e1 30          	shl    rcx,0x30
  21b1b1:	48 01 c1             	add    rcx,rax
  21b1b4:	48 89 7c 24 e8       	mov    QWORD PTR [rsp-0x18],rdi
  21b1b9:	48 b8 00 00 00 00 00 	movabs rax,0x3fff000000000000
  21b1c0:	00 ff 3f 
  21b1c3:	48 01 c8             	add    rax,rcx
  21b1c6:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  21b1cb:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]

    return @bitCast(f128, result);
  21b1d0:	c3                   	ret    
        return 0;
  21b1d1:	0f 28 05 c8 50 fe ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffe50c8]        # 2002a0 <__unnamed_2>
  21b1d8:	c3                   	ret    
  21b1d9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021b1e0 <__floatuntitf>:
const LDBL_MANT_DIG = 113;

pub extern fn __floatuntitf(arg: u128) f128 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21b1e0:	48 89 f8             	mov    rax,rdi
  21b1e3:	48 09 f0             	or     rax,rsi
  21b1e6:	0f 84 a0 00 00 00    	je     21b28c <__floatuntitf+0xac>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21b1ec:	41 56                	push   r14
  21b1ee:	53                   	push   rbx
  21b1ef:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21b1f4:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21b1f9:	83 c1 40             	add    ecx,0x40
  21b1fc:	48 85 f6             	test   rsi,rsi
  21b1ff:	0f 45 c8             	cmovne ecx,eax
  21b202:	41 b9 80 00 00 00    	mov    r9d,0x80
  21b208:	41 29 c9             	sub    r9d,ecx
    var e: i32 = sd - 1; // exponent
  21b20b:	ba 7f 00 00 00       	mov    edx,0x7f
  21b210:	29 ca                	sub    edx,ecx
    if (sd > LDBL_MANT_DIG) {
  21b212:	41 83 f9 72          	cmp    r9d,0x72
  21b216:	7c 7c                	jl     21b294 <__floatuntitf+0xb4>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit LDBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit LDBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21b218:	0f 84 99 00 00 00    	je     21b2b7 <__floatuntitf+0xd7>
  21b21e:	41 83 f9 73          	cmp    r9d,0x73
  21b222:	0f 84 97 00 00 00    	je     21b2bf <__floatuntitf+0xdf>
            LDBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            LDBL_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  21b228:	41 b8 73 00 00 00    	mov    r8d,0x73
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  21b22e:	41 8d 49 0d          	lea    ecx,[r9+0xd]
  21b232:	83 e1 7f             	and    ecx,0x7f
  21b235:	49 89 fe             	mov    r14,rdi
  21b238:	49 0f ad f6          	shrd   r14,rsi,cl
                const shift_amt = @bitCast(i32, N + (LDBL_MANT_DIG + 2)) - sd;
  21b23c:	45 29 c8             	sub    r8d,r9d
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  21b23f:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  21b244:	45 31 db             	xor    r11d,r11d
  21b247:	f6 c1 40             	test   cl,0x40
  21b24a:	4d 0f 45 f2          	cmovne r14,r10
  21b24e:	4d 0f 45 d3          	cmovne r10,r11
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  21b252:	41 83 e0 7f          	and    r8d,0x7f
  21b256:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21b25d:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  21b262:	44 89 c1             	mov    ecx,r8d
  21b265:	48 0f ad db          	shrd   rbx,rbx,cl
  21b269:	41 f6 c0 40          	test   r8b,0x40
  21b26d:	48 0f 45 d8          	cmovne rbx,rax
  21b271:	49 0f 45 c3          	cmovne rax,r11
  21b275:	48 21 fb             	and    rbx,rdi
  21b278:	48 21 f0             	and    rax,rsi
  21b27b:	31 ff                	xor    edi,edi
  21b27d:	48 09 d8             	or     rax,rbx
  21b280:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (LDBL_MANT_DIG + 2))) |
  21b284:	4c 09 f7             	or     rdi,r14
  21b287:	4c 89 d6             	mov    rsi,r10
  21b28a:	eb 33                	jmp    21b2bf <__floatuntitf+0xdf>
        return 0.0;
  21b28c:	0f 28 05 0d 50 fe ff 	movaps xmm0,XMMWORD PTR [rip+0xfffffffffffe500d]        # 2002a0 <__unnamed_2>
  21b293:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to LDBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, LDBL_MANT_DIG - sd);
  21b294:	b9 71 00 00 00       	mov    ecx,0x71
  21b299:	44 29 c9             	sub    ecx,r9d
  21b29c:	83 e1 7f             	and    ecx,0x7f
  21b29f:	48 0f a5 fe          	shld   rsi,rdi,cl
  21b2a3:	c4 e2 f1 f7 ff       	shlx   rdi,rdi,rcx
  21b2a8:	31 c0                	xor    eax,eax
  21b2aa:	f6 c1 40             	test   cl,0x40
  21b2ad:	48 0f 45 f7          	cmovne rsi,rdi
  21b2b1:	48 0f 44 c7          	cmove  rax,rdi
  21b2b5:	eb 3b                	jmp    21b2f2 <__floatuntitf+0x112>
                a <<= 1;
  21b2b7:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  21b2bc:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21b2bf:	b8 02 01 00 00       	mov    eax,0x102
  21b2c4:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  21b2c9:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  21b2cc:	48 83 c0 01          	add    rax,0x1
  21b2d0:	48 83 d6 00          	adc    rsi,0x0
        if ((a & (u128(1) << LDBL_MANT_DIG)) != 0) {
  21b2d4:	48 0f ba e6 33       	bt     rsi,0x33
  21b2d9:	72 0b                	jb     21b2e6 <__floatuntitf+0x106>
  21b2db:	48 0f ac f0 02       	shrd   rax,rsi,0x2
  21b2e0:	48 c1 ee 02          	shr    rsi,0x2
  21b2e4:	eb 0c                	jmp    21b2f2 <__floatuntitf+0x112>
            a >>= 1;
  21b2e6:	48 0f ac f0 03       	shrd   rax,rsi,0x3
  21b2eb:	48 c1 ee 03          	shr    rsi,0x3
  21b2ef:	44 89 ca             	mov    edx,r9d
        // a is now rounded to LDBL_MANT_DIG bits
    }

    const high: u128 = (@intCast(u64, (e + 16383)) << 48) | // exponent
  21b2f2:	81 c2 ff 3f 00 00    	add    edx,0x3fff
  21b2f8:	48 c1 e2 30          	shl    rdx,0x30
        (@truncate(u64, a >> 64) & 0x0000ffffffffffff); // mantissa-high
  21b2fc:	b1 30                	mov    cl,0x30
  21b2fe:	c4 e2 f0 f5 ce       	bzhi   rcx,rsi,rcx
    const low = @truncate(u64, a); // mantissa-low

    return @bitCast(f128, low | (high << 64));
  21b303:	48 89 44 24 e8       	mov    QWORD PTR [rsp-0x18],rax
    const high: u128 = (@intCast(u64, (e + 16383)) << 48) | // exponent
  21b308:	48 09 d1             	or     rcx,rdx
    return @bitCast(f128, low | (high << 64));
  21b30b:	48 89 4c 24 f0       	mov    QWORD PTR [rsp-0x10],rcx
  21b310:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
  21b315:	5b                   	pop    rbx
  21b316:	41 5e                	pop    r14
  21b318:	c3                   	ret    
  21b319:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021b320 <__floatuntidf>:
const DBL_MANT_DIG = 53;

pub extern fn __floatuntidf(arg: u128) f64 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21b320:	48 89 f8             	mov    rax,rdi
  21b323:	48 09 f0             	or     rax,rsi
  21b326:	0f 84 a0 00 00 00    	je     21b3cc <__floatuntidf+0xac>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21b32c:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21b331:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21b336:	83 c1 40             	add    ecx,0x40
  21b339:	48 85 f6             	test   rsi,rsi
  21b33c:	0f 45 c8             	cmovne ecx,eax
  21b33f:	ba 80 00 00 00       	mov    edx,0x80
  21b344:	29 ca                	sub    edx,ecx
    var e: i32 = sd - 1; // exponent
  21b346:	41 bb 7f 00 00 00    	mov    r11d,0x7f
  21b34c:	41 29 cb             	sub    r11d,ecx
    if (sd > DBL_MANT_DIG) {
  21b34f:	83 fa 36             	cmp    edx,0x36
  21b352:	7c 7d                	jl     21b3d1 <__floatuntidf+0xb1>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit DBL_MANT_DIG-1 bits to the right of 1
        //  Q = bit DBL_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21b354:	0f 84 97 00 00 00    	je     21b3f1 <__floatuntidf+0xd1>
  21b35a:	83 fa 37             	cmp    edx,0x37
  21b35d:	0f 84 96 00 00 00    	je     21b3f9 <__floatuntidf+0xd9>
            DBL_MANT_DIG + 1 => {
                a <<= 1;
            },
            DBL_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  21b363:	41 56                	push   r14
  21b365:	53                   	push   rbx
  21b366:	41 b8 37 00 00 00    	mov    r8d,0x37
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  21b36c:	8d 4a 49             	lea    ecx,[rdx+0x49]
  21b36f:	83 e1 7f             	and    ecx,0x7f
  21b372:	49 89 f9             	mov    r9,rdi
  21b375:	49 0f ad f1          	shrd   r9,rsi,cl
                const shift_amt = @bitCast(i32, N + (DBL_MANT_DIG + 2)) - sd;
  21b379:	41 29 d0             	sub    r8d,edx
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  21b37c:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  21b381:	45 31 f6             	xor    r14d,r14d
  21b384:	f6 c1 40             	test   cl,0x40
  21b387:	4d 0f 45 ca          	cmovne r9,r10
  21b38b:	4d 0f 45 d6          	cmovne r10,r14
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  21b38f:	41 83 e0 7f          	and    r8d,0x7f
  21b393:	48 c7 c3 ff ff ff ff 	mov    rbx,0xffffffffffffffff
  21b39a:	c4 e2 bb f7 c3       	shrx   rax,rbx,r8
  21b39f:	44 89 c1             	mov    ecx,r8d
  21b3a2:	48 0f ad db          	shrd   rbx,rbx,cl
  21b3a6:	41 f6 c0 40          	test   r8b,0x40
  21b3aa:	48 0f 45 d8          	cmovne rbx,rax
  21b3ae:	49 0f 45 c6          	cmovne rax,r14
  21b3b2:	48 21 fb             	and    rbx,rdi
  21b3b5:	48 21 f0             	and    rax,rsi
  21b3b8:	31 ff                	xor    edi,edi
  21b3ba:	48 09 d8             	or     rax,rbx
  21b3bd:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (DBL_MANT_DIG + 2))) |
  21b3c1:	4c 09 cf             	or     rdi,r9
  21b3c4:	4c 89 d6             	mov    rsi,r10
        switch (sd) {
  21b3c7:	5b                   	pop    rbx
  21b3c8:	41 5e                	pop    r14
  21b3ca:	eb 2d                	jmp    21b3f9 <__floatuntidf+0xd9>
        return 0.0;
  21b3cc:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21b3d0:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to DBL_MANT_DIG bits
    } else {
        a <<= @intCast(u7, DBL_MANT_DIG - sd);
  21b3d1:	b8 35 00 00 00       	mov    eax,0x35
  21b3d6:	29 d0                	sub    eax,edx
  21b3d8:	83 e0 7f             	and    eax,0x7f
  21b3db:	c4 e2 f9 f7 d7       	shlx   rdx,rdi,rax
  21b3e0:	31 c9                	xor    ecx,ecx
  21b3e2:	a8 40                	test   al,0x40
  21b3e4:	48 0f 44 ca          	cmove  rcx,rdx
    if (sd > DBL_MANT_DIG) {
  21b3e8:	48 89 ce             	mov    rsi,rcx
  21b3eb:	48 c1 ee 20          	shr    rsi,0x20
  21b3ef:	eb 48                	jmp    21b439 <__floatuntidf+0x119>
                a <<= 1;
  21b3f1:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  21b3f6:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21b3f9:	b8 02 01 00 00       	mov    eax,0x102
  21b3fe:	c4 e2 78 f7 c7       	bextr  eax,edi,eax
  21b403:	48 09 f8             	or     rax,rdi
        a += 1; // round - this step may add a significant bit
  21b406:	48 83 c0 01          	add    rax,0x1
  21b40a:	48 83 d6 00          	adc    rsi,0x0
            a >>= 1;
  21b40e:	48 89 f1             	mov    rcx,rsi
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  21b411:	48 0f ba e0 37       	bt     rax,0x37
  21b416:	72 10                	jb     21b428 <__floatuntidf+0x108>
  21b418:	48 0f a4 c1 3e       	shld   rcx,rax,0x3e
  21b41d:	48 c1 e8 22          	shr    rax,0x22
  21b421:	c1 e6 1e             	shl    esi,0x1e
  21b424:	09 c6                	or     esi,eax
  21b426:	eb 11                	jmp    21b439 <__floatuntidf+0x119>
            a >>= 1;
  21b428:	48 0f a4 c1 3d       	shld   rcx,rax,0x3d
        if ((a & (u128(1) << DBL_MANT_DIG)) != 0) {
  21b42d:	48 c1 e8 23          	shr    rax,0x23
  21b431:	c1 e6 1d             	shl    esi,0x1d
  21b434:	09 c6                	or     esi,eax
  21b436:	41 89 d3             	mov    r11d,edx
        // a is now rounded to DBL_MANT_DIG bits
    }

    const high: u64 = @bitCast(u32, (e + 1023) << 20) | // exponent
  21b439:	41 c1 e3 14          	shl    r11d,0x14
        (@truncate(u32, a >> 32) & 0x000FFFFF); // mantissa-high
  21b43d:	81 e6 ff ff 0f 00    	and    esi,0xfffff
    const high: u64 = @bitCast(u32, (e + 1023) << 20) | // exponent
  21b443:	42 8d 04 1e          	lea    eax,[rsi+r11*1]
  21b447:	05 00 00 f0 3f       	add    eax,0x3ff00000
    const low = @truncate(u32, a); // mantissa-low

    return @bitCast(f64, low | (high << 32));
  21b44c:	48 c1 e0 20          	shl    rax,0x20
  21b450:	89 c9                	mov    ecx,ecx
  21b452:	48 09 c1             	or     rcx,rax
  21b455:	c4 e1 f9 6e c1       	vmovq  xmm0,rcx
  21b45a:	c3                   	ret    
  21b45b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000021b460 <__floatuntisf>:
const FLT_MANT_DIG = 24;

pub extern fn __floatuntisf(arg: u128) f32 {
    @setRuntimeSafety(is_test);

    if (arg == 0)
  21b460:	48 89 f8             	mov    rax,rdi
  21b463:	48 09 f0             	or     rax,rsi
  21b466:	0f 84 93 00 00 00    	je     21b4ff <__floatuntisf+0x9f>
        return 0.0;

    var a = arg;
    const N: u32 = @sizeOf(u128) * 8;
    const sd = @bitCast(i32, N - @clz(a)); // number of significant digits
  21b46c:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21b471:	f3 48 0f bd cf       	lzcnt  rcx,rdi
  21b476:	83 c1 40             	add    ecx,0x40
  21b479:	48 85 f6             	test   rsi,rsi
  21b47c:	0f 45 c8             	cmovne ecx,eax
  21b47f:	ba 80 00 00 00       	mov    edx,0x80
  21b484:	29 ca                	sub    edx,ecx
    var e: i32 = sd - 1; // exponent
  21b486:	b8 7f 00 00 00       	mov    eax,0x7f
  21b48b:	29 c8                	sub    eax,ecx
    if (sd > FLT_MANT_DIG) {
  21b48d:	83 fa 19             	cmp    edx,0x19
  21b490:	7c 72                	jl     21b504 <__floatuntisf+0xa4>
        //                                                12345678901234567890123456
        //  1 = msb 1 bit
        //  P = bit FLT_MANT_DIG-1 bits to the right of 1
        //  Q = bit FLT_MANT_DIG bits to the right of 1
        //  R = "or" of all bits to the right of Q
        switch (sd) {
  21b492:	0f 84 87 00 00 00    	je     21b51f <__floatuntisf+0xbf>
  21b498:	83 fa 1a             	cmp    edx,0x1a
  21b49b:	0f 84 81 00 00 00    	je     21b522 <__floatuntisf+0xc2>
            },
            FLT_MANT_DIG + 2 => {},
            else => {
                const shift_amt = @bitCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
                const shift_amt_u7 = @intCast(u7, shift_amt);
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  21b4a1:	53                   	push   rbx
  21b4a2:	8d 4a 66             	lea    ecx,[rdx+0x66]
  21b4a5:	83 e1 7f             	and    ecx,0x7f
  21b4a8:	49 89 f9             	mov    r9,rdi
  21b4ab:	49 0f ad f1          	shrd   r9,rsi,cl
                const shift_amt = @bitCast(i32, N + (FLT_MANT_DIG + 2)) - sd;
  21b4af:	41 b8 1a 00 00 00    	mov    r8d,0x1a
  21b4b5:	41 29 d0             	sub    r8d,edx
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  21b4b8:	c4 62 f3 f7 d6       	shrx   r10,rsi,rcx
  21b4bd:	45 31 db             	xor    r11d,r11d
  21b4c0:	f6 c1 40             	test   cl,0x40
  21b4c3:	4d 0f 44 d1          	cmove  r10,r9
                    @boolToInt((a & (u128(@maxValue(u128)) >> shift_amt_u7)) != 0);
  21b4c7:	41 83 e0 7f          	and    r8d,0x7f
  21b4cb:	49 c7 c1 ff ff ff ff 	mov    r9,0xffffffffffffffff
  21b4d2:	c4 c2 bb f7 d9       	shrx   rbx,r9,r8
  21b4d7:	44 89 c1             	mov    ecx,r8d
  21b4da:	4d 0f ad c9          	shrd   r9,r9,cl
  21b4de:	41 f6 c0 40          	test   r8b,0x40
  21b4e2:	4c 0f 45 cb          	cmovne r9,rbx
  21b4e6:	4c 0f 44 db          	cmove  r11,rbx
  21b4ea:	49 21 f9             	and    r9,rdi
  21b4ed:	49 21 f3             	and    r11,rsi
  21b4f0:	31 ff                	xor    edi,edi
  21b4f2:	4d 09 cb             	or     r11,r9
  21b4f5:	40 0f 95 c7          	setne  dil
                a = (a >> @intCast(u7, sd - (FLT_MANT_DIG + 2))) |
  21b4f9:	4c 09 d7             	or     rdi,r10
        switch (sd) {
  21b4fc:	5b                   	pop    rbx
  21b4fd:	eb 23                	jmp    21b522 <__floatuntisf+0xc2>
        return 0.0;
  21b4ff:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21b503:	c3                   	ret    
            a >>= 1;
            e += 1;
        }
        // a is now rounded to FLT_MANT_DIG bits
    } else {
        a <<= @intCast(u7, FLT_MANT_DIG - sd);
  21b504:	be 18 00 00 00       	mov    esi,0x18
  21b509:	29 d6                	sub    esi,edx
  21b50b:	83 e6 7f             	and    esi,0x7f
  21b50e:	c4 e2 c9 f7 d7       	shlx   rdx,rdi,rsi
  21b513:	31 c9                	xor    ecx,ecx
  21b515:	40 f6 c6 40          	test   sil,0x40
  21b519:	48 0f 44 ca          	cmove  rcx,rdx
  21b51d:	eb 28                	jmp    21b547 <__floatuntisf+0xe7>
                a <<= 1;
  21b51f:	48 01 ff             	add    rdi,rdi
        a |= @boolToInt((a & 4) != 0); // Or P into R
  21b522:	b9 02 01 00 00       	mov    ecx,0x102
  21b527:	c4 e2 70 f7 cf       	bextr  ecx,edi,ecx
  21b52c:	48 09 f9             	or     rcx,rdi
        a += 1; // round - this step may add a significant bit
  21b52f:	48 83 c1 01          	add    rcx,0x1
        if ((a & (u128(1) << FLT_MANT_DIG)) != 0) {
  21b533:	f7 c1 00 00 00 04    	test   ecx,0x4000000
  21b539:	75 06                	jne    21b541 <__floatuntisf+0xe1>
  21b53b:	48 c1 e9 02          	shr    rcx,0x2
  21b53f:	eb 06                	jmp    21b547 <__floatuntisf+0xe7>
            a >>= 1;
  21b541:	48 c1 e9 03          	shr    rcx,0x3
  21b545:	89 d0                	mov    eax,edx
        // a is now rounded to FLT_MANT_DIG bits
    }

    const high = @bitCast(u32, (e + 127) << 23); // exponent
  21b547:	c1 e0 17             	shl    eax,0x17
    const low = @truncate(u32, a) & 0x007fffff; // mantissa
  21b54a:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff

    return @bitCast(f32, high | low);
  21b550:	8d 04 08             	lea    eax,[rax+rcx*1]
  21b553:	05 00 00 80 3f       	add    eax,0x3f800000
  21b558:	c5 f9 6e c0          	vmovd  xmm0,eax
  21b55c:	c3                   	ret    
  21b55d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000021b560 <__extenddftf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21b560:	c4 e1 f9 7e c1       	vmovq  rcx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21b565:	b0 3f                	mov    al,0x3f
  21b567:	c4 e2 f8 f5 f1       	bzhi   rsi,rcx,rax
  21b56c:	48 b8 ff ff ff ff ff 	movabs rax,0x7fffffffffffffff
  21b573:	ff ff 7f 
    const sign: src_rep_t = aRep & srcSignMask;
  21b576:	48 83 c0 01          	add    rax,0x1
  21b57a:	48 21 c8             	and    rax,rcx
    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  21b57d:	48 ba 00 00 00 00 00 	movabs rdx,0xfff0000000000000
  21b584:	00 f0 ff 
  21b587:	48 01 f2             	add    rdx,rsi
  21b58a:	48 c1 ea 35          	shr    rdx,0x35
  21b58e:	48 81 fa fe 03 00 00 	cmp    rdx,0x3fe
  21b595:	77 1a                	ja     21b5b1 <__extenddftf2+0x51>
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  21b597:	48 89 f2             	mov    rdx,rsi
  21b59a:	48 c1 e2 3c          	shl    rdx,0x3c
  21b59e:	48 c1 ee 04          	shr    rsi,0x4
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  21b5a2:	48 bf 00 00 00 00 00 	movabs rdi,0x3c00000000000000
  21b5a9:	00 00 3c 
  21b5ac:	48 01 f7             	add    rdi,rsi
  21b5af:	eb 7a                	jmp    21b62b <__extenddftf2+0xcb>
    } else if (aAbs >= srcInfinity) {
  21b5b1:	48 89 f2             	mov    rdx,rsi
  21b5b4:	48 c1 ea 34          	shr    rdx,0x34
  21b5b8:	48 81 fa ff 07 00 00 	cmp    rdx,0x7ff
  21b5bf:	72 17                	jb     21b5d8 <__extenddftf2+0x78>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  21b5c1:	48 89 ca             	mov    rdx,rcx
  21b5c4:	48 c1 e2 3c          	shl    rdx,0x3c
  21b5c8:	48 c1 e9 04          	shr    rcx,0x4
  21b5cc:	48 bf 00 00 00 00 00 	movabs rdi,0x7fff000000000000
  21b5d3:	00 ff 7f 
  21b5d6:	eb 4a                	jmp    21b622 <__extenddftf2+0xc2>
    } else if (aAbs != 0) {
  21b5d8:	48 85 f6             	test   rsi,rsi
  21b5db:	74 4a                	je     21b627 <__extenddftf2+0xc7>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  21b5dd:	f3 48 0f bd ce       	lzcnt  rcx,rsi
  21b5e2:	44 8d 41 75          	lea    r8d,[rcx+0x75]
  21b5e6:	41 83 e0 7f          	and    r8d,0x7f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  21b5ea:	83 c1 31             	add    ecx,0x31
  21b5ed:	83 e1 7f             	and    ecx,0x7f
  21b5f0:	45 31 c9             	xor    r9d,r9d
  21b5f3:	31 ff                	xor    edi,edi
  21b5f5:	48 0f a5 f7          	shld   rdi,rsi,cl
  21b5f9:	c4 e2 f1 f7 d6       	shlx   rdx,rsi,rcx
  21b5fe:	f6 c1 40             	test   cl,0x40
  21b601:	48 0f 45 fa          	cmovne rdi,rdx
  21b605:	49 0f 45 d1          	cmovne rdx,r9
        absResult ^= dstMinNormal;
  21b609:	48 b9 00 00 00 00 00 	movabs rcx,0x1000000000000
  21b610:	00 01 00 
  21b613:	48 31 f9             	xor    rcx,rdi
        const resultExponent: u32 = dstExpBias - srcExpBias - scale + 1;
  21b616:	bf 01 3c 00 00       	mov    edi,0x3c01
  21b61b:	44 29 c7             	sub    edi,r8d
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  21b61e:	48 c1 e7 30          	shl    rdi,0x30
  21b622:	48 09 cf             	or     rdi,rcx
  21b625:	eb 04                	jmp    21b62b <__extenddftf2+0xcb>
  21b627:	31 d2                	xor    edx,edx
  21b629:	31 ff                	xor    edi,edi
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21b62b:	48 89 54 24 e8       	mov    QWORD PTR [rsp-0x18],rdx
  21b630:	48 09 c7             	or     rdi,rax
  21b633:	48 89 7c 24 f0       	mov    QWORD PTR [rsp-0x10],rdi
  21b638:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
    return extendXfYf2(f128, f64, a);
  21b63d:	c3                   	ret    
  21b63e:	66 90                	xchg   ax,ax

000000000021b640 <__extendsftf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21b640:	c5 f9 7e c2          	vmovd  edx,xmm0
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21b644:	89 d1                	mov    ecx,edx
  21b646:	81 e1 ff ff ff 7f    	and    ecx,0x7fffffff
    const sign: src_rep_t = aRep & srcSignMask;
  21b64c:	89 d0                	mov    eax,edx
  21b64e:	25 00 00 00 80       	and    eax,0x80000000
    if (aAbs -% srcMinNormal < srcInfinity - srcMinNormal) {
  21b653:	8d b1 00 00 80 ff    	lea    esi,[rcx-0x800000]
  21b659:	81 fe ff ff ff 7e    	cmp    esi,0x7effffff
  21b65f:	77 17                	ja     21b678 <__extendsftf2+0x38>
        absResult = dst_rep_t(aAbs) << (dstSigBits - srcSigBits);
  21b661:	89 ca                	mov    edx,ecx
  21b663:	48 c1 e2 19          	shl    rdx,0x19
        absResult += (dstExpBias - srcExpBias) << dstSigBits;
  21b667:	48 b9 00 00 00 00 00 	movabs rcx,0x3f80000000000000
  21b66e:	00 80 3f 
  21b671:	48 01 d1             	add    rcx,rdx
  21b674:	31 d2                	xor    edx,edx
  21b676:	eb 6f                	jmp    21b6e7 <__extendsftf2+0xa7>
    } else if (aAbs >= srcInfinity) {
  21b678:	81 f9 00 00 80 7f    	cmp    ecx,0x7f800000
  21b67e:	72 17                	jb     21b697 <__extendsftf2+0x57>
        absResult |= dst_rep_t(aAbs & srcNaNCode) << (dstSigBits - srcSigBits);
  21b680:	89 d2                	mov    edx,edx
  21b682:	48 c1 e2 19          	shl    rdx,0x19
  21b686:	48 b9 00 00 00 00 00 	movabs rcx,0x7fff000000000000
  21b68d:	00 ff 7f 
  21b690:	48 09 d1             	or     rcx,rdx
  21b693:	31 d2                	xor    edx,edx
  21b695:	eb 50                	jmp    21b6e7 <__extendsftf2+0xa7>
    } else if (aAbs != 0) {
  21b697:	85 c9                	test   ecx,ecx
  21b699:	74 48                	je     21b6e3 <__extendsftf2+0xa3>
        const scale: u32 = @clz(aAbs) - @clz(src_rep_t(srcMinNormal));
  21b69b:	f3 0f bd f1          	lzcnt  esi,ecx
  21b69f:	83 c6 38             	add    esi,0x38
  21b6a2:	83 e6 3f             	and    esi,0x3f
        absResult = dst_rep_t(aAbs) << @intCast(DstShift, dstSigBits - srcSigBits + scale);
  21b6a5:	89 ca                	mov    edx,ecx
  21b6a7:	8d 4e 59             	lea    ecx,[rsi+0x59]
  21b6aa:	83 e1 7f             	and    ecx,0x7f
  21b6ad:	45 31 c0             	xor    r8d,r8d
  21b6b0:	31 ff                	xor    edi,edi
  21b6b2:	48 0f a5 d7          	shld   rdi,rdx,cl
  21b6b6:	c4 e2 f1 f7 d2       	shlx   rdx,rdx,rcx
  21b6bb:	f6 c1 40             	test   cl,0x40
  21b6be:	48 0f 45 fa          	cmovne rdi,rdx
  21b6c2:	49 0f 45 d0          	cmovne rdx,r8
        absResult ^= dstMinNormal;
  21b6c6:	49 b8 00 00 00 00 00 	movabs r8,0x1000000000000
  21b6cd:	00 01 00 
  21b6d0:	49 31 f8             	xor    r8,rdi
        const resultExponent: u32 = dstExpBias - srcExpBias - scale + 1;
  21b6d3:	b9 81 3f 00 00       	mov    ecx,0x3f81
  21b6d8:	29 f1                	sub    ecx,esi
        absResult |= @intCast(dst_rep_t, resultExponent) << dstSigBits;
  21b6da:	48 c1 e1 30          	shl    rcx,0x30
  21b6de:	4c 09 c1             	or     rcx,r8
  21b6e1:	eb 04                	jmp    21b6e7 <__extendsftf2+0xa7>
  21b6e3:	31 d2                	xor    edx,edx
  21b6e5:	31 c9                	xor    ecx,ecx
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | dst_rep_t(sign) << (dstBits - srcBits);
  21b6e7:	48 c1 e0 20          	shl    rax,0x20
  21b6eb:	48 89 54 24 e8       	mov    QWORD PTR [rsp-0x18],rdx
  21b6f0:	48 09 c8             	or     rax,rcx
  21b6f3:	48 89 44 24 f0       	mov    QWORD PTR [rsp-0x10],rax
  21b6f8:	0f 28 44 24 e8       	movaps xmm0,XMMWORD PTR [rsp-0x18]
    return extendXfYf2(f128, f32, a);
  21b6fd:	c3                   	ret    
  21b6fe:	66 90                	xchg   ax,ax

000000000021b700 <__trunctfdf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21b700:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  21b706:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  21b70b:	48 8b 54 24 f0       	mov    rdx,QWORD PTR [rsp-0x10]
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21b710:	b0 3f                	mov    al,0x3f
  21b712:	c4 e2 f8 f5 ca       	bzhi   rcx,rdx,rax
    if (aAbs -% underflow < aAbs -% overflow) {
  21b717:	48 b8 00 00 00 00 00 	movabs rax,0xc3ff000000000000
  21b71e:	00 ff c3 
  21b721:	48 01 c8             	add    rax,rcx
  21b724:	48 bf 00 00 00 00 00 	movabs rdi,0xbc01000000000000
  21b72b:	00 01 bc 
  21b72e:	48 01 cf             	add    rdi,rcx
  21b731:	48 39 f8             	cmp    rax,rdi
  21b734:	73 35                	jae    21b76b <__trunctfdf2+0x6b>
  21b736:	48 b8 00 00 00 00 00 	movabs rax,0x4000000000000000
  21b73d:	00 00 40 
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  21b740:	48 89 d1             	mov    rcx,rdx
  21b743:	48 0f a4 f1 04       	shld   rcx,rsi,0x4
        const roundBits: src_rep_t = aAbs & roundMask;
  21b748:	40 b7 3c             	mov    dil,0x3c
  21b74b:	c4 e2 c0 f5 f6       	bzhi   rsi,rsi,rdi
        if (roundBits > halfway) {
  21b750:	48 bf 01 00 00 00 00 	movabs rdi,0x800000000000001
  21b757:	00 00 08 
  21b75a:	48 39 fe             	cmp    rsi,rdi
  21b75d:	72 40                	jb     21b79f <__trunctfdf2+0x9f>
            absResult += 1;
  21b75f:	48 01 c1             	add    rcx,rax
  21b762:	48 83 c1 01          	add    rcx,0x1
  21b766:	e9 0f 01 00 00       	jmp    21b87a <__trunctfdf2+0x17a>
    } else if (aAbs > srcInfinity) {
  21b76b:	48 83 fe 01          	cmp    rsi,0x1
  21b76f:	48 b8 00 00 00 00 00 	movabs rax,0x7fff000000000000
  21b776:	00 ff 7f 
  21b779:	48 89 cf             	mov    rdi,rcx
  21b77c:	48 19 c7             	sbb    rdi,rax
  21b77f:	72 55                	jb     21b7d6 <__trunctfdf2+0xd6>
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  21b781:	48 0f ac d6 3c       	shrd   rsi,rdx,0x3c
  21b786:	b0 33                	mov    al,0x33
  21b788:	c4 e2 f8 f5 c6       	bzhi   rax,rsi,rax
  21b78d:	48 b9 00 00 00 00 00 	movabs rcx,0x7ff8000000000000
  21b794:	00 f8 7f 
  21b797:	48 09 c1             	or     rcx,rax
  21b79a:	e9 db 00 00 00       	jmp    21b87a <__trunctfdf2+0x17a>
  21b79f:	48 01 c1             	add    rcx,rax
        } else if (roundBits == halfway) {
  21b7a2:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  21b7a7:	48 b8 00 00 00 00 00 	movabs rax,0x800000000000000
  21b7ae:	00 00 08 
  21b7b1:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  21b7b6:	c5 f9 74 c1          	vpcmpeqb xmm0,xmm0,xmm1
  21b7ba:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21b7be:	3d ff ff 00 00       	cmp    eax,0xffff
  21b7c3:	0f 85 b1 00 00 00    	jne    21b87a <__trunctfdf2+0x17a>
  21b7c9:	89 c8                	mov    eax,ecx
  21b7cb:	83 e0 01             	and    eax,0x1
  21b7ce:	48 01 c1             	add    rcx,rax
  21b7d1:	e9 a4 00 00 00       	jmp    21b87a <__trunctfdf2+0x17a>
    } else if (aAbs >= overflow) {
  21b7d6:	48 c1 e9 30          	shr    rcx,0x30
  21b7da:	48 81 f9 fe 43 00 00 	cmp    rcx,0x43fe
  21b7e1:	76 0f                	jbe    21b7f2 <__trunctfdf2+0xf2>
  21b7e3:	48 b9 00 00 00 00 00 	movabs rcx,0x7ff0000000000000
  21b7ea:	00 f0 7f 
  21b7ed:	e9 88 00 00 00       	jmp    21b87a <__trunctfdf2+0x17a>
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21b7f2:	b8 00 3c 00 00       	mov    eax,0x3c00
  21b7f7:	29 c8                	sub    eax,ecx
        if (shift > srcSigBits) {
  21b7f9:	83 f8 6f             	cmp    eax,0x6f
  21b7fc:	76 04                	jbe    21b802 <__trunctfdf2+0x102>
  21b7fe:	31 c9                	xor    ecx,ecx
  21b800:	eb 78                	jmp    21b87a <__trunctfdf2+0x17a>
  21b802:	b1 30                	mov    cl,0x30
  21b804:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
  21b809:	49 b8 00 00 00 00 00 	movabs r8,0x1000000000000
  21b810:	00 01 00 
  21b813:	49 09 c8             	or     r8,rcx
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  21b816:	b9 7f 00 00 00       	mov    ecx,0x7f
  21b81b:	29 c1                	sub    ecx,eax
  21b81d:	83 e1 7f             	and    ecx,0x7f
  21b820:	4c 89 c7             	mov    rdi,r8
  21b823:	48 0f a5 f7          	shld   rdi,rsi,cl
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21b827:	83 c0 01             	add    eax,0x1
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  21b82a:	c4 62 f1 f7 ce       	shlx   r9,rsi,rcx
  21b82f:	45 31 d2             	xor    r10d,r10d
  21b832:	f6 c1 40             	test   cl,0x40
  21b835:	49 0f 45 f9          	cmovne rdi,r9
  21b839:	4d 0f 45 ca          	cmovne r9,r10
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  21b83d:	83 e0 7f             	and    eax,0x7f
  21b840:	89 c1                	mov    ecx,eax
  21b842:	4c 0f ad c6          	shrd   rsi,r8,cl
  21b846:	c4 c2 fb f7 c8       	shrx   rcx,r8,rax
  21b84b:	a8 40                	test   al,0x40
  21b84d:	48 0f 45 f1          	cmovne rsi,rcx
  21b851:	49 0f 45 ca          	cmovne rcx,r10
  21b855:	4c 09 ce             	or     rsi,r9
  21b858:	48 09 f9             	or     rcx,rdi
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  21b85b:	48 0f a4 f1 04       	shld   rcx,rsi,0x4
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  21b860:	b0 3c                	mov    al,0x3c
  21b862:	c4 e2 f8 f5 c6       	bzhi   rax,rsi,rax
            if (roundBits > halfway) {
  21b867:	48 be 01 00 00 00 00 	movabs rsi,0x800000000000001
  21b86e:	00 00 08 
  21b871:	48 39 f0             	cmp    rax,rsi
  21b874:	72 1a                	jb     21b890 <__trunctfdf2+0x190>
                absResult += 1;
  21b876:	48 83 c1 01          	add    rcx,0x1
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  21b87a:	48 b8 00 00 00 00 00 	movabs rax,0x8000000000000000
  21b881:	00 00 80 
  21b884:	48 21 c2             	and    rdx,rax
  21b887:	48 09 ca             	or     rdx,rcx
    return @bitCast(dst_t, result);
  21b88a:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
    return truncXfYf2(f64, f128, a);
  21b88f:	c3                   	ret    
            } else if (roundBits == halfway) {
  21b890:	c4 e1 f9 6e c0       	vmovq  xmm0,rax
  21b895:	e9 0d ff ff ff       	jmp    21b7a7 <__trunctfdf2+0xa7>
  21b89a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000021b8a0 <__trunctfsf2>:
    const aRep: src_rep_t = @bitCast(src_rep_t, a);
  21b8a0:	66 0f 7f 44 24 e8    	movdqa XMMWORD PTR [rsp-0x18],xmm0
  21b8a6:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  21b8ab:	48 8b 54 24 f0       	mov    rdx,QWORD PTR [rsp-0x10]
    const aAbs: src_rep_t = aRep & srcAbsMask;
  21b8b0:	b0 3f                	mov    al,0x3f
  21b8b2:	c4 e2 f8 f5 fa       	bzhi   rdi,rdx,rax
    if (aAbs -% underflow < aAbs -% overflow) {
  21b8b7:	48 b8 00 00 00 00 00 	movabs rax,0xc07f000000000000
  21b8be:	00 7f c0 
  21b8c1:	48 01 f8             	add    rax,rdi
  21b8c4:	48 b9 00 00 00 00 00 	movabs rcx,0xbf81000000000000
  21b8cb:	00 81 bf 
  21b8ce:	48 01 f9             	add    rcx,rdi
  21b8d1:	48 39 c8             	cmp    rax,rcx
  21b8d4:	73 29                	jae    21b8ff <__trunctfsf2+0x5f>
        absResult = @truncate(dst_rep_t, aAbs >> (srcSigBits - dstSigBits));
  21b8d6:	48 89 d1             	mov    rcx,rdx
  21b8d9:	48 c1 e9 19          	shr    rcx,0x19
        const roundBits: src_rep_t = aAbs & roundMask;
  21b8dd:	89 d0                	mov    eax,edx
  21b8df:	25 ff ff ff 01       	and    eax,0x1ffffff
        if (roundBits > halfway) {
  21b8e4:	48 83 fe 01          	cmp    rsi,0x1
  21b8e8:	48 89 c7             	mov    rdi,rax
  21b8eb:	48 81 df 00 00 00 01 	sbb    rdi,0x1000000
  21b8f2:	72 39                	jb     21b92d <__trunctfsf2+0x8d>
            absResult += 1;
  21b8f4:	81 c1 01 00 00 40    	add    ecx,0x40000001
  21b8fa:	e9 0e 01 00 00       	jmp    21ba0d <__trunctfsf2+0x16d>
    } else if (aAbs > srcInfinity) {
  21b8ff:	48 83 fe 01          	cmp    rsi,0x1
  21b903:	48 b8 00 00 00 00 00 	movabs rax,0x7fff000000000000
  21b90a:	00 ff 7f 
  21b90d:	48 89 f9             	mov    rcx,rdi
  21b910:	48 19 c1             	sbb    rcx,rax
  21b913:	72 5c                	jb     21b971 <__trunctfsf2+0xd1>
        absResult |= @intCast(dst_rep_t, ((aAbs & srcNaNCode) >> (srcSigBits - dstSigBits)) & dstNaNCode);
  21b915:	48 89 d1             	mov    rcx,rdx
  21b918:	48 c1 e9 19          	shr    rcx,0x19
  21b91c:	81 e1 ff ff 3f 00    	and    ecx,0x3fffff
  21b922:	81 c9 00 00 c0 7f    	or     ecx,0x7fc00000
  21b928:	e9 e0 00 00 00       	jmp    21ba0d <__trunctfsf2+0x16d>
  21b92d:	81 c1 00 00 00 40    	add    ecx,0x40000000
        } else if (roundBits == halfway) {
  21b933:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  21b938:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  21b93d:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  21b941:	b8 00 00 00 01       	mov    eax,0x1000000
  21b946:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  21b94b:	c5 f1 73 f9 08       	vpslldq xmm1,xmm1,0x8
  21b950:	c5 f9 74 c1          	vpcmpeqb xmm0,xmm0,xmm1
  21b954:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21b958:	3d ff ff 00 00       	cmp    eax,0xffff
  21b95d:	0f 85 aa 00 00 00    	jne    21ba0d <__trunctfsf2+0x16d>
  21b963:	89 c8                	mov    eax,ecx
  21b965:	83 e0 01             	and    eax,0x1
  21b968:	01 c8                	add    eax,ecx
  21b96a:	89 c1                	mov    ecx,eax
  21b96c:	e9 9c 00 00 00       	jmp    21ba0d <__trunctfsf2+0x16d>
    } else if (aAbs >= overflow) {
  21b971:	48 c1 ef 30          	shr    rdi,0x30
  21b975:	b9 00 00 80 7f       	mov    ecx,0x7f800000
  21b97a:	48 81 ff 7e 40 00 00 	cmp    rdi,0x407e
  21b981:	0f 87 86 00 00 00    	ja     21ba0d <__trunctfsf2+0x16d>
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21b987:	b8 80 3f 00 00       	mov    eax,0x3f80
  21b98c:	29 f8                	sub    eax,edi
  21b98e:	31 c9                	xor    ecx,ecx
        if (shift > srcSigBits) {
  21b990:	83 f8 6f             	cmp    eax,0x6f
  21b993:	77 78                	ja     21ba0d <__trunctfsf2+0x16d>
  21b995:	b1 30                	mov    cl,0x30
  21b997:	c4 e2 f0 f5 ca       	bzhi   rcx,rdx,rcx
  21b99c:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  21b9a3:	00 01 00 
  21b9a6:	48 09 cf             	or     rdi,rcx
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  21b9a9:	b9 7f 00 00 00       	mov    ecx,0x7f
  21b9ae:	29 c1                	sub    ecx,eax
  21b9b0:	83 e1 7f             	and    ecx,0x7f
  21b9b3:	49 89 f8             	mov    r8,rdi
  21b9b6:	49 0f a5 f0          	shld   r8,rsi,cl
        const shift = @intCast(u32, srcExpBias - dstExpBias - aExp + 1);
  21b9ba:	83 c0 01             	add    eax,0x1
            const sticky: src_rep_t = significand << @intCast(SrcShift, srcBits - shift);
  21b9bd:	c4 62 f1 f7 ce       	shlx   r9,rsi,rcx
  21b9c2:	45 31 d2             	xor    r10d,r10d
  21b9c5:	f6 c1 40             	test   cl,0x40
  21b9c8:	4d 0f 45 c1          	cmovne r8,r9
  21b9cc:	4d 0f 45 ca          	cmovne r9,r10
            const denormalizedSignificand: src_rep_t = significand >> @intCast(SrcShift, shift) | sticky;
  21b9d0:	83 e0 7f             	and    eax,0x7f
  21b9d3:	89 c1                	mov    ecx,eax
  21b9d5:	48 0f ad fe          	shrd   rsi,rdi,cl
  21b9d9:	c4 e2 fb f7 ff       	shrx   rdi,rdi,rax
  21b9de:	a8 40                	test   al,0x40
  21b9e0:	48 0f 45 f7          	cmovne rsi,rdi
  21b9e4:	49 0f 45 fa          	cmovne rdi,r10
  21b9e8:	4c 09 ce             	or     rsi,r9
  21b9eb:	4c 09 c7             	or     rdi,r8
            absResult = @intCast(dst_rep_t, denormalizedSignificand >> (srcSigBits - dstSigBits));
  21b9ee:	48 89 f9             	mov    rcx,rdi
  21b9f1:	48 c1 e9 19          	shr    rcx,0x19
            const roundBits: src_rep_t = denormalizedSignificand & roundMask;
  21b9f5:	81 e7 ff ff ff 01    	and    edi,0x1ffffff
            if (roundBits > halfway) {
  21b9fb:	48 83 fe 01          	cmp    rsi,0x1
  21b9ff:	48 89 f8             	mov    rax,rdi
  21ba02:	48 1d 00 00 00 01    	sbb    rax,0x1000000
  21ba08:	72 14                	jb     21ba1e <__trunctfsf2+0x17e>
                absResult += 1;
  21ba0a:	83 c1 01             	add    ecx,0x1
    const result: dst_rep_t align(@alignOf(dst_t)) = absResult | @truncate(dst_rep_t, sign >> @intCast(SrcShift, srcBits - dstBits));
  21ba0d:	48 c1 ea 20          	shr    rdx,0x20
  21ba11:	81 e2 00 00 00 80    	and    edx,0x80000000
  21ba17:	09 ca                	or     edx,ecx
    return @bitCast(dst_t, result);
  21ba19:	c5 f9 6e c2          	vmovd  xmm0,edx
    return truncXfYf2(f32, f128, a);
  21ba1d:	c3                   	ret    
            } else if (roundBits == halfway) {
  21ba1e:	c4 e1 f9 6e c6       	vmovq  xmm0,rsi
  21ba23:	c4 e1 f9 6e cf       	vmovq  xmm1,rdi
  21ba28:	e9 10 ff ff ff       	jmp    21b93d <__trunctfsf2+0x9d>
  21ba2d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000021ba30 <__fixunssfsi>:

    const implicitBit = (rep_t(1) << significandBits);
    const significandMask = (implicitBit - 1);

    // Break a into sign, exponent, significand
    const aRep: rep_t = @bitCast(rep_t, a);
  21ba30:	c5 f9 7e c1          	vmovd  ecx,xmm0
  21ba34:	31 c0                	xor    eax,eax
    const absMask = signBit - 1;
    const aAbs: rep_t = aRep & absMask;

    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21ba36:	85 c9                	test   ecx,ecx
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
    const significand: rep_t = (aAbs & significandMask) | implicitBit;

    // If either the value or the exponent is negative, the result is zero.
    if (sign == -1 or exponent < 0) return 0;
  21ba38:	78 43                	js     21ba7d <__fixunssfsi+0x4d>
  21ba3a:	89 ca                	mov    edx,ecx
  21ba3c:	c1 ea 17             	shr    edx,0x17
  21ba3f:	0f b6 f2             	movzx  esi,dl
  21ba42:	83 fe 7f             	cmp    esi,0x7f
  21ba45:	72 36                	jb     21ba7d <__fixunssfsi+0x4d>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21ba47:	8d 7e 81             	lea    edi,[rsi-0x7f]
  21ba4a:	b8 ff ff ff ff       	mov    eax,0xffffffff

    // If the value is too large for the integer type, saturate.
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21ba4f:	83 ff 1f             	cmp    edi,0x1f
  21ba52:	77 29                	ja     21ba7d <__fixunssfsi+0x4d>
  21ba54:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  21ba5a:	81 c9 00 00 80 00    	or     ecx,0x800000

    // If 0 <= exponent < significandBits, right shift to get the result.
    // Otherwise, shift left.
    if (exponent < significandBits) {
  21ba60:	81 fe 95 00 00 00    	cmp    esi,0x95
  21ba66:	77 0d                	ja     21ba75 <__fixunssfsi+0x45>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21ba68:	b8 16 00 00 00       	mov    eax,0x16
  21ba6d:	29 d0                	sub    eax,edx
  21ba6f:	c4 e2 7b f7 c1       	shrx   eax,ecx,eax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfsi(a: f32) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u32, a);
  21ba74:	c3                   	ret    
    } else {
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21ba75:	83 c2 0a             	add    edx,0xa
  21ba78:	c4 e2 69 f7 c1       	shlx   eax,ecx,edx
  21ba7d:	c3                   	ret    
  21ba7e:	66 90                	xchg   ax,ax

000000000021ba80 <__fixunssfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21ba80:	c5 f9 7e c1          	vmovd  ecx,xmm0
  21ba84:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21ba86:	85 c9                	test   ecx,ecx
    if (sign == -1 or exponent < 0) return 0;
  21ba88:	78 47                	js     21bad1 <__fixunssfdi+0x51>
  21ba8a:	89 ca                	mov    edx,ecx
  21ba8c:	c1 ea 17             	shr    edx,0x17
  21ba8f:	0f b6 f2             	movzx  esi,dl
  21ba92:	83 fe 7f             	cmp    esi,0x7f
  21ba95:	72 3a                	jb     21bad1 <__fixunssfdi+0x51>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21ba97:	8d 7e 81             	lea    edi,[rsi-0x7f]
  21ba9a:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21baa1:	83 ff 3f             	cmp    edi,0x3f
  21baa4:	77 2b                	ja     21bad1 <__fixunssfdi+0x51>
  21baa6:	81 e1 ff ff 7f 00    	and    ecx,0x7fffff
  21baac:	81 c9 00 00 80 00    	or     ecx,0x800000
    if (exponent < significandBits) {
  21bab2:	81 fe 95 00 00 00    	cmp    esi,0x95
  21bab8:	77 0d                	ja     21bac7 <__fixunssfdi+0x47>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21baba:	b8 16 00 00 00       	mov    eax,0x16
  21babf:	29 d0                	sub    eax,edx
  21bac1:	c4 e2 7b f7 c1       	shrx   eax,ecx,eax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfdi(a: f32) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u64, a);
  21bac6:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21bac7:	89 c8                	mov    eax,ecx
  21bac9:	83 c2 2a             	add    edx,0x2a
  21bacc:	c4 e2 e9 f7 c0       	shlx   rax,rax,rdx
  21bad1:	c3                   	ret    
  21bad2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21bad9:	1f 84 00 00 00 00 00 

000000000021bae0 <__fixunssfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bae0:	c5 f9 7e c6          	vmovd  esi,xmm0
  21bae4:	31 d2                	xor    edx,edx
  21bae6:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21baeb:	85 f6                	test   esi,esi
    if (sign == -1 or exponent < 0) return 0;
  21baed:	78 68                	js     21bb57 <__fixunssfti+0x77>
  21baef:	89 f1                	mov    ecx,esi
  21baf1:	c1 e9 17             	shr    ecx,0x17
  21baf4:	0f b6 f9             	movzx  edi,cl
  21baf7:	83 ff 7f             	cmp    edi,0x7f
  21bafa:	72 5b                	jb     21bb57 <__fixunssfti+0x77>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bafc:	44 8d 47 81          	lea    r8d,[rdi-0x7f]
  21bb00:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  21bb07:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bb0e:	41 83 f8 7f          	cmp    r8d,0x7f
  21bb12:	77 43                	ja     21bb57 <__fixunssfti+0x77>
  21bb14:	81 e6 ff ff 7f 00    	and    esi,0x7fffff
  21bb1a:	81 ce 00 00 80 00    	or     esi,0x800000
    if (exponent < significandBits) {
  21bb20:	81 ff 95 00 00 00    	cmp    edi,0x95
  21bb26:	77 0f                	ja     21bb37 <__fixunssfti+0x57>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21bb28:	b8 16 00 00 00       	mov    eax,0x16
  21bb2d:	29 c8                	sub    eax,ecx
  21bb2f:	c4 e2 7b f7 c6       	shrx   eax,esi,eax
  21bb34:	31 d2                	xor    edx,edx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunssfti(a: f32) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f32, u128, a);
  21bb36:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21bb37:	89 f0                	mov    eax,esi
  21bb39:	83 c1 6a             	add    ecx,0x6a
  21bb3c:	83 e1 7f             	and    ecx,0x7f
  21bb3f:	31 d2                	xor    edx,edx
  21bb41:	48 0f a5 c2          	shld   rdx,rax,cl
  21bb45:	31 f6                	xor    esi,esi
  21bb47:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  21bb4c:	f6 c1 40             	test   cl,0x40
  21bb4f:	48 0f 45 d0          	cmovne rdx,rax
  21bb53:	48 0f 45 c6          	cmovne rax,rsi
  21bb57:	c3                   	ret    
  21bb58:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21bb5f:	00 

000000000021bb60 <__fixunsdfsi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bb60:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  21bb65:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21bb67:	48 85 d2             	test   rdx,rdx
    if (sign == -1 or exponent < 0) return 0;
  21bb6a:	78 4b                	js     21bbb7 <__fixunsdfsi+0x57>
  21bb6c:	48 89 d1             	mov    rcx,rdx
  21bb6f:	48 c1 e9 34          	shr    rcx,0x34
  21bb73:	89 ce                	mov    esi,ecx
  21bb75:	81 e6 ff 07 00 00    	and    esi,0x7ff
  21bb7b:	81 fe ff 03 00 00    	cmp    esi,0x3ff
  21bb81:	72 34                	jb     21bbb7 <__fixunsdfsi+0x57>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bb83:	81 c6 01 fc ff ff    	add    esi,0xfffffc01
  21bb89:	b8 ff ff ff ff       	mov    eax,0xffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bb8e:	83 fe 1f             	cmp    esi,0x1f
  21bb91:	77 24                	ja     21bbb7 <__fixunsdfsi+0x57>
  21bb93:	b0 34                	mov    al,0x34
  21bb95:	c4 e2 f8 f5 c2       	bzhi   rax,rdx,rax
  21bb9a:	48 ba ff ff ff ff ff 	movabs rdx,0xfffffffffffff
  21bba1:	ff 0f 00 
  21bba4:	48 83 c2 01          	add    rdx,0x1
  21bba8:	48 09 c2             	or     rdx,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21bbab:	b8 33 00 00 00       	mov    eax,0x33
  21bbb0:	29 c8                	sub    eax,ecx
  21bbb2:	c4 e2 fb f7 c2       	shrx   rax,rdx,rax
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfsi(a: f64) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u32, a);
  21bbb7:	c3                   	ret    
  21bbb8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21bbbf:	00 

000000000021bbc0 <__fixunsdfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bbc0:	c4 e1 f9 7e c2       	vmovq  rdx,xmm0
  21bbc5:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21bbc7:	48 85 d2             	test   rdx,rdx
    if (sign == -1 or exponent < 0) return 0;
  21bbca:	78 5e                	js     21bc2a <__fixunsdfdi+0x6a>
  21bbcc:	48 89 d1             	mov    rcx,rdx
  21bbcf:	48 c1 e9 34          	shr    rcx,0x34
  21bbd3:	89 ce                	mov    esi,ecx
  21bbd5:	81 e6 ff 07 00 00    	and    esi,0x7ff
  21bbdb:	81 fe ff 03 00 00    	cmp    esi,0x3ff
  21bbe1:	72 47                	jb     21bc2a <__fixunsdfdi+0x6a>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bbe3:	8d be 01 fc ff ff    	lea    edi,[rsi-0x3ff]
  21bbe9:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bbf0:	83 ff 3f             	cmp    edi,0x3f
  21bbf3:	77 35                	ja     21bc2a <__fixunsdfdi+0x6a>
  21bbf5:	b0 34                	mov    al,0x34
  21bbf7:	c4 e2 f8 f5 d2       	bzhi   rdx,rdx,rax
  21bbfc:	48 b8 ff ff ff ff ff 	movabs rax,0xfffffffffffff
  21bc03:	ff 0f 00 
  21bc06:	48 83 c0 01          	add    rax,0x1
  21bc0a:	48 09 d0             	or     rax,rdx
    if (exponent < significandBits) {
  21bc0d:	81 fe 32 04 00 00    	cmp    esi,0x432
  21bc13:	77 0d                	ja     21bc22 <__fixunsdfdi+0x62>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21bc15:	ba 33 00 00 00       	mov    edx,0x33
  21bc1a:	29 ca                	sub    edx,ecx
  21bc1c:	c4 e2 eb f7 c0       	shrx   rax,rax,rdx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfdi(a: f64) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u64, a);
  21bc21:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21bc22:	83 c1 0d             	add    ecx,0xd
  21bc25:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  21bc2a:	c3                   	ret    
  21bc2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000021bc30 <__fixunsdfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bc30:	c4 e1 f9 7e c6       	vmovq  rsi,xmm0
  21bc35:	31 d2                	xor    edx,edx
  21bc37:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21bc3c:	48 85 f6             	test   rsi,rsi
    if (sign == -1 or exponent < 0) return 0;
  21bc3f:	78 7f                	js     21bcc0 <__fixunsdfti+0x90>
  21bc41:	48 89 f1             	mov    rcx,rsi
  21bc44:	48 c1 e9 34          	shr    rcx,0x34
  21bc48:	89 cf                	mov    edi,ecx
  21bc4a:	81 e7 ff 07 00 00    	and    edi,0x7ff
  21bc50:	81 ff ff 03 00 00    	cmp    edi,0x3ff
  21bc56:	72 68                	jb     21bcc0 <__fixunsdfti+0x90>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bc58:	44 8d 87 01 fc ff ff 	lea    r8d,[rdi-0x3ff]
  21bc5f:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  21bc66:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bc6d:	41 83 f8 7f          	cmp    r8d,0x7f
  21bc71:	77 4d                	ja     21bcc0 <__fixunsdfti+0x90>
  21bc73:	b0 34                	mov    al,0x34
  21bc75:	c4 e2 f8 f5 d6       	bzhi   rdx,rsi,rax
  21bc7a:	48 b8 ff ff ff ff ff 	movabs rax,0xfffffffffffff
  21bc81:	ff 0f 00 
  21bc84:	48 83 c0 01          	add    rax,0x1
  21bc88:	48 09 d0             	or     rax,rdx
    if (exponent < significandBits) {
  21bc8b:	81 ff 32 04 00 00    	cmp    edi,0x432
  21bc91:	77 0f                	ja     21bca2 <__fixunsdfti+0x72>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21bc93:	ba 33 00 00 00       	mov    edx,0x33
  21bc98:	29 ca                	sub    edx,ecx
  21bc9a:	c4 e2 eb f7 c0       	shrx   rax,rax,rdx
  21bc9f:	31 d2                	xor    edx,edx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunsdfti(a: f64) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f64, u128, a);
  21bca1:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21bca2:	8d 49 4d             	lea    ecx,[rcx+0x4d]
  21bca5:	83 e1 7f             	and    ecx,0x7f
  21bca8:	31 d2                	xor    edx,edx
  21bcaa:	48 0f a5 c2          	shld   rdx,rax,cl
  21bcae:	31 f6                	xor    esi,esi
  21bcb0:	c4 e2 f1 f7 c0       	shlx   rax,rax,rcx
  21bcb5:	f6 c1 40             	test   cl,0x40
  21bcb8:	48 0f 45 d0          	cmovne rdx,rax
  21bcbc:	48 0f 45 c6          	cmovne rax,rsi
  21bcc0:	c3                   	ret    
  21bcc1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21bcc8:	0f 1f 84 00 00 00 00 
  21bccf:	00 

000000000021bcd0 <__fixunstfsi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bcd0:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  21bcd5:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  21bcda:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21bcdc:	48 85 c9             	test   rcx,rcx
    if (sign == -1 or exponent < 0) return 0;
  21bcdf:	78 5a                	js     21bd3b <__fixunstfsi+0x6b>
  21bce1:	48 89 ca             	mov    rdx,rcx
  21bce4:	48 c1 ea 30          	shr    rdx,0x30
  21bce8:	89 d6                	mov    esi,edx
  21bcea:	81 e6 ff 7f 00 00    	and    esi,0x7fff
  21bcf0:	81 fe ff 3f 00 00    	cmp    esi,0x3fff
  21bcf6:	72 43                	jb     21bd3b <__fixunstfsi+0x6b>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bcf8:	81 c6 01 c0 ff ff    	add    esi,0xffffc001
  21bcfe:	b8 ff ff ff ff       	mov    eax,0xffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bd03:	83 fe 1f             	cmp    esi,0x1f
  21bd06:	77 33                	ja     21bd3b <__fixunstfsi+0x6b>
  21bd08:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  21bd0d:	b0 30                	mov    al,0x30
  21bd0f:	c4 e2 f8 f5 c1       	bzhi   rax,rcx,rax
  21bd14:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  21bd1b:	00 01 00 
  21bd1e:	48 09 c7             	or     rdi,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21bd21:	b9 6f 00 00 00       	mov    ecx,0x6f
  21bd26:	29 d1                	sub    ecx,edx
  21bd28:	83 e1 7f             	and    ecx,0x7f
  21bd2b:	48 0f ad fe          	shrd   rsi,rdi,cl
  21bd2f:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  21bd34:	f6 c1 40             	test   cl,0x40
  21bd37:	48 0f 44 c6          	cmove  rax,rsi
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfsi(a: f128) u32 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u32, a);
  21bd3b:	c3                   	ret    
  21bd3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000021bd40 <__fixunstfdi>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bd40:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  21bd45:	48 8b 4c 24 f0       	mov    rcx,QWORD PTR [rsp-0x10]
  21bd4a:	31 c0                	xor    eax,eax
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21bd4c:	48 85 c9             	test   rcx,rcx
    if (sign == -1 or exponent < 0) return 0;
  21bd4f:	78 5c                	js     21bdad <__fixunstfdi+0x6d>
  21bd51:	48 89 ca             	mov    rdx,rcx
  21bd54:	48 c1 ea 30          	shr    rdx,0x30
  21bd58:	89 d6                	mov    esi,edx
  21bd5a:	81 e6 ff 7f 00 00    	and    esi,0x7fff
  21bd60:	81 fe ff 3f 00 00    	cmp    esi,0x3fff
  21bd66:	72 45                	jb     21bdad <__fixunstfdi+0x6d>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bd68:	81 c6 01 c0 ff ff    	add    esi,0xffffc001
  21bd6e:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bd75:	83 fe 3f             	cmp    esi,0x3f
  21bd78:	77 33                	ja     21bdad <__fixunstfdi+0x6d>
  21bd7a:	48 8b 74 24 e8       	mov    rsi,QWORD PTR [rsp-0x18]
  21bd7f:	b0 30                	mov    al,0x30
  21bd81:	c4 e2 f8 f5 c1       	bzhi   rax,rcx,rax
  21bd86:	48 bf 00 00 00 00 00 	movabs rdi,0x1000000000000
  21bd8d:	00 01 00 
  21bd90:	48 09 c7             	or     rdi,rax
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21bd93:	b9 6f 00 00 00       	mov    ecx,0x6f
  21bd98:	29 d1                	sub    ecx,edx
  21bd9a:	83 e1 7f             	and    ecx,0x7f
  21bd9d:	48 0f ad fe          	shrd   rsi,rdi,cl
  21bda1:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  21bda6:	f6 c1 40             	test   cl,0x40
  21bda9:	48 0f 44 c6          	cmove  rax,rsi
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfdi(a: f128) u64 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u64, a);
  21bdad:	c3                   	ret    
  21bdae:	66 90                	xchg   ax,ax

000000000021bdb0 <__fixunstfti>:
    const aRep: rep_t = @bitCast(rep_t, a);
  21bdb0:	0f 29 44 24 e8       	movaps XMMWORD PTR [rsp-0x18],xmm0
  21bdb5:	48 8b 74 24 f0       	mov    rsi,QWORD PTR [rsp-0x10]
  21bdba:	31 d2                	xor    edx,edx
  21bdbc:	b8 00 00 00 00       	mov    eax,0x0
    const sign = if ((aRep & signBit) != 0) i32(-1) else i32(1);
  21bdc1:	48 85 f6             	test   rsi,rsi
    if (sign == -1 or exponent < 0) return 0;
  21bdc4:	0f 88 93 00 00 00    	js     21be5d <__fixunstfti+0xad>
  21bdca:	48 89 f1             	mov    rcx,rsi
  21bdcd:	48 c1 e9 30          	shr    rcx,0x30
  21bdd1:	89 cf                	mov    edi,ecx
  21bdd3:	81 e7 ff 7f 00 00    	and    edi,0x7fff
  21bdd9:	81 ff ff 3f 00 00    	cmp    edi,0x3fff
  21bddf:	72 7c                	jb     21be5d <__fixunstfti+0xad>
    const exponent = @intCast(i32, aAbs >> significandBits) - exponentBias;
  21bde1:	44 8d 87 01 c0 ff ff 	lea    r8d,[rdi-0x3fff]
  21bde8:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  21bdef:	48 c7 c2 ff ff ff ff 	mov    rdx,0xffffffffffffffff
    if (@intCast(c_uint, exponent) >= fixuint_t.bit_count) return ~fixuint_t(0);
  21bdf6:	41 83 f8 7f          	cmp    r8d,0x7f
  21bdfa:	77 61                	ja     21be5d <__fixunstfti+0xad>
  21bdfc:	48 8b 44 24 e8       	mov    rax,QWORD PTR [rsp-0x18]
  21be01:	b2 30                	mov    dl,0x30
  21be03:	c4 e2 e8 f5 f6       	bzhi   rsi,rsi,rdx
  21be08:	48 ba 00 00 00 00 00 	movabs rdx,0x1000000000000
  21be0f:	00 01 00 
  21be12:	48 09 f2             	or     rdx,rsi
    if (exponent < significandBits) {
  21be15:	81 ff 6e 40 00 00    	cmp    edi,0x406e
  21be1b:	77 24                	ja     21be41 <__fixunstfti+0x91>
        return @intCast(fixuint_t, significand >> @intCast(Log2Int(rep_t), significandBits - exponent));
  21be1d:	be 6f 00 00 00       	mov    esi,0x6f
  21be22:	29 ce                	sub    esi,ecx
  21be24:	83 e6 7f             	and    esi,0x7f
  21be27:	89 f1                	mov    ecx,esi
  21be29:	48 0f ad d0          	shrd   rax,rdx,cl
  21be2d:	c4 e2 cb f7 ca       	shrx   rcx,rdx,rsi
  21be32:	31 d2                	xor    edx,edx
  21be34:	40 f6 c6 40          	test   sil,0x40
  21be38:	48 0f 45 c1          	cmovne rax,rcx
  21be3c:	48 0f 44 d1          	cmove  rdx,rcx
const fixuint = @import("fixuint.zig").fixuint;
const builtin = @import("builtin");

pub extern fn __fixunstfti(a: f128) u128 {
    @setRuntimeSafety(builtin.is_test);
    return fixuint(f128, u128, a);
  21be40:	c3                   	ret    
        return @intCast(fixuint_t, significand) << @intCast(Log2Int(fixuint_t), exponent - significandBits);
  21be41:	83 c1 11             	add    ecx,0x11
  21be44:	83 e1 7f             	and    ecx,0x7f
  21be47:	48 0f a5 c2          	shld   rdx,rax,cl
  21be4b:	c4 e2 f1 f7 f0       	shlx   rsi,rax,rcx
  21be50:	31 c0                	xor    eax,eax
  21be52:	f6 c1 40             	test   cl,0x40
  21be55:	48 0f 45 d6          	cmovne rdx,rsi
  21be59:	48 0f 44 c6          	cmove  rax,rsi
  21be5d:	c3                   	ret    
  21be5e:	66 90                	xchg   ax,ax

000000000021be60 <__udivsi3>:
    const d = __udivsi3(a, b);
    rem.* = @bitCast(u32, @bitCast(i32, a) -% (@bitCast(i32, d) * @bitCast(i32, b)));
    return d;
}

extern fn __udivsi3(n: u32, d: u32) u32 {
  21be60:	55                   	push   rbp
  21be61:	41 56                	push   r14
  21be63:	53                   	push   rbx
  21be64:	31 c0                	xor    eax,eax
    @setRuntimeSafety(is_test);

    const n_uword_bits: c_uint = u32.bit_count;
    // special cases
    if (d == 0) return 0; // ?!
    if (n == 0) return 0;
  21be66:	85 ff                	test   edi,edi
    if (d == 0) return 0; // ?!
  21be68:	74 19                	je     21be83 <__udivsi3+0x23>
  21be6a:	85 f6                	test   esi,esi
  21be6c:	74 15                	je     21be83 <__udivsi3+0x23>
    var sr = @bitCast(c_uint, c_int(@clz(d)) - c_int(@clz(n)));
  21be6e:	f3 0f bd ce          	lzcnt  ecx,esi
  21be72:	f3 0f bd d7          	lzcnt  edx,edi
  21be76:	89 cb                	mov    ebx,ecx
  21be78:	29 d3                	sub    ebx,edx
    // 0 <= sr <= n_uword_bits - 1 or sr large
    if (sr > n_uword_bits - 1) {
  21be7a:	83 fb 1f             	cmp    ebx,0x1f
  21be7d:	77 04                	ja     21be83 <__udivsi3+0x23>
        // d > r
        return 0;
    }
    if (sr == n_uword_bits - 1) {
  21be7f:	75 07                	jne    21be88 <__udivsi3+0x28>
  21be81:	89 f8                	mov    eax,edi
  21be83:	5b                   	pop    rbx
  21be84:	41 5e                	pop    r14
  21be86:	5d                   	pop    rbp
  21be87:	c3                   	ret    
        // d == 1
        return n;
    }
    sr += 1;
  21be88:	44 8d 4b 01          	lea    r9d,[rbx+0x1]
    // 1 <= sr <= n_uword_bits - 1
    // Not a special case
    var q: u32 = n << @intCast(u5, n_uword_bits - sr);
  21be8c:	b8 1f 00 00 00       	mov    eax,0x1f
  21be91:	29 d8                	sub    eax,ebx
  21be93:	c4 e2 79 f7 c7       	shlx   eax,edi,eax
    var r: u32 = n >> @intCast(u5, sr);
  21be98:	c4 e2 33 f7 ff       	shrx   edi,edi,r9d
  21be9d:	44 8d 46 ff          	lea    r8d,[rsi-0x1]
    var carry: u32 = 0;
    while (sr > 0) : (sr -= 1) {
  21bea1:	41 83 e1 03          	and    r9d,0x3
  21bea5:	83 fb 03             	cmp    ebx,0x3
  21bea8:	73 10                	jae    21beba <__udivsi3+0x5a>
  21beaa:	31 c9                	xor    ecx,ecx
  21beac:	45 85 c9             	test   r9d,r9d
  21beaf:	0f 85 a6 00 00 00    	jne    21bf5b <__udivsi3+0xfb>
  21beb5:	e9 c5 00 00 00       	jmp    21bf7f <__udivsi3+0x11f>
  21beba:	42 8d 14 0a          	lea    edx,[rdx+r9*1]
  21bebe:	83 c2 ff             	add    edx,0xffffffff
  21bec1:	29 ca                	sub    edx,ecx
  21bec3:	31 c9                	xor    ecx,ecx
  21bec5:	41 ba 1e 01 00 00    	mov    r10d,0x11e
  21becb:	41 bb 1d 01 00 00    	mov    r11d,0x11d
  21bed1:	41 be 1c 01 00 00    	mov    r14d,0x11c
  21bed7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21bede:	00 00 
        // r:q = ((r:q)  << 1) | carry
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21bee0:	0f a4 c7 01          	shld   edi,eax,0x1
        q = (q << 1) | carry;
  21bee4:	8d 1c 00             	lea    ebx,[rax+rax*1]
  21bee7:	09 cb                	or     ebx,ecx
        // if (r.all >= d.all)
        // {
        //      r.all -= d.all;
        //      carry = 1;
        // }
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21bee9:	44 89 c1             	mov    ecx,r8d
  21beec:	29 f9                	sub    ecx,edi
  21beee:	c1 f9 1f             	sar    ecx,0x1f
        carry = @intCast(u32, s & 1);
  21bef1:	89 cd                	mov    ebp,ecx
  21bef3:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21bef6:	21 f1                	and    ecx,esi
  21bef8:	29 cf                	sub    edi,ecx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21befa:	c4 e2 28 f7 c8       	bextr  ecx,eax,r10d
  21beff:	8d 0c 79             	lea    ecx,[rcx+rdi*2]
        q = (q << 1) | carry;
  21bf02:	8d 7c 5d 00          	lea    edi,[rbp+rbx*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21bf06:	44 89 c3             	mov    ebx,r8d
  21bf09:	29 cb                	sub    ebx,ecx
  21bf0b:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21bf0e:	89 dd                	mov    ebp,ebx
  21bf10:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21bf13:	21 f3                	and    ebx,esi
  21bf15:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21bf17:	c4 e2 20 f7 d8       	bextr  ebx,eax,r11d
  21bf1c:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  21bf1f:	8d 5c 7d 00          	lea    ebx,[rbp+rdi*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21bf23:	44 89 c7             	mov    edi,r8d
  21bf26:	29 cf                	sub    edi,ecx
  21bf28:	c1 ff 1f             	sar    edi,0x1f
        carry = @intCast(u32, s & 1);
  21bf2b:	89 fd                	mov    ebp,edi
  21bf2d:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21bf30:	21 f7                	and    edi,esi
  21bf32:	29 f9                	sub    ecx,edi
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21bf34:	c4 e2 08 f7 c0       	bextr  eax,eax,r14d
  21bf39:	8d 3c 48             	lea    edi,[rax+rcx*2]
        q = (q << 1) | carry;
  21bf3c:	8d 44 5d 00          	lea    eax,[rbp+rbx*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21bf40:	44 89 c3             	mov    ebx,r8d
  21bf43:	29 fb                	sub    ebx,edi
  21bf45:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21bf48:	89 d9                	mov    ecx,ebx
  21bf4a:	83 e1 01             	and    ecx,0x1
        r -= d & @bitCast(u32, s);
  21bf4d:	21 f3                	and    ebx,esi
  21bf4f:	29 df                	sub    edi,ebx
    while (sr > 0) : (sr -= 1) {
  21bf51:	83 c2 04             	add    edx,0x4
  21bf54:	75 8a                	jne    21bee0 <__udivsi3+0x80>
  21bf56:	45 85 c9             	test   r9d,r9d
  21bf59:	74 24                	je     21bf7f <__udivsi3+0x11f>
  21bf5b:	41 f7 d9             	neg    r9d
  21bf5e:	66 90                	xchg   ax,ax
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21bf60:	0f a4 c7 01          	shld   edi,eax,0x1
        q = (q << 1) | carry;
  21bf64:	01 c0                	add    eax,eax
  21bf66:	09 c8                	or     eax,ecx
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21bf68:	44 89 c2             	mov    edx,r8d
  21bf6b:	29 fa                	sub    edx,edi
  21bf6d:	c1 fa 1f             	sar    edx,0x1f
        carry = @intCast(u32, s & 1);
  21bf70:	89 d1                	mov    ecx,edx
  21bf72:	83 e1 01             	and    ecx,0x1
        r -= d & @bitCast(u32, s);
  21bf75:	21 f2                	and    edx,esi
  21bf77:	29 d7                	sub    edi,edx
    while (sr > 0) : (sr -= 1) {
  21bf79:	41 83 c1 01          	add    r9d,0x1
  21bf7d:	75 e1                	jne    21bf60 <__udivsi3+0x100>
    }
    q = (q << 1) | carry;
  21bf7f:	01 c0                	add    eax,eax
  21bf81:	09 c8                	or     eax,ecx
  21bf83:	5b                   	pop    rbx
  21bf84:	41 5e                	pop    r14
  21bf86:	5d                   	pop    rbp
  21bf87:	c3                   	ret    
  21bf88:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21bf8f:	00 

000000000021bf90 <__udivdi3>:
    return __udivmoddi4(a, b, null);
  21bf90:	31 d2                	xor    edx,edx
  21bf92:	e9 a9 e6 ff ff       	jmp    21a640 <__udivmoddi4>
  21bf97:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  21bf9e:	00 00 

000000000021bfa0 <__umoddi3>:
extern fn __umoddi3(a: u64, b: u64) u64 {
  21bfa0:	50                   	push   rax
  21bfa1:	48 89 e2             	mov    rdx,rsp
    _ = __udivmoddi4(a, b, &r);
  21bfa4:	e8 97 e6 ff ff       	call   21a640 <__udivmoddi4>
    return r;
  21bfa9:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  21bfad:	59                   	pop    rcx
  21bfae:	c3                   	ret    
  21bfaf:	90                   	nop

000000000021bfb0 <__udivmodsi4>:
extern fn __udivmodsi4(a: u32, b: u32, rem: *u32) u32 {
  21bfb0:	55                   	push   rbp
  21bfb1:	41 57                	push   r15
  21bfb3:	41 56                	push   r14
  21bfb5:	41 55                	push   r13
  21bfb7:	41 54                	push   r12
  21bfb9:	53                   	push   rbx
  21bfba:	31 c0                	xor    eax,eax
    if (n == 0) return 0;
  21bfbc:	85 ff                	test   edi,edi
    if (d == 0) return 0; // ?!
  21bfbe:	0f 84 33 01 00 00    	je     21c0f7 <__udivmodsi4+0x147>
  21bfc4:	85 f6                	test   esi,esi
  21bfc6:	0f 84 2b 01 00 00    	je     21c0f7 <__udivmodsi4+0x147>
    var sr = @bitCast(c_uint, c_int(@clz(d)) - c_int(@clz(n)));
  21bfcc:	f3 44 0f bd de       	lzcnt  r11d,esi
  21bfd1:	f3 0f bd df          	lzcnt  ebx,edi
  21bfd5:	44 89 dd             	mov    ebp,r11d
  21bfd8:	29 dd                	sub    ebp,ebx
    if (sr > n_uword_bits - 1) {
  21bfda:	83 fd 1f             	cmp    ebp,0x1f
  21bfdd:	0f 87 14 01 00 00    	ja     21c0f7 <__udivmodsi4+0x147>
  21bfe3:	89 f8                	mov    eax,edi
    if (sr == n_uword_bits - 1) {
  21bfe5:	0f 84 0c 01 00 00    	je     21c0f7 <__udivmodsi4+0x147>
    sr += 1;
  21bfeb:	44 8d 4d 01          	lea    r9d,[rbp+0x1]
    var q: u32 = n << @intCast(u5, n_uword_bits - sr);
  21bfef:	b8 1f 00 00 00       	mov    eax,0x1f
  21bff4:	29 e8                	sub    eax,ebp
  21bff6:	c4 e2 79 f7 c7       	shlx   eax,edi,eax
    var r: u32 = n >> @intCast(u5, sr);
  21bffb:	c4 e2 33 f7 cf       	shrx   ecx,edi,r9d
  21c000:	44 8d 46 ff          	lea    r8d,[rsi-0x1]
    while (sr > 0) : (sr -= 1) {
  21c004:	41 83 e1 03          	and    r9d,0x3
  21c008:	83 fd 03             	cmp    ebp,0x3
  21c00b:	73 11                	jae    21c01e <__udivmodsi4+0x6e>
  21c00d:	45 31 db             	xor    r11d,r11d
  21c010:	45 85 c9             	test   r9d,r9d
  21c013:	0f 85 aa 00 00 00    	jne    21c0c3 <__udivmodsi4+0x113>
  21c019:	e9 d4 00 00 00       	jmp    21c0f2 <__udivmodsi4+0x142>
  21c01e:	46 8d 14 0b          	lea    r10d,[rbx+r9*1]
  21c022:	41 83 c2 ff          	add    r10d,0xffffffff
  21c026:	45 29 da             	sub    r10d,r11d
  21c029:	45 31 db             	xor    r11d,r11d
  21c02c:	41 be 1e 01 00 00    	mov    r14d,0x11e
  21c032:	41 bf 1d 01 00 00    	mov    r15d,0x11d
  21c038:	41 bc 1c 01 00 00    	mov    r12d,0x11c
  21c03e:	66 90                	xchg   ax,ax
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c040:	0f a4 c1 01          	shld   ecx,eax,0x1
        q = (q << 1) | carry;
  21c044:	44 8d 2c 00          	lea    r13d,[rax+rax*1]
  21c048:	45 09 dd             	or     r13d,r11d
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c04b:	44 89 c3             	mov    ebx,r8d
  21c04e:	29 cb                	sub    ebx,ecx
  21c050:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21c053:	89 dd                	mov    ebp,ebx
  21c055:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21c058:	21 f3                	and    ebx,esi
  21c05a:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c05c:	c4 e2 08 f7 d8       	bextr  ebx,eax,r14d
  21c061:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  21c064:	46 8d 5c 6d 00       	lea    r11d,[rbp+r13*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c069:	44 89 c3             	mov    ebx,r8d
  21c06c:	29 cb                	sub    ebx,ecx
  21c06e:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21c071:	89 dd                	mov    ebp,ebx
  21c073:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21c076:	21 f3                	and    ebx,esi
  21c078:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c07a:	c4 e2 00 f7 d8       	bextr  ebx,eax,r15d
  21c07f:	8d 0c 4b             	lea    ecx,[rbx+rcx*2]
        q = (q << 1) | carry;
  21c082:	46 8d 5c 5d 00       	lea    r11d,[rbp+r11*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c087:	44 89 c3             	mov    ebx,r8d
  21c08a:	29 cb                	sub    ebx,ecx
  21c08c:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21c08f:	89 dd                	mov    ebp,ebx
  21c091:	83 e5 01             	and    ebp,0x1
        r -= d & @bitCast(u32, s);
  21c094:	21 f3                	and    ebx,esi
  21c096:	29 d9                	sub    ecx,ebx
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c098:	c4 e2 18 f7 c0       	bextr  eax,eax,r12d
  21c09d:	8d 0c 48             	lea    ecx,[rax+rcx*2]
        q = (q << 1) | carry;
  21c0a0:	42 8d 44 5d 00       	lea    eax,[rbp+r11*2+0x0]
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c0a5:	44 89 c3             	mov    ebx,r8d
  21c0a8:	29 cb                	sub    ebx,ecx
  21c0aa:	c1 fb 1f             	sar    ebx,0x1f
        carry = @intCast(u32, s & 1);
  21c0ad:	41 89 db             	mov    r11d,ebx
  21c0b0:	41 83 e3 01          	and    r11d,0x1
        r -= d & @bitCast(u32, s);
  21c0b4:	21 f3                	and    ebx,esi
  21c0b6:	29 d9                	sub    ecx,ebx
    while (sr > 0) : (sr -= 1) {
  21c0b8:	41 83 c2 04          	add    r10d,0x4
  21c0bc:	75 82                	jne    21c040 <__udivmodsi4+0x90>
  21c0be:	45 85 c9             	test   r9d,r9d
  21c0c1:	74 2f                	je     21c0f2 <__udivmodsi4+0x142>
  21c0c3:	41 f7 d9             	neg    r9d
  21c0c6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  21c0cd:	00 00 00 
        r = (r << 1) | (q >> @intCast(u5, n_uword_bits - 1));
  21c0d0:	0f a4 c1 01          	shld   ecx,eax,0x1
        q = (q << 1) | carry;
  21c0d4:	01 c0                	add    eax,eax
  21c0d6:	44 09 d8             	or     eax,r11d
        const s = @intCast(i32, d -% r -% 1) >> @intCast(u5, n_uword_bits - 1);
  21c0d9:	44 89 c5             	mov    ebp,r8d
  21c0dc:	29 cd                	sub    ebp,ecx
  21c0de:	c1 fd 1f             	sar    ebp,0x1f
        carry = @intCast(u32, s & 1);
  21c0e1:	41 89 eb             	mov    r11d,ebp
  21c0e4:	41 83 e3 01          	and    r11d,0x1
        r -= d & @bitCast(u32, s);
  21c0e8:	21 f5                	and    ebp,esi
  21c0ea:	29 e9                	sub    ecx,ebp
    while (sr > 0) : (sr -= 1) {
  21c0ec:	41 83 c1 01          	add    r9d,0x1
  21c0f0:	75 de                	jne    21c0d0 <__udivmodsi4+0x120>
    q = (q << 1) | carry;
  21c0f2:	01 c0                	add    eax,eax
  21c0f4:	44 09 d8             	or     eax,r11d
    rem.* = @bitCast(u32, @bitCast(i32, a) -% (@bitCast(i32, d) * @bitCast(i32, b)));
  21c0f7:	0f af f0             	imul   esi,eax
  21c0fa:	29 f7                	sub    edi,esi
  21c0fc:	89 3a                	mov    DWORD PTR [rdx],edi
    return d;
  21c0fe:	5b                   	pop    rbx
  21c0ff:	41 5c                	pop    r12
  21c101:	41 5d                	pop    r13
  21c103:	41 5e                	pop    r14
  21c105:	41 5f                	pop    r15
  21c107:	5d                   	pop    rbp
  21c108:	c3                   	ret    
  21c109:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000021c110 <__divti3>:
const compiler_rt = @import("index.zig");

pub extern fn __divti3(a: i128, b: i128) i128 {
    @setRuntimeSafety(builtin.is_test);

    const s_a = a >> (i128.bit_count - 1);
  21c110:	41 56                	push   r14
  21c112:	53                   	push   rbx
  21c113:	50                   	push   rax
  21c114:	48 89 f0             	mov    rax,rsi
  21c117:	48 c1 f8 3f          	sar    rax,0x3f
    const s_b = b >> (i128.bit_count - 1);
  21c11b:	49 89 ce             	mov    r14,rcx
  21c11e:	49 31 f6             	xor    r14,rsi
  21c121:	48 89 cb             	mov    rbx,rcx
  21c124:	48 c1 fb 3f          	sar    rbx,0x3f

    const an = (a ^ s_a) -% s_a;
  21c128:	48 31 c6             	xor    rsi,rax
  21c12b:	48 31 c7             	xor    rdi,rax
  21c12e:	48 29 c7             	sub    rdi,rax
  21c131:	48 19 c6             	sbb    rsi,rax
    const bn = (b ^ s_b) -% s_b;
  21c134:	48 31 d9             	xor    rcx,rbx
  21c137:	48 31 da             	xor    rdx,rbx
  21c13a:	48 29 da             	sub    rdx,rbx
  21c13d:	48 19 d9             	sbb    rcx,rbx

    const r = udivmod(u128, @bitCast(u128, an), @bitCast(u128, bn), null);
  21c140:	45 31 c0             	xor    r8d,r8d
  21c143:	e8 18 00 00 00       	call   21c160 <udivmod.14>
    const s = s_a ^ s_b;
  21c148:	49 c1 fe 3f          	sar    r14,0x3f
    return (@bitCast(i128, r) ^ s) -% s;
  21c14c:	4c 31 f2             	xor    rdx,r14
  21c14f:	4c 31 f0             	xor    rax,r14
  21c152:	4c 29 f0             	sub    rax,r14
  21c155:	4c 19 f2             	sbb    rdx,r14
  21c158:	48 83 c4 08          	add    rsp,0x8
  21c15c:	5b                   	pop    rbx
  21c15d:	41 5e                	pop    r14
  21c15f:	c3                   	ret    

000000000021c160 <udivmod.14>:
pub fn udivmod(comptime DoubleInt: type, a: DoubleInt, b: DoubleInt, maybe_rem: ?*DoubleInt) DoubleInt {
  21c160:	55                   	push   rbp
  21c161:	41 57                	push   r15
  21c163:	41 56                	push   r14
  21c165:	41 55                	push   r13
  21c167:	41 54                	push   r12
  21c169:	53                   	push   rbx
  21c16a:	49 89 d1             	mov    r9,rdx
    if (n[high] == 0) {
  21c16d:	48 85 f6             	test   rsi,rsi
  21c170:	74 38                	je     21c1aa <udivmod.14+0x4a>
    if (d[low] == 0) {
  21c172:	4d 85 c9             	test   r9,r9
  21c175:	74 55                	je     21c1cc <udivmod.14+0x6c>
  21c177:	48 85 c9             	test   rcx,rcx
        if (d[high] == 0) {
  21c17a:	0f 84 af 00 00 00    	je     21c22f <udivmod.14+0xcf>
            sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  21c180:	f3 48 0f bd c1       	lzcnt  rax,rcx
  21c185:	f3 48 0f bd d6       	lzcnt  rdx,rsi
  21c18a:	29 d0                	sub    eax,edx
            if (sr > SingleInt.bit_count - 1) {
  21c18c:	83 f8 40             	cmp    eax,0x40
  21c18f:	0f 82 23 01 00 00    	jb     21c2b8 <udivmod.14+0x158>
  21c195:	4d 85 c0             	test   r8,r8
  21c198:	0f 84 3f 01 00 00    	je     21c2dd <udivmod.14+0x17d>
  21c19e:	49 89 38             	mov    QWORD PTR [r8],rdi
  21c1a1:	49 89 70 08          	mov    QWORD PTR [r8+0x8],rsi
  21c1a5:	e9 33 01 00 00       	jmp    21c2dd <udivmod.14+0x17d>
        if (d[high] == 0) {
  21c1aa:	48 85 c9             	test   rcx,rcx
  21c1ad:	0f 84 df 00 00 00    	je     21c292 <udivmod.14+0x132>
  21c1b3:	4d 85 c0             	test   r8,r8
        if (maybe_rem) |rem| {
  21c1b6:	0f 84 21 01 00 00    	je     21c2dd <udivmod.14+0x17d>
            rem.* = n[low];
  21c1bc:	49 89 38             	mov    QWORD PTR [r8],rdi
  21c1bf:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  21c1c6:	00 
  21c1c7:	e9 11 01 00 00       	jmp    21c2dd <udivmod.14+0x17d>
  21c1cc:	48 85 c9             	test   rcx,rcx
        if (d[high] == 0) {
  21c1cf:	0f 84 fa 00 00 00    	je     21c2cf <udivmod.14+0x16f>
        if (n[low] == 0) {
  21c1d5:	48 85 ff             	test   rdi,rdi
  21c1d8:	0f 84 6e 02 00 00    	je     21c44c <udivmod.14+0x2ec>
        if ((d[high] & (d[high] - 1)) == 0) {
  21c1de:	48 8d 41 ff          	lea    rax,[rcx-0x1]
  21c1e2:	48 85 c8             	test   rax,rcx
  21c1e5:	0f 84 c3 02 00 00    	je     21c4ae <udivmod.14+0x34e>
        sr = @bitCast(c_uint, c_int(@clz(d[high])) - c_int(@clz(n[high])));
  21c1eb:	f3 4c 0f bd d1       	lzcnt  r10,rcx
  21c1f0:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21c1f5:	41 29 c2             	sub    r10d,eax
        if (sr > SingleInt.bit_count - 2) {
  21c1f8:	41 83 fa 3f          	cmp    r10d,0x3f
  21c1fc:	73 97                	jae    21c195 <udivmod.14+0x35>
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21c1fe:	b8 3f 00 00 00       	mov    eax,0x3f
  21c203:	44 29 d0             	sub    eax,r10d
        sr += 1;
  21c206:	41 83 c2 01          	add    r10d,0x1
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21c20a:	83 e0 3f             	and    eax,0x3f
        r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21c20d:	44 89 d5             	mov    ebp,r10d
  21c210:	83 e5 3f             	and    ebp,0x3f
  21c213:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21c218:	c4 e2 f9 f7 de       	shlx   rbx,rsi,rax
  21c21d:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
        q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21c222:	c4 e2 f9 f7 ff       	shlx   rdi,rdi,rax
        r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21c227:	48 09 de             	or     rsi,rbx
  21c22a:	e9 de 00 00 00       	jmp    21c30d <udivmod.14+0x1ad>
            if ((d[low] & (d[low] - 1)) == 0) {
  21c22f:	49 8d 41 ff          	lea    rax,[r9-0x1]
  21c233:	4c 85 c8             	test   rax,r9
  21c236:	0f 84 36 02 00 00    	je     21c472 <udivmod.14+0x312>
            sr = 1 + SingleInt.bit_count + c_uint(@clz(d[low])) - c_uint(@clz(n[high]));
  21c23c:	f3 4d 0f bd d1       	lzcnt  r10,r9
  21c241:	41 83 c2 41          	add    r10d,0x41
  21c245:	f3 48 0f bd c6       	lzcnt  rax,rsi
  21c24a:	41 29 c2             	sub    r10d,eax
            if (sr == SingleInt.bit_count) {
  21c24d:	41 83 fa 40          	cmp    r10d,0x40
  21c251:	74 6f                	je     21c2c2 <udivmod.14+0x162>
  21c253:	44 89 d3             	mov    ebx,r10d
  21c256:	f7 db                	neg    ebx
  21c258:	83 e3 3f             	and    ebx,0x3f
  21c25b:	c4 62 e1 f7 e7       	shlx   r12,rdi,rbx
            } else if (sr < SingleInt.bit_count) {
  21c260:	41 83 fa 40          	cmp    r10d,0x40
  21c264:	0f 83 90 02 00 00    	jae    21c4fa <udivmod.14+0x39a>
  21c26a:	31 ed                	xor    ebp,ebp
    while (sr > 0) : (sr -= 1) {
  21c26c:	45 85 d2             	test   r10d,r10d
  21c26f:	0f 84 de 02 00 00    	je     21c553 <udivmod.14+0x3f3>
  21c275:	44 89 d5             	mov    ebp,r10d
  21c278:	83 e5 3f             	and    ebp,0x3f
  21c27b:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
  21c280:	c4 e2 e1 f7 de       	shlx   rbx,rsi,rbx
  21c285:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
  21c28a:	48 09 de             	or     rsi,rbx
  21c28d:	4c 89 e7             	mov    rdi,r12
  21c290:	eb 7b                	jmp    21c30d <udivmod.14+0x1ad>
  21c292:	4d 85 c0             	test   r8,r8
            if (maybe_rem) |rem| {
  21c295:	0f 84 40 02 00 00    	je     21c4db <udivmod.14+0x37b>
  21c29b:	48 89 f8             	mov    rax,rdi
  21c29e:	4c 09 c8             	or     rax,r9
  21c2a1:	48 c1 e8 20          	shr    rax,0x20
  21c2a5:	0f 84 1e 02 00 00    	je     21c4c9 <udivmod.14+0x369>
  21c2ab:	31 d2                	xor    edx,edx
  21c2ad:	48 89 f8             	mov    rax,rdi
  21c2b0:	49 f7 f1             	div    r9
  21c2b3:	e9 18 02 00 00       	jmp    21c4d0 <udivmod.14+0x370>
            sr += 1;
  21c2b8:	44 8d 50 01          	lea    r10d,[rax+0x1]
            if (sr == SingleInt.bit_count) {
  21c2bc:	41 83 fa 40          	cmp    r10d,0x40
  21c2c0:	75 24                	jne    21c2e6 <udivmod.14+0x186>
  21c2c2:	41 ba 40 00 00 00    	mov    r10d,0x40
  21c2c8:	45 31 e4             	xor    r12d,r12d
  21c2cb:	31 d2                	xor    edx,edx
  21c2cd:	eb 41                	jmp    21c310 <udivmod.14+0x1b0>
            if (maybe_rem) |rem| {
  21c2cf:	4d 85 c0             	test   r8,r8
  21c2d2:	74 09                	je     21c2dd <udivmod.14+0x17d>
                rem.* = n[high] % d[low];
  21c2d4:	c5 f8 57 c0          	vxorps xmm0,xmm0,xmm0
  21c2d8:	c4 c1 78 11 00       	vmovups XMMWORD PTR [r8],xmm0
  21c2dd:	31 ff                	xor    edi,edi
  21c2df:	31 f6                	xor    esi,esi
  21c2e1:	e9 5b 01 00 00       	jmp    21c441 <udivmod.14+0x2e1>
                r[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21c2e6:	44 89 d5             	mov    ebp,r10d
  21c2e9:	83 e5 3f             	and    ebp,0x3f
  21c2ec:	c4 e2 d3 f7 d6       	shrx   rdx,rsi,rbp
  21c2f1:	bb 3f 00 00 00       	mov    ebx,0x3f
                r[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21c2f6:	29 c3                	sub    ebx,eax
  21c2f8:	83 e3 3f             	and    ebx,0x3f
  21c2fb:	c4 e2 e1 f7 c6       	shlx   rax,rsi,rbx
  21c300:	c4 e2 d3 f7 f7       	shrx   rsi,rdi,rbp
  21c305:	48 09 c6             	or     rsi,rax
                q[high] = n[low] << @intCast(Log2SingleInt, SingleInt.bit_count - sr);
  21c308:	c4 e2 e1 f7 ff       	shlx   rdi,rdi,rbx
  21c30d:	45 31 e4             	xor    r12d,r12d
  21c310:	4d 89 cf             	mov    r15,r9
  21c313:	49 83 c7 ff          	add    r15,0xffffffffffffffff
  21c317:	49 89 cb             	mov    r11,rcx
  21c31a:	49 83 d3 ff          	adc    r11,0xffffffffffffffff
    while (sr > 0) : (sr -= 1) {
  21c31e:	44 89 d0             	mov    eax,r10d
  21c321:	83 e0 01             	and    eax,0x1
  21c324:	31 ed                	xor    ebp,ebp
  21c326:	41 83 fa 01          	cmp    r10d,0x1
  21c32a:	75 0f                	jne    21c33b <udivmod.14+0x1db>
  21c32c:	31 db                	xor    ebx,ebx
  21c32e:	85 c0                	test   eax,eax
  21c330:	0f 85 ac 00 00 00    	jne    21c3e2 <udivmod.14+0x282>
  21c336:	e9 da 00 00 00       	jmp    21c415 <udivmod.14+0x2b5>
  21c33b:	4c 89 44 24 f8       	mov    QWORD PTR [rsp-0x8],r8
  21c340:	89 44 24 f4          	mov    DWORD PTR [rsp-0xc],eax
  21c344:	41 89 c5             	mov    r13d,eax
  21c347:	45 29 d5             	sub    r13d,r10d
  21c34a:	41 ba 3e 01 00 00    	mov    r10d,0x13e
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21c350:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21c355:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21c35a:	48 89 f8             	mov    rax,rdi
  21c35d:	4c 0f a4 e0 01       	shld   rax,r12,0x1
        q[low] = (q[low] << 1) | carry;
  21c362:	4b 8d 1c 24          	lea    rbx,[r12+r12*1]
  21c366:	89 ed                	mov    ebp,ebp
  21c368:	48 09 dd             	or     rbp,rbx
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21c36b:	49 39 f7             	cmp    r15,rsi
  21c36e:	4c 89 db             	mov    rbx,r11
  21c371:	48 19 d3             	sbb    rbx,rdx
  21c374:	48 c1 fb 3f          	sar    rbx,0x3f
        carry = @intCast(u32, s & 1);
  21c378:	41 89 de             	mov    r14d,ebx
  21c37b:	41 83 e6 01          	and    r14d,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  21c37f:	49 89 d8             	mov    r8,rbx
  21c382:	49 21 c8             	and    r8,rcx
  21c385:	4c 21 cb             	and    rbx,r9
  21c388:	48 29 de             	sub    rsi,rbx
  21c38b:	4c 19 c2             	sbb    rdx,r8
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21c38e:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21c393:	c4 e2 a8 f7 ff       	bextr  rdi,rdi,r10
  21c398:	48 8d 34 77          	lea    rsi,[rdi+rsi*2]
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21c39c:	c4 c2 a8 f7 fc       	bextr  rdi,r12,r10
  21c3a1:	48 8d 3c 47          	lea    rdi,[rdi+rax*2]
        q[low] = (q[low] << 1) | carry;
  21c3a5:	4d 8d 24 6e          	lea    r12,[r14+rbp*2]
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21c3a9:	49 39 f7             	cmp    r15,rsi
  21c3ac:	4c 89 d8             	mov    rax,r11
  21c3af:	48 19 d0             	sbb    rax,rdx
  21c3b2:	48 c1 f8 3f          	sar    rax,0x3f
        carry = @intCast(u32, s & 1);
  21c3b6:	89 c5                	mov    ebp,eax
  21c3b8:	83 e5 01             	and    ebp,0x1
        r_all -= b & @bitCast(DoubleInt, s);
  21c3bb:	48 89 c3             	mov    rbx,rax
  21c3be:	48 21 cb             	and    rbx,rcx
  21c3c1:	4c 21 c8             	and    rax,r9
  21c3c4:	48 29 c6             	sub    rsi,rax
  21c3c7:	48 19 da             	sbb    rdx,rbx
    while (sr > 0) : (sr -= 1) {
  21c3ca:	41 83 c5 02          	add    r13d,0x2
  21c3ce:	75 80                	jne    21c350 <udivmod.14+0x1f0>
  21c3d0:	89 eb                	mov    ebx,ebp
  21c3d2:	49 89 f2             	mov    r10,rsi
  21c3d5:	4c 8b 44 24 f8       	mov    r8,QWORD PTR [rsp-0x8]
  21c3da:	8b 44 24 f4          	mov    eax,DWORD PTR [rsp-0xc]
  21c3de:	85 c0                	test   eax,eax
  21c3e0:	74 33                	je     21c415 <udivmod.14+0x2b5>
        r[high] = (r[high] << 1) | (r[low] >> (SingleInt.bit_count - 1));
  21c3e2:	48 0f a4 f2 01       	shld   rdx,rsi,0x1
        r[low] = (r[low] << 1) | (q[high] >> (SingleInt.bit_count - 1));
  21c3e7:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
        const s: SignedDoubleInt = @intCast(SignedDoubleInt, b -% r_all -% 1) >> (DoubleInt.bit_count - 1);
  21c3ec:	49 39 f7             	cmp    r15,rsi
  21c3ef:	49 19 d3             	sbb    r11,rdx
  21c3f2:	49 c1 fb 3f          	sar    r11,0x3f
        r_all -= b & @bitCast(DoubleInt, s);
  21c3f6:	4c 21 d9             	and    rcx,r11
  21c3f9:	4d 21 d9             	and    r9,r11
  21c3fc:	4c 29 ce             	sub    rsi,r9
  21c3ff:	48 19 ca             	sbb    rdx,rcx
        carry = @intCast(u32, s & 1);
  21c402:	41 83 e3 01          	and    r11d,0x1
        q[high] = (q[high] << 1) | (q[low] >> (SingleInt.bit_count - 1));
  21c406:	4c 0f a4 e7 01       	shld   rdi,r12,0x1
        q[low] = (q[low] << 1) | carry;
  21c40b:	4e 8d 24 63          	lea    r12,[rbx+r12*2]
  21c40f:	44 89 dd             	mov    ebp,r11d
  21c412:	49 89 f2             	mov    r10,rsi
  21c415:	48 89 f8             	mov    rax,rdi
    const q_all = ((@ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &q[0]).*) << 1) | carry; // TODO issue #421
  21c418:	89 ed                	mov    ebp,ebp
  21c41a:	31 c9                	xor    ecx,ecx
  21c41c:	4c 89 e7             	mov    rdi,r12
  21c41f:	31 f6                	xor    esi,esi
  21c421:	49 89 c4             	mov    r12,rax
  21c424:	4c 09 e6             	or     rsi,r12
  21c427:	48 0f a4 fe 01       	shld   rsi,rdi,0x1
  21c42c:	48 09 ce             	or     rsi,rcx
  21c42f:	48 01 ff             	add    rdi,rdi
  21c432:	48 09 ef             	or     rdi,rbp
    if (maybe_rem) |rem| {
  21c435:	4d 85 c0             	test   r8,r8
  21c438:	74 07                	je     21c441 <udivmod.14+0x2e1>
        rem.* = r_all;
  21c43a:	4d 89 10             	mov    QWORD PTR [r8],r10
  21c43d:	49 89 50 08          	mov    QWORD PTR [r8+0x8],rdx
        return 0;
  21c441:	48 89 f8             	mov    rax,rdi
  21c444:	48 89 f2             	mov    rdx,rsi
  21c447:	e9 fc 00 00 00       	jmp    21c548 <udivmod.14+0x3e8>
            if (maybe_rem) |rem| {
  21c44c:	4d 85 c0             	test   r8,r8
  21c44f:	0f 84 d5 00 00 00    	je     21c52a <udivmod.14+0x3ca>
  21c455:	48 89 f0             	mov    rax,rsi
  21c458:	48 09 c8             	or     rax,rcx
  21c45b:	48 c1 e8 20          	shr    rax,0x20
  21c45f:	0f 84 b4 00 00 00    	je     21c519 <udivmod.14+0x3b9>
  21c465:	31 d2                	xor    edx,edx
  21c467:	48 89 f0             	mov    rax,rsi
  21c46a:	48 f7 f1             	div    rcx
  21c46d:	e9 ad 00 00 00       	jmp    21c51f <udivmod.14+0x3bf>
                if (maybe_rem) |rem| {
  21c472:	4d 85 c0             	test   r8,r8
  21c475:	74 0e                	je     21c485 <udivmod.14+0x325>
                    rem.* = n[low] & (d[low] - 1);
  21c477:	48 21 f8             	and    rax,rdi
  21c47a:	49 89 00             	mov    QWORD PTR [r8],rax
  21c47d:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  21c484:	00 
                if (d[low] == 1) {
  21c485:	49 83 f9 01          	cmp    r9,0x1
  21c489:	74 b6                	je     21c441 <udivmod.14+0x2e1>
                sr = @ctz(d[low]);
  21c48b:	f3 49 0f bc c1       	tzcnt  rax,r9
                q[high] = n[high] >> @intCast(Log2SingleInt, sr);
  21c490:	89 c1                	mov    ecx,eax
  21c492:	83 e1 3f             	and    ecx,0x3f
  21c495:	c4 e2 f3 f7 d6       	shrx   rdx,rsi,rcx
                q[low] = (n[high] << @intCast(Log2SingleInt, SingleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr));
  21c49a:	f7 d8                	neg    eax
  21c49c:	c4 e2 f9 f7 f6       	shlx   rsi,rsi,rax
  21c4a1:	c4 e2 f3 f7 c7       	shrx   rax,rdi,rcx
  21c4a6:	48 09 f0             	or     rax,rsi
  21c4a9:	e9 9a 00 00 00       	jmp    21c548 <udivmod.14+0x3e8>
            if (maybe_rem) |rem| {
  21c4ae:	4d 85 c0             	test   r8,r8
  21c4b1:	74 0a                	je     21c4bd <udivmod.14+0x35d>
                r[high] = n[high] & (d[high] - 1);
  21c4b3:	48 21 f0             	and    rax,rsi
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21c4b6:	49 89 38             	mov    QWORD PTR [r8],rdi
  21c4b9:	49 89 40 08          	mov    QWORD PTR [r8+0x8],rax
            return n[high] >> @intCast(Log2SingleInt, @ctz(d[high]));
  21c4bd:	f3 48 0f bc c1       	tzcnt  rax,rcx
  21c4c2:	c4 e2 fb f7 c6       	shrx   rax,rsi,rax
  21c4c7:	eb 7d                	jmp    21c546 <udivmod.14+0x3e6>
  21c4c9:	31 d2                	xor    edx,edx
  21c4cb:	89 f8                	mov    eax,edi
  21c4cd:	41 f7 f1             	div    r9d
                rem.* = n[low] % d[low];
  21c4d0:	49 89 10             	mov    QWORD PTR [r8],rdx
  21c4d3:	49 c7 40 08 00 00 00 	mov    QWORD PTR [r8+0x8],0x0
  21c4da:	00 
  21c4db:	48 89 f8             	mov    rax,rdi
  21c4de:	4c 09 c8             	or     rax,r9
  21c4e1:	48 c1 e8 20          	shr    rax,0x20
  21c4e5:	74 0a                	je     21c4f1 <udivmod.14+0x391>
  21c4e7:	31 d2                	xor    edx,edx
  21c4e9:	48 89 f8             	mov    rax,rdi
  21c4ec:	49 f7 f1             	div    r9
  21c4ef:	eb 55                	jmp    21c546 <udivmod.14+0x3e6>
  21c4f1:	31 d2                	xor    edx,edx
  21c4f3:	89 f8                	mov    eax,edi
  21c4f5:	41 f7 f1             	div    r9d
  21c4f8:	eb 4c                	jmp    21c546 <udivmod.14+0x3e6>
                q[high] = (n[high] << @intCast(Log2SingleInt, DoubleInt.bit_count - sr)) | (n[low] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count));
  21c4fa:	c4 e2 e1 f7 d6       	shlx   rdx,rsi,rbx
  21c4ff:	44 89 d5             	mov    ebp,r10d
  21c502:	83 e5 3f             	and    ebp,0x3f
  21c505:	c4 e2 d3 f7 ff       	shrx   rdi,rdi,rbp
  21c50a:	48 09 d7             	or     rdi,rdx
                r[low] = n[high] >> @intCast(Log2SingleInt, sr - SingleInt.bit_count);
  21c50d:	c4 e2 d3 f7 f6       	shrx   rsi,rsi,rbp
  21c512:	31 d2                	xor    edx,edx
  21c514:	e9 f7 fd ff ff       	jmp    21c310 <udivmod.14+0x1b0>
  21c519:	31 d2                	xor    edx,edx
  21c51b:	89 f0                	mov    eax,esi
  21c51d:	f7 f1                	div    ecx
                rem.* = @ptrCast(*align(@alignOf(SingleInt)) DoubleInt, &r[0]).*; // TODO issue #421
  21c51f:	49 89 50 08          	mov    QWORD PTR [r8+0x8],rdx
  21c523:	49 c7 00 00 00 00 00 	mov    QWORD PTR [r8],0x0
  21c52a:	48 89 f0             	mov    rax,rsi
  21c52d:	48 09 c8             	or     rax,rcx
  21c530:	48 c1 e8 20          	shr    rax,0x20
  21c534:	74 0a                	je     21c540 <udivmod.14+0x3e0>
  21c536:	31 d2                	xor    edx,edx
  21c538:	48 89 f0             	mov    rax,rsi
  21c53b:	48 f7 f1             	div    rcx
  21c53e:	eb 06                	jmp    21c546 <udivmod.14+0x3e6>
  21c540:	31 d2                	xor    edx,edx
  21c542:	89 f0                	mov    eax,esi
  21c544:	f7 f1                	div    ecx
  21c546:	31 d2                	xor    edx,edx
  21c548:	5b                   	pop    rbx
  21c549:	41 5c                	pop    r12
  21c54b:	41 5d                	pop    r13
  21c54d:	41 5e                	pop    r14
  21c54f:	41 5f                	pop    r15
  21c551:	5d                   	pop    rbp
  21c552:	c3                   	ret    
  21c553:	31 c9                	xor    ecx,ecx
  21c555:	31 ff                	xor    edi,edi
  21c557:	31 f6                	xor    esi,esi
  21c559:	e9 c6 fe ff ff       	jmp    21c424 <udivmod.14+0x2c4>
  21c55e:	66 90                	xchg   ax,ax

000000000021c560 <__muloti4>:
const udivmod = @import("udivmod.zig").udivmod;
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __muloti4(a: i128, b: i128, overflow: *c_int) i128 {
  21c560:	55                   	push   rbp
  21c561:	41 57                	push   r15
  21c563:	41 56                	push   r14
  21c565:	41 55                	push   r13
  21c567:	41 54                	push   r12
  21c569:	53                   	push   rbx
  21c56a:	48 83 ec 28          	sub    rsp,0x28
  21c56e:	4d 89 c7             	mov    r15,r8
  21c571:	48 89 d5             	mov    rbp,rdx
  21c574:	49 89 f4             	mov    r12,rsi
  21c577:	48 89 fb             	mov    rbx,rdi
  21c57a:	c4 c1 f9 6e c4       	vmovq  xmm0,r12
  21c57f:	c4 e1 f9 6e cb       	vmovq  xmm1,rbx
  21c584:	c5 f1 6c c0          	vpunpcklqdq xmm0,xmm1,xmm0
    @setRuntimeSafety(builtin.is_test);

    const min = @bitCast(i128, u128(1 << (i128.bit_count - 1)));
    const max = ~min;
    overflow.* = 0;
  21c588:	41 c7 07 00 00 00 00 	mov    DWORD PTR [r15],0x0

    const r = a *% b;
  21c58f:	48 89 e8             	mov    rax,rbp
  21c592:	49 0f af c4          	imul   rax,r12
  21c596:	c4 e2 8b f6 d3       	mulx   rdx,r14,rbx
  21c59b:	48 01 c2             	add    rdx,rax
  21c59e:	49 89 cd             	mov    r13,rcx
  21c5a1:	4c 0f af eb          	imul   r13,rbx
  21c5a5:	49 01 d5             	add    r13,rdx
    if (a == min) {
  21c5a8:	48 be 00 00 00 00 00 	movabs rsi,0x8000000000000000
  21c5af:	00 00 80 
  21c5b2:	c4 e1 f9 6e ce       	vmovq  xmm1,rsi
  21c5b7:	c5 e9 73 f9 08       	vpslldq xmm2,xmm1,0x8
  21c5bc:	c5 f9 74 c2          	vpcmpeqb xmm0,xmm0,xmm2
  21c5c0:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21c5c4:	3d ff ff 00 00       	cmp    eax,0xffff
  21c5c9:	75 13                	jne    21c5de <__muloti4+0x7e>
        if (b != 0 and b != 1) {
  21c5cb:	48 83 fd 02          	cmp    rbp,0x2
  21c5cf:	48 83 d9 00          	sbb    rcx,0x0
  21c5d3:	0f 83 b7 00 00 00    	jae    21c690 <__muloti4+0x130>
  21c5d9:	e9 b9 00 00 00       	jmp    21c697 <__muloti4+0x137>
            overflow.* = 1;
        }
        return r;
    }
    if (b == min) {
  21c5de:	c4 e1 f9 6e c5       	vmovq  xmm0,rbp
  21c5e3:	c4 e1 f9 6e c9       	vmovq  xmm1,rcx
  21c5e8:	c5 f9 6c c1          	vpunpcklqdq xmm0,xmm0,xmm1
  21c5ec:	c5 f9 74 c2          	vpcmpeqb xmm0,xmm0,xmm2
  21c5f0:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21c5f4:	3d ff ff 00 00       	cmp    eax,0xffff
  21c5f9:	75 13                	jne    21c60e <__muloti4+0xae>
        if (a != 0 and a != 1) {
  21c5fb:	48 83 fb 02          	cmp    rbx,0x2
  21c5ff:	49 83 dc 00          	sbb    r12,0x0
  21c603:	0f 83 87 00 00 00    	jae    21c690 <__muloti4+0x130>
  21c609:	e9 89 00 00 00       	jmp    21c697 <__muloti4+0x137>
            overflow.* = 1;
        }
        return r;
    }

    const sa = a >> (i128.bit_count - 1);
  21c60e:	4c 89 e0             	mov    rax,r12
  21c611:	48 c1 f8 3f          	sar    rax,0x3f
    const abs_a = (a ^ sa) -% sa;
  21c615:	49 31 c4             	xor    r12,rax
  21c618:	48 31 c3             	xor    rbx,rax
  21c61b:	48 29 c3             	sub    rbx,rax
  21c61e:	49 19 c4             	sbb    r12,rax
    const sb = b >> (i128.bit_count - 1);
  21c621:	48 89 ca             	mov    rdx,rcx
  21c624:	48 c1 fa 3f          	sar    rdx,0x3f
    const abs_b = (b ^ sb) -% sb;
  21c628:	48 31 d1             	xor    rcx,rdx
  21c62b:	48 31 d5             	xor    rbp,rdx
  21c62e:	48 29 d5             	sub    rbp,rdx
  21c631:	48 19 d1             	sbb    rcx,rdx

    if (abs_a < 2 or abs_b < 2) {
  21c634:	48 83 fb 02          	cmp    rbx,0x2
  21c638:	4c 89 e7             	mov    rdi,r12
  21c63b:	48 83 df 00          	sbb    rdi,0x0
  21c63f:	7c 56                	jl     21c697 <__muloti4+0x137>
  21c641:	48 83 fd 02          	cmp    rbp,0x2
  21c645:	48 89 cf             	mov    rdi,rcx
  21c648:	48 83 df 00          	sbb    rdi,0x0
  21c64c:	7c 49                	jl     21c697 <__muloti4+0x137>
        return r;
    }

    if (sa == sb) {
  21c64e:	c4 e1 f9 6e c2       	vmovq  xmm0,rdx
  21c653:	c5 f9 6c c0          	vpunpcklqdq xmm0,xmm0,xmm0
  21c657:	c4 e1 f9 6e c8       	vmovq  xmm1,rax
  21c65c:	c5 f1 6c c9          	vpunpcklqdq xmm1,xmm1,xmm1
  21c660:	c5 f1 74 c0          	vpcmpeqb xmm0,xmm1,xmm0
  21c664:	c5 f9 d7 c0          	vpmovmskb eax,xmm0
  21c668:	3d ff ff 00 00       	cmp    eax,0xffff
  21c66d:	75 3d                	jne    21c6ac <__muloti4+0x14c>
  21c66f:	48 be ff ff ff ff ff 	movabs rsi,0x7fffffffffffffff
  21c676:	ff ff 7f 
  21c679:	48 c7 c7 ff ff ff ff 	mov    rdi,0xffffffffffffffff
  21c680:	48 89 ea             	mov    rdx,rbp
  21c683:	e8 a8 00 00 00       	call   21c730 <__udivti3>
        if (abs_a > @divFloor(max, abs_b)) {
  21c688:	48 39 d8             	cmp    rax,rbx
  21c68b:	4c 19 e2             	sbb    rdx,r12
  21c68e:	7d 07                	jge    21c697 <__muloti4+0x137>
  21c690:	41 c7 07 01 00 00 00 	mov    DWORD PTR [r15],0x1
        return r;
  21c697:	4c 89 f0             	mov    rax,r14
  21c69a:	4c 89 ea             	mov    rdx,r13
  21c69d:	48 83 c4 28          	add    rsp,0x28
  21c6a1:	5b                   	pop    rbx
  21c6a2:	41 5c                	pop    r12
  21c6a4:	41 5d                	pop    r13
  21c6a6:	41 5e                	pop    r14
  21c6a8:	41 5f                	pop    r15
  21c6aa:	5d                   	pop    rbp
  21c6ab:	c3                   	ret    
  21c6ac:	31 c0                	xor    eax,eax
            overflow.* = 1;
        }
    } else {
        if (abs_a > @divFloor(min, -abs_b)) {
  21c6ae:	48 f7 dd             	neg    rbp
  21c6b1:	48 19 c8             	sbb    rax,rcx
  21c6b4:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  21c6b9:	31 ff                	xor    edi,edi
  21c6bb:	48 89 ea             	mov    rdx,rbp
  21c6be:	48 89 c1             	mov    rcx,rax
  21c6c1:	c5 f9 7f 54 24 10    	vmovdqa XMMWORD PTR [rsp+0x10],xmm2
  21c6c7:	e8 44 fa ff ff       	call   21c110 <__divti3>
  21c6cc:	48 89 d1             	mov    rcx,rdx
  21c6cf:	48 85 c9             	test   rcx,rcx
  21c6d2:	41 0f 98 c0          	sets   r8b
  21c6d6:	48 89 c2             	mov    rdx,rax
  21c6d9:	c4 e2 eb f6 fd       	mulx   rdi,rdx,rbp
  21c6de:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
  21c6e3:	48 0f af f0          	imul   rsi,rax
  21c6e7:	48 01 f7             	add    rdi,rsi
  21c6ea:	48 0f af e9          	imul   rbp,rcx
  21c6ee:	48 01 fd             	add    rbp,rdi
  21c6f1:	c4 e1 f9 6e c5       	vmovq  xmm0,rbp
  21c6f6:	c4 e1 f9 6e ca       	vmovq  xmm1,rdx
  21c6fb:	c5 f1 6c c0          	vpunpcklqdq xmm0,xmm1,xmm0
  21c6ff:	c5 f9 74 44 24 10    	vpcmpeqb xmm0,xmm0,XMMWORD PTR [rsp+0x10]
  21c705:	c5 f9 d7 d0          	vpmovmskb edx,xmm0
  21c709:	81 fa ff ff 00 00    	cmp    edx,0xffff
  21c70f:	0f 95 c2             	setne  dl
  21c712:	44 20 c2             	and    dl,r8b
  21c715:	0f b6 d2             	movzx  edx,dl
  21c718:	48 29 d0             	sub    rax,rdx
  21c71b:	48 83 d9 00          	sbb    rcx,0x0
  21c71f:	48 39 d8             	cmp    rax,rbx
  21c722:	4c 19 e1             	sbb    rcx,r12
  21c725:	0f 8c 65 ff ff ff    	jl     21c690 <__muloti4+0x130>
  21c72b:	e9 67 ff ff ff       	jmp    21c697 <__muloti4+0x137>

000000000021c730 <__udivti3>:
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __udivmodti4(a: u128, b: u128, maybe_rem: ?*u128) u128 {
    @setRuntimeSafety(builtin.is_test);
    return udivmod(u128, a, b, maybe_rem);
  21c730:	45 31 c0             	xor    r8d,r8d
  21c733:	e9 28 fa ff ff       	jmp    21c160 <udivmod.14>
  21c738:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  21c73f:	00 

000000000021c740 <__udivmodti4>:
  21c740:	e9 1b fa ff ff       	jmp    21c160 <udivmod.14>
  21c745:	66 66 2e 0f 1f 84 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
  21c74c:	00 00 00 00 

000000000021c750 <__umodti3>:
const udivmodti4 = @import("udivmodti4.zig");
const builtin = @import("builtin");
const compiler_rt = @import("index.zig");

pub extern fn __umodti3(a: u128, b: u128) u128 {
  21c750:	48 83 ec 18          	sub    rsp,0x18
  21c754:	4c 8d 44 24 08       	lea    r8,[rsp+0x8]
  21c759:	e8 02 fa ff ff       	call   21c160 <udivmod.14>
    @setRuntimeSafety(builtin.is_test);
    var r: u128 = undefined;
    _ = udivmodti4.__udivmodti4(a, b, &r);
    return r;
  21c75e:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
  21c763:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  21c768:	48 83 c4 18          	add    rsp,0x18
  21c76c:	c3                   	ret    
